<!-- Generated documentation from tests.sgm -->
<!-- DO NOT EDIT - generated by codegen -->

  <section xmlns='http://docbook.org/ns/docbook' xml:id='category-CHOOSE-EXPRESSIONS'>
    <title>Choose Expressions</title>
    <para>Choose expressions pattern match on union types, allowing different code paths based on which variant is present.</para>

    <section xml:id='tests-CHOOSE-ON-VARIANTS'>
      <title>Choose on Variant Construction</title>
      <para>Choose can match directly on constructed variants.</para>
      <informaltable frame='none'>
        <tgroup cols='2'>
          <colspec colwidth='1*'/>
          <colspec colwidth='1*'/>
          <thead>
            <row>
              <entry>Input</entry>
              <entry>Result</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry><programlisting>define Option union(Some: int, None)
choose Option.Some(7): when Some: v: v else 0</programlisting></entry>
              <entry><literal>7
        </literal></entry>
            </row>
            <row>
              <entry><programlisting>define Option union(Some: int, None)
choose Option.None: when Some: v: v else 0</programlisting></entry>
              <entry><literal>0

    </literal></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </section>

    <section xml:id='tests-CHOOSE-BINDING'>
      <title>Choose with Binding</title>
      <para>When a variant carries a value, the value can be bound to a name.</para>
      <informaltable frame='none'>
        <tgroup cols='2'>
          <colspec colwidth='1*'/>
          <colspec colwidth='1*'/>
          <thead>
            <row>
              <entry>Input</entry>
              <entry>Result</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry><programlisting>define Result union(Ok: int, Err: int)
choose Result.Ok(42): when Ok: x: x + 1 else 0</programlisting></entry>
              <entry><literal>43

    </literal></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </section>

    <section xml:id='tests-CHOOSE-MULTIPLE-WHEN'>
      <title>Multiple When Clauses</title>
      <para>Choose can have multiple when clauses to match different variants.</para>
      <informaltable frame='none'>
        <tgroup cols='2'>
          <colspec colwidth='1*'/>
          <colspec colwidth='1*'/>
          <thead>
            <row>
              <entry>Input</entry>
              <entry>Result</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry><programlisting>define Result union(Ok: int, Err: int)
choose Result.Ok(10): when Ok: x: x when Err: e: e + 100</programlisting></entry>
              <entry><literal>10
        </literal></entry>
            </row>
            <row>
              <entry><programlisting>define Result union(Ok: int, Err: int)
choose Result.Err(5): when Ok: x: x when Err: e: e + 100</programlisting></entry>
              <entry><literal>105
</literal></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </section>
  </section>

  <section xmlns='http://docbook.org/ns/docbook' xml:id='category-OPTIONAL-TYPES'>
    <title>Optional Types</title>
    <para>Optional types use null pointer optimization (NPO) for efficient representation.</para>

    <section xml:id='tests-IS-NULL-CHECK'>
      <title>Is Null Check</title>
      <para>The is null expression checks if an optional value is None.</para>
      <informaltable frame='none'>
        <tgroup cols='2'>
          <colspec colwidth='1*'/>
          <colspec colwidth='1*'/>
          <thead>
            <row>
              <entry>Input</entry>
              <entry>Result</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry><programlisting>define Option[T] union: (Some: T, None)
function check(x: int?) returns int: if x is null: 0 else 1
check(Option[int].None)</programlisting></entry>
              <entry><literal>0
        </literal></entry>
            </row>
            <row>
              <entry><programlisting>define Option[T] union: (Some: T, None)
function check(x: int?) returns int: if x is null: 0 else 1
check(Option[int].Some(42))</programlisting></entry>
              <entry><literal>1

    </literal></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </section>

    <section xml:id='tests-OPTIONAL-SUGAR'>
      <title>Optional Type Sugar</title>
      <para>T? is syntactic sugar for Option[T].</para>
      <informaltable frame='none'>
        <tgroup cols='2'>
          <colspec colwidth='1*'/>
          <colspec colwidth='1*'/>
          <thead>
            <row>
              <entry>Input</entry>
              <entry>Result</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry><programlisting>define Option[T] union: (Some: T, None)
function unwrap(x: int?) returns int: choose x: when Some: v: v else 0
unwrap(Option[int].Some(42))</programlisting></entry>
              <entry><literal>42

    </literal></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </section>

    <section xml:id='tests-GENERIC-OPTION'>
      <title>Generic Option Types</title>
      <para>Generic unions like Option[T] work with choose for pattern matching.</para>
      <informaltable frame='none'>
        <tgroup cols='2'>
          <colspec colwidth='1*'/>
          <colspec colwidth='1*'/>
          <thead>
            <row>
              <entry>Input</entry>
              <entry>Result</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry><programlisting>define Option[T] union: (Some: T, None)
choose Option[int].Some(42): when Some: v: v else 0</programlisting></entry>
              <entry><literal>42
        </literal></entry>
            </row>
            <row>
              <entry><programlisting>define Option[T] union: (Some: T, None)
choose Option[int].None: when Some: v: v else -1</programlisting></entry>
              <entry><literal>-1
</literal></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </section>
  </section>

  <section xmlns='http://docbook.org/ns/docbook' xml:id='category-VARIANT-CONSTRUCTION'>
    <title>Variant Construction</title>
    <para>Union variants can be constructed explicitly using Type.Variant syntax.</para>

    <section xml:id='tests-VARIANT-CONSTRUCT'>
      <title>Construct Variants</title>
      <para>Variants are constructed with Type.Variant(value) syntax.</para>
      <informaltable frame='none'>
        <tgroup cols='2'>
          <colspec colwidth='1*'/>
          <colspec colwidth='1*'/>
          <thead>
            <row>
              <entry>Input</entry>
              <entry>Result</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry><programlisting>define Result union: (Ok: int, Error: int)
choose Result.Ok(42): when Ok: x: x else 0</programlisting></entry>
              <entry><literal>42
        </literal></entry>
            </row>
            <row>
              <entry><programlisting>define Result union: (Ok: int, Error: int)
choose Result.Error(100): when Error: e: e else 0</programlisting></entry>
              <entry><literal>100

    </literal></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </section>

    <section xml:id='tests-VARIANT-IS'>
      <title>Variant Is Expression</title>
      <para>The is expression tests if a union value matches a variant.</para>
      <informaltable frame='none'>
        <tgroup cols='2'>
          <colspec colwidth='1*'/>
          <colspec colwidth='1*'/>
          <thead>
            <row>
              <entry>Input</entry>
              <entry>Result</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry><programlisting>define Result union: (Ok: int, Error: int)
if Result.Ok(50) is Ok : 1 else 0</programlisting></entry>
              <entry><literal>1
        </literal></entry>
            </row>
            <row>
              <entry><programlisting>define Result union: (Ok: int, Error: int)
if Result.Error(33) is Ok : 1 else 0</programlisting></entry>
              <entry><literal>0
</literal></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </section>
  </section>
