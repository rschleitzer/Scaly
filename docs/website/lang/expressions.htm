<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Expressions</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="The Scaly Programming Language"
HREF="index.html"><LINK
REL="PREVIOUS"
TITLE="Definitions"
HREF="definitions.htm"><LINK
REL="NEXT"
TITLE="Standard Library Reference"
HREF="stdlib.htm"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=UTF-8"></HEAD
><BODY
CLASS="chapter"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>The Scaly Programming Language</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="definitions.htm"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="stdlib.htm"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="chapter"
><H1
><A
NAME="AEN688"
></A
>Chapter 5 Expressions</H1
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
><A
HREF="expressions.htm#AEN690"
>Overview</A
></DT
><DT
><A
HREF="expressions.htm#AEN693"
>Literals</A
></DT
><DT
><A
HREF="expressions.htm#AEN843"
>Operations</A
></DT
><DT
><A
HREF="expressions.htm#AEN959"
>Definitions</A
></DT
><DT
><A
HREF="expressions.htm#AEN994"
>If Expressions</A
></DT
><DT
><A
HREF="expressions.htm#AEN1002"
>Match Expressions</A
></DT
><DT
><A
HREF="expressions.htm#AEN1011"
>Let Bindings</A
></DT
></DL
></DIV
><DIV
CLASS="section"
><H1
CLASS="section"
><A
NAME="AEN690"
>Overview</A
></H1
><P
>Expressions are the core computational units of Scaly. Every expression
      evaluates to a value. Unlike many languages, Scaly uses postfix operators
      and does not define operator precedence â€” evaluation order is always
      explicit.
    </P
></DIV
><DIV
CLASS="section"
><H1
CLASS="section"
><A
NAME="AEN693"
>Literals</A
></H1
><P
>Expressions are the core computational units of Scaly. Every expression evaluates to a value.</P
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN696"
>Boolean Literals</A
></H2
><P
>The boolean literals are true and false.</P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN699"
></A
><TABLE
BORDER="0"
FRAME="void"
CLASS="CALSTABLE"
><COL
WIDTH="1*"><COL
WIDTH="1*"><THEAD
><TR
><TH
>Input</TH
><TH
>Result</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="literal"
>true</TT
></TD
><TD
><TT
CLASS="literal"
>true</TT
></TD
></TR
><TR
><TD
><TT
CLASS="literal"
>false</TT
></TD
><TD
><TT
CLASS="literal"
>false</TT
></TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN718"
>Integer Literals</A
></H2
><P
>Integer literals are sequences of decimal digits, optionally preceded by a minus sign for negative numbers.</P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN721"
></A
><TABLE
BORDER="0"
FRAME="void"
CLASS="CALSTABLE"
><COL
WIDTH="1*"><COL
WIDTH="1*"><THEAD
><TR
><TH
>Input</TH
><TH
>Result</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="literal"
>42</TT
></TD
><TD
><TT
CLASS="literal"
>42</TT
></TD
></TR
><TR
><TD
><TT
CLASS="literal"
>0</TT
></TD
><TD
><TT
CLASS="literal"
>0</TT
></TD
></TR
><TR
><TD
><TT
CLASS="literal"
>-7</TT
></TD
><TD
><TT
CLASS="literal"
>-7</TT
></TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN745"
>Hexadecimal Literals</A
></H2
><P
>Hexadecimal literals start with 0x or 0X followed by hexadecimal digits (0-9, a-f, A-F).</P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN748"
></A
><TABLE
BORDER="0"
FRAME="void"
CLASS="CALSTABLE"
><COL
WIDTH="1*"><COL
WIDTH="1*"><THEAD
><TR
><TH
>Input</TH
><TH
>Result</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="literal"
>0xFF</TT
></TD
><TD
><TT
CLASS="literal"
>255</TT
></TD
></TR
><TR
><TD
><TT
CLASS="literal"
>0x1A</TT
></TD
><TD
><TT
CLASS="literal"
>26</TT
></TD
></TR
><TR
><TD
><TT
CLASS="literal"
>0x0</TT
></TD
><TD
><TT
CLASS="literal"
>0</TT
></TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN772"
>Floating-Point Literals</A
></H2
><P
>Floating-point literals contain a decimal point separating the integer and fractional parts.</P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN775"
></A
><TABLE
BORDER="0"
FRAME="void"
CLASS="CALSTABLE"
><COL
WIDTH="1*"><COL
WIDTH="1*"><THEAD
><TR
><TH
>Input</TH
><TH
>Result</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="literal"
>3.14</TT
></TD
><TD
><TT
CLASS="literal"
>3.14</TT
></TD
></TR
><TR
><TD
><TT
CLASS="literal"
>2.0</TT
></TD
><TD
><TT
CLASS="literal"
>2</TT
></TD
></TR
><TR
><TD
><TT
CLASS="literal"
>0.5</TT
></TD
><TD
><TT
CLASS="literal"
>0.5</TT
></TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN799"
>String Literals</A
></H2
><P
>String literals are enclosed in double quotes. They may span multiple lines, with line breaks preserved in the resulting string.</P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN802"
></A
><TABLE
BORDER="0"
FRAME="void"
CLASS="CALSTABLE"
><COL
WIDTH="1*"><COL
WIDTH="1*"><THEAD
><TR
><TH
>Input</TH
><TH
>Result</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="literal"
>"hello"</TT
></TD
><TD
><TT
CLASS="literal"
>hello</TT
></TD
></TR
><TR
><TD
><TT
CLASS="literal"
>""</TT
></TD
><TD
><TT
CLASS="literal"
></TT
></TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN821"
>Character Literals</A
></H2
><P
>Character literals represent a single character, enclosed in backticks.</P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN824"
></A
><TABLE
BORDER="0"
FRAME="void"
CLASS="CALSTABLE"
><COL
WIDTH="1*"><COL
WIDTH="1*"><THEAD
><TR
><TH
>Input</TH
><TH
>Result</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="literal"
>`a`</TT
></TD
><TD
><TT
CLASS="literal"
>a</TT
></TD
></TR
><TR
><TD
><TT
CLASS="literal"
>`Z`</TT
></TD
><TD
><TT
CLASS="literal"
>Z</TT
></TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
></DIV
><DIV
CLASS="section"
><H1
CLASS="section"
><A
NAME="AEN843"
>Operations</A
></H1
><P
>Oparations allow combining expressions.</P
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN846"
>Prefix Functions</A
></H2
><P
>An operation is a sequence of operands that evaluates to a single value.
        Each operand is an expression optionally followed by member access. An operation ends with a colon, a line break,
        or anything which is not an expression. Evaluation uses a context which is empty at the start of an operation.
        When the context is empty, operator-shaped identifiers act as prefix functions, taking the next operand as their argument.</P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN849"
></A
><TABLE
BORDER="0"
FRAME="void"
CLASS="CALSTABLE"
><COL
WIDTH="1*"><COL
WIDTH="1*"><THEAD
><TR
><TH
>Input</TH
><TH
>Result</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="literal"
>-7</TT
></TD
><TD
><TT
CLASS="literal"
>-7</TT
></TD
></TR
><TR
><TD
><TT
CLASS="literal"
>-(-3)</TT
></TD
><TD
><TT
CLASS="literal"
>3</TT
></TD
></TR
><TR
><TD
><TT
CLASS="literal"
>+ 3</TT
></TD
><TD
><TT
CLASS="literal"
>3</TT
></TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN873"
>Operator Chains</A
></H2
><P
>When the context holds a value, operators chain left-to-right. Each operator takes the current value and the next operand,
        producing a new value. There is no operator precedence built into the language itself. Operator precedence is built into the implementation
        of the individual operators. The common arithmetic operators are built into the standard library.</P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN876"
></A
><TABLE
BORDER="0"
FRAME="void"
CLASS="CALSTABLE"
><COL
WIDTH="1*"><COL
WIDTH="1*"><THEAD
><TR
><TH
>Input</TH
><TH
>Result</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="literal"
>3 + 4</TT
></TD
><TD
><TT
CLASS="literal"
>7</TT
></TD
></TR
><TR
><TD
><TT
CLASS="literal"
>10 - 3</TT
></TD
><TD
><TT
CLASS="literal"
>7</TT
></TD
></TR
><TR
><TD
><TT
CLASS="literal"
>6 * 7</TT
></TD
><TD
><TT
CLASS="literal"
>42</TT
></TD
></TR
><TR
><TD
><TT
CLASS="literal"
>3 + 4 * 2</TT
></TD
><TD
><TT
CLASS="literal"
>11</TT
></TD
></TR
><TR
><TD
><TT
CLASS="literal"
>20 - 5 - 3</TT
></TD
><TD
><TT
CLASS="literal"
>12</TT
></TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN910"
>Parentheses and Grouping</A
></H2
><P
>Parentheses create a empty context. This allows prefix forms inside an otherwise operator chain,
        and explicit grouping when needed.</P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN913"
></A
><TABLE
BORDER="0"
FRAME="void"
CLASS="CALSTABLE"
><COL
WIDTH="1*"><COL
WIDTH="1*"><THEAD
><TR
><TH
>Input</TH
><TH
>Result</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="literal"
>5 * (- 2)</TT
></TD
><TD
><TT
CLASS="literal"
>-10</TT
></TD
></TR
><TR
><TD
><TT
CLASS="literal"
>2 * (3 + 4)</TT
></TD
><TD
><TT
CLASS="literal"
>14</TT
></TD
></TR
><TR
><TD
><TT
CLASS="literal"
>(2 + 3) * (4 + 1)</TT
></TD
><TD
><TT
CLASS="literal"
>25</TT
></TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN937"
>Identifier Shapes</A
></H2
><P
>Identifiers can have name shape (alphanumeric) or operator shape (symbols). The shape is purely lexical and does not determine behavior. Whether an identifier acts as a prefix function or chain operator depends on its declaration and the register state.</P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN940"
></A
><TABLE
BORDER="0"
FRAME="void"
CLASS="CALSTABLE"
><COL
WIDTH="1*"><COL
WIDTH="1*"><THEAD
><TR
><TH
>Input</TH
><TH
>Result</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="literal"
>10 div 3</TT
></TD
><TD
><TT
CLASS="literal"
>3</TT
></TD
></TR
><TR
><TD
><TT
CLASS="literal"
>abs (- 5)</TT
></TD
><TD
><TT
CLASS="literal"
>5</TT
></TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
></DIV
><DIV
CLASS="section"
><H1
CLASS="section"
><A
NAME="AEN959"
>Definitions</A
></H1
><P
>Definitions declare new types that can be used throughout a program.</P
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN962"
>Structure Definitions</A
></H2
><P
>The define keyword creates a new structure type with named properties.</P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN965"
></A
><TABLE
BORDER="0"
FRAME="void"
CLASS="CALSTABLE"
><COL
WIDTH="1*"><COL
WIDTH="1*"><THEAD
><TR
><TH
>Input</TH
><TH
>Result</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="literal"
>define Point(x: int, y: int)
Point(3, 4)</TT
></TD
><TD
><TT
CLASS="literal"
>{"_type":"Point","x":3,"y":4}</TT
></TD
></TR
><TR
><TD
><TT
CLASS="literal"
>define Point(x: int, y: int)
Point(3, 4).x</TT
></TD
><TD
><TT
CLASS="literal"
>3</TT
></TD
></TR
><TR
><TD
><TT
CLASS="literal"
>define Point(x: int, y: int)
let p Point(3, 4): p.x + p.y</TT
></TD
><TD
><TT
CLASS="literal"
>7</TT
></TD
></TR
><TR
><TD
><TT
CLASS="literal"
>define Point(x: int, y: int)
define Rectangle(origin: Point, width: int, height: int)
Rectangle(Point(0, 0), 10, 5).width</TT
></TD
><TD
><TT
CLASS="literal"
>10</TT
></TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
></DIV
><DIV
CLASS="section"
><H1
CLASS="section"
><A
NAME="AEN994"
>If Expressions</A
></H1
><P
>If expressions evaluate one of two branches based on a boolean condition.
      The syntax is <TT
CLASS="code"
>if</TT
> followed by the condition, a colon, the consequent,
      and optionally <TT
CLASS="code"
>else</TT
> with an alternative.
    </P
><PRE
CLASS="programlisting"
>if true: 1 else 0        ; evaluates to 1
if false: 1 else 0       ; evaluates to 0
if 5 &#62; 3: 10 else 20     ; evaluates to 10</PRE
><P
>&#13;      If expressions can be nested:
    </P
><PRE
CLASS="programlisting"
>if false: 1 else if true: 2 else 3  ; evaluates to 2</PRE
></DIV
><DIV
CLASS="section"
><H1
CLASS="section"
><A
NAME="AEN1002"
>Match Expressions</A
></H1
><P
>Match expressions compare a value against multiple cases.
      The syntax is <TT
CLASS="code"
>match</TT
> followed by the scrutinee, a colon,
      one or more <TT
CLASS="code"
>case</TT
> branches, and optionally <TT
CLASS="code"
>else</TT
>.
    </P
><PRE
CLASS="programlisting"
>match 2: case 1: 10 case 2: 20 else 0  ; evaluates to 20
match 5: case 1: 10 else 0              ; evaluates to 0</PRE
><P
>&#13;      Multiple cases can share the same branch:
    </P
><PRE
CLASS="programlisting"
>match 2: case 1 case 2: "one or two" else "other"</PRE
></DIV
><DIV
CLASS="section"
><H1
CLASS="section"
><A
NAME="AEN1011"
>Let Bindings</A
></H1
><P
>Let bindings introduce local variables. The syntax is
      <TT
CLASS="code"
>let</TT
> followed by a name and a value expression (no equals sign).
      Multiple statements are separated by colons.
    </P
><PRE
CLASS="programlisting"
>let x 5: x               ; evaluates to 5
let x 5: x + 3           ; evaluates to 8
let x 5: let y 3: x + y  ; evaluates to 8</PRE
><P
>&#13;      The value can be any expression, including arithmetic:
    </P
><PRE
CLASS="programlisting"
>let x 2 + 3: x * 2       ; x is 5, result is 10</PRE
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="definitions.htm"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="stdlib.htm"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Definitions</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Standard Library Reference</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>