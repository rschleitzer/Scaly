<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Expressions</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="The Scaly Programming Language"
HREF="index.html"><LINK
REL="PREVIOUS"
TITLE="Definitions"
HREF="definitions.htm"><LINK
REL="NEXT"
TITLE="Standard Library Reference"
HREF="stdlib.htm"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=UTF-8"></HEAD
><BODY
CLASS="chapter"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>The Scaly Programming Language</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="definitions.htm"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="stdlib.htm"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="chapter"
><H1
><A
NAME="AEN1169"
></A
>Chapter 6 Expressions</H1
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
><A
HREF="expressions.htm#AEN1171"
>Overview</A
></DT
><DT
><A
HREF="expressions.htm#AEN1174"
>Literals</A
></DT
><DT
><A
HREF="expressions.htm#AEN1324"
>Operations</A
></DT
><DT
><A
HREF="expressions.htm#AEN1482"
>Comparison Operators</A
></DT
><DT
><A
HREF="expressions.htm#AEN1569"
>Boolean Operators</A
></DT
><DT
><A
HREF="expressions.htm#AEN1626"
>Bitwise Operators</A
></DT
><DT
><A
HREF="expressions.htm#AEN1661"
>If Expressions</A
></DT
><DT
><A
HREF="expressions.htm#AEN1669"
>Match Expressions</A
></DT
><DT
><A
HREF="expressions.htm#AEN1678"
>Choose Expressions</A
></DT
><DT
><A
HREF="expressions.htm#AEN1742"
>Optional Types</A
></DT
><DT
><A
HREF="expressions.htm#AEN1806"
>Variant Construction</A
></DT
></DL
></DIV
><DIV
CLASS="section"
><H1
CLASS="section"
><A
NAME="AEN1171"
>Overview</A
></H1
><P
>Expressions are the core computational units of Scaly. Every expression
      evaluates to a value. Unlike many languages, Scaly uses postfix operators
      and does not define operator precedence â€” evaluation order is always
      explicit.
    </P
></DIV
><DIV
CLASS="section"
><H1
CLASS="section"
><A
NAME="AEN1174"
>Literals</A
></H1
><P
>Expressions are the core computational units of Scaly. Every expression evaluates to a value.</P
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN1177"
>Boolean Literals</A
></H2
><P
>The boolean literals are true and false.</P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN1180"
></A
><TABLE
BORDER="0"
FRAME="void"
CLASS="CALSTABLE"
><COL
WIDTH="1*"><COL
WIDTH="1*"><THEAD
><TR
><TH
>Input</TH
><TH
>Result</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="literal"
>true</TT
></TD
><TD
><TT
CLASS="literal"
>true
        </TT
></TD
></TR
><TR
><TD
><TT
CLASS="literal"
>false</TT
></TD
><TD
><TT
CLASS="literal"
>false

    </TT
></TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN1199"
>Integer Literals</A
></H2
><P
>Integer literals are sequences of decimal digits, optionally preceded by a minus sign for negative numbers.</P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN1202"
></A
><TABLE
BORDER="0"
FRAME="void"
CLASS="CALSTABLE"
><COL
WIDTH="1*"><COL
WIDTH="1*"><THEAD
><TR
><TH
>Input</TH
><TH
>Result</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="literal"
>42</TT
></TD
><TD
><TT
CLASS="literal"
>42
        </TT
></TD
></TR
><TR
><TD
><TT
CLASS="literal"
>0</TT
></TD
><TD
><TT
CLASS="literal"
>0
        </TT
></TD
></TR
><TR
><TD
><TT
CLASS="literal"
>-7</TT
></TD
><TD
><TT
CLASS="literal"
>-7

    </TT
></TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN1226"
>Hexadecimal Literals</A
></H2
><P
>Hexadecimal literals start with 0x or 0X followed by hexadecimal digits (0-9, a-f, A-F).</P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN1229"
></A
><TABLE
BORDER="0"
FRAME="void"
CLASS="CALSTABLE"
><COL
WIDTH="1*"><COL
WIDTH="1*"><THEAD
><TR
><TH
>Input</TH
><TH
>Result</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="literal"
>0xFF</TT
></TD
><TD
><TT
CLASS="literal"
>255
        </TT
></TD
></TR
><TR
><TD
><TT
CLASS="literal"
>0x1A</TT
></TD
><TD
><TT
CLASS="literal"
>26
        </TT
></TD
></TR
><TR
><TD
><TT
CLASS="literal"
>0x0</TT
></TD
><TD
><TT
CLASS="literal"
>0

    </TT
></TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN1253"
>Floating-Point Literals</A
></H2
><P
>Floating-point literals contain a decimal point separating the integer and fractional parts.</P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN1256"
></A
><TABLE
BORDER="0"
FRAME="void"
CLASS="CALSTABLE"
><COL
WIDTH="1*"><COL
WIDTH="1*"><THEAD
><TR
><TH
>Input</TH
><TH
>Result</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="literal"
>3.14</TT
></TD
><TD
><TT
CLASS="literal"
>3.14
        </TT
></TD
></TR
><TR
><TD
><TT
CLASS="literal"
>2.0</TT
></TD
><TD
><TT
CLASS="literal"
>2.0
        </TT
></TD
></TR
><TR
><TD
><TT
CLASS="literal"
>0.5</TT
></TD
><TD
><TT
CLASS="literal"
>0.5

    </TT
></TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN1280"
>String Literals</A
></H2
><P
>String literals are enclosed in double quotes. They may span multiple lines, with line breaks preserved in the resulting string.</P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN1283"
></A
><TABLE
BORDER="0"
FRAME="void"
CLASS="CALSTABLE"
><COL
WIDTH="1*"><COL
WIDTH="1*"><THEAD
><TR
><TH
>Input</TH
><TH
>Result</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="literal"
>"hello"</TT
></TD
><TD
><TT
CLASS="literal"
>hello
        </TT
></TD
></TR
><TR
><TD
><TT
CLASS="literal"
>""</TT
></TD
><TD
><TT
CLASS="literal"
>&#13;    </TT
></TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN1302"
>Character Literals</A
></H2
><P
>Character literals represent a single character, enclosed in backticks.</P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN1305"
></A
><TABLE
BORDER="0"
FRAME="void"
CLASS="CALSTABLE"
><COL
WIDTH="1*"><COL
WIDTH="1*"><THEAD
><TR
><TH
>Input</TH
><TH
>Result</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="literal"
>`a`</TT
></TD
><TD
><TT
CLASS="literal"
>a
        </TT
></TD
></TR
><TR
><TD
><TT
CLASS="literal"
>`Z`</TT
></TD
><TD
><TT
CLASS="literal"
>Z
</TT
></TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
></DIV
><DIV
CLASS="section"
><H1
CLASS="section"
><A
NAME="AEN1324"
>Operations</A
></H1
><P
>Operations allow combining expressions.</P
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN1327"
>Prefix Functions</A
></H2
><P
>An operation is a sequence of operands that evaluates to a single value.
        Each operand is an expression optionally followed by member access. An operation ends with a colon, a line break,
        or anything which is not an expression. Evaluation uses a context which is empty at the start of an operation.
        When the context is empty, operator-shaped identifiers act as prefix functions, taking the next operand as their argument.</P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN1330"
></A
><TABLE
BORDER="0"
FRAME="void"
CLASS="CALSTABLE"
><COL
WIDTH="1*"><COL
WIDTH="1*"><THEAD
><TR
><TH
>Input</TH
><TH
>Result</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="literal"
>-7</TT
></TD
><TD
><TT
CLASS="literal"
>-7
        </TT
></TD
></TR
><TR
><TD
><TT
CLASS="literal"
>-(-3)</TT
></TD
><TD
><TT
CLASS="literal"
>3
        </TT
></TD
></TR
><TR
><TD
><TT
CLASS="literal"
>+ 3</TT
></TD
><TD
><TT
CLASS="literal"
>3

    </TT
></TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN1354"
>Operator Chains</A
></H2
><P
>When the context holds a value, operators combine with operands according to standard mathematical precedence.
        Multiplicative operators (*, /, %, div, mod) bind tighter than additive operators (+, -).
        Comparison and equality operators have lower precedence than arithmetic.
        Operators of equal precedence associate left-to-right.</P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN1357"
></A
><TABLE
BORDER="0"
FRAME="void"
CLASS="CALSTABLE"
><COL
WIDTH="1*"><COL
WIDTH="1*"><THEAD
><TR
><TH
>Input</TH
><TH
>Result</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="literal"
>3 + 4</TT
></TD
><TD
><TT
CLASS="literal"
>7
        </TT
></TD
></TR
><TR
><TD
><TT
CLASS="literal"
>10 - 3</TT
></TD
><TD
><TT
CLASS="literal"
>7
        </TT
></TD
></TR
><TR
><TD
><TT
CLASS="literal"
>6 * 7</TT
></TD
><TD
><TT
CLASS="literal"
>42
        </TT
></TD
></TR
><TR
><TD
><TT
CLASS="literal"
>84 / 2</TT
></TD
><TD
><TT
CLASS="literal"
>42
        </TT
></TD
></TR
><TR
><TD
><TT
CLASS="literal"
>17 % 5</TT
></TD
><TD
><TT
CLASS="literal"
>2
        </TT
></TD
></TR
><TR
><TD
><TT
CLASS="literal"
>3 + 4 * 2</TT
></TD
><TD
><TT
CLASS="literal"
>11
        </TT
></TD
></TR
><TR
><TD
><TT
CLASS="literal"
>20 - 5 - 3</TT
></TD
><TD
><TT
CLASS="literal"
>12

    </TT
></TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN1401"
>Parentheses and Grouping</A
></H2
><P
>Parentheses create a empty context. This allows prefix forms inside an otherwise operator chain,
        and explicit grouping when needed.</P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN1404"
></A
><TABLE
BORDER="0"
FRAME="void"
CLASS="CALSTABLE"
><COL
WIDTH="1*"><COL
WIDTH="1*"><THEAD
><TR
><TH
>Input</TH
><TH
>Result</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="literal"
>5 * (- 2)</TT
></TD
><TD
><TT
CLASS="literal"
>-10
        </TT
></TD
></TR
><TR
><TD
><TT
CLASS="literal"
>2 * (3 + 4)</TT
></TD
><TD
><TT
CLASS="literal"
>14
        </TT
></TD
></TR
><TR
><TD
><TT
CLASS="literal"
>(2 + 3) * (4 + 1)</TT
></TD
><TD
><TT
CLASS="literal"
>25

    </TT
></TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN1428"
>Identifier Shapes</A
></H2
><P
>Identifiers can have name shape (alphanumeric) or operator shape (symbols). The shape is purely lexical and does not determine behavior. Whether an identifier acts as a prefix function or chain operator depends on its declaration and the register state.</P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN1431"
></A
><TABLE
BORDER="0"
FRAME="void"
CLASS="CALSTABLE"
><COL
WIDTH="1*"><COL
WIDTH="1*"><THEAD
><TR
><TH
>Input</TH
><TH
>Result</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="literal"
>10 div 3</TT
></TD
><TD
><TT
CLASS="literal"
>3
        </TT
></TD
></TR
><TR
><TD
><TT
CLASS="literal"
>abs (- 5)</TT
></TD
><TD
><TT
CLASS="literal"
>5

    </TT
></TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN1450"
>Let Bindings</A
></H2
><P
>Let bindings introduce local variables. The syntax is let followed by a name and a value expression (no equals sign). Multiple statements are separated by colons or newlines.</P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN1453"
></A
><TABLE
BORDER="0"
FRAME="void"
CLASS="CALSTABLE"
><COL
WIDTH="1*"><COL
WIDTH="1*"><THEAD
><TR
><TH
>Input</TH
><TH
>Result</TH
></TR
></THEAD
><TBODY
><TR
><TD
><PRE
CLASS="programlisting"
>let x 5
x</PRE
></TD
><TD
><TT
CLASS="literal"
>5
        </TT
></TD
></TR
><TR
><TD
><PRE
CLASS="programlisting"
>let x 5
x + 3</PRE
></TD
><TD
><TT
CLASS="literal"
>8
        </TT
></TD
></TR
><TR
><TD
><PRE
CLASS="programlisting"
>let x 5
let y 3
x + y</PRE
></TD
><TD
><TT
CLASS="literal"
>8
        </TT
></TD
></TR
><TR
><TD
><PRE
CLASS="programlisting"
>let x 2 + 3
x * 2</PRE
></TD
><TD
><TT
CLASS="literal"
>10
</TT
></TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
></DIV
><DIV
CLASS="section"
><H1
CLASS="section"
><A
NAME="AEN1482"
>Comparison Operators</A
></H1
><P
>Comparison operators compare two values and return a boolean result.</P
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN1485"
>Equality</A
></H2
><P
>The equality operator (=) tests if two values are equal. The inequality operator (not equal to) tests if two values are different.</P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN1488"
></A
><TABLE
BORDER="0"
FRAME="void"
CLASS="CALSTABLE"
><COL
WIDTH="1*"><COL
WIDTH="1*"><THEAD
><TR
><TH
>Input</TH
><TH
>Result</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="literal"
>5 = 5</TT
></TD
><TD
><TT
CLASS="literal"
>true
        </TT
></TD
></TR
><TR
><TD
><TT
CLASS="literal"
>5 = 3</TT
></TD
><TD
><TT
CLASS="literal"
>false
        </TT
></TD
></TR
><TR
><TD
><TT
CLASS="literal"
>5 &#60;&#62; 3</TT
></TD
><TD
><TT
CLASS="literal"
>true
        </TT
></TD
></TR
><TR
><TD
><TT
CLASS="literal"
>5 &#60;&#62; 5</TT
></TD
><TD
><TT
CLASS="literal"
>false

    </TT
></TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN1517"
>Relational Operators</A
></H2
><P
>Relational operators compare the ordering of values.</P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN1520"
></A
><TABLE
BORDER="0"
FRAME="void"
CLASS="CALSTABLE"
><COL
WIDTH="1*"><COL
WIDTH="1*"><THEAD
><TR
><TH
>Input</TH
><TH
>Result</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="literal"
>3 &#60; 5</TT
></TD
><TD
><TT
CLASS="literal"
>true
        </TT
></TD
></TR
><TR
><TD
><TT
CLASS="literal"
>5 &#60; 3</TT
></TD
><TD
><TT
CLASS="literal"
>false
        </TT
></TD
></TR
><TR
><TD
><TT
CLASS="literal"
>5 &#62; 3</TT
></TD
><TD
><TT
CLASS="literal"
>true
        </TT
></TD
></TR
><TR
><TD
><TT
CLASS="literal"
>3 &#62; 5</TT
></TD
><TD
><TT
CLASS="literal"
>false
        </TT
></TD
></TR
><TR
><TD
><TT
CLASS="literal"
>5 &#60;= 5</TT
></TD
><TD
><TT
CLASS="literal"
>true
        </TT
></TD
></TR
><TR
><TD
><TT
CLASS="literal"
>5 &#60;= 3</TT
></TD
><TD
><TT
CLASS="literal"
>false
        </TT
></TD
></TR
><TR
><TD
><TT
CLASS="literal"
>5 &#62;= 5</TT
></TD
><TD
><TT
CLASS="literal"
>true
        </TT
></TD
></TR
><TR
><TD
><TT
CLASS="literal"
>3 &#62;= 5</TT
></TD
><TD
><TT
CLASS="literal"
>false
</TT
></TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
></DIV
><DIV
CLASS="section"
><H1
CLASS="section"
><A
NAME="AEN1569"
>Boolean Operators</A
></H1
><P
>Boolean operators combine boolean values.</P
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN1572"
>Boolean Negation</A
></H2
><P
>The tilde operator negates a boolean value.</P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN1575"
></A
><TABLE
BORDER="0"
FRAME="void"
CLASS="CALSTABLE"
><COL
WIDTH="1*"><COL
WIDTH="1*"><THEAD
><TR
><TH
>Input</TH
><TH
>Result</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="literal"
>~true</TT
></TD
><TD
><TT
CLASS="literal"
>false
        </TT
></TD
></TR
><TR
><TD
><TT
CLASS="literal"
>~false</TT
></TD
><TD
><TT
CLASS="literal"
>true

    </TT
></TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN1594"
>Boolean And/Or</A
></H2
><P
>The ampersand operator performs logical AND, the pipe operator performs logical OR.</P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN1597"
></A
><TABLE
BORDER="0"
FRAME="void"
CLASS="CALSTABLE"
><COL
WIDTH="1*"><COL
WIDTH="1*"><THEAD
><TR
><TH
>Input</TH
><TH
>Result</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="literal"
>true &#38; true</TT
></TD
><TD
><TT
CLASS="literal"
>true
        </TT
></TD
></TR
><TR
><TD
><TT
CLASS="literal"
>true &#38; false</TT
></TD
><TD
><TT
CLASS="literal"
>false
        </TT
></TD
></TR
><TR
><TD
><TT
CLASS="literal"
>false | false</TT
></TD
><TD
><TT
CLASS="literal"
>false
        </TT
></TD
></TR
><TR
><TD
><TT
CLASS="literal"
>true | false</TT
></TD
><TD
><TT
CLASS="literal"
>true
</TT
></TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
></DIV
><DIV
CLASS="section"
><H1
CLASS="section"
><A
NAME="AEN1626"
>Bitwise Operators</A
></H1
><P
>Bitwise operators manipulate integer values at the bit level.</P
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN1629"
>Bit Shifts</A
></H2
><P
>The left shift operator shifts bits to the left, effectively multiplying by powers of two. The right shift operator shifts bits to the right, effectively dividing by powers of two.</P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN1632"
></A
><TABLE
BORDER="0"
FRAME="void"
CLASS="CALSTABLE"
><COL
WIDTH="1*"><COL
WIDTH="1*"><THEAD
><TR
><TH
>Input</TH
><TH
>Result</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="literal"
>1 &#60;&#60; 4</TT
></TD
><TD
><TT
CLASS="literal"
>16
        </TT
></TD
></TR
><TR
><TD
><TT
CLASS="literal"
>5 &#60;&#60; 3</TT
></TD
><TD
><TT
CLASS="literal"
>40
        </TT
></TD
></TR
><TR
><TD
><TT
CLASS="literal"
>16 &#62;&#62; 2</TT
></TD
><TD
><TT
CLASS="literal"
>4
        </TT
></TD
></TR
><TR
><TD
><TT
CLASS="literal"
>100 &#62;&#62; 3</TT
></TD
><TD
><TT
CLASS="literal"
>12
</TT
></TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
></DIV
><DIV
CLASS="section"
><H1
CLASS="section"
><A
NAME="AEN1661"
>If Expressions</A
></H1
><P
>If expressions evaluate one of two branches based on a boolean condition.
      The syntax is <TT
CLASS="code"
>if</TT
> followed by the condition, a colon, the consequent,
      and optionally <TT
CLASS="code"
>else</TT
> with an alternative.
    </P
><PRE
CLASS="programlisting"
>if true: 1 else 0        ; evaluates to 1
if false: 1 else 0       ; evaluates to 0
if 5 &#62; 3: 10 else 20     ; evaluates to 10</PRE
><P
>&#13;      If expressions can be nested:
    </P
><PRE
CLASS="programlisting"
>if false: 1 else if true: 2 else 3  ; evaluates to 2</PRE
></DIV
><DIV
CLASS="section"
><H1
CLASS="section"
><A
NAME="AEN1669"
>Match Expressions</A
></H1
><P
>Match expressions compare a value against multiple cases.
      The syntax is <TT
CLASS="code"
>match</TT
> followed by the scrutinee, a colon,
      one or more <TT
CLASS="code"
>case</TT
> branches, and optionally <TT
CLASS="code"
>else</TT
>.
    </P
><PRE
CLASS="programlisting"
>match 2: case 1: 10 case 2: 20 else 0  ; evaluates to 20
match 5: case 1: 10 else 0              ; evaluates to 0</PRE
><P
>&#13;      Multiple cases can share the same branch:
    </P
><PRE
CLASS="programlisting"
>match 2: case 1 case 2: "one or two" else "other"</PRE
></DIV
><DIV
CLASS="section"
><H1
CLASS="section"
><A
NAME="AEN1678"
>Choose Expressions</A
></H1
><P
>Choose expressions pattern match on union types, allowing different code paths based on which variant is present.</P
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN1681"
>Choose on Variant Construction</A
></H2
><P
>Choose can match directly on constructed variants.</P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN1684"
></A
><TABLE
BORDER="0"
FRAME="void"
CLASS="CALSTABLE"
><COL
WIDTH="1*"><COL
WIDTH="1*"><THEAD
><TR
><TH
>Input</TH
><TH
>Result</TH
></TR
></THEAD
><TBODY
><TR
><TD
><PRE
CLASS="programlisting"
>define Option union(Some: int, None)
choose Option.Some(7): when v: Some: v else 0</PRE
></TD
><TD
><TT
CLASS="literal"
>7
        </TT
></TD
></TR
><TR
><TD
><PRE
CLASS="programlisting"
>define Option union(Some: int, None)
choose Option.None: when v: Some: v else 0</PRE
></TD
><TD
><TT
CLASS="literal"
>0

    </TT
></TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN1703"
>Choose with Binding</A
></H2
><P
>When a variant carries a value, the value can be bound to a name.</P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN1706"
></A
><TABLE
BORDER="0"
FRAME="void"
CLASS="CALSTABLE"
><COL
WIDTH="1*"><COL
WIDTH="1*"><THEAD
><TR
><TH
>Input</TH
><TH
>Result</TH
></TR
></THEAD
><TBODY
><TR
><TD
><PRE
CLASS="programlisting"
>define Result union(Ok: int, Err: int)
choose Result.Ok(42): when x: Ok: x + 1 else 0</PRE
></TD
><TD
><TT
CLASS="literal"
>43

    </TT
></TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN1720"
>Multiple When Clauses</A
></H2
><P
>Choose can have multiple when clauses to match different variants.</P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN1723"
></A
><TABLE
BORDER="0"
FRAME="void"
CLASS="CALSTABLE"
><COL
WIDTH="1*"><COL
WIDTH="1*"><THEAD
><TR
><TH
>Input</TH
><TH
>Result</TH
></TR
></THEAD
><TBODY
><TR
><TD
><PRE
CLASS="programlisting"
>define Result union(Ok: int, Err: int)
choose Result.Ok(10): when x: Ok: x when e: Err: e + 100</PRE
></TD
><TD
><TT
CLASS="literal"
>10
        </TT
></TD
></TR
><TR
><TD
><PRE
CLASS="programlisting"
>define Result union(Ok: int, Err: int)
choose Result.Err(5): when x: Ok: x when e: Err: e + 100</PRE
></TD
><TD
><TT
CLASS="literal"
>105
</TT
></TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
></DIV
><DIV
CLASS="section"
><H1
CLASS="section"
><A
NAME="AEN1742"
>Optional Types</A
></H1
><P
>Optional types use null pointer optimization (NPO) for efficient representation.</P
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN1745"
>Is Null Check</A
></H2
><P
>The is null expression checks if an optional value is None.</P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN1748"
></A
><TABLE
BORDER="0"
FRAME="void"
CLASS="CALSTABLE"
><COL
WIDTH="1*"><COL
WIDTH="1*"><THEAD
><TR
><TH
>Input</TH
><TH
>Result</TH
></TR
></THEAD
><TBODY
><TR
><TD
><PRE
CLASS="programlisting"
>define Option[T] union: (Some: T, None)
function check(x: int?) returns int: if x is null: 0 else 1
check(Option[int].None)</PRE
></TD
><TD
><TT
CLASS="literal"
>0
        </TT
></TD
></TR
><TR
><TD
><PRE
CLASS="programlisting"
>define Option[T] union: (Some: T, None)
function check(x: int?) returns int: if x is null: 0 else 1
check(Option[int].Some(42))</PRE
></TD
><TD
><TT
CLASS="literal"
>1

    </TT
></TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN1767"
>Optional Type Sugar</A
></H2
><P
>T? is syntactic sugar for Option[T].</P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN1770"
></A
><TABLE
BORDER="0"
FRAME="void"
CLASS="CALSTABLE"
><COL
WIDTH="1*"><COL
WIDTH="1*"><THEAD
><TR
><TH
>Input</TH
><TH
>Result</TH
></TR
></THEAD
><TBODY
><TR
><TD
><PRE
CLASS="programlisting"
>define Option[T] union: (Some: T, None)
function unwrap(x: int?) returns int: choose x: when v: Some: v else 0
unwrap(Option[int].Some(42))</PRE
></TD
><TD
><TT
CLASS="literal"
>42

    </TT
></TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN1784"
>Generic Option Types</A
></H2
><P
>Generic unions like Option[T] work with choose for pattern matching.</P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN1787"
></A
><TABLE
BORDER="0"
FRAME="void"
CLASS="CALSTABLE"
><COL
WIDTH="1*"><COL
WIDTH="1*"><THEAD
><TR
><TH
>Input</TH
><TH
>Result</TH
></TR
></THEAD
><TBODY
><TR
><TD
><PRE
CLASS="programlisting"
>define Option[T] union: (Some: T, None)
choose Option[int].Some(42): when v: Some: v else 0</PRE
></TD
><TD
><TT
CLASS="literal"
>42
        </TT
></TD
></TR
><TR
><TD
><PRE
CLASS="programlisting"
>define Option[T] union: (Some: T, None)
choose Option[int].None: when v: Some: v else -1</PRE
></TD
><TD
><TT
CLASS="literal"
>-1
</TT
></TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
></DIV
><DIV
CLASS="section"
><H1
CLASS="section"
><A
NAME="AEN1806"
>Variant Construction</A
></H1
><P
>Union variants can be constructed explicitly using Type.Variant syntax.</P
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN1809"
>Construct Variants</A
></H2
><P
>Variants are constructed with Type.Variant(value) syntax.</P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN1812"
></A
><TABLE
BORDER="0"
FRAME="void"
CLASS="CALSTABLE"
><COL
WIDTH="1*"><COL
WIDTH="1*"><THEAD
><TR
><TH
>Input</TH
><TH
>Result</TH
></TR
></THEAD
><TBODY
><TR
><TD
><PRE
CLASS="programlisting"
>define Result union: (Ok: int, Error: int)
choose Result.Ok(42): when x: Ok: x else 0</PRE
></TD
><TD
><TT
CLASS="literal"
>42
        </TT
></TD
></TR
><TR
><TD
><PRE
CLASS="programlisting"
>define Result union: (Ok: int, Error: int)
choose Result.Error(100): when e: Error: e else 0</PRE
></TD
><TD
><TT
CLASS="literal"
>100

    </TT
></TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN1831"
>Variant Is Expression</A
></H2
><P
>The is expression tests if a union value matches a variant.</P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN1834"
></A
><TABLE
BORDER="0"
FRAME="void"
CLASS="CALSTABLE"
><COL
WIDTH="1*"><COL
WIDTH="1*"><THEAD
><TR
><TH
>Input</TH
><TH
>Result</TH
></TR
></THEAD
><TBODY
><TR
><TD
><PRE
CLASS="programlisting"
>define Result union: (Ok: int, Error: int)
if Result.Ok(50) is Ok : 1 else 0</PRE
></TD
><TD
><TT
CLASS="literal"
>1
        </TT
></TD
></TR
><TR
><TD
><PRE
CLASS="programlisting"
>define Result union: (Ok: int, Error: int)
if Result.Error(33) is Ok : 1 else 0</PRE
></TD
><TD
><TT
CLASS="literal"
>0
</TT
></TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="definitions.htm"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="stdlib.htm"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Definitions</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Standard Library Reference</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>