<!DOCTYPE suite SYSTEM "test.dtd">

<suite xml:id = scaly-tests title = "Scaly Tests">

<category xml:id = literals title = "Literals">

    <prose>Expressions are the core computational units of Scaly. Every expression evaluates to a value.

    <tests xml:id = boolean-literals title = "Boolean Literals">
        <prose>The boolean literals are true and false.
        <test xml:id = bool-true><input>true<expect>true
        <test xml:id = bool-false><input>false<expect>false

    <tests xml:id = integer-literals title = "Integer Literals">
        <prose>Integer literals are sequences of decimal digits, optionally preceded by a minus sign for negative numbers.
        <test xml:id = int-positive><input>42<expect>42
        <test xml:id = int-zero><input>0<expect>0
        <test xml:id = int-negative><input>-7<expect>-7

    <tests xml:id = hex-literals title = "Hexadecimal Literals">
        <prose>Hexadecimal literals start with 0x or 0X followed by hexadecimal digits (0-9, a-f, A-F).
        <test xml:id = hex-ff><input>0xFF<expect>255
        <test xml:id = hex-1a><input>0x1A<expect>26
        <test xml:id = hex-zero><input>0x0<expect>0

    <tests xml:id = float-literals title = "Floating-Point Literals">
        <prose>Floating-point literals contain a decimal point separating the integer and fractional parts.
        <test xml:id = float-pi><input>3.14<expect>3.14
        <test xml:id = float-two><input>2.0<expect>2
        <test xml:id = float-half><input>0.5<expect>0.5

    <tests xml:id = string-literals title = "String Literals">
        <prose>String literals are enclosed in double quotes. They may span multiple lines, with line breaks preserved in the resulting string.
        <test xml:id = string-hello><input>"hello"<expect>hello
        <test xml:id = string-empty><input>""<expect>

    <tests xml:id = character-literals title = "Character Literals">
        <prose>Character literals represent a single character, enclosed in backticks.
        <test xml:id = char-a><input>`a`<expect>a
        <test xml:id = char-z><input>`Z`<expect>Z

<category xml:id = operations title = "Operations">

    <prose>Oparations allow combining expressions.

    <tests xml:id = prefix-functions title = "Prefix Functions">
        <prose>An operation is a sequence of operands that evaluates to a single value.
        Each operand is an expression optionally followed by member access. An operation ends with a colon, a line break,
        or anything which is not an expression. Evaluation uses a context which is empty at the start of an operation.
        When the context is empty, operator-shaped identifiers act as prefix functions, taking the next operand as their argument.
        <test xml:id = negate-positive><input>-7<expect>-7
        <test xml:id = negate-negative><input>-(-3)<expect>3
        <test xml:id = prefix-add><input>+ 3<expect>3

    <tests xml:id = operator-chains title = "Operator Chains">
        <prose>When the context holds a value, operators chain left-to-right. Each operator takes the current value and the next operand,
        producing a new value. There is no operator precedence built into the language itself. Operator precedence is built into the implementation
        of the individual operators. The common arithmetic operators are built into the standard library.
        <test xml:id = simple-add><input>3 + 4<expect>7
        <test xml:id = simple-subtract><input>10 - 3<expect>7
        <test xml:id = simple-multiply><input>6 * 7<expect>42
        <test xml:id = chain-with-precedence><input>3 + 4 * 2<expect>11
        <test xml:id = chain-left-to-right><input>20 - 5 - 3<expect>12

    <tests xml:id = parentheses-grouping title = "Parentheses and Grouping">
        <prose>Parentheses create a empty context. This allows prefix forms inside an otherwise operator chain,
        and explicit grouping when needed.
        <test xml:id = parens-negate><input>5 * (- 2)<expect>-10
        <test xml:id = parens-grouping><input>2 * (3 + 4)<expect>14
        <test xml:id = nested-parens><input>(2 + 3) * (4 + 1)<expect>25

    <tests xml:id = identifier-shapes title = "Identifier Shapes">
        <prose>Identifiers can have name shape (alphanumeric) or operator shape (symbols). The shape is purely lexical and does not determine behavior. Whether an identifier acts as a prefix function or chain operator depends on its declaration and the register state.
        <test xml:id = name-as-operator><input>10 div 3<expect>3
        <test xml:id = name-as-function><input>abs (- 5)<expect>5

</category>

<category xml:id = definitions title = "Definitions">

    <prose>Definitions declare new types that can be used throughout a program.

    <tests xml:id = structure-definitions title = "Structure Definitions">
        <prose>The define keyword creates a new structure type with named properties.
        <test xml:id = define-point program = true><input>define Point(x: int, y: int)
Point(3, 4)<expect>{"_type":"Point","x":3,"y":4}
        <test xml:id = define-field-access program = true><input>define Point(x: int, y: int)
Point(3, 4).x<expect>3
        <test xml:id = define-with-let program = true><input>define Point(x: int, y: int)
let p Point(3, 4): p.x + p.y<expect>7
        <test xml:id = define-nested program = true><input>define Point(x: int, y: int)
define Rectangle(origin: Point, width: int, height: int)
Rectangle(Point(0, 0), 10, 5).width<expect>10

</category>

</suite>
