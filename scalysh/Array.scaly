namespace scaly {

class Array[T] {

    mutable size: int 0
    mutable capacity: int 0
    mutable rawArray: pointer[T] ()

    initializer(capacity: int) {
        set this.capacity: capacity
        set rawArray: ()
    }

    initializer(array: Array[T]) {
        set size: array.length()
        set capacity: array.length()
        allocate()
        memcpy(rawArray, array.getRawArray(), size * sizeof T)
    }

    operator (i: int): T throws ArrayOutOfBoundsError {
        if (i >= size) {
            throw ArrayOutOfBoundsError() }

        return rawArray + (i * sizeof T) as T
    }

    method length(): int {
        return size
    }

    method getRawArray(): pointer {
        return rawArray;
    }

    // Append a value to the array
    method push(item: T) {
        if (rawArray = ()) {
            set capacity: 1
            set size: 0
            allocate()
        }
        else {
            if (size = capacity) {
                reAllocate(capacity * 2) }
        }

        set rawArray[size]: item
        set size: size + 1
    }

    // Take away a value from the array's end
    method pop(): T? {
        if (size = 0) {
            return ()
        }
        else {
            T item = this[size - 1]
            set size: size - 1
            return item
        }
    }

    // Remove a value from the array
    method remove(t: T) {
        mutable i: int 0
        do {
            if (this[i] = t) {
                mutable j: int i + 1
                do {
                    set this[j - 1]: this[j]
                } while (j < size)
                set size: size - 1
                return
            }
            set i: i + 1
        } while (i < size)
    }

    method reAllocate(newCapacity: int) {
        let oldArray: pointer[T] rawArray
        set capacity: newCapacity
        allocate()
        memcpy(rawArray, oldArray, size * sizeof T);

        // Reclaim the page if it was oversized, i.e., exclusively allocated
        if (((Object*)oldArray).getPage().isOversized()) {
            getPage().reclaimArray(oldArray) }
    }

    method allocate() {
        set rawArray: getPage().allocateObject(capacity * sizeof pointer[T])
    }
}

}
