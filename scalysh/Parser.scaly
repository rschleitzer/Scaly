namespace scalyc {

class Parser(

    fileName: string,
    text: string

    ) {

    mutable lexer: Lexer new Lexer(text)

    let usingKeyword: string = new string("using")
    let namespaceKeyword: string = new string("namespace")
    let typedefKeyword: string = new string("typedef")
    let letKeyword: string = new string("let")
    let mutableKeyword: string = new string("mutable")
    let threadlocalKeyword: string = new string("threadlocal")
    let varKeyword: string = new string("var")
    let setKeyword: string = new string("set")
    let classKeyword: string = new string("class")
    let extendsKeyword: string = new string("extends")
    let initializerKeyword: string = new string("initializer")
    let allocatorKeyword: string = new string("allocator")
    let methodKeyword: string = new string("method")
    let functionKeyword: string = new string("function")
    let operatorKeyword: string = new string("operator")
    let thisKeyword: string = new string("this")
    let newKeyword: string = new string("new")
    let sizeofKeyword: string = new string("sizeof")
    let catchKeyword: string = new string("catch")
    let throwsKeyword: string = new string("throws")
    let asKeyword: string = new string("as")
    let isKeyword: string = new string("is")
    let ifKeyword: string = new string("if")
    let elseKeyword: string = new string("else")
    let switchKeyword: string = new string("switch")
    let caseKeyword: string = new string("case")
    let defaultKeyword: string = new string("default")
    let forKeyword: string = new string("for")
    let inKeyword: string = new string("in")
    let whileKeyword: string = new string("while")
    let doKeyword: string = new string("do")
    let loopKeyword: string = new string("loop")
    let breakKeyword: string = new string("break")
    let continueKeyword: string = new string("continue")
    let returnKeyword: string = new string("return")
    let throwKeyword: string = new string("throw")
    let intrinsicKeyword: string = new string("intrinsic")
    let defineKeyword: string = new string("define")
    let semicolon: string = new string(";")
    let leftCurly: string = new string("{")
    let rightCurly: string = new string("}")
    let leftParen: string = new string("(")
    let rightParen: string = new string(")")
    let leftBracket: string = new string("[")
    let rightBracket: string = new string("]")
    let dot: string = new string(".")
    let comma: string = new string(",")
    let colon: string = new string(":")
    let question: string = new string("?")
    let exclamation: string = new string("!")
    let at: string = new string("@")
    let hash: string = new string("#")
    let dollar: string = new string("$")
    let underscore: string = new string("_")
    let backtick: string = new string("`")

    function parseFile(): File throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()

        let intrinsics: Array[Intrinsic] = parseIntrinsicList()
        if (intrinsics <> null) {
            if (isAtEnd() = false) {
                let errorPos: Position$ = lexer.getPreviousPosition()
                throw syntax(errorPos.line, errorPos.column)
            }
        }

        let usings: Array[Using] = parseUsingList()
        if (usings <> null) {
            if (isAtEnd() = false) {
                let errorPos: Position$ = lexer.getPreviousPosition()
                throw syntax(errorPos.line, errorPos.column)
            }
        }

        let defines: Array[Define] = parseDefineList()
        if (defines <> null) {
            if (isAtEnd() = false) {
                let errorPos: Position$ = lexer.getPreviousPosition()
                throw syntax(errorPos.line, errorPos.column)
            }
        }

        let declarations: Array[Declaration] = parseDeclarationList()
        if (declarations <> null) {
            if (isAtEnd() = false) {
                let errorPos: Position$ = lexer.getPreviousPosition()
                throw syntax(errorPos.line, errorPos.column)
            }
        }

        let statements: Array[Statement] = parseStatementList()
        if (statements <> null) {
            if (isAtEnd() = false) {
                let errorPos: Position$ = lexer.getPreviousPosition()
                throw syntax(errorPos.line, errorPos.column)
            }
        }

        let end: Position$ lexer.getPosition()

        let ret: File new File(intrinsics, usings, defines, declarations, statements, new Position(start), new Position(end))
        if (intrinsics <> ()) {
            for (item: Intrinsic in intrinsics) {
                item.parent = ret }
        }
        if (usings <> ()) {
            for (item: Using in usings) {
                item.parent = ret }
        }
        if (defines <> ()) {
            for (item: Define in defines) {
                item.parent = ret }
        }
        if (declarations <> ()) {
            for (item: Declaration in declarations) {
                item.parent = ret }
        }
        if (statements <> ()) {
            for (item: Statement in statements) {
                item.parent = ret }
        }

        ret
    }

    method parseIntrinsicList(): Array[Intrinsic] {
        mutable ret: Array[Intrinsic]$ = null
        while (true) {

            let node: Intrinsic parseIntrinsic()
            if (node = ()) {
                break }

            if (ret = ()) {
                ret = new Array[Intrinsic]() }

            ret.add(node)
        }

        ret
    }

    function parseIntrinsic(): Intrinsic {
        let start: Position$ = lexer.getPreviousPosition()

        let successIntrinsic1: bool = lexer.parseKeyword(intrinsicKeyword)
        if (successIntrinsic1) {
            lexer.advance() }
        else {
            return () }

        let name: string = lexer.parseIdentifier()
        if ((name <> ()) && isIdentifier(name)) {
            lexer.advance() }
        else {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Intrinsic new Intrinsic(name, new Position(start), new Position(end))

        ret
    }

    method parseUsingList(): Array[Using] {
        mutable ret: Array[Using]$ = null
        while (true) {

            let node: Using parseUsing()
            if (node = ()) {
                break }

            if (ret = ()) {
                ret = new Array[Using]() }

            ret.add(node)
        }

        ret
    }

    function parseUsing(): Using {
        let start: Position$ = lexer.getPreviousPosition()

        let successUsing1: bool = lexer.parseKeyword(usingKeyword)
        if (successUsing1) {
            lexer.advance() }
        else {
            return () }

        let name: Name = parseName()
        if (name = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Using new Using(name, new Position(start), new Position(end))
        name.parent = ret

        ret
    }

    method parseDefineList(): Array[Define] {
        mutable ret: Array[Define]$ = null
        while (true) {

            let node: Define parseDefine()
            if (node = ()) {
                break }

            if (ret = ()) {
                ret = new Array[Define]() }

            ret.add(node)
        }

        ret
    }

    function parseDefine(): Define {
        let start: Position$ = lexer.getPreviousPosition()

        let successDefine1: bool = lexer.parseKeyword(defineKeyword)
        if (successDefine1) {
            lexer.advance() }
        else {
            return () }

        let name: Name = parseName()
        if (name = ()) {
            return () }

        let typeSpec: Type = parseType()
        if (typeSpec = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Define new Define(name, typeSpec, new Position(start), new Position(end))
        name.parent = ret
        typeSpec.parent = ret

        ret
    }

    method parseDeclarationList(): Array[Declaration] {
        mutable ret: Array[Declaration]$ = null
        while (true) {

            let node: Declaration parseDeclaration()
            if (node = ()) {
                break }

            if (ret = ()) {
                ret = new Array[Declaration]() }

            ret.add(node)
        }

        ret
    }

    function parseDeclaration(): Declaration {
        {
            let node: Namespace = parseNamespace()
            if (node <> ()) {
                return node }
        }

        {
            let node: Function = parseFunction()
            if (node <> ()) {
                return node }
        }

        {
            let node: Class = parseClass()
            if (node <> ()) {
                return node }
        }

        {
            let node: LetDeclaration = parseLetDeclaration()
            if (node <> ()) {
                return node }
        }

        {
            let node: VarDeclaration = parseVarDeclaration()
            if (node <> ()) {
                return node }
        }

        {
            let node: MutableDeclaration = parseMutableDeclaration()
            if (node <> ()) {
                return node }
        }

        {
            let node: ThreadLocalDeclaration = parseThreadLocalDeclaration()
            if (node <> ()) {
                return node }
        }

        null
    }

    function parseNamespace(): Namespace {
        let start: Position$ = lexer.getPreviousPosition()

        let successNamespace1: bool = lexer.parseKeyword(namespaceKeyword)
        if (successNamespace1) {
            lexer.advance() }
        else {
            return () }

        let name: Name = parseName()
        if (name = ()) {
            return () }

        let successLeftCurly3: bool = lexer.parsePunctuation(leftCurly)
        if (successLeftCurly3) {
            lexer.advance() }
        else {
            return () }

        let usings: Array[Using] = parseUsingList()

        let defines: Array[Define] = parseDefineList()

        let declarations: Array[Declaration] = parseDeclarationList()

        let successRightCurly7: bool = lexer.parsePunctuation(rightCurly)
        if (successRightCurly7) {
            lexer.advance() }
        else {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Namespace new Namespace(name, usings, defines, declarations, new Position(start), new Position(end))
        name.parent = ret
        if (usings <> ()) {
            for (item: Using in usings) {
                item.parent = ret }
        }
        if (defines <> ()) {
            for (item: Define in defines) {
                item.parent = ret }
        }
        if (declarations <> ()) {
            for (item: Declaration in declarations) {
                item.parent = ret }
        }

        ret
    }

    function parseFunction(): Function {
        let start: Position$ = lexer.getPreviousPosition()

        let successFunction1: bool = lexer.parseKeyword(functionKeyword)
        if (successFunction1) {
            lexer.advance() }
        else {
            return () }

        let procedure: Procedure = parseProcedure()
        if (procedure = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Function new Function(procedure, new Position(start), new Position(end))
        procedure.parent = ret

        ret
    }

    function parseProcedure(): Procedure {
        let start: Position$ = lexer.getPreviousPosition()

        let name: string = lexer.parseIdentifier()
        if ((name <> ()) && isIdentifier(name)) {
            lexer.advance() }
        else {
            return () }

        let routine: Routine = parseRoutine()
        if (routine = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Procedure new Procedure(name, routine, new Position(start), new Position(end))
        routine.parent = ret

        ret
    }

    function parseRoutine(): Routine {
        let start: Position$ = lexer.getPreviousPosition()

        let input: Structure = parseStructure()

        let output: TypeAnnotation = parseTypeAnnotation()

        let throwsClause: Throws = parseThrows()

        let body: Block = parseBlock()
        if (body = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Routine new Routine(input, output, throwsClause, body, new Position(start), new Position(end))
        if (input <> ()) {
            input.parent = ret }
        if (output <> ()) {
            output.parent = ret }
        if (throwsClause <> ()) {
            throwsClause.parent = ret }
        body.parent = ret

        ret
    }

    function parseLetDeclaration(): LetDeclaration {
        let start: Position$ = lexer.getPreviousPosition()

        let declaration: Let = parseLet()
        if (declaration = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: LetDeclaration new LetDeclaration(declaration, new Position(start), new Position(end))
        declaration.parent = ret

        ret
    }

    function parseVarDeclaration(): VarDeclaration {
        let start: Position$ = lexer.getPreviousPosition()

        let declaration: Var = parseVar()
        if (declaration = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: VarDeclaration new VarDeclaration(declaration, new Position(start), new Position(end))
        declaration.parent = ret

        ret
    }

    function parseMutableDeclaration(): MutableDeclaration {
        let start: Position$ = lexer.getPreviousPosition()

        let declaration: Mutable = parseMutable()
        if (declaration = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: MutableDeclaration new MutableDeclaration(declaration, new Position(start), new Position(end))
        declaration.parent = ret

        ret
    }

    function parseThreadLocalDeclaration(): ThreadLocalDeclaration {
        let start: Position$ = lexer.getPreviousPosition()

        let declaration: ThreadLocal = parseThreadLocal()
        if (declaration = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: ThreadLocalDeclaration new ThreadLocalDeclaration(declaration, new Position(start), new Position(end))
        declaration.parent = ret

        ret
    }

    method parseStatementList(): Array[Statement] {
        mutable ret: Array[Statement]$ = null
        while (true) {

            let node: Statement parseStatement()
            if (node = ()) {
                break }

            if (ret = ()) {
                ret = new Array[Statement]() }

            ret.add(node)
        }

        ret
    }

    function parseStatement(): Statement {
        {
            let node: Let = parseLet()
            if (node <> ()) {
                return node }
        }

        {
            let node: Var = parseVar()
            if (node <> ()) {
                return node }
        }

        {
            let node: Mutable = parseMutable()
            if (node <> ()) {
                return node }
        }

        {
            let node: ThreadLocal = parseThreadLocal()
            if (node <> ()) {
                return node }
        }

        {
            let node: Set = parseSet()
            if (node <> ()) {
                return node }
        }

        {
            let node: Calculation = parseCalculation()
            if (node <> ()) {
                return node }
        }

        {
            let node: Break = parseBreak()
            if (node <> ()) {
                return node }
        }

        {
            let node: Continue = parseContinue()
            if (node <> ()) {
                return node }
        }

        {
            let node: Return = parseReturn()
            if (node <> ()) {
                return node }
        }

        {
            let node: Throw = parseThrow()
            if (node <> ()) {
                return node }
        }

        null
    }

    function parseName(): Name {
        let start: Position$ = lexer.getPreviousPosition()

        let name: string = lexer.parseIdentifier()
        if ((name <> ()) && isIdentifier(name)) {
            lexer.advance() }
        else {
            return () }

        let extensions: Array[Extension] = parseExtensionList()

        let end: Position$ lexer.getPosition()

        let ret: Name new Name(name, extensions, new Position(start), new Position(end))
        if (extensions <> ()) {
            for (item: Extension in extensions) {
                item.parent = ret }
        }

        ret
    }

    method parseExtensionList(): Array[Extension] {
        mutable ret: Array[Extension]$ = null
        while (true) {

            let node: Extension parseExtension()
            if (node = ()) {
                break }

            if (ret = ()) {
                ret = new Array[Extension]() }

            ret.add(node)
        }

        ret
    }

    function parseExtension(): Extension {
        let start: Position$ = lexer.getPreviousPosition()

        let successDot1: bool = lexer.parsePunctuation(dot)
        if (successDot1) {
            lexer.advance() }
        else {
            return () }

        let name: string = lexer.parseIdentifier()
        if ((name <> ()) && isIdentifier(name)) {
            lexer.advance() }
        else {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Extension new Extension(name, new Position(start), new Position(end))

        ret
    }

    function parseLet(): Let {
        let start: Position$ = lexer.getPreviousPosition()

        let successLet1: bool = lexer.parseKeyword(letKeyword)
        if (successLet1) {
            lexer.advance() }
        else {
            return () }

        let binding: Binding = parseBinding()
        if (binding = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Let new Let(binding, new Position(start), new Position(end))
        binding.parent = ret

        ret
    }

    function parseVar(): Var {
        let start: Position$ = lexer.getPreviousPosition()

        let successVar1: bool = lexer.parseKeyword(varKeyword)
        if (successVar1) {
            lexer.advance() }
        else {
            return () }

        let binding: Binding = parseBinding()
        if (binding = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Var new Var(binding, new Position(start), new Position(end))
        binding.parent = ret

        ret
    }

    function parseMutable(): Mutable {
        let start: Position$ = lexer.getPreviousPosition()

        let successMutable1: bool = lexer.parseKeyword(mutableKeyword)
        if (successMutable1) {
            lexer.advance() }
        else {
            return () }

        let binding: Binding = parseBinding()
        if (binding = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Mutable new Mutable(binding, new Position(start), new Position(end))
        binding.parent = ret

        ret
    }

    function parseThreadLocal(): ThreadLocal {
        let start: Position$ = lexer.getPreviousPosition()

        let successThreadlocal1: bool = lexer.parseKeyword(threadlocalKeyword)
        if (successThreadlocal1) {
            lexer.advance() }
        else {
            return () }

        let binding: Binding = parseBinding()
        if (binding = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: ThreadLocal new ThreadLocal(binding, new Position(start), new Position(end))
        binding.parent = ret

        ret
    }

    function parseBinding(): Binding {
        let start: Position$ = lexer.getPreviousPosition()

        let name: Name = parseName()
        if (name = ()) {
            return () }

        let typeAnnotation: TypeAnnotation = parseTypeAnnotation()

        let calculation: Calculation = parseCalculation()
        if (calculation = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Binding new Binding(name, typeAnnotation, calculation, new Position(start), new Position(end))
        name.parent = ret
        if (typeAnnotation <> ()) {
            typeAnnotation.parent = ret }
        calculation.parent = ret

        ret
    }

    function parseSet(): Set {
        let start: Position$ = lexer.getPreviousPosition()

        let successSet1: bool = lexer.parseKeyword(setKeyword)
        if (successSet1) {
            lexer.advance() }
        else {
            return () }

        let lValue: Operation = parseOperation()
        if (lValue = ()) {
            return () }

        let successColon3: bool = lexer.parsePunctuation(colon)
        if (successColon3) {
            lexer.advance() }
        else {
            return () }

        let rValue: Calculation = parseCalculation()
        if (rValue = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Set new Set(lValue, rValue, new Position(start), new Position(end))
        lValue.parent = ret
        rValue.parent = ret

        ret
    }

    function parseCalculation(): Calculation {
        let start: Position$ = lexer.getPreviousPosition()

        let operation: Operation = parseOperation()
        if (operation = ()) {
            return () }

        let successSemicolon2: bool = lexer.parsePunctuation(semicolon)
        if (successSemicolon2) {
            lexer.advance() }

        let end: Position$ lexer.getPosition()

        let ret: Calculation new Calculation(operation, new Position(start), new Position(end))
        operation.parent = ret

        ret
    }

    function parseOperation(): Operation {
        let start: Position$ = lexer.getPreviousPosition()

        let op: Array[Operand] = parseOperandList()

        let end: Position$ lexer.getPosition()

        let ret: Operation new Operation(op, new Position(start), new Position(end))
        if (op <> ()) {
            for (item: Operand in op) {
                item.parent = ret }
        }

        ret
    }

    method parseOperandList(): Array[Operand] {
        mutable ret: Array[Operand]$ = null
        while (true) {

            let node: Operand parseOperand()
            if (node = ()) {
                break }

            if (ret = ()) {
                ret = new Array[Operand]() }

            ret.add(node)
        }

        ret
    }

    function parseOperand(): Operand {
        let start: Position$ = lexer.getPreviousPosition()

        let primary: Expression = parseExpression()
        if (primary = ()) {
            return () }

        let postfixes: Array[Postfix] = parsePostfixList()

        let end: Position$ lexer.getPosition()

        let ret: Operand new Operand(primary, postfixes, new Position(start), new Position(end))
        primary.parent = ret
        if (postfixes <> ()) {
            for (item: Postfix in postfixes) {
                item.parent = ret }
        }

        ret
    }

    method parsePostfixList(): Array[Postfix] {
        mutable ret: Array[Postfix]$ = null
        while (true) {

            let node: Postfix parsePostfix()
            if (node = ()) {
                break }

            if (ret = ()) {
                ret = new Array[Postfix]() }

            ret.add(node)
        }

        ret
    }

    function parsePostfix(): Postfix {
        {
            let node: MemberAccess = parseMemberAccess()
            if (node <> ()) {
                return node }
        }

        {
            let node: As = parseAs()
            if (node <> ()) {
                return node }
        }

        {
            let node: Is = parseIs()
            if (node <> ()) {
                return node }
        }

        {
            let node: Unwrap = parseUnwrap()
            if (node <> ()) {
                return node }
        }

        {
            let node: Catch = parseCatch()
            if (node <> ()) {
                return node }
        }

        null
    }

    function parseMemberAccess(): MemberAccess {
        let start: Position$ = lexer.getPreviousPosition()

        let successDot1: bool = lexer.parsePunctuation(dot)
        if (successDot1) {
            lexer.advance() }
        else {
            return () }

        let member: string = lexer.parseIdentifier()
        if ((member <> ()) && isIdentifier(member)) {
            lexer.advance() }
        else {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: MemberAccess new MemberAccess(member, new Position(start), new Position(end))

        ret
    }

    function parseAs(): As {
        let start: Position$ = lexer.getPreviousPosition()

        let successAs1: bool = lexer.parseKeyword(asKeyword)
        if (successAs1) {
            lexer.advance() }
        else {
            return () }

        let typeSpec: TypeSpec = parseTypeSpec()
        if (typeSpec = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: As new As(typeSpec, new Position(start), new Position(end))
        typeSpec.parent = ret

        ret
    }

    function parseIs(): Is {
        let start: Position$ = lexer.getPreviousPosition()

        let successIs1: bool = lexer.parseKeyword(isKeyword)
        if (successIs1) {
            lexer.advance() }
        else {
            return () }

        let typeSpec: TypeSpec = parseTypeSpec()
        if (typeSpec = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Is new Is(typeSpec, new Position(start), new Position(end))
        typeSpec.parent = ret

        ret
    }

    function parseUnwrap(): Unwrap {
        let start: Position$ = lexer.getPreviousPosition()

        let successExclamation1: bool = lexer.parsePunctuation(exclamation)
        if (successExclamation1) {
            lexer.advance() }
        else {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Unwrap new Unwrap(new Position(start), new Position(end))

        ret
    }

    function parseCatch(): Catch {
        let start: Position$ = lexer.getPreviousPosition()

        let successCatch1: bool = lexer.parseKeyword(catchKeyword)
        if (successCatch1) {
            lexer.advance() }
        else {
            return () }

        let typeSpec: CatchPattern = parseCatchPattern()
        if (typeSpec = ()) {
            return () }

        let handler: Block = parseBlock()
        if (handler = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Catch new Catch(typeSpec, handler, new Position(start), new Position(end))
        typeSpec.parent = ret
        handler.parent = ret

        ret
    }

    function parseCatchPattern(): CatchPattern {
        {
            let node: WildCardCatchPattern = parseWildCardCatchPattern()
            if (node <> ()) {
                return node }
        }

        {
            let node: NameCatchPattern = parseNameCatchPattern()
            if (node <> ()) {
                return node }
        }

        null
    }

    function parseWildCardCatchPattern(): WildCardCatchPattern {
        let start: Position$ = lexer.getPreviousPosition()

        let pattern: WildcardPattern = parseWildcardPattern()
        if (pattern = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: WildCardCatchPattern new WildCardCatchPattern(pattern, new Position(start), new Position(end))
        pattern.parent = ret

        ret
    }

    function parseNameCatchPattern(): NameCatchPattern {
        let start: Position$ = lexer.getPreviousPosition()

        let name: Name = parseName()

        let successLeftParen2: bool = lexer.parsePunctuation(leftParen)
        if (successLeftParen2) {
            lexer.advance() }
        else {
            return () }

        let errorName: string = lexer.parseIdentifier()
        if ((errorName <> ()) && isIdentifier(errorName)) {
            lexer.advance() }

        let successRightParen4: bool = lexer.parsePunctuation(rightParen)
        if (successRightParen4) {
            lexer.advance() }
        else {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: NameCatchPattern new NameCatchPattern(name, errorName, new Position(start), new Position(end))
        if (name <> ()) {
            name.parent = ret }

        ret
    }

    method parseExpressionList(): Array[Expression] {
        mutable ret: Array[Expression]$ = null
        while (true) {

            let node: Expression parseExpression()
            if (node = ()) {
                break }

            if (ret = ()) {
                ret = new Array[Expression]() }

            ret.add(node)
        }

        ret
    }

    function parseExpression(): Expression {
        {
            let node: Block = parseBlock()
            if (node <> ()) {
                return node }
        }

        {
            let node: Name = parseName()
            if (node <> ()) {
                return node }
        }

        {
            let node: Constant = parseConstant()
            if (node <> ()) {
                return node }
        }

        {
            let node: If = parseIf()
            if (node <> ()) {
                return node }
        }

        {
            let node: Switch = parseSwitch()
            if (node <> ()) {
                return node }
        }

        {
            let node: For = parseFor()
            if (node <> ()) {
                return node }
        }

        {
            let node: While = parseWhile()
            if (node <> ()) {
                return node }
        }

        {
            let node: Do = parseDo()
            if (node <> ()) {
                return node }
        }

        {
            let node: This = parseThis()
            if (node <> ()) {
                return node }
        }

        {
            let node: New = parseNew()
            if (node <> ()) {
                return node }
        }

        {
            let node: Object = parseObject()
            if (node <> ()) {
                return node }
        }

        {
            let node: Array = parseArray()
            if (node <> ()) {
                return node }
        }

        {
            let node: SizeOf = parseSizeOf()
            if (node <> ()) {
                return node }
        }

        null
    }

    function parseBlock(): Block {
        let start: Position$ = lexer.getPreviousPosition()

        let successLeftCurly1: bool = lexer.parsePunctuation(leftCurly)
        if (successLeftCurly1) {
            lexer.advance() }
        else {
            return () }

        let statements: Array[Statement] = parseStatementList()

        let successRightCurly3: bool = lexer.parsePunctuation(rightCurly)
        if (successRightCurly3) {
            lexer.advance() }
        else {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Block new Block(statements, new Position(start), new Position(end))
        if (statements <> ()) {
            for (item: Statement in statements) {
                item.parent = ret }
        }

        ret
    }

    function parseConstant(): Constant {
        let start: Position$ = lexer.getPreviousPosition()

        let literal: Literal = lexer.parseLiteral()
        if (literal <> ()) {
            lexer.advance() }
        else {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Constant new Constant(literal, new Position(start), new Position(end))

        ret
    }

    function parseIf(): If {
        let start: Position$ = lexer.getPreviousPosition()

        let successIf1: bool = lexer.parseKeyword(ifKeyword)
        if (successIf1) {
            lexer.advance() }
        else {
            return () }

        let successLeftParen2: bool = lexer.parsePunctuation(leftParen)
        if (successLeftParen2) {
            lexer.advance() }
        else {
            return () }

        let condition: Operation = parseOperation()
        if (condition = ()) {
            return () }

        let successRightParen4: bool = lexer.parsePunctuation(rightParen)
        if (successRightParen4) {
            lexer.advance() }
        else {
            return () }

        let consequent: Block = parseBlock()
        if (consequent = ()) {
            return () }

        let elseClause: Else = parseElse()

        let end: Position$ lexer.getPosition()

        let ret: If new If(condition, consequent, elseClause, new Position(start), new Position(end))
        condition.parent = ret
        consequent.parent = ret
        if (elseClause <> ()) {
            elseClause.parent = ret }

        ret
    }

    function parseElse(): Else {
        let start: Position$ = lexer.getPreviousPosition()

        let successElse1: bool = lexer.parseKeyword(elseKeyword)
        if (successElse1) {
            lexer.advance() }
        else {
            return () }

        let alternative: Block = parseBlock()
        if (alternative = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Else new Else(alternative, new Position(start), new Position(end))
        alternative.parent = ret

        ret
    }

    function parseSwitch(): Switch {
        let start: Position$ = lexer.getPreviousPosition()

        let successSwitch1: bool = lexer.parseKeyword(switchKeyword)
        if (successSwitch1) {
            lexer.advance() }
        else {
            return () }

        let successLeftParen2: bool = lexer.parsePunctuation(leftParen)
        if (successLeftParen2) {
            lexer.advance() }
        else {
            return () }

        let condition: Operation = parseOperation()
        if (condition = ()) {
            return () }

        let successRightParen4: bool = lexer.parsePunctuation(rightParen)
        if (successRightParen4) {
            lexer.advance() }
        else {
            return () }

        let successLeftCurly5: bool = lexer.parsePunctuation(leftCurly)
        if (successLeftCurly5) {
            lexer.advance() }
        else {
            return () }

        let cases: Array[SwitchCase] = parseSwitchCaseList()

        let successRightCurly7: bool = lexer.parsePunctuation(rightCurly)
        if (successRightCurly7) {
            lexer.advance() }
        else {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Switch new Switch(condition, cases, new Position(start), new Position(end))
        condition.parent = ret
        if (cases <> ()) {
            for (item: SwitchCase in cases) {
                item.parent = ret }
        }

        ret
    }

    method parseSwitchCaseList(): Array[SwitchCase] {
        mutable ret: Array[SwitchCase]$ = null
        while (true) {

            let node: SwitchCase parseSwitchCase()
            if (node = ()) {
                break }

            if (ret = ()) {
                ret = new Array[SwitchCase]() }

            ret.add(node)
        }

        ret
    }

    function parseSwitchCase(): SwitchCase {
        let start: Position$ = lexer.getPreviousPosition()

        let label: CaseLabel = parseCaseLabel()
        if (label = ()) {
            return () }

        let content: Block = parseBlock()
        if (content = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: SwitchCase new SwitchCase(label, content, new Position(start), new Position(end))
        label.parent = ret
        content.parent = ret

        ret
    }

    function parseCaseLabel(): CaseLabel {
        {
            let node: ItemCaseLabel = parseItemCaseLabel()
            if (node <> ()) {
                return node }
        }

        {
            let node: DefaultCaseLabel = parseDefaultCaseLabel()
            if (node <> ()) {
                return node }
        }

        null
    }

    function parseItemCaseLabel(): ItemCaseLabel {
        let start: Position$ = lexer.getPreviousPosition()

        let successCase1: bool = lexer.parseKeyword(caseKeyword)
        if (successCase1) {
            lexer.advance() }
        else {
            return () }

        let items: Array[CaseItem] = parseCaseItemList()

        let end: Position$ lexer.getPosition()

        let ret: ItemCaseLabel new ItemCaseLabel(items, new Position(start), new Position(end))
        if (items <> ()) {
            for (item: CaseItem in items) {
                item.parent = ret }
        }

        ret
    }

    method parseCaseItemList(): Array[CaseItem] {
        mutable ret: Array[CaseItem]$ = null
        while (true) {

            let node: CaseItem parseCaseItem()
            if (node = ()) {
                break }

            if (ret = ()) {
                ret = new Array[CaseItem]() }

            ret.add(node)
        }

        ret
    }

    function parseCaseItem(): CaseItem {
        let start: Position$ = lexer.getPreviousPosition()

        let pattern: CasePattern = parseCasePattern()
        if (pattern = ()) {
            return () }

        let successComma2: bool = lexer.parsePunctuation(comma)
        if (successComma2) {
            lexer.advance() }

        let end: Position$ lexer.getPosition()

        let ret: CaseItem new CaseItem(pattern, new Position(start), new Position(end))
        pattern.parent = ret

        ret
    }

    method parseCasePatternList(): Array[CasePattern] {
        mutable ret: Array[CasePattern]$ = null
        while (true) {

            let node: CasePattern parseCasePattern()
            if (node = ()) {
                break }

            if (ret = ()) {
                ret = new Array[CasePattern]() }

            ret.add(node)
        }

        ret
    }

    function parseCasePattern(): CasePattern {
        {
            let node: ConstantPattern = parseConstantPattern()
            if (node <> ()) {
                return node }
        }

        {
            let node: WildcardPattern = parseWildcardPattern()
            if (node <> ()) {
                return node }
        }

        {
            let node: NamePattern = parseNamePattern()
            if (node <> ()) {
                return node }
        }

        null
    }

    function parseConstantPattern(): ConstantPattern {
        let start: Position$ = lexer.getPreviousPosition()

        let constant: Constant = parseConstant()
        if (constant = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: ConstantPattern new ConstantPattern(constant, new Position(start), new Position(end))
        constant.parent = ret

        ret
    }

    function parseWildcardPattern(): WildcardPattern {
        let start: Position$ = lexer.getPreviousPosition()

        let successUnderscore1: bool = lexer.parsePunctuation(underscore)
        if (successUnderscore1) {
            lexer.advance() }
        else {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: WildcardPattern new WildcardPattern(new Position(start), new Position(end))

        ret
    }

    function parseNamePattern(): NamePattern {
        let start: Position$ = lexer.getPreviousPosition()

        let name: Name = parseName()
        if (name = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: NamePattern new NamePattern(name, new Position(start), new Position(end))
        name.parent = ret

        ret
    }

    function parseDefaultCaseLabel(): DefaultCaseLabel {
        let start: Position$ = lexer.getPreviousPosition()

        let successDefault1: bool = lexer.parseKeyword(defaultKeyword)
        if (successDefault1) {
            lexer.advance() }
        else {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: DefaultCaseLabel new DefaultCaseLabel(new Position(start), new Position(end))

        ret
    }

    function parseFor(): For {
        let start: Position$ = lexer.getPreviousPosition()

        let successFor1: bool = lexer.parseKeyword(forKeyword)
        if (successFor1) {
            lexer.advance() }
        else {
            return () }

        let successLeftParen2: bool = lexer.parsePunctuation(leftParen)
        if (successLeftParen2) {
            lexer.advance() }
        else {
            return () }

        let index: string = lexer.parseIdentifier()
        if ((index <> ()) && isIdentifier(index)) {
            lexer.advance() }
        else {
            return () }

        let typeAnnotation: TypeAnnotation = parseTypeAnnotation()

        let successIn5: bool = lexer.parseKeyword(inKeyword)
        if (successIn5) {
            lexer.advance() }
        else {
            return () }

        let operation: Operation = parseOperation()
        if (operation = ()) {
            return () }

        let successRightParen7: bool = lexer.parsePunctuation(rightParen)
        if (successRightParen7) {
            lexer.advance() }
        else {
            return () }

        let iteration: Loop = parseLoop()
        if (iteration = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: For new For(index, typeAnnotation, operation, iteration, new Position(start), new Position(end))
        if (typeAnnotation <> ()) {
            typeAnnotation.parent = ret }
        operation.parent = ret
        iteration.parent = ret

        ret
    }

    function parseWhile(): While {
        let start: Position$ = lexer.getPreviousPosition()

        let successWhile1: bool = lexer.parseKeyword(whileKeyword)
        if (successWhile1) {
            lexer.advance() }
        else {
            return () }

        let successLeftParen2: bool = lexer.parsePunctuation(leftParen)
        if (successLeftParen2) {
            lexer.advance() }
        else {
            return () }

        let condition: Operation = parseOperation()
        if (condition = ()) {
            return () }

        let successRightParen4: bool = lexer.parsePunctuation(rightParen)
        if (successRightParen4) {
            lexer.advance() }
        else {
            return () }

        let iteration: Loop = parseLoop()
        if (iteration = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: While new While(condition, iteration, new Position(start), new Position(end))
        condition.parent = ret
        iteration.parent = ret

        ret
    }

    function parseDo(): Do {
        let start: Position$ = lexer.getPreviousPosition()

        let successDo1: bool = lexer.parseKeyword(doKeyword)
        if (successDo1) {
            lexer.advance() }
        else {
            return () }

        let iteration: Loop = parseLoop()
        if (iteration = ()) {
            return () }

        let successWhile3: bool = lexer.parseKeyword(whileKeyword)
        if (successWhile3) {
            lexer.advance() }
        else {
            return () }

        let successLeftParen4: bool = lexer.parsePunctuation(leftParen)
        if (successLeftParen4) {
            lexer.advance() }
        else {
            return () }

        let condition: Operation = parseOperation()
        if (condition = ()) {
            return () }

        let successRightParen6: bool = lexer.parsePunctuation(rightParen)
        if (successRightParen6) {
            lexer.advance() }
        else {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Do new Do(iteration, condition, new Position(start), new Position(end))
        iteration.parent = ret
        condition.parent = ret

        ret
    }

    function parseLoop(): Loop {
        {
            let node: SimpleLoop = parseSimpleLoop()
            if (node <> ()) {
                return node }
        }

        {
            let node: NamedLoop = parseNamedLoop()
            if (node <> ()) {
                return node }
        }

        null
    }

    function parseSimpleLoop(): SimpleLoop {
        let start: Position$ = lexer.getPreviousPosition()

        let code: Block = parseBlock()
        if (code = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: SimpleLoop new SimpleLoop(code, new Position(start), new Position(end))
        code.parent = ret

        ret
    }

    function parseNamedLoop(): NamedLoop {
        let start: Position$ = lexer.getPreviousPosition()

        let successLoop1: bool = lexer.parseKeyword(loopKeyword)
        if (successLoop1) {
            lexer.advance() }
        else {
            return () }

        let name: string = lexer.parseIdentifier()
        if ((name <> ()) && isIdentifier(name)) {
            lexer.advance() }
        else {
            return () }

        let code: Block = parseBlock()
        if (code = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: NamedLoop new NamedLoop(name, code, new Position(start), new Position(end))
        code.parent = ret

        ret
    }

    function parseThis(): This {
        let start: Position$ = lexer.getPreviousPosition()

        let successThis1: bool = lexer.parseKeyword(thisKeyword)
        if (successThis1) {
            lexer.advance() }
        else {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: This new This(new Position(start), new Position(end))

        ret
    }

    function parseNew(): New {
        let start: Position$ = lexer.getPreviousPosition()

        let successNew1: bool = lexer.parseKeyword(newKeyword)
        if (successNew1) {
            lexer.advance() }
        else {
            return () }

        let typeSpec: Type = parseType()
        if (typeSpec = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: New new New(typeSpec, new Position(start), new Position(end))
        typeSpec.parent = ret

        ret
    }

    function parseObject(): Object {
        let start: Position$ = lexer.getPreviousPosition()

        let successLeftParen1: bool = lexer.parsePunctuation(leftParen)
        if (successLeftParen1) {
            lexer.advance() }
        else {
            return () }

        let firstOp: Operation = parseOperation()

        let additionalOps: Array[Item] = parseItemList()

        let successRightParen4: bool = lexer.parsePunctuation(rightParen)
        if (successRightParen4) {
            lexer.advance() }
        else {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Object new Object(firstOp, additionalOps, new Position(start), new Position(end))
        if (firstOp <> ()) {
            firstOp.parent = ret }
        if (additionalOps <> ()) {
            for (item: Item in additionalOps) {
                item.parent = ret }
        }

        ret
    }

    function parseArray(): Array {
        let start: Position$ = lexer.getPreviousPosition()

        let successLeftBracket1: bool = lexer.parsePunctuation(leftBracket)
        if (successLeftBracket1) {
            lexer.advance() }
        else {
            return () }

        let firstOp: Operation = parseOperation()

        let additionalOps: Array[Item] = parseItemList()

        let successRightBracket4: bool = lexer.parsePunctuation(rightBracket)
        if (successRightBracket4) {
            lexer.advance() }
        else {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Array new Array(firstOp, additionalOps, new Position(start), new Position(end))
        if (firstOp <> ()) {
            firstOp.parent = ret }
        if (additionalOps <> ()) {
            for (item: Item in additionalOps) {
                item.parent = ret }
        }

        ret
    }

    method parseItemList(): Array[Item] {
        mutable ret: Array[Item]$ = null
        while (true) {

            let node: Item parseItem()
            if (node = ()) {
                break }

            if (ret = ()) {
                ret = new Array[Item]() }

            ret.add(node)
        }

        ret
    }

    function parseItem(): Item {
        let start: Position$ = lexer.getPreviousPosition()

        let successComma1: bool = lexer.parsePunctuation(comma)
        if (successComma1) {
            lexer.advance() }
        else {
            return () }

        let operation: Operation = parseOperation()
        if (operation = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Item new Item(operation, new Position(start), new Position(end))
        operation.parent = ret

        ret
    }

    function parseSizeOf(): SizeOf {
        let start: Position$ = lexer.getPreviousPosition()

        let successSizeof1: bool = lexer.parseKeyword(sizeofKeyword)
        if (successSizeof1) {
            lexer.advance() }
        else {
            return () }

        let typeSpec: Type = parseType()
        if (typeSpec = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: SizeOf new SizeOf(typeSpec, new Position(start), new Position(end))
        typeSpec.parent = ret

        ret
    }

    function parseBreak(): Break {
        let start: Position$ = lexer.getPreviousPosition()

        let successBreak1: bool = lexer.parseKeyword(breakKeyword)
        if (successBreak1) {
            lexer.advance() }
        else {
            return () }

        let iteration: string = lexer.parseIdentifier()
        if ((iteration <> ()) && isIdentifier(iteration)) {
            lexer.advance() }

        let successSemicolon3: bool = lexer.parsePunctuation(semicolon)
        if (successSemicolon3) {
            lexer.advance() }

        let end: Position$ lexer.getPosition()

        let ret: Break new Break(iteration, new Position(start), new Position(end))

        ret
    }

    function parseContinue(): Continue {
        let start: Position$ = lexer.getPreviousPosition()

        let successContinue1: bool = lexer.parseKeyword(continueKeyword)
        if (successContinue1) {
            lexer.advance() }
        else {
            return () }

        let iteration: string = lexer.parseIdentifier()
        if ((iteration <> ()) && isIdentifier(iteration)) {
            lexer.advance() }

        let successSemicolon3: bool = lexer.parsePunctuation(semicolon)
        if (successSemicolon3) {
            lexer.advance() }

        let end: Position$ lexer.getPosition()

        let ret: Continue new Continue(iteration, new Position(start), new Position(end))

        ret
    }

    function parseReturn(): Return {
        let start: Position$ = lexer.getPreviousPosition()

        let successReturn1: bool = lexer.parseKeyword(returnKeyword)
        if (successReturn1) {
            lexer.advance() }
        else {
            return () }

        let result: Calculation = parseCalculation()

        let end: Position$ lexer.getPosition()

        let ret: Return new Return(result, new Position(start), new Position(end))
        if (result <> ()) {
            result.parent = ret }

        ret
    }

    function parseThrow(): Throw {
        let start: Position$ = lexer.getPreviousPosition()

        let successThrow1: bool = lexer.parseKeyword(throwKeyword)
        if (successThrow1) {
            lexer.advance() }
        else {
            return () }

        let exception: Calculation = parseCalculation()
        if (exception = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Throw new Throw(exception, new Position(start), new Position(end))
        exception.parent = ret

        ret
    }

    function parseClass(): Class {
        let start: Position$ = lexer.getPreviousPosition()

        let successClass1: bool = lexer.parseKeyword(classKeyword)
        if (successClass1) {
            lexer.advance() }
        else {
            return () }

        let name: Name = parseName()
        if (name = ()) {
            return () }

        let generics: GenericParameters = parseGenericParameters()

        let baseClass: Extends = parseExtends()

        let contents: Structure = parseStructure()

        let body: ClassBody = parseClassBody()

        let end: Position$ lexer.getPosition()

        let ret: Class new Class(name, generics, baseClass, contents, body, new Position(start), new Position(end))
        name.parent = ret
        if (generics <> ()) {
            generics.parent = ret }
        if (baseClass <> ()) {
            baseClass.parent = ret }
        if (contents <> ()) {
            contents.parent = ret }
        if (body <> ()) {
            body.parent = ret }

        ret
    }

    function parseGenericParameters(): GenericParameters {
        let start: Position$ = lexer.getPreviousPosition()

        let successLeftBracket1: bool = lexer.parsePunctuation(leftBracket)
        if (successLeftBracket1) {
            lexer.advance() }
        else {
            return () }

        let name: string = lexer.parseIdentifier()
        if ((name <> ()) && isIdentifier(name)) {
            lexer.advance() }
        else {
            return () }

        let additionalGenerics: Array[GenericParameter] = parseGenericParameterList()

        let successRightBracket4: bool = lexer.parsePunctuation(rightBracket)
        if (successRightBracket4) {
            lexer.advance() }
        else {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: GenericParameters new GenericParameters(name, additionalGenerics, new Position(start), new Position(end))
        if (additionalGenerics <> ()) {
            for (item: GenericParameter in additionalGenerics) {
                item.parent = ret }
        }

        ret
    }

    method parseGenericParameterList(): Array[GenericParameter] {
        mutable ret: Array[GenericParameter]$ = null
        while (true) {

            let node: GenericParameter parseGenericParameter()
            if (node = ()) {
                break }

            if (ret = ()) {
                ret = new Array[GenericParameter]() }

            ret.add(node)
        }

        ret
    }

    function parseGenericParameter(): GenericParameter {
        let start: Position$ = lexer.getPreviousPosition()

        let successComma1: bool = lexer.parsePunctuation(comma)
        if (successComma1) {
            lexer.advance() }
        else {
            return () }

        let name: string = lexer.parseIdentifier()
        if ((name <> ()) && isIdentifier(name)) {
            lexer.advance() }
        else {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: GenericParameter new GenericParameter(name, new Position(start), new Position(end))

        ret
    }

    function parseExtends(): Extends {
        let start: Position$ = lexer.getPreviousPosition()

        let successExtends1: bool = lexer.parseKeyword(extendsKeyword)
        if (successExtends1) {
            lexer.advance() }
        else {
            return () }

        let name: Name = parseName()
        if (name = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Extends new Extends(name, new Position(start), new Position(end))
        name.parent = ret

        ret
    }

    function parseStructure(): Structure {
        let start: Position$ = lexer.getPreviousPosition()

        let successLeftParen1: bool = lexer.parsePunctuation(leftParen)
        if (successLeftParen1) {
            lexer.advance() }
        else {
            return () }

        let components: Array[Component] = parseComponentList()

        let successRightParen3: bool = lexer.parsePunctuation(rightParen)
        if (successRightParen3) {
            lexer.advance() }
        else {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Structure new Structure(components, new Position(start), new Position(end))
        if (components <> ()) {
            for (item: Component in components) {
                item.parent = ret }
        }

        ret
    }

    method parseComponentList(): Array[Component] {
        mutable ret: Array[Component]$ = null
        while (true) {

            let node: Component parseComponent()
            if (node = ()) {
                break }

            if (ret = ()) {
                ret = new Array[Component]() }

            ret.add(node)
        }

        ret
    }

    function parseComponent(): Component {
        let start: Position$ = lexer.getPreviousPosition()

        let name: string = lexer.parseIdentifier()
        if ((name <> ()) && isIdentifier(name)) {
            lexer.advance() }
        else {
            return () }

        let typeAnnotation: TypeAnnotation = parseTypeAnnotation()

        let successComma3: bool = lexer.parsePunctuation(comma)
        if (successComma3) {
            lexer.advance() }

        let end: Position$ lexer.getPosition()

        let ret: Component new Component(name, typeAnnotation, new Position(start), new Position(end))
        if (typeAnnotation <> ()) {
            typeAnnotation.parent = ret }

        ret
    }

    function parseClassBody(): ClassBody {
        let start: Position$ = lexer.getPreviousPosition()

        let successLeftCurly1: bool = lexer.parsePunctuation(leftCurly)
        if (successLeftCurly1) {
            lexer.advance() }
        else {
            return () }

        let members: Array[ClassMember] = parseClassMemberList()

        let successRightCurly3: bool = lexer.parsePunctuation(rightCurly)
        if (successRightCurly3) {
            lexer.advance() }
        else {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: ClassBody new ClassBody(members, new Position(start), new Position(end))
        if (members <> ()) {
            for (item: ClassMember in members) {
                item.parent = ret }
        }

        ret
    }

    method parseClassMemberList(): Array[ClassMember] {
        mutable ret: Array[ClassMember]$ = null
        while (true) {

            let node: ClassMember parseClassMember()
            if (node = ()) {
                break }

            if (ret = ()) {
                ret = new Array[ClassMember]() }

            ret.add(node)
        }

        ret
    }

    function parseClassMember(): ClassMember {
        {
            let node: LetMember = parseLetMember()
            if (node <> ()) {
                return node }
        }

        {
            let node: VarMember = parseVarMember()
            if (node <> ()) {
                return node }
        }

        {
            let node: MutableMember = parseMutableMember()
            if (node <> ()) {
                return node }
        }

        {
            let node: SetInitialization = parseSetInitialization()
            if (node <> ()) {
                return node }
        }

        {
            let node: Method = parseMethod()
            if (node <> ()) {
                return node }
        }

        {
            let node: StaticFunction = parseStaticFunction()
            if (node <> ()) {
                return node }
        }

        {
            let node: Operator = parseOperator()
            if (node <> ()) {
                return node }
        }

        {
            let node: Initializer = parseInitializer()
            if (node <> ()) {
                return node }
        }

        {
            let node: Allocator = parseAllocator()
            if (node <> ()) {
                return node }
        }

        null
    }

    function parseLetMember(): LetMember {
        let start: Position$ = lexer.getPreviousPosition()

        let declaration: Let = parseLet()
        if (declaration = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: LetMember new LetMember(declaration, new Position(start), new Position(end))
        declaration.parent = ret

        ret
    }

    function parseVarMember(): VarMember {
        let start: Position$ = lexer.getPreviousPosition()

        let declaration: Var = parseVar()
        if (declaration = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: VarMember new VarMember(declaration, new Position(start), new Position(end))
        declaration.parent = ret

        ret
    }

    function parseMutableMember(): MutableMember {
        let start: Position$ = lexer.getPreviousPosition()

        let declaration: Mutable = parseMutable()
        if (declaration = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: MutableMember new MutableMember(declaration, new Position(start), new Position(end))
        declaration.parent = ret

        ret
    }

    function parseSetInitialization(): SetInitialization {
        let start: Position$ = lexer.getPreviousPosition()

        let definition: Set = parseSet()
        if (definition = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: SetInitialization new SetInitialization(definition, new Position(start), new Position(end))
        definition.parent = ret

        ret
    }

    function parseMethod(): Method {
        let start: Position$ = lexer.getPreviousPosition()

        let successMethod1: bool = lexer.parseKeyword(methodKeyword)
        if (successMethod1) {
            lexer.advance() }
        else {
            return () }

        let procedure: Procedure = parseProcedure()
        if (procedure = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Method new Method(procedure, new Position(start), new Position(end))
        procedure.parent = ret

        ret
    }

    function parseStaticFunction(): StaticFunction {
        let start: Position$ = lexer.getPreviousPosition()

        let procedure: Function = parseFunction()
        if (procedure = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: StaticFunction new StaticFunction(procedure, new Position(start), new Position(end))
        procedure.parent = ret

        ret
    }

    function parseOperator(): Operator {
        let start: Position$ = lexer.getPreviousPosition()

        let successOperator1: bool = lexer.parseKeyword(operatorKeyword)
        if (successOperator1) {
            lexer.advance() }
        else {
            return () }

        let routine: Routine = parseRoutine()
        if (routine = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Operator new Operator(routine, new Position(start), new Position(end))
        routine.parent = ret

        ret
    }

    function parseInitializer(): Initializer {
        let start: Position$ = lexer.getPreviousPosition()

        let successInitializer1: bool = lexer.parseKeyword(initializerKeyword)
        if (successInitializer1) {
            lexer.advance() }
        else {
            return () }

        let input: Structure = parseStructure()

        let body: Block = parseBlock()
        if (body = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Initializer new Initializer(input, body, new Position(start), new Position(end))
        if (input <> ()) {
            input.parent = ret }
        body.parent = ret

        ret
    }

    function parseAllocator(): Allocator {
        let start: Position$ = lexer.getPreviousPosition()

        let successAllocator1: bool = lexer.parseKeyword(allocatorKeyword)
        if (successAllocator1) {
            lexer.advance() }
        else {
            return () }

        let input: Structure = parseStructure()

        let body: Block = parseBlock()
        if (body = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Allocator new Allocator(input, body, new Position(start), new Position(end))
        if (input <> ()) {
            input.parent = ret }
        body.parent = ret

        ret
    }

    function parseTypeAnnotation(): TypeAnnotation {
        let start: Position$ = lexer.getPreviousPosition()

        let successColon1: bool = lexer.parsePunctuation(colon)
        if (successColon1) {
            lexer.advance() }
        else {
            return () }

        let typeSpec: TypeSpec = parseTypeSpec()
        if (typeSpec = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: TypeAnnotation new TypeAnnotation(typeSpec, new Position(start), new Position(end))
        typeSpec.parent = ret

        ret
    }

    method parseTypeSpecList(): Array[TypeSpec] {
        mutable ret: Array[TypeSpec]$ = null
        while (true) {

            let node: TypeSpec parseTypeSpec()
            if (node = ()) {
                break }

            if (ret = ()) {
                ret = new Array[TypeSpec]() }

            ret.add(node)
        }

        ret
    }

    function parseTypeSpec(): TypeSpec {
        {
            let node: Type = parseType()
            if (node <> ()) {
                return node }
        }

        {
            let node: Variant = parseVariant()
            if (node <> ()) {
                return node }
        }

        null
    }

    method parseTypeList(): Array[Type] {
        mutable ret: Array[Type]$ = null
        while (true) {

            let node: Type parseType()
            if (node = ()) {
                break }

            if (ret = ()) {
                ret = new Array[Type]() }

            ret.add(node)
        }

        ret
    }

    function parseType(): Type {
        let start: Position$ = lexer.getPreviousPosition()

        let name: Name = parseName()
        if (name = ()) {
            return () }

        let generics: GenericArguments = parseGenericArguments()

        let optional: Optional = parseOptional()

        let lifeTime: LifeTime = parseLifeTime()

        let end: Position$ lexer.getPosition()

        let ret: Type new Type(name, generics, optional, lifeTime, new Position(start), new Position(end))
        name.parent = ret
        if (generics <> ()) {
            generics.parent = ret }
        if (optional <> ()) {
            optional.parent = ret }
        if (lifeTime <> ()) {
            lifeTime.parent = ret }

        ret
    }

    function parseVariant(): Variant {
        let start: Position$ = lexer.getPreviousPosition()

        let successLeftParen1: bool = lexer.parsePunctuation(leftParen)
        if (successLeftParen1) {
            lexer.advance() }
        else {
            return () }

        let types: Array[Type] = parseTypeList()

        let successRightParen3: bool = lexer.parsePunctuation(rightParen)
        if (successRightParen3) {
            lexer.advance() }
        else {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Variant new Variant(types, new Position(start), new Position(end))
        if (types <> ()) {
            for (item: Type in types) {
                item.parent = ret }
        }

        ret
    }

    function parseThrows(): Throws {
        let start: Position$ = lexer.getPreviousPosition()

        let successThrows1: bool = lexer.parseKeyword(throwsKeyword)
        if (successThrows1) {
            lexer.advance() }
        else {
            return () }

        let throwsType: TypeSpec = parseTypeSpec()
        if (throwsType = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Throws new Throws(throwsType, new Position(start), new Position(end))
        throwsType.parent = ret

        ret
    }

    function parseGenericArguments(): GenericArguments {
        let start: Position$ = lexer.getPreviousPosition()

        let successLeftBracket1: bool = lexer.parsePunctuation(leftBracket)
        if (successLeftBracket1) {
            lexer.advance() }
        else {
            return () }

        let generic: Type = parseType()
        if (generic = ()) {
            return () }

        let additionalGenerics: Array[GenericArgument] = parseGenericArgumentList()

        let successRightBracket4: bool = lexer.parsePunctuation(rightBracket)
        if (successRightBracket4) {
            lexer.advance() }
        else {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: GenericArguments new GenericArguments(generic, additionalGenerics, new Position(start), new Position(end))
        generic.parent = ret
        if (additionalGenerics <> ()) {
            for (item: GenericArgument in additionalGenerics) {
                item.parent = ret }
        }

        ret
    }

    method parseGenericArgumentList(): Array[GenericArgument] {
        mutable ret: Array[GenericArgument]$ = null
        while (true) {

            let node: GenericArgument parseGenericArgument()
            if (node = ()) {
                break }

            if (ret = ()) {
                ret = new Array[GenericArgument]() }

            ret.add(node)
        }

        ret
    }

    function parseGenericArgument(): GenericArgument {
        let start: Position$ = lexer.getPreviousPosition()

        let successComma1: bool = lexer.parsePunctuation(comma)
        if (successComma1) {
            lexer.advance() }
        else {
            return () }

        let typeSpec: Type = parseType()
        if (typeSpec = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: GenericArgument new GenericArgument(typeSpec, new Position(start), new Position(end))
        typeSpec.parent = ret

        ret
    }

    function parseOptional(): Optional {
        let start: Position$ = lexer.getPreviousPosition()

        let successQuestion1: bool = lexer.parsePunctuation(question)
        if (successQuestion1) {
            lexer.advance() }
        else {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Optional new Optional(new Position(start), new Position(end))

        ret
    }

    function parseLifeTime(): LifeTime {
        {
            let node: Root = parseRoot()
            if (node <> ()) {
                return node }
        }

        {
            let node: Local = parseLocal()
            if (node <> ()) {
                return node }
        }

        {
            let node: Reference = parseReference()
            if (node <> ()) {
                return node }
        }

        {
            let node: Thrown = parseThrown()
            if (node <> ()) {
                return node }
        }

        null
    }

    function parseRoot(): Root {
        let start: Position$ = lexer.getPreviousPosition()

        let successDollar1: bool = lexer.parsePunctuation(dollar)
        if (successDollar1) {
            lexer.advance() }
        else {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Root new Root(new Position(start), new Position(end))

        ret
    }

    function parseLocal(): Local {
        let start: Position$ = lexer.getPreviousPosition()

        let successAt1: bool = lexer.parsePunctuation(at)
        if (successAt1) {
            lexer.advance() }
        else {
            return () }

        let location: string = lexer.parseIdentifier()
        if ((location <> ()) && isIdentifier(location)) {
            lexer.advance() }
        else {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Local new Local(location, new Position(start), new Position(end))

        ret
    }

    function parseReference(): Reference {
        let start: Position$ = lexer.getPreviousPosition()

        let successBacktick1: bool = lexer.parsePunctuation(backtick)
        if (successBacktick1) {
            lexer.advance() }
        else {
            return () }

        let age: Literal = lexer.parseLiteral()
        if (age <> ()) {
            lexer.advance() }

        let end: Position$ lexer.getPosition()

        let ret: Reference new Reference(age, new Position(start), new Position(end))

        ret
    }

    function parseThrown(): Thrown {
        let start: Position$ = lexer.getPreviousPosition()

        let successHash1: bool = lexer.parsePunctuation(hash)
        if (successHash1) {
            lexer.advance() }
        else {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Thrown new Thrown(new Position(start), new Position(end))

        ret
    }

    function isAtEnd(): bool {
        lexer.isAtEnd()
    }

    function isIdentifier(id: string): bool {
        if (id.equals(usingKeyword)) {
            return false }

        if (id.equals(namespaceKeyword)) {
            return false }

        if (id.equals(typedefKeyword)) {
            return false }

        if (id.equals(letKeyword)) {
            return false }

        if (id.equals(mutableKeyword)) {
            return false }

        if (id.equals(threadlocalKeyword)) {
            return false }

        if (id.equals(varKeyword)) {
            return false }

        if (id.equals(setKeyword)) {
            return false }

        if (id.equals(classKeyword)) {
            return false }

        if (id.equals(extendsKeyword)) {
            return false }

        if (id.equals(initializerKeyword)) {
            return false }

        if (id.equals(allocatorKeyword)) {
            return false }

        if (id.equals(methodKeyword)) {
            return false }

        if (id.equals(functionKeyword)) {
            return false }

        if (id.equals(operatorKeyword)) {
            return false }

        if (id.equals(thisKeyword)) {
            return false }

        if (id.equals(newKeyword)) {
            return false }

        if (id.equals(sizeofKeyword)) {
            return false }

        if (id.equals(catchKeyword)) {
            return false }

        if (id.equals(throwsKeyword)) {
            return false }

        if (id.equals(asKeyword)) {
            return false }

        if (id.equals(isKeyword)) {
            return false }

        if (id.equals(ifKeyword)) {
            return false }

        if (id.equals(elseKeyword)) {
            return false }

        if (id.equals(switchKeyword)) {
            return false }

        if (id.equals(caseKeyword)) {
            return false }

        if (id.equals(defaultKeyword)) {
            return false }

        if (id.equals(forKeyword)) {
            return false }

        if (id.equals(inKeyword)) {
            return false }

        if (id.equals(whileKeyword)) {
            return false }

        if (id.equals(doKeyword)) {
            return false }

        if (id.equals(loopKeyword)) {
            return false }

        if (id.equals(breakKeyword)) {
            return false }

        if (id.equals(continueKeyword)) {
            return false }

        if (id.equals(returnKeyword)) {
            return false }

        if (id.equals(throwKeyword)) {
            return false }

        if (id.equals(intrinsicKeyword)) {
            return false }

        if (id.equals(defineKeyword)) {
            return false }

        true
    }
}

class Visitor {
    function openProgram(programSyntax: ProgramSyntax): bool {
        true
    }

    function closeProgram(programSyntax: ProgramSyntax) {
    }

    function openFile(fileSyntax: FileSyntax): bool {
        true
    }

    function closeFile(fileSyntax: FileSyntax) {
    }

    function visitIntrinsic(intrinsicSyntax: IntrinsicSyntax) {
    }

    function openUsing(usingSyntax: UsingSyntax): bool {
        true
    }

    function closeUsing(usingSyntax: UsingSyntax) {
    }

    function openDefine(defineSyntax: DefineSyntax): bool {
        true
    }

    function closeDefine(defineSyntax: DefineSyntax) {
    }

    function openNamespace(namespaceSyntax: NamespaceSyntax): bool {
        true
    }

    function closeNamespace(namespaceSyntax: NamespaceSyntax) {
    }

    function openFunction(functionSyntax: FunctionSyntax): bool {
        true
    }

    function closeFunction(functionSyntax: FunctionSyntax) {
    }

    function openProcedure(procedureSyntax: ProcedureSyntax): bool {
        true
    }

    function closeProcedure(procedureSyntax: ProcedureSyntax) {
    }

    function openRoutine(routineSyntax: RoutineSyntax): bool {
        true
    }

    function closeRoutine(routineSyntax: RoutineSyntax) {
    }

    function openLetDeclaration(letDeclarationSyntax: LetDeclarationSyntax): bool {
        true
    }

    function closeLetDeclaration(letDeclarationSyntax: LetDeclarationSyntax) {
    }

    function openVarDeclaration(varDeclarationSyntax: VarDeclarationSyntax): bool {
        true
    }

    function closeVarDeclaration(varDeclarationSyntax: VarDeclarationSyntax) {
    }

    function openMutableDeclaration(mutableDeclarationSyntax: MutableDeclarationSyntax): bool {
        true
    }

    function closeMutableDeclaration(mutableDeclarationSyntax: MutableDeclarationSyntax) {
    }

    function openThreadLocalDeclaration(threadLocalDeclarationSyntax: ThreadLocalDeclarationSyntax): bool {
        true
    }

    function closeThreadLocalDeclaration(threadLocalDeclarationSyntax: ThreadLocalDeclarationSyntax) {
    }

    function openName(nameSyntax: NameSyntax): bool {
        true
    }

    function closeName(nameSyntax: NameSyntax) {
    }

    function visitExtension(extensionSyntax: ExtensionSyntax) {
    }

    function openLet(letSyntax: LetSyntax): bool {
        true
    }

    function closeLet(letSyntax: LetSyntax) {
    }

    function openVar(varSyntax: VarSyntax): bool {
        true
    }

    function closeVar(varSyntax: VarSyntax) {
    }

    function openMutable(mutableSyntax: MutableSyntax): bool {
        true
    }

    function closeMutable(mutableSyntax: MutableSyntax) {
    }

    function openThreadLocal(threadLocalSyntax: ThreadLocalSyntax): bool {
        true
    }

    function closeThreadLocal(threadLocalSyntax: ThreadLocalSyntax) {
    }

    function openBinding(bindingSyntax: BindingSyntax): bool {
        true
    }

    function closeBinding(bindingSyntax: BindingSyntax) {
    }

    function openSet(setSyntax: SetSyntax): bool {
        true
    }

    function closeSet(setSyntax: SetSyntax) {
    }

    function openCalculation(calculationSyntax: CalculationSyntax): bool {
        true
    }

    function closeCalculation(calculationSyntax: CalculationSyntax) {
    }

    function openOperation(operationSyntax: OperationSyntax): bool {
        true
    }

    function closeOperation(operationSyntax: OperationSyntax) {
    }

    function openOperand(operandSyntax: OperandSyntax): bool {
        true
    }

    function closeOperand(operandSyntax: OperandSyntax) {
    }

    function visitMemberAccess(memberAccessSyntax: MemberAccessSyntax) {
    }

    function openAs(asSyntax: AsSyntax): bool {
        true
    }

    function closeAs(asSyntax: AsSyntax) {
    }

    function openIs(isSyntax: IsSyntax): bool {
        true
    }

    function closeIs(isSyntax: IsSyntax) {
    }

    function visitUnwrap(unwrapSyntax: UnwrapSyntax) {
    }

    function openCatch(catchSyntax: CatchSyntax): bool {
        true
    }

    function closeCatch(catchSyntax: CatchSyntax) {
    }

    function openWildCardCatchPattern(wildCardCatchPatternSyntax: WildCardCatchPatternSyntax): bool {
        true
    }

    function closeWildCardCatchPattern(wildCardCatchPatternSyntax: WildCardCatchPatternSyntax) {
    }

    function openNameCatchPattern(nameCatchPatternSyntax: NameCatchPatternSyntax): bool {
        true
    }

    function closeNameCatchPattern(nameCatchPatternSyntax: NameCatchPatternSyntax) {
    }

    function openBlock(blockSyntax: BlockSyntax): bool {
        true
    }

    function closeBlock(blockSyntax: BlockSyntax) {
    }

    function visitConstant(constantSyntax: ConstantSyntax) {
    }

    function openIf(ifSyntax: IfSyntax): bool {
        true
    }

    function closeIf(ifSyntax: IfSyntax) {
    }

    function openElse(elseSyntax: ElseSyntax): bool {
        true
    }

    function closeElse(elseSyntax: ElseSyntax) {
    }

    function openSwitch(switchSyntax: SwitchSyntax): bool {
        true
    }

    function closeSwitch(switchSyntax: SwitchSyntax) {
    }

    function openSwitchCase(switchCaseSyntax: SwitchCaseSyntax): bool {
        true
    }

    function closeSwitchCase(switchCaseSyntax: SwitchCaseSyntax) {
    }

    function openItemCaseLabel(itemCaseLabelSyntax: ItemCaseLabelSyntax): bool {
        true
    }

    function closeItemCaseLabel(itemCaseLabelSyntax: ItemCaseLabelSyntax) {
    }

    function openCaseItem(caseItemSyntax: CaseItemSyntax): bool {
        true
    }

    function closeCaseItem(caseItemSyntax: CaseItemSyntax) {
    }

    function openConstantPattern(constantPatternSyntax: ConstantPatternSyntax): bool {
        true
    }

    function closeConstantPattern(constantPatternSyntax: ConstantPatternSyntax) {
    }

    function visitWildcardPattern(wildcardPatternSyntax: WildcardPatternSyntax) {
    }

    function openNamePattern(namePatternSyntax: NamePatternSyntax): bool {
        true
    }

    function closeNamePattern(namePatternSyntax: NamePatternSyntax) {
    }

    function visitDefaultCaseLabel(defaultCaseLabelSyntax: DefaultCaseLabelSyntax) {
    }

    function openFor(forSyntax: ForSyntax): bool {
        true
    }

    function closeFor(forSyntax: ForSyntax) {
    }

    function openWhile(whileSyntax: WhileSyntax): bool {
        true
    }

    function closeWhile(whileSyntax: WhileSyntax) {
    }

    function openDo(doSyntax: DoSyntax): bool {
        true
    }

    function closeDo(doSyntax: DoSyntax) {
    }

    function openSimpleLoop(simpleLoopSyntax: SimpleLoopSyntax): bool {
        true
    }

    function closeSimpleLoop(simpleLoopSyntax: SimpleLoopSyntax) {
    }

    function openNamedLoop(namedLoopSyntax: NamedLoopSyntax): bool {
        true
    }

    function closeNamedLoop(namedLoopSyntax: NamedLoopSyntax) {
    }

    function visitThis(thisSyntax: ThisSyntax) {
    }

    function openNew(newSyntax: NewSyntax): bool {
        true
    }

    function closeNew(newSyntax: NewSyntax) {
    }

    function openObject(objectSyntax: ObjectSyntax): bool {
        true
    }

    function closeObject(objectSyntax: ObjectSyntax) {
    }

    function openArray(arraySyntax: ArraySyntax): bool {
        true
    }

    function closeArray(arraySyntax: ArraySyntax) {
    }

    function openItem(itemSyntax: ItemSyntax): bool {
        true
    }

    function closeItem(itemSyntax: ItemSyntax) {
    }

    function openSizeOf(sizeOfSyntax: SizeOfSyntax): bool {
        true
    }

    function closeSizeOf(sizeOfSyntax: SizeOfSyntax) {
    }

    function visitBreak(breakSyntax: BreakSyntax) {
    }

    function visitContinue(continueSyntax: ContinueSyntax) {
    }

    function openReturn(returnSyntax: ReturnSyntax): bool {
        true
    }

    function closeReturn(returnSyntax: ReturnSyntax) {
    }

    function openThrow(throwSyntax: ThrowSyntax): bool {
        true
    }

    function closeThrow(throwSyntax: ThrowSyntax) {
    }

    function openClass(classSyntax: ClassSyntax): bool {
        true
    }

    function closeClass(classSyntax: ClassSyntax) {
    }

    function openGenericParameters(genericParametersSyntax: GenericParametersSyntax): bool {
        true
    }

    function closeGenericParameters(genericParametersSyntax: GenericParametersSyntax) {
    }

    function visitGenericParameter(genericParameterSyntax: GenericParameterSyntax) {
    }

    function openExtends(extendsSyntax: ExtendsSyntax): bool {
        true
    }

    function closeExtends(extendsSyntax: ExtendsSyntax) {
    }

    function openStructure(structureSyntax: StructureSyntax): bool {
        true
    }

    function closeStructure(structureSyntax: StructureSyntax) {
    }

    function openComponent(componentSyntax: ComponentSyntax): bool {
        true
    }

    function closeComponent(componentSyntax: ComponentSyntax) {
    }

    function openClassBody(classBodySyntax: ClassBodySyntax): bool {
        true
    }

    function closeClassBody(classBodySyntax: ClassBodySyntax) {
    }

    function openLetMember(letMemberSyntax: LetMemberSyntax): bool {
        true
    }

    function closeLetMember(letMemberSyntax: LetMemberSyntax) {
    }

    function openVarMember(varMemberSyntax: VarMemberSyntax): bool {
        true
    }

    function closeVarMember(varMemberSyntax: VarMemberSyntax) {
    }

    function openMutableMember(mutableMemberSyntax: MutableMemberSyntax): bool {
        true
    }

    function closeMutableMember(mutableMemberSyntax: MutableMemberSyntax) {
    }

    function openSetInitialization(setInitializationSyntax: SetInitializationSyntax): bool {
        true
    }

    function closeSetInitialization(setInitializationSyntax: SetInitializationSyntax) {
    }

    function openMethod(methodSyntax: MethodSyntax): bool {
        true
    }

    function closeMethod(methodSyntax: MethodSyntax) {
    }

    function openStaticFunction(staticFunctionSyntax: StaticFunctionSyntax): bool {
        true
    }

    function closeStaticFunction(staticFunctionSyntax: StaticFunctionSyntax) {
    }

    function openOperator(operatorSyntax: OperatorSyntax): bool {
        true
    }

    function closeOperator(operatorSyntax: OperatorSyntax) {
    }

    function openInitializer(initializerSyntax: InitializerSyntax): bool {
        true
    }

    function closeInitializer(initializerSyntax: InitializerSyntax) {
    }

    function openAllocator(allocatorSyntax: AllocatorSyntax): bool {
        true
    }

    function closeAllocator(allocatorSyntax: AllocatorSyntax) {
    }

    function openTypeAnnotation(typeAnnotationSyntax: TypeAnnotationSyntax): bool {
        true
    }

    function closeTypeAnnotation(typeAnnotationSyntax: TypeAnnotationSyntax) {
    }

    function openType(typeSyntax: TypeSyntax): bool {
        true
    }

    function closeType(typeSyntax: TypeSyntax) {
    }

    function openVariant(variantSyntax: VariantSyntax): bool {
        true
    }

    function closeVariant(variantSyntax: VariantSyntax) {
    }

    function openThrows(throwsSyntax: ThrowsSyntax): bool {
        true
    }

    function closeThrows(throwsSyntax: ThrowsSyntax) {
    }

    function openGenericArguments(genericArgumentsSyntax: GenericArgumentsSyntax): bool {
        true
    }

    function closeGenericArguments(genericArgumentsSyntax: GenericArgumentsSyntax) {
    }

    function openGenericArgument(genericArgumentSyntax: GenericArgumentSyntax): bool {
        true
    }

    function closeGenericArgument(genericArgumentSyntax: GenericArgumentSyntax) {
    }

    function visitOptional(optionalSyntax: OptionalSyntax) {
    }

    function visitRoot(rootSyntax: RootSyntax) {
    }

    function visitLocal(localSyntax: LocalSyntax) {
    }

    function visitReference(referenceSyntax: ReferenceSyntax) {
    }

    function visitThrown(thrownSyntax: ThrownSyntax) {
    }
}

class SyntaxNode (

    start: Position,
    end: Position

    ) {

    var parent: SyntaxNode? ()
}

class Program extends SyntaxNode (

    name: string, 
    files: Array[File]

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openProgram(this) = false) {
            return }

        if (files <> ()) {
            for (node: File in files) {
                node.accept(visitor) } }

        visitor.closeProgram(this)
    }
}

class File extends SyntaxNode (

    intrinsics: Array[Intrinsic], 
    usings: Array[Using], 
    defines: Array[Define], 
    declarations: Array[Declaration], 
    statements: Array[Statement]

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openFile(this) = false) {
            return }

        if (intrinsics <> ()) {
            for (node: Intrinsic in intrinsics) {
                node.accept(visitor) } }

        if (usings <> ()) {
            for (node: Using in usings) {
                node.accept(visitor) } }

        if (defines <> ()) {
            for (node: Define in defines) {
                node.accept(visitor) } }

        if (declarations <> ()) {
            for (node: Declaration in declarations) {
                node.accept(visitor) } }

        if (statements <> ()) {
            for (node: Statement in statements) {
                node.accept(visitor) } }

        visitor.closeFile(this)
    }
}

class Intrinsic extends SyntaxNode (

    name: string

    ) {
    function accept(visitor: Visitor) {

        visitor.visitIntrinsic(this)
    }
}

class Using extends SyntaxNode (

    name: Name

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openUsing(this) = false) {
            return }
        name.accept(visitor)

        visitor.closeUsing(this)
    }
}

class Define extends SyntaxNode (

    name: Name, 
    typeSpec: Type

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openDefine(this) = false) {
            return }
        name.accept(visitor)
        typeSpec.accept(visitor)

        visitor.closeDefine(this)
    }
}

class Declaration extends SyntaxNode {
    function accept(visitor: Visitor) {
    }
}

class Namespace extends Declaration (

    name: Name, 
    usings: Array[Using], 
    defines: Array[Define], 
    declarations: Array[Declaration], 

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openNamespace(this) = false) {
            return }
        name.accept(visitor)

        if (usings <> ()) {
            for (node: Using in usings) {
                node.accept(visitor) } }

        if (defines <> ()) {
            for (node: Define in defines) {
                node.accept(visitor) } }

        if (declarations <> ()) {
            for (node: Declaration in declarations) {
                node.accept(visitor) } }

        visitor.closeNamespace(this)
    }
}

class Function extends Declaration (

    procedure: Procedure

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openFunction(this) = false) {
            return }
        procedure.accept(visitor)

        visitor.closeFunction(this)
    }
}

class Procedure extends SyntaxNode (

    name: string, 
    routine: Routine

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openProcedure(this) = false) {
            return }
        routine.accept(visitor)

        visitor.closeProcedure(this)
    }
}

class Routine extends SyntaxNode (

    input: Structure, 
    output: TypeAnnotation, 
    throwsClause: Throws, 
    body: Block

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openRoutine(this) = false) {
            return }

        if (input <> ()) {
            input.accept(visitor) }

        if (output <> ()) {
            output.accept(visitor) }

        if (throwsClause <> ()) {
            throwsClause.accept(visitor) }
        body.accept(visitor)

        visitor.closeRoutine(this)
    }
}

class LetDeclaration extends Declaration (

    declaration: Let

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openLetDeclaration(this) = false) {
            return }
        declaration.accept(visitor)

        visitor.closeLetDeclaration(this)
    }
}

class VarDeclaration extends Declaration (

    declaration: Var

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openVarDeclaration(this) = false) {
            return }
        declaration.accept(visitor)

        visitor.closeVarDeclaration(this)
    }
}

class MutableDeclaration extends Declaration (

    declaration: Mutable

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openMutableDeclaration(this) = false) {
            return }
        declaration.accept(visitor)

        visitor.closeMutableDeclaration(this)
    }
}

class ThreadLocalDeclaration extends Declaration (

    declaration: ThreadLocal

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openThreadLocalDeclaration(this) = false) {
            return }
        declaration.accept(visitor)

        visitor.closeThreadLocalDeclaration(this)
    }
}

class Statement extends SyntaxNode {
    function accept(visitor: Visitor) {
    }
}

class Name extends Expression (

    name: string, 
    extensions: Array[Extension]

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openName(this) = false) {
            return }

        if (extensions <> ()) {
            for (node: Extension in extensions) {
                node.accept(visitor) } }

        visitor.closeName(this)
    }
}

class Extension extends SyntaxNode (

    name: string

    ) {
    function accept(visitor: Visitor) {

        visitor.visitExtension(this)
    }
}

class Let extends Statement (

    binding: Binding

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openLet(this) = false) {
            return }
        binding.accept(visitor)

        visitor.closeLet(this)
    }
}

class Var extends Statement (

    binding: Binding

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openVar(this) = false) {
            return }
        binding.accept(visitor)

        visitor.closeVar(this)
    }
}

class Mutable extends Statement (

    binding: Binding

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openMutable(this) = false) {
            return }
        binding.accept(visitor)

        visitor.closeMutable(this)
    }
}

class ThreadLocal extends Statement (

    binding: Binding

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openThreadLocal(this) = false) {
            return }
        binding.accept(visitor)

        visitor.closeThreadLocal(this)
    }
}

class Binding extends SyntaxNode (

    name: Name, 
    typeAnnotation: TypeAnnotation, 
    calculation: Calculation

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openBinding(this) = false) {
            return }
        name.accept(visitor)

        if (typeAnnotation <> ()) {
            typeAnnotation.accept(visitor) }
        calculation.accept(visitor)

        visitor.closeBinding(this)
    }
}

class Set extends Statement (

    lValue: Operation, 
    rValue: Calculation

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openSet(this) = false) {
            return }
        lValue.accept(visitor)
        rValue.accept(visitor)

        visitor.closeSet(this)
    }
}

class Calculation extends Statement (

    operation: Operation, 

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openCalculation(this) = false) {
            return }
        operation.accept(visitor)

        visitor.closeCalculation(this)
    }
}

class Operation extends SyntaxNode (

    op: Array[Operand]

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openOperation(this) = false) {
            return }

        if (op <> ()) {
            for (node: Operand in op) {
                node.accept(visitor) } }

        visitor.closeOperation(this)
    }
}

class Operand extends Statement (

    primary: Expression, 
    postfixes: Array[Postfix]

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openOperand(this) = false) {
            return }
        primary.accept(visitor)

        if (postfixes <> ()) {
            for (node: Postfix in postfixes) {
                node.accept(visitor) } }

        visitor.closeOperand(this)
    }
}

class Postfix extends SyntaxNode {
    function accept(visitor: Visitor) {
    }
}

class MemberAccess extends Postfix (

    member: string

    ) {
    function accept(visitor: Visitor) {

        visitor.visitMemberAccess(this)
    }
}

class As extends Postfix (

    typeSpec: TypeSpec

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openAs(this) = false) {
            return }
        typeSpec.accept(visitor)

        visitor.closeAs(this)
    }
}

class Is extends Postfix (

    typeSpec: TypeSpec

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openIs(this) = false) {
            return }
        typeSpec.accept(visitor)

        visitor.closeIs(this)
    }
}

class Unwrap extends Postfix (


    ) {
    function accept(visitor: Visitor) {

        visitor.visitUnwrap(this)
    }
}

class Catch extends Postfix (

    typeSpec: CatchPattern, 
    handler: Block

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openCatch(this) = false) {
            return }
        typeSpec.accept(visitor)
        handler.accept(visitor)

        visitor.closeCatch(this)
    }
}

class CatchPattern extends SyntaxNode {
    function accept(visitor: Visitor) {
    }
}

class WildCardCatchPattern extends CatchPattern (

    pattern: WildcardPattern

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openWildCardCatchPattern(this) = false) {
            return }
        pattern.accept(visitor)

        visitor.closeWildCardCatchPattern(this)
    }
}

class NameCatchPattern extends CatchPattern (

    name: Name, 
    errorName: string, 

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openNameCatchPattern(this) = false) {
            return }

        if (name <> ()) {
            name.accept(visitor) }

        visitor.closeNameCatchPattern(this)
    }
}

class Expression extends SyntaxNode {
    function accept(visitor: Visitor) {
    }
}

class Block extends Expression (

    statements: Array[Statement], 

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openBlock(this) = false) {
            return }

        if (statements <> ()) {
            for (node: Statement in statements) {
                node.accept(visitor) } }

        visitor.closeBlock(this)
    }
}

class Constant extends Expression (

    literal: Literal

    ) {
    function accept(visitor: Visitor) {

        visitor.visitConstant(this)
    }
}

class If extends Expression (

    condition: Operation, 
    consequent: Block, 
    elseClause: Else

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openIf(this) = false) {
            return }
        condition.accept(visitor)
        consequent.accept(visitor)

        if (elseClause <> ()) {
            elseClause.accept(visitor) }

        visitor.closeIf(this)
    }
}

class Else extends SyntaxNode (

    alternative: Block

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openElse(this) = false) {
            return }
        alternative.accept(visitor)

        visitor.closeElse(this)
    }
}

class Switch extends Expression (

    condition: Operation, 
    cases: Array[SwitchCase], 

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openSwitch(this) = false) {
            return }
        condition.accept(visitor)

        if (cases <> ()) {
            for (node: SwitchCase in cases) {
                node.accept(visitor) } }

        visitor.closeSwitch(this)
    }
}

class SwitchCase extends SyntaxNode (

    label: CaseLabel, 
    content: Block

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openSwitchCase(this) = false) {
            return }
        label.accept(visitor)
        content.accept(visitor)

        visitor.closeSwitchCase(this)
    }
}

class CaseLabel extends SyntaxNode {
    function accept(visitor: Visitor) {
    }
}

class ItemCaseLabel extends CaseLabel (

    items: Array[CaseItem]

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openItemCaseLabel(this) = false) {
            return }

        if (items <> ()) {
            for (node: CaseItem in items) {
                node.accept(visitor) } }

        visitor.closeItemCaseLabel(this)
    }
}

class CaseItem extends SyntaxNode (

    pattern: CasePattern, 

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openCaseItem(this) = false) {
            return }
        pattern.accept(visitor)

        visitor.closeCaseItem(this)
    }
}

class CasePattern extends SyntaxNode {
    function accept(visitor: Visitor) {
    }
}

class ConstantPattern extends CasePattern (

    constant: Constant

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openConstantPattern(this) = false) {
            return }
        constant.accept(visitor)

        visitor.closeConstantPattern(this)
    }
}

class WildcardPattern extends CasePattern (


    ) {
    function accept(visitor: Visitor) {

        visitor.visitWildcardPattern(this)
    }
}

class NamePattern extends CasePattern (

    name: Name

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openNamePattern(this) = false) {
            return }
        name.accept(visitor)

        visitor.closeNamePattern(this)
    }
}

class DefaultCaseLabel extends CaseLabel (


    ) {
    function accept(visitor: Visitor) {

        visitor.visitDefaultCaseLabel(this)
    }
}

class For extends Expression (

    index: string, 
    typeAnnotation: TypeAnnotation, 
    operation: Operation, 
    iteration: Loop

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openFor(this) = false) {
            return }

        if (typeAnnotation <> ()) {
            typeAnnotation.accept(visitor) }
        operation.accept(visitor)
        iteration.accept(visitor)

        visitor.closeFor(this)
    }
}

class While extends Expression (

    condition: Operation, 
    iteration: Loop

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openWhile(this) = false) {
            return }
        condition.accept(visitor)
        iteration.accept(visitor)

        visitor.closeWhile(this)
    }
}

class Do extends Expression (

    iteration: Loop, 
    condition: Operation, 

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openDo(this) = false) {
            return }
        iteration.accept(visitor)
        condition.accept(visitor)

        visitor.closeDo(this)
    }
}

class Loop extends SyntaxNode {
    function accept(visitor: Visitor) {
    }
}

class SimpleLoop extends Loop (

    code: Block

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openSimpleLoop(this) = false) {
            return }
        code.accept(visitor)

        visitor.closeSimpleLoop(this)
    }
}

class NamedLoop extends Loop (

    name: string, 
    code: Block

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openNamedLoop(this) = false) {
            return }
        code.accept(visitor)

        visitor.closeNamedLoop(this)
    }
}

class This extends Expression (


    ) {
    function accept(visitor: Visitor) {

        visitor.visitThis(this)
    }
}

class New extends Expression (

    typeSpec: Type

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openNew(this) = false) {
            return }
        typeSpec.accept(visitor)

        visitor.closeNew(this)
    }
}

class Object extends Expression (

    firstOp: Operation, 
    additionalOps: Array[Item], 

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openObject(this) = false) {
            return }

        if (firstOp <> ()) {
            firstOp.accept(visitor) }

        if (additionalOps <> ()) {
            for (node: Item in additionalOps) {
                node.accept(visitor) } }

        visitor.closeObject(this)
    }
}

class Array extends Expression (

    firstOp: Operation, 
    additionalOps: Array[Item], 

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openArray(this) = false) {
            return }

        if (firstOp <> ()) {
            firstOp.accept(visitor) }

        if (additionalOps <> ()) {
            for (node: Item in additionalOps) {
                node.accept(visitor) } }

        visitor.closeArray(this)
    }
}

class Item extends SyntaxNode (

    operation: Operation

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openItem(this) = false) {
            return }
        operation.accept(visitor)

        visitor.closeItem(this)
    }
}

class SizeOf extends Expression (

    typeSpec: Type

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openSizeOf(this) = false) {
            return }
        typeSpec.accept(visitor)

        visitor.closeSizeOf(this)
    }
}

class Break extends Statement (

    iteration: string, 

    ) {
    function accept(visitor: Visitor) {

        visitor.visitBreak(this)
    }
}

class Continue extends Statement (

    iteration: string, 

    ) {
    function accept(visitor: Visitor) {

        visitor.visitContinue(this)
    }
}

class Return extends Statement (

    result: Calculation

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openReturn(this) = false) {
            return }

        if (result <> ()) {
            result.accept(visitor) }

        visitor.closeReturn(this)
    }
}

class Throw extends Statement (

    exception: Calculation

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openThrow(this) = false) {
            return }
        exception.accept(visitor)

        visitor.closeThrow(this)
    }
}

class Class extends Declaration (

    name: Name, 
    generics: GenericParameters, 
    baseClass: Extends, 
    contents: Structure, 
    body: ClassBody

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openClass(this) = false) {
            return }
        name.accept(visitor)

        if (generics <> ()) {
            generics.accept(visitor) }

        if (baseClass <> ()) {
            baseClass.accept(visitor) }

        if (contents <> ()) {
            contents.accept(visitor) }

        if (body <> ()) {
            body.accept(visitor) }

        visitor.closeClass(this)
    }
}

class GenericParameters extends SyntaxNode (

    name: string, 
    additionalGenerics: Array[GenericParameter], 

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openGenericParameters(this) = false) {
            return }

        if (additionalGenerics <> ()) {
            for (node: GenericParameter in additionalGenerics) {
                node.accept(visitor) } }

        visitor.closeGenericParameters(this)
    }
}

class GenericParameter extends SyntaxNode (

    name: string

    ) {
    function accept(visitor: Visitor) {

        visitor.visitGenericParameter(this)
    }
}

class Extends extends SyntaxNode (

    name: Name

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openExtends(this) = false) {
            return }
        name.accept(visitor)

        visitor.closeExtends(this)
    }
}

class Structure extends SyntaxNode (

    components: Array[Component], 

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openStructure(this) = false) {
            return }

        if (components <> ()) {
            for (node: Component in components) {
                node.accept(visitor) } }

        visitor.closeStructure(this)
    }
}

class Component extends SyntaxNode (

    name: string, 
    typeAnnotation: TypeAnnotation, 

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openComponent(this) = false) {
            return }

        if (typeAnnotation <> ()) {
            typeAnnotation.accept(visitor) }

        visitor.closeComponent(this)
    }
}

class ClassBody extends SyntaxNode (

    members: Array[ClassMember], 

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openClassBody(this) = false) {
            return }

        if (members <> ()) {
            for (node: ClassMember in members) {
                node.accept(visitor) } }

        visitor.closeClassBody(this)
    }
}

class ClassMember extends SyntaxNode {
    function accept(visitor: Visitor) {
    }
}

class LetMember extends ClassMember (

    declaration: Let

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openLetMember(this) = false) {
            return }
        declaration.accept(visitor)

        visitor.closeLetMember(this)
    }
}

class VarMember extends ClassMember (

    declaration: Var

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openVarMember(this) = false) {
            return }
        declaration.accept(visitor)

        visitor.closeVarMember(this)
    }
}

class MutableMember extends ClassMember (

    declaration: Mutable

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openMutableMember(this) = false) {
            return }
        declaration.accept(visitor)

        visitor.closeMutableMember(this)
    }
}

class SetInitialization extends ClassMember (

    definition: Set

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openSetInitialization(this) = false) {
            return }
        definition.accept(visitor)

        visitor.closeSetInitialization(this)
    }
}

class Method extends ClassMember (

    procedure: Procedure

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openMethod(this) = false) {
            return }
        procedure.accept(visitor)

        visitor.closeMethod(this)
    }
}

class StaticFunction extends ClassMember (

    procedure: Function

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openStaticFunction(this) = false) {
            return }
        procedure.accept(visitor)

        visitor.closeStaticFunction(this)
    }
}

class Operator extends ClassMember (

    routine: Routine

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openOperator(this) = false) {
            return }
        routine.accept(visitor)

        visitor.closeOperator(this)
    }
}

class Initializer extends ClassMember (

    input: Structure, 
    body: Block

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openInitializer(this) = false) {
            return }

        if (input <> ()) {
            input.accept(visitor) }
        body.accept(visitor)

        visitor.closeInitializer(this)
    }
}

class Allocator extends ClassMember (

    input: Structure, 
    body: Block

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openAllocator(this) = false) {
            return }

        if (input <> ()) {
            input.accept(visitor) }
        body.accept(visitor)

        visitor.closeAllocator(this)
    }
}

class TypeAnnotation extends SyntaxNode (

    typeSpec: TypeSpec

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openTypeAnnotation(this) = false) {
            return }
        typeSpec.accept(visitor)

        visitor.closeTypeAnnotation(this)
    }
}

class TypeSpec extends SyntaxNode {
    function accept(visitor: Visitor) {
    }
}

class Type extends TypeSpec (

    name: Name, 
    generics: GenericArguments, 
    optional: Optional, 
    lifeTime: LifeTime

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openType(this) = false) {
            return }
        name.accept(visitor)

        if (generics <> ()) {
            generics.accept(visitor) }

        if (optional <> ()) {
            optional.accept(visitor) }

        if (lifeTime <> ()) {
            lifeTime.accept(visitor) }

        visitor.closeType(this)
    }
}

class Variant extends TypeSpec (

    types: Array[Type], 

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openVariant(this) = false) {
            return }

        if (types <> ()) {
            for (node: Type in types) {
                node.accept(visitor) } }

        visitor.closeVariant(this)
    }
}

class Throws extends SyntaxNode (

    throwsType: TypeSpec

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openThrows(this) = false) {
            return }
        throwsType.accept(visitor)

        visitor.closeThrows(this)
    }
}

class GenericArguments extends SyntaxNode (

    generic: Type, 
    additionalGenerics: Array[GenericArgument], 

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openGenericArguments(this) = false) {
            return }
        generic.accept(visitor)

        if (additionalGenerics <> ()) {
            for (node: GenericArgument in additionalGenerics) {
                node.accept(visitor) } }

        visitor.closeGenericArguments(this)
    }
}

class GenericArgument extends SyntaxNode (

    typeSpec: Type

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openGenericArgument(this) = false) {
            return }
        typeSpec.accept(visitor)

        visitor.closeGenericArgument(this)
    }
}

class Optional extends SyntaxNode (


    ) {
    function accept(visitor: Visitor) {

        visitor.visitOptional(this)
    }
}

class LifeTime extends SyntaxNode {
    function accept(visitor: Visitor) {
    }
}

class Root extends LifeTime (


    ) {
    function accept(visitor: Visitor) {

        visitor.visitRoot(this)
    }
}

class Local extends LifeTime (

    location: string

    ) {
    function accept(visitor: Visitor) {

        visitor.visitLocal(this)
    }
}

class Reference extends LifeTime (

    age: Literal

    ) {
    function accept(visitor: Visitor) {

        visitor.visitReference(this)
    }
}

class Thrown extends LifeTime (


    ) {
    function accept(visitor: Visitor) {

        visitor.visitThrown(this)
    }
}

} // namespace scalyc
