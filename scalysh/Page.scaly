class Scaly.Page
(
    currentPage: Page? = ()
    nextObjectOffset: int
    exclusivePages: int
)
{
    let alignment: int = 8
    let pageSize: size = 0x1000
    let maxStackPages: size = 0x1000

    method reset {
        pointer.set(getExtensionPageLocation(), 0)
        set exclusivePages = 0
        set nextObjectOffset = sizeof Page
        set currentPage = this
    }

    method clear {
        deallocateExtensions()
        reset()
    }

    method isOversized
        currentPage = ()

    method getExtensionPageLocation
        this as pointer + pageSize - sizeof pointer

    method getNextObject
        this as pointer + nextObjectOffset

    method setNextObject(object: pointer)
        set nextObjectOffset = (object - this) as pointer

    method getNextExclusivePageLocation 
        getExtensionPageLocation() - ((exclusivePages + 1) * sizeof pointer)

    method allocateObject(objectSize: size): pointer {

        if currentPage = ()
            return 0

        if this <> currentPage {

            // We're already known to be full, so we delegate to the current page
            var newObject = currentPage.allocateObject(objectSize)

            // It is always possible that we are out of memory
            if newObject = 0
                return 0

            // Possibly our current page was also full so we propagate back the new current page
            let allocatingPage: Page? = getPage(newObject)

            // This if is only to enable the member access in the next line. 
            // We know that if newObject <> 0, allocatingPage is never ()
            if allocatingPage {
                if (allocatingPage as pointer) <> (currentPage as pointer) and not (allocatingPage.isOversized()) {
                    // We can't assign mutable objects, so we work around this using pointers.
                    pointer.set(currentPage as pointer, allocatingPage as pointer)
                }
            }

            return newObject
        }

        // Try to allocate from ourselves
        var location = getNextObject()
        var nextLocation = align(location + objectSize)
        if nextLocation <= getNextExclusivePageLocation() {
            setNextObject(nextLocation)
            return location
        }

        // So the space did not fit.

        // Calculate gross size to decide whether we're oversized
        var grossSize = sizeof Page + objectSize + sizeof pointer + alignment
        if grossSize > pageSize {
            if getNextObject() = getExtensionPageLocation() {

                // Allocate an extension page with default size
                var extensionPage = allocateExtensionPage();

                // Try again with the new extension page
                return extensionPage.allocateObject(objectSize)
            }

            // We allocate oversized objects directly.
            mutable pagePointer: pointer 0
            posix_memalign(adressof pagePointer, pageSize, objectSize + sizeof Page)
            if pagePointer = 0
                return 0

            mutable page: pointer as Page
            page.reset()
            
            // This is a hint about the oversize of the page
            set page.currentPage = ()

            pointer.set(getExtensionPageLocation(), page)
            set exclusivePages = exclusivePages + 1
            return page + sizeof Page
        }

        // So we're not oversized. Create extension page and let it allocate.
        var allocatedExtensionPage = allocateExtensionPage()
        if allocatedExtensionPage
            return allocatedExtensionPage.allocateObject(objectSize)
        else
            return 0
    }

    method allocateExtensionPage(): Page? {

        if not Scaly.Task.currentTask
            return ()

        var extensionPage = Scaly.Task.currentTask.getExtensionPage()
        if not extensionPage
            return ()

        extensionPage.reset()
        pointer.set(getExtensionPageLocation(), extensionPage)
        set currentPage = extensionPage
        return extensionPage
    }

    method allocateExclusivePage(): Page? {
        if this as pointer <> currentPage as pointer {
            // We're already known to be full, so we delegate to the current page
            return currentPage.allocateExclusivePage()
        }

        // Check first whether we need an ordinary extension
        if getNextObject() >= getNextExclusivePageLocation() {
            // Allocate an extension page with default size
            return allocateExtensionPage().allocateExclusivePage()
        }

        if not Scaly.Task.currentTask
            return ()

        var exclusivePage = Scaly.Task.currentTask.getExtensionPage()
        if not exclusivePage
            return ()

        exclusivePage.reset()
        pointer.set(getNextExclusivePageLocation(), exclusivePage)
        set exclusivePages = exclusivePages + 1
        return exclusivePage
    }

    method extend(address: pointer, objectSize: size) {

        if objectSize = 0
            set objectSize = 1

        var nextLocation = align(address + objectSize)

        // If nextObject would not change because of the alignment, that's it
        if nextLocation = getNextObject()
            return true

        // If nextObject is already higher, other objects were allocated in the meantime
        if nextLocation < getNextObject()
            return false

        // Now we still have to check whether we still would have space left
        if nextLocation >= getNextExclusivePageLocation()
            return false

        // Allocate the extension
        setNextObject(nextLocation)
        return true
    }

    method _Page::deallocateExtensions() {
        mutable page: Page? = this
        do {
            if page = ()
                break

            let nextExtensionPage = page.getExtensionPageLocation as pointer

            // Deallocate oversized or exclusive pages
            mutable pPage = page.getExtensionPageLocation() - sizeof pointer;

            mutable i: int = 0
            do {
                if not (pPage as Page).isOversized()
                    (pPage as Page).deallocateExtensions()
                forget(pPage as Page)
                set pPage = pPage - sizeof pointer
                set i = i + 1
            } while i < page.exclusivePages

            if (page != this)
                forget(page);

            pointer.set(addressof page, nextExtensionPage)

        } while true
    }

    function forget(Page page) {
        Scaly.Task.currentTask.releaseExtensionPage(page)
    }

    method reclaimArray(address: pointer): bool {

        if not currentPage
            return false

        // Quick attempt to find it at the current page
        if currentPage.deallocateExclusivePage(address as Page)
            return true

        // Second attempt scanning the rest of the chain
        mutable page: Page? = this
        do {
            if page.deallocateExclusivePage(address as Page)
                return true

            set page = page.getExtensionPageLocation() as Page
        } while page <> currentPage
        
        // If we arrive here, we have a memory leak.
        return false
    }

    function getPage(address: pointer): Page {
        return address and not (_pageSize - 1) as Page
    }

    method deallocateExclusivePage(page: Page): bool {

        // Exclusive pages start pointer
        mutable pPage = getExtensionPageLocation() - sizeof pointer

        // Exclusive pages end pointer
        let nextExtensionPageLocation = getNextExclusivePageLocation();

        while pPage > nextExtensionPageLocation {
            if pPage as Page = page
                break

            set pPage = pPage - sizeof pointer
        }

        // Report if we could not find it
        if pPage = nextExtensionPageLocation
            return false

        // Shift the remaining array one position up
        do {
            pointer.set(pPage, (pPage - sizeof pointer) as pointer)
            set pPage = pPage - sizeof pointer
        } while pPage > nextExtensionPageLocation
        // Make room for one more extension
        exclusivePages--;
        forget(_page);
        return true;
    }

}
