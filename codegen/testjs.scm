; testjs.scm - Generate JavaScript test cases from test.dtd documents

(define (generate-testjs) ($
"// Generated test cases from tests.sgm
// DO NOT EDIT - generated by codegen

import { describe, it, expect, beforeEach } from 'vitest'
import { evaluate, evaluateProgram, resetEvaluator } from '../src/index.js'

"
    (apply-to-selected-children "category" (lambda (category)
        (apply-to-selected-children-of category "tests" (lambda (tests) ($
"describe('"(attribute-string "title" tests)"', () => {
"
            (apply-to-selected-children-of tests "test" (lambda (test)
                (if (test-is-program? test)
                    (generate-program-test test)
                    (generate-expression-test test))))
"})

"
        )))))
))

; Generate test for simple expression (uses evaluate)
(define (generate-expression-test test) ($
"  "(test-it test)"('"(test-description test)"', () => {
    const result = evaluate("(test-input-quoted test)")
    expect(result._tag).toBe('Ok')
    expect(result.value).toBe("(test-expect-value test)")
  })
"
))

; Generate test for program (uses evaluateProgram with reset)
(define (generate-program-test test) ($
"  "(test-it test)"('"(test-description test)"', () => {
    resetEvaluator()
    const result = evaluateProgram("(test-input-quoted test)")
    expect(result._tag).toBe('Ok')
    expect("(test-expect-comparison test)").toBe("(test-expect-value test)")
  })
"
))

; Check if test has program="true"
(define (test-is-program? test)
    (string=? (attribute-string "program" test) "true"))

; Get comparison expression based on test type
(define (test-expect-comparison test)
    (let ((val (test-expect test)))
        (if (is-json-object? val)
            "JSON.stringify(result.value)"
            "result.value")))

; Get "it" or "it.skip" based on skip attribute
(define (test-it test)
    (if (string=? (attribute-string "skip" test) "true")
        "it.skip"
        "it"))

; Get the input element's text content
(define (test-input test)
    (trim (data (node-list-first (select-elements (children test) "input")))))

; Get the expect element's text content
(define (test-expect test)
    (trim (data (node-list-first (select-elements (children test) "expect")))))

; Trim leading/trailing whitespace
(define (trim s)
    (let ((chars (string->list s)))
        (list->string
            (reverse
                (drop-leading-ws
                    (reverse
                        (drop-leading-ws chars)))))))

(define (drop-leading-ws lst)
    (cond
        ((null? lst) '())
        ((char=? (car lst) #\space) (drop-leading-ws (cdr lst)))
        ((char=? (car lst) #\U-000A) (drop-leading-ws (cdr lst)))
        ((char=? (car lst) #\U-000D) (drop-leading-ws (cdr lst)))
        (else lst)))

; Get description from test id or description element
(define (test-description test)
    (let ((desc (node-list-first (select-elements (children test) "description"))))
        (if (node-list-empty? desc)
            (attribute-string "xml:id" test)
            (data desc))))

; Quote input for JS - use single quotes and escape as needed
(define (test-input-quoted test)
    (let ((val (test-input test)))
        (if (string-contains-backtick? val)
            ($ "'" (escape-single-quotes val) "'")
            ($ "`" val "`"))))

(define (escape-single-quotes s)
    (list->string
        (apply append
            (map (lambda (c)
                    (if (char=? c #\')
                        (list #\\ #\')
                        (list c)))
                 (string->list s)))))

(define (string-contains-backtick? s)
    (if (member #\` (string->list s)) #t #f))

; Quote a string value for JS
(define (quote-string val)
    (if (= (string-length val) 0)
        "''"
        (string-append "'" (string-append val "'"))))

; Quote a JSON object as a string literal
(define (quote-json val)
    (string-append "'" (string-append val "'")))

; Get expect value - handle different types
(define (test-expect-value test)
    (let ((val (test-expect test)))
        (if (string=? val "true")
            "true"
            (if (string=? val "false")
                "false"
                (if (is-number? val)
                    val
                    (if (is-json-object? val)
                        (quote-json val)
                        (quote-string val)))))))

; Check if string represents a number (starts with digit or minus)
(define (is-number? s)
    (if (= (string-length s) 0)
        #f
        (member (string-ref s 0) '(#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9 #\-))))

; Check if string looks like a JSON object (starts with {)
(define (is-json-object? s)
    (if (= (string-length s) 0)
        #f
        (char=? (string-ref s 0) #\{)))
