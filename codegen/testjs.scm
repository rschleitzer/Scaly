; testjs.scm - Generate JavaScript test cases from test.dtd documents

(define (generate-testjs) ($
"// Generated test cases from tests.sgm
// DO NOT EDIT - generated by codegen

import { describe, it, expect } from 'vitest'
import { evaluate } from '../src/index.js'

"
    (apply-to-selected-children "category" (lambda (category)
        (apply-to-selected-children-of category "tests" (lambda (tests) ($
"describe('"(attribute-string "title" tests)"', () => {
"
            (apply-to-selected-children-of tests "test" (lambda (test) ($
"  "(test-it test)"('"(test-description test)"', () => {
    const result = evaluate("(test-input-quoted test)")
    expect(result._tag).toBe('Ok')
    expect(result.value).toBe("(test-expect-value test)")
  })
"
            )))
"})

"
        )))))
))

; Get "it" or "it.skip" based on skip attribute
(define (test-it test)
    (if (string=? (attribute-string "skip" test) "true")
        "it.skip"
        "it"))

; Get the input element's text content
(define (test-input test)
    (trim (data (node-list-first (select-elements (children test) "input")))))

; Get the expect element's text content
(define (test-expect test)
    (trim (data (node-list-first (select-elements (children test) "expect")))))

; Trim leading/trailing whitespace
(define (trim s)
    (let ((chars (string->list s)))
        (list->string
            (reverse
                (drop-leading-ws
                    (reverse
                        (drop-leading-ws chars)))))))

(define (drop-leading-ws lst)
    (cond
        ((null? lst) '())
        ((char=? (car lst) #\space) (drop-leading-ws (cdr lst)))
        ((char=? (car lst) #\U-000A) (drop-leading-ws (cdr lst)))
        ((char=? (car lst) #\U-000D) (drop-leading-ws (cdr lst)))
        (else lst)))

; Get description from test id or description element
(define (test-description test)
    (let ((desc (node-list-first (select-elements (children test) "description"))))
        (if (node-list-empty? desc)
            (attribute-string "xml:id" test)
            (data desc))))

; Quote input for JS - use single quotes and escape as needed
(define (test-input-quoted test)
    (let ((val (test-input test)))
        (if (string-contains-backtick? val)
            ($ "'" (escape-single-quotes val) "'")
            ($ "`" val "`"))))

(define (escape-single-quotes s)
    (list->string
        (apply append
            (map (lambda (c)
                    (if (char=? c #\')
                        (list #\\ #\')
                        (list c)))
                 (string->list s)))))

(define (string-contains-backtick? s)
    (if (member #\` (string->list s)) #t #f))

; Quote a string value for JS
(define (quote-string val)
    (if (= (string-length val) 0)
        "''"
        (string-append "'" (string-append val "'"))))

; Get expect value - handle different types
(define (test-expect-value test)
    (let ((val (test-expect test)))
        (if (string=? val "true")
            "true"
            (if (string=? val "false")
                "false"
                (if (is-number? val)
                    val
                    (quote-string val))))))

; Check if string represents a number (starts with digit or minus)
(define (is-number? s)
    (if (= (string-length s) 0)
        #f
        (member (string-ref s 0) '(#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9 #\-))))
