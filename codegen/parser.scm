<![CDATA[
;; Generate C++ Parser.h and Parser.cpp from scaly.sgm
;; Converts Scaly parser to idiomatic C++ with llvm::Expected

(define (generate-parser-h) ($
"// Parser.h - Generated from scaly.sgm
// DO NOT EDIT - generated by codegen

#pragma once

#include \"Lexer.h\"
#include \"Syntax.h\"
#include \"llvm/ADT/StringRef.h\"
#include \"llvm/ADT/StringSet.h\"
#include \"llvm/Support/Error.h\"
#include <vector>

namespace scaly {

class Parser {
public:
    explicit Parser(llvm::StringRef Source);

    llvm::Expected<ProgramSyntax> parseProgram();
    llvm::Expected<FileSyntax> parseFile();
    bool isAtEnd() const;

private:
    Lexer Lex;
    llvm::StringSet<> Keywords;

    void initKeywords();

    // Literal parsing
    llvm::Expected<Literal> parseLiteralToken();

    // Generated parse methods
"
    (apply-to-selected-children "syntax" (lambda (syntax)
        (if (and (not (string=? (id syntax) "Program"))
                 (not (string=? (id syntax) "File")))
            ($
                (if (multiple? syntax) ($
"    llvm::Expected<std::vector<"(id syntax)"Syntax>*> parse"(id syntax)"List();
"               )"")
"    llvm::Expected<"(id syntax)"Syntax> parse"(id syntax)"();
"           )
            "")
    ))
"};

} // namespace scaly
"
))

(define (generate-parser-cpp) ($
"// Parser.cpp - Generated from scaly.sgm
// DO NOT EDIT - generated by codegen

#include \"Parser.h\"

namespace scaly {

namespace {
// Error helpers
llvm::Error different() {
    return llvm::make_error<llvm::StringError>(
        \"different syntax\", llvm::inconvertibleErrorCode());
}

std::pair<size_t, size_t> calculateLineCol(llvm::StringRef Source, size_t Offset) {
    size_t Line = 1, Col = 1;
    for (size_t I = 0; I < Offset && I < Source.size(); ++I) {
        if (Source[I] == '\\n') { ++Line; Col = 1; }
        else ++Col;
    }
    return {Line, Col};
}

std::string buildHintLine(llvm::StringRef Source, size_t Start, size_t End) {
    if (Source.empty() || Start >= Source.size()) return \"\";
    size_t LineStart = Start;
    while (LineStart > 0 && Source[LineStart - 1] != '\\n') --LineStart;
    size_t LineEnd = Start;
    while (LineEnd < Source.size() && Source[LineEnd] != '\\n') ++LineEnd;
    std::string Line = \"    \" + Source.slice(LineStart, LineEnd).str() + \"\\n    \";
    for (size_t I = LineStart; I < LineEnd; ++I) {
        if (I >= Start && I < End) Line += '^';
        else if (Source[I] == '\\t') Line += '\\t';
        else Line += ' ';
    }
    return Line;
}

llvm::Error invalid(const Lexer& Lex, size_t Start, size_t End, llvm::StringRef Message) {
    auto [Line, Col] = calculateLineCol(Lex.source(), Start);
    std::string Msg = std::to_string(Line) + \":\" + std::to_string(Col) + \": \" + Message.str();
    Msg += \"\\n\" + buildHintLine(Lex.source(), Start, End);
    return llvm::make_error<llvm::StringError>(
        Msg, llvm::inconvertibleErrorCode());
}
} // anonymous namespace

Parser::Parser(llvm::StringRef Source) : Lex(Source) {
    initKeywords();
}

void Parser::initKeywords() {
"   (apply-to-selected-children "keyword" (lambda (keyword) ($
"    Keywords.insert(\""(id keyword)"\");
"   )))
"}

bool Parser::isAtEnd() const {
    return Lex.isAtEnd();
}

llvm::Expected<Literal> Parser::parseLiteralToken() {
    if (is<EmptyToken>(Lex.token()))
        Lex.advance();

    if (auto *Lit = get_if<LiteralToken>(Lex.token())) {
        Literal Result = Lit->Value;
        Lex.empty();
        return Result;
    }

    return different();
}
"
    (apply-to-selected-children "syntax" (lambda (syntax) ($
        (if (multiple? syntax) ($
"
llvm::Expected<std::vector<"(id syntax)"Syntax>*> Parser::parse"(id syntax)"List() {
    auto *List = new std::vector<"(id syntax)"Syntax>();
    while (true) {
        auto NodeOrErr = parse"(id syntax)"();
        if (!NodeOrErr) {
            // Check if this is 'different' (no more items) vs real error
            std::string ErrMsg = llvm::toString(NodeOrErr.takeError());
            if (ErrMsg != \"different syntax\") {
                delete List;
                return llvm::make_error<llvm::StringError>(ErrMsg, llvm::inconvertibleErrorCode());
            }
            if (List->empty()) {
                delete List;
                return different();
            }
            return List;
        }
        List->push_back(std::move(*NodeOrErr));
    }
}
"       )"")
"
llvm::Expected<"(id syntax)"Syntax> Parser::parse"(id syntax)"() {
"       (if (abstract? syntax)
            ;; Abstract syntax - try each alternative
            ($
"    std::string FirstRealError;
"               (apply-to-children-of syntax (lambda (content) ($
"    {
        auto Result = parse"(link content)"();
        if (Result)
            return "(id syntax)"Syntax{std::move(*Result)};
        std::string ErrMsg = llvm::toString(Result.takeError());
        if (ErrMsg != \"different syntax\" && FirstRealError.empty())
            FirstRealError = std::move(ErrMsg);
    }
"               )))
"    if (!FirstRealError.empty())
        return llvm::make_error<llvm::StringError>(FirstRealError, llvm::inconvertibleErrorCode());
    return different();
"           )
            ;; Concrete syntax - parse each field
            ($
"    size_t Start = Lex.previousPosition();
"               (apply-to-children-of syntax (lambda (content)
                    (case (type content)
                        (("syntax")
                            (if (optional? content)
                                ($
"
    "(if (multiple? content) ($ "std::vector<"(link content)"Syntax>*") ($ (link content)"Syntax*"))" "(string-firstchar-upcase (property content))" = nullptr;
    {
        auto ParseResult = parse"(link content)(if (multiple? content) "List" "")"();
        if (ParseResult)
            "(string-firstchar-upcase (property content))" = "(if (multiple? content) "*ParseResult" ($ "new "(link content)"Syntax(std::move(*ParseResult))"))";"
                                    (if (multiple? content)
                                        "
        else {
            std::string ErrMsg = llvm::toString(ParseResult.takeError());
            if (ErrMsg != \"different syntax\")
                return llvm::make_error<llvm::StringError>(ErrMsg, llvm::inconvertibleErrorCode());
        }"
                                        "
        else
            llvm::consumeError(ParseResult.takeError());")
"
    }
"                               )
                                ;; non-optional syntax
                                ($
"
    auto "(string-firstchar-upcase (property content))"OrErr = parse"(link content)(if (multiple? content) "List" "")"();
    if (!"(string-firstchar-upcase (property content))"OrErr)"
                                    (if (equal? 1 (child-number content))
                                        ($ "
        return "(string-firstchar-upcase (property content))"OrErr.takeError();")
                                        ($ " {
        std::string ErrMsg = llvm::toString("(string-firstchar-upcase (property content))"OrErr.takeError());
        if (ErrMsg != \"different syntax\")
            return llvm::make_error<llvm::StringError>(ErrMsg, llvm::inconvertibleErrorCode());
        return invalid(Lex, Start, Lex.position(), \"expected "(link content)"\");
    }")
                                    )
"
    auto "(if (multiple? content) "*" "")(string-firstchar-upcase (property content))" = "(if (multiple? content) "" "std::move(")"*"(string-firstchar-upcase (property content))"OrErr"(if (multiple? content) "" ")")";"
"
"                               )
                            )
                        )
                        (("literal")
                            ($
"
    auto "(string-firstchar-upcase (property content))"OrErr = parseLiteralToken();
    if (!"(string-firstchar-upcase (property content))"OrErr)
        return "(string-firstchar-upcase (property content))"OrErr.takeError();
    auto "(string-firstchar-upcase (property content))" = std::move(*"(string-firstchar-upcase (property content))"OrErr);
"                           )
                        )
                        (("keyword")
                            ($
"
    if (!Lex.parseKeyword(\""(id (element-with-id (link content)))"\"))"
                                (if (equal? 1 (child-number content))
                                    "
        return different();"
                                    ($ "
        return invalid(Lex, Start, Lex.position(), \"expected '"(id (element-with-id (link content)))"'\");")
                                )
"
"                           )
                        )
                        (("punctuation")
                            (if (optional? content)
                                ;; Optional punctuation - just try it
                                ($
"
    Lex.parsePunctuation('"(value (element-with-id (link content)))"');
"                               )
                                ;; Required punctuation
                                ($
"
    if (!Lex.parsePunctuation('"(value (element-with-id (link content)))"'))"
                                    (if (equal? 1 (child-number content))
                                        "
        return different();"
                                        ($ "
        return invalid(Lex, Start, Lex.position(), \"expected '"(value (element-with-id (link content)))"'\");")
                                    )
"
"                               )
                            )
                        )
                        (("colon")
                            (if (optional? content)
                                ;; Optional colon - just try it
                                ($
"
    Lex.parseColon();
"                               )
                                ;; Required colon
                                ($
"
    if (!Lex.parseColon())"
                                    (if (equal? 1 (child-number content))
                                        "
        return different();"
                                        "
        return invalid(Lex, Start, Lex.position(), \"expected colon or newline\");")
"
"                               )
                            )
                        )
                        (("identifier")
                            (if (equal? 1 (child-number content))
                                ;; First element - return different() for both empty and keyword
                                ($
"
    llvm::StringRef "(string-firstchar-upcase (property content))" = Lex.peekIdentifier();
    if ("(string-firstchar-upcase (property content))".empty() || Keywords.count("(string-firstchar-upcase (property content))"))
        return different();
    Lex.parseIdentifier();  // Consume the identifier
"                               )
                                ;; Not first element - give specific error for keyword
                                ($
"
    llvm::StringRef "(string-firstchar-upcase (property content))" = Lex.peekIdentifier();
    if ("(string-firstchar-upcase (property content))".empty())
        return invalid(Lex, Start, Lex.position(), \"expected identifier\");
    if (Keywords.count("(string-firstchar-upcase (property content))")) {
        std::string Msg = \"'\" + "(string-firstchar-upcase (property content))".str() + \"' is a reserved keyword\";
        return invalid(Lex, Start, Lex.position(), Msg);
    }
    Lex.parseIdentifier();  // Consume the identifier
"                               )
                            )
                        )
                        (("attribute")
                            ($
"
    llvm::StringRef "(string-firstchar-upcase (property content))" = Lex.parseAttribute();
    if ("(string-firstchar-upcase (property content))".empty())"
                                (if (equal? 1 (child-number content))
                                    "
        return different();"
                                    "
        return invalid(Lex, Start, Lex.position(), \"expected attribute\");")
"
"                           )
                        )
                        (else "")
                    )
                ))
"
    size_t End = Lex.position();

    return "(id syntax)"Syntax{Start, End"
                (apply-to-property-children-of syntax (lambda (content) ($
                    ", "
                    (if (or (equal? (type content) "keyword") (equal? (type content) "punctuation"))
                        "true"
                        (string-firstchar-upcase (property content)))
                )))
"};
"
            )
        )
"
}
"   )))
"
} // namespace scaly
"
))
]]>