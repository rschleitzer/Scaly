<![CDATA[
;; Generate C++ Parser.h and Parser.cpp from scaly.sgm
;; Converts Scaly parser to idiomatic C++ with llvm::Expected

(define (generate-parser-h) ($
"// Parser.h - Generated from scaly.sgm
// DO NOT EDIT - generated by codegen

#pragma once

#include \"Lexer.h\"
#include \"Syntax.h\"
#include \"llvm/ADT/StringRef.h\"
#include \"llvm/ADT/StringSet.h\"
#include \"llvm/Support/Error.h\"
#include <vector>

namespace scaly {

class Parser {
public:
    explicit Parser(llvm::StringRef Source);

    llvm::Expected<ProgramSyntax> parseProgram();
    bool isAtEnd() const;

private:
    Lexer Lex;
    llvm::StringSet<> Keywords;

    void initKeywords();

    // Literal parsing
    llvm::Expected<Literal> parseLiteralToken();

    // Generated parse methods
"
    (apply-to-selected-children "syntax" (lambda (syntax)
        (if (not (string=? (id syntax) "Program"))
            ($
                (if (multiple? syntax) ($
"    llvm::Expected<std::vector<"(id syntax)"Syntax>*> parse"(id syntax)"List();
"               )"")
"    llvm::Expected<"(id syntax)"Syntax> parse"(id syntax)"();
"           )
            "")
    ))
"};

} // namespace scaly
"
))

(define (generate-parser-cpp) ($
"// Parser.cpp - Generated from scaly.sgm
// DO NOT EDIT - generated by codegen

#include \"Parser.h\"

namespace scaly {

namespace {
// Error helpers
llvm::Error different() {
    return llvm::make_error<llvm::StringError>(
        \"different syntax\", llvm::inconvertibleErrorCode());
}

llvm::Error invalid(size_t Start, size_t End, llvm::StringRef Message) {
    return llvm::make_error<llvm::StringError>(
        Message, llvm::inconvertibleErrorCode());
}
} // anonymous namespace

Parser::Parser(llvm::StringRef Source) : Lex(Source) {
    initKeywords();
}

void Parser::initKeywords() {
"   (apply-to-selected-children "keyword" (lambda (keyword) ($
"    Keywords.insert(\""(id keyword)"\");
"   )))
"}

bool Parser::isAtEnd() const {
    return Lex.isAtEnd();
}

llvm::Expected<Literal> Parser::parseLiteralToken() {
    if (is<EmptyToken>(Lex.token()))
        Lex.advance();

    if (auto *Lit = get_if<LiteralToken>(Lex.token())) {
        Literal Result = Lit->Value;
        Lex.empty();
        return Result;
    }

    return different();
}
"
    (apply-to-selected-children "syntax" (lambda (syntax) ($
        (if (multiple? syntax) ($
"
llvm::Expected<std::vector<"(id syntax)"Syntax>*> Parser::parse"(id syntax)"List() {
    auto *List = new std::vector<"(id syntax)"Syntax>();
    while (true) {
        auto NodeOrErr = parse"(id syntax)"();
        if (!NodeOrErr) {
            if (List->empty()) {
                delete List;
                return NodeOrErr.takeError();
            }
            llvm::consumeError(NodeOrErr.takeError());
            return List;
        }
        List->push_back(std::move(*NodeOrErr));
    }
}
"       )"")
"
llvm::Expected<"(id syntax)"Syntax> Parser::parse"(id syntax)"() {
"       (if (abstract? syntax)
            ;; Abstract syntax - try each alternative
            ($
                (apply-to-children-of syntax (lambda (content) ($
"    {
        auto Result = parse"(link content)"();
        if (Result)
            return "(id syntax)"Syntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
"               )))
"    return different();
"           )
            ;; Concrete syntax - parse each field
            ($
"    size_t Start = Lex.previousPosition();
"               (apply-to-children-of syntax (lambda (content)
                    (case (type content)
                        (("syntax")
                            (if (optional? content)
                                ($
"
    "(if (multiple? content) ($ "std::vector<"(link content)"Syntax>*") ($ (link content)"Syntax*"))" "(string-firstchar-upcase (property content))" = nullptr;
    {
        auto ParseResult = parse"(link content)(if (multiple? content) "List" "")"();
        if (ParseResult)
            "(string-firstchar-upcase (property content))" = "(if (multiple? content) "*ParseResult" ($ "new "(link content)"Syntax(std::move(*ParseResult))"))";"
                                    (if (multiple? content) "" "
        else
            llvm::consumeError(ParseResult.takeError());")
"
    }
"                               )
                                ;; non-optional syntax
                                ($
"
    auto "(string-firstchar-upcase (property content))"OrErr = parse"(link content)(if (multiple? content) "List" "")"();
    if (!"(string-firstchar-upcase (property content))"OrErr)"
                                    (if (equal? 1 (child-number content))
                                        ($ "
        return "(string-firstchar-upcase (property content))"OrErr.takeError();")
                                        ($ "
        return invalid(Start, Lex.position(), \"expected "(link content)"\");")
                                    )
"
    auto "(if (multiple? content) "*" "")(string-firstchar-upcase (property content))" = "(if (multiple? content) "" "std::move(")"*"(string-firstchar-upcase (property content))"OrErr"(if (multiple? content) "" ")")";"
"
"                               )
                            )
                        )
                        (("literal")
                            ($
"
    auto "(string-firstchar-upcase (property content))"OrErr = parseLiteralToken();
    if (!"(string-firstchar-upcase (property content))"OrErr)
        return "(string-firstchar-upcase (property content))"OrErr.takeError();
    auto "(string-firstchar-upcase (property content))" = std::move(*"(string-firstchar-upcase (property content))"OrErr);
"                           )
                        )
                        (("keyword")
                            ($
"
    if (!Lex.parseKeyword(\""(id (element-with-id (link content)))"\"))"
                                (if (equal? 1 (child-number content))
                                    "
        return different();"
                                    ($ "
        return invalid(Start, Lex.position(), \"expected '"(id (element-with-id (link content)))"'\");")
                                )
"
"                           )
                        )
                        (("punctuation")
                            (if (optional? content)
                                ;; Optional punctuation - just try it
                                ($
"
    Lex.parsePunctuation('"(value (element-with-id (link content)))"');
"                               )
                                ;; Required punctuation
                                ($
"
    if (!Lex.parsePunctuation('"(value (element-with-id (link content)))"'))"
                                    (if (equal? 1 (child-number content))
                                        "
        return different();"
                                        ($ "
        return invalid(Start, Lex.position(), \"expected '"(value (element-with-id (link content)))"'\");")
                                    )
"
"                               )
                            )
                        )
                        (("colon")
                            (if (optional? content)
                                ;; Optional colon - just try it
                                ($
"
    Lex.parseColon();
"                               )
                                ;; Required colon
                                ($
"
    if (!Lex.parseColon())"
                                    (if (equal? 1 (child-number content))
                                        "
        return different();"
                                        "
        return invalid(Start, Lex.position(), \"expected colon or newline\");")
"
"                               )
                            )
                        )
                        (("identifier")
                            ($
"
    llvm::StringRef "(string-firstchar-upcase (property content))" = Lex.parseIdentifier();
    if ("(string-firstchar-upcase (property content))".empty() || Keywords.count("(string-firstchar-upcase (property content))"))"
                                (if (equal? 1 (child-number content))
                                    "
        return different();"
                                    "
        return invalid(Start, Lex.position(), \"expected identifier\");")
"
"                           )
                        )
                        (("attribute")
                            ($
"
    llvm::StringRef "(string-firstchar-upcase (property content))" = Lex.parseAttribute();
    if ("(string-firstchar-upcase (property content))".empty())"
                                (if (equal? 1 (child-number content))
                                    "
        return different();"
                                    "
        return invalid(Start, Lex.position(), \"expected attribute\");")
"
"                           )
                        )
                        (else "")
                    )
                ))
"
    size_t End = Lex.position();

    return "(id syntax)"Syntax{Start, End"
                (apply-to-property-children-of syntax (lambda (content) ($
                    ", "
                    (if (or (equal? (type content) "keyword") (equal? (type content) "punctuation"))
                        "true"
                        (string-firstchar-upcase (property content)))
                )))
"};
"
            )
        )
"
}
"   )))
"
} // namespace scaly
"
))
]]>