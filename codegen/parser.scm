(define (parser) ($
"// Parser generated from scaly.sgm
// DO NOT EDIT - generated by codegen

import { Lexer } from './lexer.js'
import * as Syntax from './syntax.js'

export type ParseResult&#60;T&#62; =
  | { ok: true; value: T }
  | { ok: false; error: ParserError }

export type ParserError =
  | { _tag: 'DifferentSyntax' }
  | { _tag: 'InvalidSyntax'; start: number; end: number; message: string }

function different(): ParseResult&#60;never&#62; {
  return { ok: false, error: { _tag: 'DifferentSyntax' } }
}

function invalid(start: number, end: number, message: string): ParseResult&#60;never&#62; {
  return { ok: false, error: { _tag: 'InvalidSyntax', start, end, message } }
}

function ok&#60;T&#62;(value: T): ParseResult&#60;T&#62; {
  return { ok: true, value }
}

const KEYWORDS = new Set([
"   (apply-to-selected-children "keyword" (lambda (keyword) ($
"  '"(id keyword)"',
"   )))
"])

export class Parser {
  private lexer: Lexer

  constructor(text: string) {
    this.lexer = new Lexer(text)
  }

  parseLiteralToken(): ParseResult&#60;Syntax.Literal&#62; {
    if (this.lexer.token._tag === 'Empty') this.lexer.advance()

    const token = this.lexer.token
    switch (token._tag) {
      case 'String': {
        const ret: Syntax.StringLiteral = {
          _syntax: 'StringLiteral',
          start: this.lexer.previousPosition,
          end: this.lexer.position,
          value: token.value
        }
        this.lexer.empty()
        return ok(ret)
      }
      case 'Character': {
        const ret: Syntax.CharacterLiteral = {
          _syntax: 'CharacterLiteral',
          start: this.lexer.previousPosition,
          end: this.lexer.position,
          value: token.value
        }
        this.lexer.empty()
        return ok(ret)
      }
      case 'Integer': {
        const ret: Syntax.IntegerLiteral = {
          _syntax: 'IntegerLiteral',
          start: this.lexer.previousPosition,
          end: this.lexer.position,
          value: token.value
        }
        this.lexer.empty()
        return ok(ret)
      }
      case 'FloatingPoint': {
        const ret: Syntax.FloatingPointLiteral = {
          _syntax: 'FloatingPointLiteral',
          start: this.lexer.previousPosition,
          end: this.lexer.position,
          value: token.value
        }
        this.lexer.empty()
        return ok(ret)
      }
      case 'Hex': {
        const ret: Syntax.HexLiteral = {
          _syntax: 'HexLiteral',
          start: this.lexer.previousPosition,
          end: this.lexer.position,
          value: token.value
        }
        this.lexer.empty()
        return ok(ret)
      }
      case 'Boolean': {
        const ret: Syntax.BooleanLiteral = {
          _syntax: 'BooleanLiteral',
          start: this.lexer.previousPosition,
          end: this.lexer.position,
          value: token.value
        }
        this.lexer.empty()
        return ok(ret)
      }
      case 'Fragment': {
        const ret: Syntax.FragmentLiteral = {
          _syntax: 'FragmentLiteral',
          start: this.lexer.previousPosition,
          end: this.lexer.position,
          value: token.value
        }
        this.lexer.empty()
        return ok(ret)
      }
      default:
        return different()
    }
  }
"
    (apply-to-selected-children "syntax" (lambda (syntax) ($
        (if (multiple? syntax) ($
"
  parse"(id syntax)"List(): ParseResult&#60;Syntax."(id syntax)"Syntax[]&#62; {
    const list: Syntax."(id syntax)"Syntax[] = []
    while (true) {
      const result = this.parse"(id syntax)"()
      if (!result.ok) {
        if (result.error._tag === 'InvalidSyntax') return result
        if (list.length === 0) return result
        return ok(list)
      }
      list.push(result.value)
    }
  }
"       )"")
"
  parse"(id syntax)"(): ParseResult&#60;Syntax."(id syntax)"Syntax&#62; {
"       (if (abstract? syntax)
            ($
                (apply-to-children-of syntax (lambda (content) ($
"    {
      const result = this.parse"(link content)"()
      if (result.ok) return ok(result.value as Syntax."(id syntax)"Syntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
"
                )))
"    return different()
"
            )
            ($ ; non-abstract syntax
"    const start = this.lexer.previousPosition
"               (apply-to-children-of syntax (lambda (content) ($
                    (case (type content)
                        (("syntax") ($
"
    const "(property content)"Start = this.lexer.position
"
                            (if (optional? content) ($
"    let "(property content)": Syntax."(link content)"Syntax"(if (multiple? content) "[]" "")" | null = null
    {
      const "(property content)"Result = this.parse"(link content)(if (multiple? content) "List" "")"()
      if ("(property content)"Result.ok) "(property content)" = "(property content)"Result.value
      else if ("(property content)"Result.error._tag === 'InvalidSyntax') return "(property content)"Result
    }
"
                                ) ; end optional
                                ($ ; non-optional
"    const "(property content)"Result = this.parse"(link content)(if (multiple? content) "List" "")"()
    if (!"(property content)"Result.ok) {
"
                                    (if (equal? 1 (child-number content))
                                        ($
"      return "(property content)"Result
"                                       )
                                        ($
"      if ("(property content)"Result.error._tag === 'InvalidSyntax') return "(property content)"Result
      return invalid("(property content)"Start, this.lexer.position, 'a valid "(link content)" syntax')
"                                       )
                                    )
"    }
    const "(property content)" = "(property content)"Result.value
"
                                ) ; non-optional
                            )
                        ))
                        (("literal") ($
"
    const "(property content)"Result = this.parseLiteralToken()
    if (!"(property content)"Result.ok) return "(property content)"Result
    const "(property content)" = "(property content)"Result.value
"
                        ))
                        (else (let ((syntax-moniker (if (property content) (property content) ($ (case (type content) (("colon" "semicolon") (type content)) (else (link content)))"_"(number->string (child-number content)))))) ($ ; terminals
"
    const start_"syntax-moniker" = this.lexer.previousPosition
    const "
                            (case (type content)
                                (("keyword" "punctuation" "colon") ($ "success_"syntax-moniker))
                                (else (property content))
                            )
                            " = this.lexer."
                            (case (type content)
                                (("keyword")     ($ "parseKeyword('"(id (element-with-id (link content)))"')"))
                                (("punctuation") ($ "parsePunctuation('"(value (element-with-id (link content)))"')"))
                                (("identifier")  "parseIdentifier(KEYWORDS)")
                                (("colon")       "parseColon()")
                                (("attribute")   "parseAttribute()")
                            )
"
"
                            (let
                                ((null-handler
                                    (if (optional? content) "" ($
                                            (if (equal? 1 (child-number content))
                                                ($
"    if (!"(case (type content) (("keyword" "punctuation" "colon") ($ "success_"syntax-moniker)) (else (property content)))") return different()
"                                               )
                                                ($
"    if (!"(case (type content) (("keyword" "punctuation" "colon") ($ "success_"syntax-moniker)) (else (property content)))") {
      return invalid(start_"syntax-moniker", this.lexer.position, '"
                                                    (case (type content)
                                                        (("keyword")     (id (element-with-id (link content))))
                                                        (("punctuation") (value (element-with-id (link content))))
                                                        (("identifier")  "an identifier")
                                                        (("attribute")   "an attribute")
                                                        (("colon")       "a colon or a line feed")
                                                    )
"')
    }
"                                                )
                                            )
                                    ))
                                ))
                                null-handler)
                        )))  ;terminal
                    ) ; syntax, literal or other stuff
                ))) ; apply to children of syntax
"
    const end = this.lexer.position

    return ok({
      _syntax: '"(id syntax)"Syntax',
      start,
      end"
                (apply-to-property-children-of syntax (lambda (content) ($
                    ",
      "(property content)
                )))
"
    })
"
            ) ; $
        ) ; abstract or not
"  }
"   )))
"
  isAtEnd(): boolean {
    return this.lexer.isAtEnd()
  }
}
"

))
