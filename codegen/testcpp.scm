<![CDATA[; testcpp.scm - Generate C++ test code from test.dtd documents
; Generates Tests.cpp that uses JIT to evaluate expressions and compare results

; Helper: get the id of a node
(define (id node)
    (attribute-string "id" node))

; Define special characters via a string literal
; String contains: space, newline (literal in source)
(define newline-string "
")

; Helper: check if character is the newline
(define (is-newline? c)
    (char=? c (string-ref newline-string 0)))

; Helper: trim leading/trailing whitespace (simplified - just trim spaces and newlines)
(define (trim s)
    (drop-trailing-ws (drop-leading-ws s)))

(define (drop-leading-ws s)
    (let ((chars (string->list s)))
        (list->string (drop-while-ws chars))))

(define (drop-trailing-ws s)
    (list->string (reverse (drop-while-ws (reverse (string->list s))))))

(define (drop-while-ws chars)
    (cond
        ((null? chars) '())
        ((char-whitespace? (car chars)) (drop-while-ws (cdr chars)))
        (else chars)))

(define (char-whitespace? c)
    (or (char=? c #\space)
        (is-newline? c)))

; Get the input text from a test element
(define (test-input test)
    (let ((input-node (node-list-first (select-elements (children test) "input"))))
        (if (node-list-empty? input-node)
            ""
            (data input-node))))

; Get the expected result from a test element
(define (test-expect test)
    (let ((expect-node (node-list-first (select-elements (children test) "expect"))))
        (if (node-list-empty? expect-node)
            ""
            (data expect-node))))

; Check if test should be skipped
(define (test-skip? test)
    (attribute-string "skip" test))

; Check if test is a program (multi-statement)
(define (test-program? test)
    (attribute-string "program" test))

; Escape string for C++ string literal
(define (escape-cpp-string s)
    (list->string
        (apply append
            (map (lambda (c)
                    (cond
                        ((char=? c #\\) (string->list "\\\\"))
                        ((char=? c #\") (string->list "\\\""))
                        ((is-newline? c) (string->list "\\n"))
                        (else (list c))))
                 (string->list s)))))

; Convert test id to valid C++ identifier (replace - with _)
(define (cpp-identifier s)
    (list->string
        (map (lambda (c)
                (if (char=? c #\-) #\_ c))
             (string->list s))))

; Determine expected type from expect string
(define (expect-type expect-str input-str)
    (cond
        ((string=? expect-str "true") "bool")
        ((string=? expect-str "false") "bool")
        ((string-contains-dot? expect-str) "double")
        ((string-prefix? expect-str "{") "json")
        ((string-prefix? input-str "\"") "string")  ; String literal
        ((string-prefix? input-str "`") "char")     ; Character literal
        (else "int")))

; Check if string contains a dot (for float detection)
(define (string-contains-dot? s)
    (let loop ((chars (string->list s)))
        (cond
            ((null? chars) #f)
            ((char=? (car chars) #\.) #t)
            (else (loop (cdr chars))))))

; Check if string starts with a prefix
(define (string-prefix? s prefix)
    (let ((s-chars (string->list s))
          (p-chars (string->list prefix)))
        (and (>= (length s-chars) (length p-chars))
             (equal? (list-head s-chars (length p-chars)) p-chars))))

(define (list-head lst n)
    (if (or (null? lst) (<= n 0))
        '()
        (cons (car lst) (list-head (cdr lst) (- n 1)))))

; Generate C++ header file
(define (generate-tests-h suite-name) ($
"// "suite-name"Tests.h - Generated from tests/"suite-name".sgm
// DO NOT EDIT - generated by codegen

#pragma once

namespace scaly {

bool run"suite-name"Tests();

} // namespace scaly
"))

; Generate the C++ test file
(define (generate-tests-cpp suite-name) ($
"// "suite-name"Tests.cpp - Generated from tests/"suite-name".sgm
// DO NOT EDIT - generated by codegen

#include \""suite-name"Tests.h\"
#include \"Parser.h\"
#include \"Modeler.h\"
#include \"Planner.h\"
#include \"Emitter.h\"
#include \"llvm/Support/raw_ostream.h\"
#include <iostream>
#include <cmath>

namespace scaly {

namespace {

static int TestsPassed = 0;
static int TestsFailed = 0;

static void pass(const char* Name) {
    ++TestsPassed;
    llvm::outs() << \"    PASS: \" << Name << \"\\n\";
    llvm::outs().flush();
}

static void fail(const char* Name, const char* Message) {
    ++TestsFailed;
    llvm::outs() << \"    FAIL: \" << Name << \" - \" << Message << \"\\n\";
    llvm::outs().flush();
}

// Helper to compile source to Plan
static llvm::Expected<Plan> compileToPlan(llvm::StringRef Source) {
    Parser P(Source);
    auto ParseResult = P.parseProgram();
    if (!ParseResult)
        return ParseResult.takeError();

    Modeler M(\"<test>\");
    auto ModelResult = M.buildProgram(*ParseResult);
    if (!ModelResult)
        return ModelResult.takeError();

    Planner Pl(\"<test>\");
    return Pl.plan(*ModelResult);
}

// Helper to evaluate int expression
static llvm::Expected<int64_t> evalInt(llvm::StringRef Source) {
    auto PlanResult = compileToPlan(Source);
    if (!PlanResult)
        return PlanResult.takeError();

    EmitterConfig Config;
    Config.EmitDebugInfo = false;
    Emitter E(Config);
    return E.jitExecuteInt(*PlanResult);
}

// Helper to evaluate bool expression
static llvm::Expected<bool> evalBool(llvm::StringRef Source) {
    auto PlanResult = compileToPlan(Source);
    if (!PlanResult)
        return PlanResult.takeError();

    EmitterConfig Config;
    Config.EmitDebugInfo = false;
    Emitter E(Config);
    return E.jitExecuteBool(*PlanResult);
}

// Helper to evaluate float expression
static llvm::Expected<double> evalFloat(llvm::StringRef Source) {
    auto PlanResult = compileToPlan(Source);
    if (!PlanResult)
        return PlanResult.takeError();

    EmitterConfig Config;
    Config.EmitDebugInfo = false;
    Emitter E(Config);
    return E.jitExecuteFloat(*PlanResult);
}

} // anonymous namespace

"
    (apply-to-selected-children "category" (lambda (category) ($
"// Category: "(attribute-string "title" category)"
"
        (apply-to-selected-children-of category "tests" (lambda (tests) ($
"
// "(attribute-string "title" tests)"
"
            (apply-to-selected-children-of tests "test" (lambda (test)
                (if (test-skip? test)
                    ""
                    (generate-test-function test))))
        )))
    )))
"
bool run"suite-name"Tests() {
    TestsPassed = 0;
    TestsFailed = 0;

    std::cout << \"Running "suite-name" tests...\" << std::endl;
"
    (apply-to-selected-children "category" (lambda (category) ($
"
    std::cout << \"  "(attribute-string "title" category)"\" << std::endl;
"
        (apply-to-selected-children-of category "tests" (lambda (tests) ($
"    std::cout << \"    "(attribute-string "title" tests)"\" << std::endl;
"
            (apply-to-selected-children-of tests "test" (lambda (test)
                (if (test-skip? test)
                    ""
                    ($ "    test_"(cpp-identifier (id test))"();
"))))
        )))
    )))
"
    std::cout << std::endl;
    std::cout << \""suite-name" tests: \" << TestsPassed << \" passed, \"
              << TestsFailed << \" failed\" << std::endl;

    return TestsFailed == 0;
}

} // namespace scaly
"))

; Generate a single test function
(define (generate-test-function test)
    (let* ((test-id (id test))
           (input (test-input test))
           (expect (trim (test-expect test)))
           (type (expect-type expect input)))
        (cond
            ((string=? type "bool")
                (generate-bool-test test-id input expect))
            ((string=? type "double")
                (generate-float-test test-id input expect))
            ((string=? type "json")
                (generate-json-test test-id input expect))
            ((string=? type "string")
                (generate-string-test test-id input expect))
            ((string=? type "char")
                (generate-char-test test-id input expect))
            (else
                (generate-int-test test-id input expect)))))

; Generate int test
(define (generate-int-test test-id input expect) ($
"static void test_"(cpp-identifier test-id)"() {
    const char* Name = \""test-id"\";
    auto Result = evalInt(\""(escape-cpp-string input)"\");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != "expect") {
        std::string Msg = \"expected "expect", got \" + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}

"))

; Generate bool test
(define (generate-bool-test test-id input expect) ($
"static void test_"(cpp-identifier test-id)"() {
    const char* Name = \""test-id"\";
    auto Result = evalBool(\""(escape-cpp-string input)"\");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != "expect") {
        std::string Msg = \"expected "expect", got \" + std::string(*Result ? \"true\" : \"false\");
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}

"))

; Generate float test
(define (generate-float-test test-id input expect) ($
"static void test_"(cpp-identifier test-id)"() {
    const char* Name = \""test-id"\";
    auto Result = evalFloat(\""(escape-cpp-string input)"\");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (std::fabs(*Result - "expect") > 0.0001) {
        std::string Msg = \"expected "expect", got \" + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}

"))

; Generate JSON test (structure/union - just check it parses and plans for now)
(define (generate-json-test test-id input expect) ($
"static void test_"(cpp-identifier test-id)"() {
    const char* Name = \""test-id"\";
    auto Result = compileToPlan(\""(escape-cpp-string input)"\");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    // TODO: Add JSON serialization and comparison
    pass(Name);
}

"))

; Generate string test (just check it compiles for now - JIT string eval not implemented)
(define (generate-string-test test-id input expect) ($
"static void test_"(cpp-identifier test-id)"() {
    const char* Name = \""test-id"\";
    auto Result = compileToPlan(\""(escape-cpp-string input)"\");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    // TODO: Add string JIT evaluation when implemented
    pass(Name);
}

"))

; Generate char test (just check it compiles for now - JIT char eval not implemented)
(define (generate-char-test test-id input expect) ($
"static void test_"(cpp-identifier test-id)"() {
    const char* Name = \""test-id"\";
    auto Result = compileToPlan(\""(escape-cpp-string input)"\");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    // TODO: Add char JIT evaluation when implemented
    pass(Name);
}

"))
]]>
