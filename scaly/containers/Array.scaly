define Array[T]
(
    length: size_t
    vector: pointer[Vector[T]]
)
{
    init () (length(0), vector(null)) {}

    function get_buffer(this: Array) returns pointer[T] {
        if this.vector = null
            return null
        return this.vector.data
    }

    function get_length(this: Array[T]) returns size_t :this.length

    function get_capacity(this: Array[T]) returns size_t {
        if this.vector =  null
            return 0
        return this.vector.length
    }

    function add(this: Array[T], item: T) {
        if this.vector = null || this.length = this.vector.length
            reallocate()

        let location this.vector.data + this.length
        set *location: item

        set this.length: this.length + 1
    }

    function add(this: Array[T], items: Vector[T]) {
        var length this.length + items.length
        let size sizeof T
        if this.vector = nullptr || length >= this.vector.length
            reallocate()

        if length >= this.vector.length
        {
            var own_page Page.get(this)
            let data (T*)(*own_page).allocate_raw(length * size, alignof(T))
            let bytes_to_copy this->vector->length * size
            if this.vector.length > 0
                memcpy(data, this.vector.data, bytes_to_copy)
            let old_exclusive_page Page.get(this.vector.data)
            (*own_page).deallocate_exclusive_page(old_exclusive_page)
            set this.vector->data: data
            set this.vector.length: length
        }

        if items.length > 0
            memcpy(this.vector.data + this.length * size, items.data, items.length * size)
        set this.length: this.length + items.length
    }

    function get(this: Array[T], i: size_t) returns pointer[T] {
        if i >= this.length
            return null

        return (*this)[i]
    }

    operator [](this: Array[T], i: size_t) returns pointer[T] {
        if this.length < i + 1
            return null
        return this.vector.data + i
    }

    function reallocate(this: Array[T]) {
        let own_page Page.get(this)
        let size sizeof T
        var length: size_t 0
        if this.vector = null
        {
            let exclusive_page (*own_page).allocate_exclusive_page()
            let capacity (*exclusive_page).get_capacity(alignof(T)) - sizeof Vector[T]
            set length: capacity / size
            set this.vector: Vector[T]#exclusive_page(exclusive_page, length)
        } else {
            set length: this.vector.length * 2
            let new_vector Vector[T]#own_page(own_page, length)
            let bytes_to_copy this.vector.length * size
            memcpy(new_vector.data, this.vector.data, bytes_to_copy)
            let old_exclusive_page Page.get(this.vector.data)
            (*own_page).deallocate_exclusive_page(old_exclusive_page)
            set this.vector: new_vector
        }
    }
}    
