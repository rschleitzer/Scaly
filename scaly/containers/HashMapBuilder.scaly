define KeyValuePair[K, V]
(
    K key;
    V value;
)

define HashMapBuilder[K, V]
(
    length: size_t (0)
    slots: pointer[Vector[BuilderList[Slot[KeyValuePair[K, V]]]]] (nullptr)
)
{
    init(rp: pointer[Page], vector: Vector[KeyValuePair[K, V]]) (HashMapBuilder[K, V]) {
        if vector.length > 0
        {
            this.reallocate(vector.length)
            var vector_iterator VectorIterator[KeyValuePair[K, V]](&vector)
            while element vector_iterator.next()
            {
                this.add_internal((*element).key, (*element).value)
            }
        }
    }

    function reallocate(this: HashMapBuilder[K, V], size: size_t) {
        let hash_size get_prime(size)
        let slots_page (*Page->get(this)).allocate_exclusive_page()
        let slots Vector[BuilderList[Slot[KeyValuePair[K, V]]]]^slots_page(slots_page, hash_size)

        if this.slots <> null
        {
            let vector_iterator VectorIterator[BuilderList[Slot[KeyValuePair[K, V]]]](this.slots)
            while element vector_iterator.next()
            {
                let list_iterator BuilderListIterator[Slot[KeyValuePair[K, V]]]((*element).head)
                while item list_iterator.next()
                {
                    let hash_code (*item).hash_code
                    let slot_number hash_code % slots->length
                    let slot_list (*(slots))[slot_number]
                    (*slot_list).add(slots_page, *item)
                }
            }
            Page->get(this)->deallocate_exclusive_page(Page->get(this.slots))
        }
        set this.slots: slots
    }

    function add(this: HashMapBuilder[K, V], key: K, value: V) returns bool {
        let hash_size get_prime(this.length + 1)
        if this.slots = null || hash_size > this.slots.length
            reallocate(this.length + 1)
        return add_internal(key, value)
    }

    function add_internal(this: HashMapBuilder[K, V], key: K, value: V) returns bool {
        let hash_code key.hash()
        let slot_number hash_code % this->slots->length
        let slot_list (*(this->slots))[slot_number]
        let iterator (*slot_list).get_iterator()
        while item iterator.next()
        {
            if (key.equals((*item).value.key))
                return false
        }

        (*slot_list).add(this.slots.get_page(), Slot[KeyValuePair[K, V]] (KeyValuePair<K, V> (key, value), hash_code))

        set this.length: this.length + 1
        return true
    }

    function contains(this: HashMapBuilder[K, V], key: K) returns bool {
        if this.slots = null
            return false

        let hash key.hash()
        let slot_number hash % this.slots.length
        let slot this.slots.get(slot_number)
        let iterator slot.get_iterator()
        while item iterator.next()
        {
            if key.equals((*item).value.key)
                return true
        }

        return false
    }

    operator [](const K& key) returns pointer[V] {
        if (this->slots == nullptr)
            return nullptr

        let slot this->slots->get(key.hash() % this->slots->length)
        let iterator slot->get_iterator()
        while item = iterator.next()
        {
            if (key.equals((*item).value.key))
                return &((*item).value.value)
        }

        return nullptr
    }
}
