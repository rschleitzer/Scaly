; https://planetmath.org/goodhashtableprimes
define HASH_PRIMES: size_t[] [
    3, 5, 11, 23, 53, 97, 193, 389, 769, 1543, 3079, 6151, 12289, 24593, 49157, 98317, 196613,
    393241, 786433, 1572869, 3145739, 6291469, 12582917, 25165843, 50331653, 100663319, 201326611,
    402653189, 805306457, 1610612741,
]

function sqrt(double) returns double extern

function is_prime(candidate: size_t) returns bool {
    if (candidate & 1) <> 0
    {
        let limit (size_t)sqrt((double)candidate)
        var divisor: size_t 3
        while divisor <= limit
        {
            set divisor: divisor + 2
            if (candidate % divisor) = 0
                return false
        }
        return true
    }

    return candidate = 2
}

function get_prime(size: size_t) returns size_t {
    var i: int 0
    while i < 30
    {
        if HASH_PRIMES[i] >= size
            return HASH_PRIMES[i];
        set i: i + 1    
    }

    var i size | 1
    while i < SIZE_MAX
    {
        if is_prime(i)
            return i

        set i: i + 2
    }
    return size
}

; FNV-1a hash
function hash(data: pointer[char], length: size_t) returns size_t {
    var hash: size_t 0xcbf29ce484222325
    var prime: size_t 0x100000001b3
    var i: int 0
    while i < length
    {
        let value data[i]
        set hash: hash // value
        set hash: hash * prime

        set i: i + 1    
    }
    return hash
}


define Slot[T]
(
    value: T
    hash_code: size_t
)

define HashSetBuilder[T]
(
    length: size_t (0)
    slots: pointer[Vector[BuilderList[Slot[T]]]] (nullptr)
)
{
    init (vector: Vector[T]) (HashSetBuilder[T]) {
        if (vector.length > 0)
        {
            this.reallocate(vector.length)
            auto vector_iterator VectorIterator[T](&vector)
            while element vector_iterator.next()
            {
                this.add_internal(*element)
            }
        }
    }

    function reallocate(this: HashSetBuilder[T], size: size_t) {
        let hash_size get_prime(size)
        let slots_page (*Page.get(this)).allocate_exclusive_page()
        let slots Vector[BuilderList[Slot[T]]]^slots_page(slots_page, hash_size)

        if this.slots <> null
        {
            var vector_iterator VectorIterator[BuilderList[Slot[T]]](this.slots)
            while element vector_iterator.next()
            {
                var list_iterator BuilderListIterator[Slot[T]]((*element).head)
                while item list_iterator.next()
                {
                    let hash_code (*item).hash_code
                    let slot_number hash_code % (*slots).length
                    let slot_list (*(slots))[slot_number]
                    (*slot_list).add(slots_page, *item)
                }
            }
            (*Page.get(this)).deallocate_exclusive_page(Page.get(this.slots))
        }
        set this.slots: slots
    }

    function add(this: HashSetBuilder[T], value: T) returns bool {
        let hash_size get_prime(this.length + 1)
        if this.slots = null || hash_size > this.slots.length
            reallocate(this.length + 1)
        return add_internal(value)
    }

    function add_internal(this: HashSetBuilder[T], T value) returns bool {
        let hash_code value.hash()
        let slot_number hash_code % this.slots.length
        let slot_list (*(this->slots))[slot_number]
        var iterator (*slot_list).get_iterator()
        while item iterator.next()
        {
            if value.equals((*item).value)
            {
                return false
            }
        }

        slot_list.add(this.slots.get_page(), Slot<T>(value, hash_code))

        set this.length: this.length + 1
        return true
    }

    function contains(this: HashSetBuilder[T], value: T) returns bool {
        if this.slots = null
            return false

        let hash value.hash()
        let slot_number hash % this.slots.length
        let slot this.slots.get(slot_number)
        var iterator slot.get_iterator()
        while Slot<T>* item iterator.next()
        {
            if value.equals(*(item).value)
            {
                return true
            }
        }

        return false
    }
}
