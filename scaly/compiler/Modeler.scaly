use scaly.containers
use scaly.io

define model {

function  parse_program(program: String) returns ProgramSyntax throws ParserError {
    var r Region()
    var parser: ref[Parser] *Parser$(program)
    let program_syntax_result parser.parse_program(rp, ep)
    if parser.is_at_end() = false
        throw ParserError(InvalidSyntax(parser.lexer.previous_position, parser.lexer.position, String(ep, "a valid declaration")))

    return program_syntax_result
}

function handle_property(private_: bool, property: ref[PropertySyntax], file: String) returns Property throws ModelError {
    var r Region()
    
    try let type handle_type(rp, ep, property.annotation.type, file)
        else throw

    var initializer: pointer[Vector[Operand]] null
    if property.initializer <> nullptr
    {
        try let i handle_operands(rp, ep, (*property.initializer).operands, file)
            else throw
        set initializer: Vector[Operand]$(i)
    }

    var attributes: ref[List[Attribute]] *List[Attribute]$()
    if property.attributes <> null
    {
        for attribute_syntax in (*property.attributes)
            try let attribute handle_attribute(rp, ep, attribute_syntax, file)
                else throw
    }

    return Property(Span(property.start, property.end), false, String(rp, property.name), type, initializer, Vector[Attribute](rp, attributes))
}

;*
Result<Item, ModelError> handle_item(bool private_, ItemSyntax& item, file: String) {
    var r Region()
    Type* type null
    if (item.annotation <> null) {
        auto _type_result = handle_type(rp, ep, item.annotation->type, file)
        if (_type_result._tag == Result<Type, ModelError>::Error)
            return Result<Item, ModelError> { ._tag = Result<Item, ModelError>::Error, ._Error = _type_result._Error }
        type = _type_result._Ok
    }

    List<Attribute>& attributes = *new(alignof(List<Attribute>), _r.get_page()) List<Attribute>()
    if (item.attributes <> null) {
        auto item_attributes = item.attributes
        auto _attribute_iterator = item_attributes->get_iterator()
        while (auto _attribute_syntax = _attribute_iterator.next()) {
            auto attribute_syntax = *_attribute_syntax
            auto _attribute_result = handle_attribute(rp, ep, attribute_syntax, file)
            if (_attribute_result._tag == Result<Attribute, ModelError>::Error)
                return Result<Item, ModelError> { ._tag = Result<Item, ModelError>::Error, ._Error = _attribute_result._Error }
            auto attribute = _attribute_result._Ok
            attributes.add(attribute)
        }
    }
    return Result<Item, ModelError> { ._tag = Result<Item, ModelError>::Ok, ._Ok = Item(Span(item.start, item.end), false, new(alignof(String), _rp) String(_rp, item.name), type, Vector<Attribute>(_rp, attributes)) }
}

Result<Vector<Item>, ModelError> handle_parameterset(ParameterSetSyntax& parameterSetSyntax, file: String) {
    var r Region()
    List<Item>& items = *new(alignof(List<Item>), _r.get_page()) List<Item>()
    switch (parameterSetSyntax._tag) {
        case ParameterSetSyntax::Parameters: {
            auto parameters_syntax = parameterSetSyntax._Parameters
            if (parameters_syntax.items <> null) {
                auto _item_syntax_iterator = parameters_syntax.items->get_iterator()
                while (auto _item_syntax = _item_syntax_iterator.next()) {
                    auto item_syntax = *_item_syntax
                    auto _item_result = handle_item(rp, ep, false, item_syntax, file)
                    if (_item_result._tag == Result<Item, ModelError>::Error)
                        return Result<Vector<Item>, ModelError> { ._tag = Result<Vector<Item>, ModelError>::Error, ._Error = _item_result._Error }
                    auto item = _item_result._Ok
                    items.add(item)
                }
            }
        }
        break
        case ParameterSetSyntax::Type: {
            auto type_syntax = parameterSetSyntax._Type
            auto _type_result = handle_type(rp, ep, type_syntax, file)
            if (_type_result._tag == Result<Type, ModelError>::Error)
                return Result<Vector<Item>, ModelError> { ._tag = Result<Vector<Item>, ModelError>::Error, ._Error = _type_result._Error }
            auto type = _type_result._Ok
            items.add(Item(Span(type_syntax.start, type_syntax.end), false, nullptr, type, Vector<Attribute>()))
        }
        break
    }
    return Result<Vector<Item>, ModelError> {
        ._tag = Result<Vector<Item>, ModelError>::Ok, 
        ._Ok = Vector<Item>(_rp, items) }
}

Result<Concept, ModelError> handle_definition(String path, DefinitionSyntax& definition, bool private_, file: String)
Result<Function, ModelError> build_function(size_t start, size_t end, TargetSyntax targetSyntax, bool private_, bool pure, file: String)
Result<Initializer, ModelError> handle_initializer(InitSyntax& initializer, bool private_, file: String)
Result<DeInitializer*, ModelError> handle_deinitializer(DeInitSyntax& deinitializer, file: String)
Result<Operator, ModelError> handle_operator( OperatorSyntax& operator_syntax, bool private_, file: String)
Result<Module, ModelError> handle_module(String path, ModuleSyntax& module_syntax, bool private_)
Result<Use, ModelError> handle_use(UseSyntax& use_)

Result<DeInitializer*, ModelError> handle_body(String name, String path, BodySyntax body, List<Use>& uses, HashSetBuilder<String>& modules_checker, List<Module>& modules, List<Initializer>& initializers_builder, MultiMapBuilder<String, Function>& functions_builder, Array<Member>& members_builder, HashMapBuilder<String, Nameable>& symbols_builder, file: String) {
    var r Region()
    if (body.uses <> null) {
        auto use_syntaxes = body.uses
        auto _uses_iterator = use_syntaxes->get_iterator()
        while (auto use_syntax = _uses_iterator.next()) {
            auto use = *use_syntax
            auto _use_result = handle_use(rp, ep, *use_syntax)
            if (_use_result._tag == Result<Use, ModelError>::Error)
                return Result<DeInitializer*, ModelError> { ._tag = Result<DeInitializer*, ModelError>::Error, ._Error = _use_result._Error }
            auto use_ = _use_result._Ok
            uses.add(use_)

        }
    }

    if (body.inits <> null)
    {
        auto initializers_iterator = body.inits->get_iterator()
        while (auto initializer = initializers_iterator.next()) {
            auto _initializer_result = handle_initializer(rp, ep, *initializer, false, file)
            if (_initializer_result._tag == Result<Initializer, ModelError>::Error)
                return Result<DeInitializer*, ModelError> { ._tag = Result<DeInitializer*, ModelError>::Error, ._Error = _initializer_result._Error }
            initializers_builder.add(_initializer_result._Ok)
        }
    }

    DeInitializer* deInitializer null
    if (body.deInit <> null) {
        auto _deinitializer_result = handle_deinitializer(rp, ep, *body.deInit, file)
        if (_deinitializer_result._tag == Result<DeInitializer*, ModelError>::Error)
            return Result<DeInitializer*, ModelError> { ._tag = Result<DeInitializer*, ModelError>::Error, ._Error = _deinitializer_result._Error }
        deInitializer = _deinitializer_result._Ok
    }

    if (body.members <> null) {
        auto members_iterator = body.members->get_iterator()
        while (auto member = members_iterator.next()) {
            switch (member->constituent._tag) {
                case ConstituentSyntax::Definition: {
                    auto concept_result = handle_definition(rp, ep, path, member->constituent._Definition, false, file)
                    if (concept_result._tag == Result<Function, ModelError>::Error)
                        return Result<DeInitializer*, ModelError> { ._tag = Result<DeInitializer*, ModelError>::Error, ._Error = concept_result._Error }
                    auto concept = concept_result._Ok
                    if (functions_builder.contains(concept.name))
                        return Result<DeInitializer*, ModelError> { ._tag = Result<DeInitializer*, ModelError>::Error, ._Error = ModelError(ModelBuilderError(FunctionSymbolExists(file, Span(member->constituent._Definition.start, member->constituent._Definition.end)))) }

                    if (!symbols_builder.add(concept.name, Nameable { ._tag = Nameable::Concept, ._Concept = concept }))
                        return Result<DeInitializer*, ModelError> { ._tag = Result<DeInitializer*, ModelError>::Error,
                            ._Error = ModelError(ModelBuilderError(DuplicateName(concept.name, Span(member->constituent._Definition.start, member->constituent._Definition.end)))) }
                    members_builder.add(Member { ._tag = Member::Concept, ._Concept = concept })
                }
                break
                case ConstituentSyntax::Function: {
                    auto function_syntax = member->constituent._Function
                    auto function_result = build_function(rp, ep, function_syntax.start, function_syntax.end, function_syntax.target, false, true, file)
                    if (function_result._tag == Result<Function, ModelError>::Error)
                        return Result<DeInitializer*, ModelError> { ._tag = Result<DeInitializer*, ModelError>::Error, ._Error = function_result._Error }
                    auto function = function_result._Ok
                    auto symbol_with_function_name = symbols_builder[function.name]
                    if (symbol_with_function_name <> null)
                        return Result<DeInitializer*, ModelError> { ._tag = Result<DeInitializer*, ModelError>::Error, ._Error = ModelError(ModelBuilderError(NonFunctionSymbolExists(file, Span(member->constituent._Function.start, member->constituent._Function.end)))) }
                    functions_builder.add(function.name, function)
                    members_builder.add(Member { ._tag = Member::Function, ._Function = function })
                }
                break
                case ConstituentSyntax::Procedure: {
                    auto procedure_syntax = member->constituent._Procedure
                    auto procedure_result = build_function(rp, ep, procedure_syntax.start, procedure_syntax.end, procedure_syntax.target, false, false, file)
                    if (procedure_result._tag == Result<Function, ModelError>::Error)
                        return Result<DeInitializer*, ModelError> { ._tag = Result<DeInitializer*, ModelError>::Error, ._Error = procedure_result._Error }
                    auto function = procedure_result._Ok
                    auto symbol_with_function_name = symbols_builder[function.name]
                    if (symbol_with_function_name <> null)
                        return Result<DeInitializer*, ModelError> { ._tag = Result<DeInitializer*, ModelError>::Error, ._Error = ModelError(ModelBuilderError(NonFunctionSymbolExists(file, Span(member->constituent._Function.start, member->constituent._Function.end)))) }
                    functions_builder.add(function.name, function)
                    members_builder.add(Member { ._tag = Member::Function, ._Function = function })
                }
                break
                case ConstituentSyntax::Operator: {
                    auto operator_syntax = member->constituent._Operator
                    auto operator_result = handle_operator(rp, ep, operator_syntax, false, file)
                    if (operator_result._tag == Result<DeInitializer*, ModelError>::Error)
                        return Result<DeInitializer*, ModelError> { ._tag = Result<DeInitializer*, ModelError>::Error,
                            ._Error = operator_result._Error }
                    auto operator_ = operator_result._Ok
                    if (!symbols_builder.add(operator_.name, Nameable { ._tag = Nameable::Operator, ._Operator = operator_ }))
                        return Result<DeInitializer*, ModelError> { ._tag = Result<DeInitializer*, ModelError>::Error,
                            ._Error = ModelError(ModelBuilderError(DuplicateName(file, Span(operator_syntax.start, operator_syntax.end)))) }
                    members_builder.add(Member { ._tag = Member::Operator, ._Operator = operator_ })
                }
                break
                case ConstituentSyntax::Implement:
                    return Result<DeInitializer*, ModelError> { ._tag = Result<DeInitializer*, ModelError>::Error, ._Error = ModelError(ModelBuilderError(NotImplemented(file, String(_ep, "Implement"), Span(member->constituent._Implement.start, member->constituent._Implement.end)))) }
                case ConstituentSyntax::Trait:
                    return Result<DeInitializer*, ModelError> { ._tag = Result<DeInitializer*, ModelError>::Error, ._Error = ModelError(ModelBuilderError(NotImplemented(file, String(_ep, "Trait"), Span(member->constituent._Trait.start, member->constituent._Trait.end)))) }
                case ConstituentSyntax::Macro:
                    return Result<DeInitializer*, ModelError> { ._tag = Result<DeInitializer*, ModelError>::Error, ._Error = ModelError(ModelBuilderError(NotImplemented(file, String(_ep, "Macro"), Span(member->constituent._Macro.start, member->constituent._Macro.end)))) }
                case ConstituentSyntax::Module: {
                    auto module_syntax = member->constituent._Module
                    auto module_result = handle_module(rp, ep, path, module_syntax, false)
                    if (module_result._tag == Result<DeInitializer*, ModelError>::Error)
                        return Result<DeInitializer*, ModelError> { ._tag = Result<DeInitializer*, ModelError>::Error,
                            ._Error = module_result._Error }
                    auto module = module_result._Ok
                    if (!modules_checker.add(module.name))
                        return Result<DeInitializer*, ModelError> { ._tag = Result<DeInitializer*, ModelError>::Error,
                            ._Error = ModelError(ModelBuilderError(NonFunctionSymbolExists(file, Span(module_syntax.start, module_syntax.end)))) }
                    modules.add(module)
                }
                break
            }
        }
    }

    auto multi_map = MultiMap<String, Function>(_r.get_page(), functions_builder)
    auto multi_map_iterator = multi_map.get_iterator()
    while (auto functions = multi_map_iterator.next()) {
        auto name = (*functions)[0]->name
        symbols_builder.add(String(name), Nameable { ._tag = Nameable::Functions, ._Functions = Vector<Function>(_rp, *functions) })
    }

    return Result<DeInitializer*, ModelError> { ._tag = Result<DeInitializer*, ModelError>::Ok, ._Ok = deInitializer }
}

Result<Structure, ModelError> handle_class(String name, String path, ClassSyntax& class_syntax, bool private_, file: String) {    
    var r Region()
    HashMapBuilder<String, Nameable>& symbols_builder = *new(alignof(HashMapBuilder<String, Nameable>), _r.get_page()) HashMapBuilder<String, Nameable>()
    Array<Property>& properties_builder = *new(alignof(Array<Property>), _r.get_page()) Array<Property>()
    if (class_syntax.structure.parts <> null) {
        auto _parts_iterator = class_syntax.structure.parts->get_iterator()
        while (auto _part = _parts_iterator.next()) {
            auto part = *_part
            switch (part._tag) {
                case PartSyntax::Field: {
                    auto _property_result = handle_property(rp, ep, true, part._Property, file)
                    if (_property_result._tag == Result<Property, ModelError>::Error)
                        return Result<Structure, ModelError> { ._tag = Result<Structure, ModelError>::Error, ._Error = _property_result._Error }
                    auto property = _property_result._Ok
                    if (!symbols_builder.add(property.name, Nameable { ._tag = Nameable::Property, ._Property = property }))
                        return Result<Structure, ModelError> { ._tag = Result<Structure, ModelError>::Error,
                            ._Error = ModelError(ModelBuilderError(DuplicateName(property.name, Span(part._Property.start, part._Property.end)))) }
                    properties_builder.add(property)
                }
                break
                case PartSyntax::Property: {
                    auto _property_result = handle_property(rp, ep, false, part._Property, file)
                    if (_property_result._tag == Result<Property, ModelError>::Error)
                        return Result<Structure, ModelError> { ._tag = Result<Structure, ModelError>::Error, ._Error = _property_result._Error }
                    auto property = _property_result._Ok
                    if (!symbols_builder.add(property.name, Nameable { ._tag = Nameable::Property, ._Property = property }))
                        return Result<Structure, ModelError> { ._tag = Result<Structure, ModelError>::Error,
                            ._Error = ModelError(ModelBuilderError(DuplicateName(property.name, Span(part._Property.start, part._Property.end)))) }
                    properties_builder.add(property)
                }
                break
            }
        }
    }

    HashSetBuilder<String>& modules_checker = *new(alignof(HashSetBuilder<String>), _r.get_page()) HashSetBuilder<String>()
    List<Module>& modules = *new(alignof(List<Module>), _r.get_page()) List<Module>()
    List<Use>& uses = *new(alignof(List<Use>), _r.get_page()) List<Use>()
    MultiMapBuilder<String, Function>& functions_builder = *new(alignof(MultiMapBuilder<String, Function>), _r.get_page()) MultiMapBuilder<String, Function>()
    List<Initializer>& initializers_builder = *new(alignof(List<Initializer>), _r.get_page()) List<Initializer>()
    Array<Member>& members_builder = *new(alignof(Array<Member>), _r.get_page()) Array<Member>()
    DeInitializer* deInitializer null
    if (class_syntax.body <> null) {
        {
            auto _deInitializer_result = handle_body(rp, ep, name, path, *class_syntax.body, uses, modules_checker, modules, initializers_builder, functions_builder, members_builder, symbols_builder, file)
            if (_deInitializer_result._tag == Result<DeInitializer, ModelError>::Error)
                return Result<Structure, ModelError> { ._tag = Result<Structure, ModelError>::Error, ._Error = _deInitializer_result._Error }
            deInitializer = _deInitializer_result._Ok
        }
    }

    return Result<Structure, ModelError> { ._tag = Result<Structure, ModelError>::Ok,
        ._Ok = Structure(Span(class_syntax.start, class_syntax.end), private_, Vector<Property>(_rp, properties_builder), Vector<Module>(_rp, modules), Vector<Use>(_rp, uses), Vector<Initializer>(_rp, initializers_builder), deInitializer, Vector<Member>(_rp, members_builder), HashMap<String, Nameable>(_rp, symbols_builder))
    }
}

Result<Namespace, ModelError> handle_namespace(String name, String path, NamespaceSyntax& namespace_syntax, bool private_, file: String) {    
    var r Region()
    HashMapBuilder<String, Nameable>& symbols_builder = *new(alignof(HashMapBuilder<String, Nameable>), _r.get_page()) HashMapBuilder<String, Nameable>()
    Array<Member>& members_builder = *new(alignof(Array<Member>), _r.get_page()) Array<Member>()
    MultiMapBuilder<String, Function>& functions_builder = *new(alignof(MultiMapBuilder<String, Function>), _r.get_page()) MultiMapBuilder<String, Function>()
    HashSetBuilder<String>& modules_checker = *new(alignof(HashSetBuilder<String>), _r.get_page()) HashSetBuilder<String>()
    List<Module>& modules = *new(alignof(List<Module>), _r.get_page()) List<Module>()

    auto declarations_iterator = namespace_syntax.declarations->get_iterator()
    while (auto declaration = declarations_iterator.next()) {
        switch (declaration->symbol._tag) {
            case SymbolSyntax::Private:{
                auto export_ = declaration->symbol._Private.export_
                switch (export_._tag) {
                    case ExportSyntax::Definition: {
                        auto concept_result = handle_definition(rp, ep, path, export_._Definition, true, file)
                        if (concept_result._tag == Result<Function, ModelError>::Error)
                            return Result<Namespace, ModelError> { ._tag = Result<Namespace, ModelError>::Error, ._Error = concept_result._Error }
                        auto concept = concept_result._Ok
                        if (functions_builder.contains(concept.name))
                            return Result<Namespace, ModelError> { ._tag = Result<Namespace, ModelError>::Error, ._Error = ModelError(ModelBuilderError(FunctionSymbolExists(file, Span(declaration->symbol._Definition.start, declaration->symbol._Definition.end)))) }

                        if (!symbols_builder.add(concept.name, Nameable { ._tag = Nameable::Concept, ._Concept = concept }))
                            return Result<Namespace, ModelError> { ._tag = Result<Namespace, ModelError>::Error,
                                ._Error = ModelError(ModelBuilderError(DuplicateName(concept.name, Span(export_._Definition.start, export_._Definition.end)))) }
                        members_builder.add(Member { ._tag = Member::Concept, ._Concept = concept })
                    }
                    break
                    case ExportSyntax::Function: {
                        auto function_syntax = export_._Function
                        auto function_result = build_function(rp, ep, function_syntax.start, function_syntax.end, function_syntax.target, true, true, file)
                        if (function_result._tag == Result<Function, ModelError>::Error)
                            return Result<Namespace, ModelError> { ._tag = Result<Namespace, ModelError>::Error, ._Error = function_result._Error }
                        auto function = function_result._Ok
                        auto symbol_with_function_name = symbols_builder[function.name]
                        if (symbol_with_function_name <> null)
                            return Result<Namespace, ModelError> { ._tag = Result<Namespace, ModelError>::Error, ._Error = ModelError(ModelBuilderError(NonFunctionSymbolExists(file, Span(declaration->symbol._Function.start, declaration->symbol._Function.end)))) }
                        functions_builder.add(function.name, function)
                        members_builder.add(Member { ._tag = Member::Function, ._Function = function })
                    }
                    break
                    case ExportSyntax::Operator: {
                        auto operator_syntax = export_._Operator
                        auto operator_result = handle_operator(rp, ep, operator_syntax, true, file)
                        if (operator_result._tag == Result<Namespace, ModelError>::Error)
                            return Result<Namespace, ModelError> { ._tag = Result<Namespace, ModelError>::Error,
                                ._Error = operator_result._Error }
                        auto operator_ = operator_result._Ok
                        if (!symbols_builder.add(operator_.name, Nameable { ._tag = Nameable::Operator, ._Operator = operator_ }))
                            return Result<Namespace, ModelError> { ._tag = Result<Namespace, ModelError>::Error,
                                ._Error = ModelError(ModelBuilderError(DuplicateName(file, Span(operator_syntax.start, operator_syntax.end)))) }
                        members_builder.add(Member { ._tag = Member::Operator, ._Operator = operator_ })
                    }
                    break
                    case ExportSyntax::Trait:
                        return Result<Namespace, ModelError> { ._tag = Result<Namespace, ModelError>::Error, ._Error = ModelError(ModelBuilderError(NotImplemented(file, String(_ep, "Private Trait"), Span(declaration->symbol._Trait.start, declaration->symbol._Trait.end)))) }
                    case ExportSyntax::Module: {
                        auto module_syntax = export_._Module
                        auto module_result = handle_module(rp, ep, path, module_syntax, true)
                        if (module_result._tag == Result<Namespace, ModelError>::Error)
                            return Result<Namespace, ModelError> { ._tag = Result<Namespace, ModelError>::Error,
                                ._Error = module_result._Error }
                        auto module = module_result._Ok
                        if (!modules_checker.add(module.name))
                            return Result<Namespace, ModelError> { ._tag = Result<Namespace, ModelError>::Error,
                                ._Error = ModelError(ModelBuilderError(NonFunctionSymbolExists(file, Span(module_syntax.start, module_syntax.end)))) }
                        modules.add(module)
                    }
                    break
                }
            }
            break
            case SymbolSyntax::Definition: {
                auto concept_result = handle_definition(rp, ep, path, declaration->symbol._Definition, false, file)
                if (concept_result._tag == Result<Function, ModelError>::Error)
                    return Result<Namespace, ModelError> { ._tag = Result<Namespace, ModelError>::Error, ._Error = concept_result._Error }
                auto concept = concept_result._Ok
                if (functions_builder.contains(concept.name))
                    return Result<Namespace, ModelError> { ._tag = Result<Namespace, ModelError>::Error, ._Error = ModelError(ModelBuilderError(FunctionSymbolExists(file, Span(declaration->symbol._Definition.start, declaration->symbol._Definition.end)))) }

                if (!symbols_builder.add(concept.name, Nameable { ._tag = Nameable::Concept, ._Concept = concept }))
                    return Result<Namespace, ModelError> { ._tag = Result<Namespace, ModelError>::Error,
                        ._Error = ModelError(ModelBuilderError(DuplicateName(file, Span(declaration->symbol._Definition.start, declaration->symbol._Definition.end)))) }
                members_builder.add(Member { ._tag = Member::Concept, ._Concept = concept })
            }
            break
            case SymbolSyntax::Function: {
                auto function_syntax = declaration->symbol._Function
                auto function_result = build_function(rp, ep, function_syntax.start, function_syntax.end, function_syntax.target, false, true, file)
                if (function_result._tag == Result<Function, ModelError>::Error)
                    return Result<Namespace, ModelError> { ._tag = Result<Namespace, ModelError>::Error, ._Error = function_result._Error }
                auto function = function_result._Ok
                auto symbol_with_function_name = symbols_builder[function.name]
                if (symbol_with_function_name <> null)
                    return Result<Namespace, ModelError> { ._tag = Result<Namespace, ModelError>::Error, ._Error = ModelError(ModelBuilderError(NonFunctionSymbolExists(file, Span(declaration->symbol._Function.start, declaration->symbol._Function.end)))) }
                functions_builder.add(function.name, function)
                members_builder.add(Member { ._tag = Member::Function, ._Function = function })
            }
            break
            case SymbolSyntax::Operator: {
                auto operator_syntax = declaration->symbol._Operator
                auto operator_result = handle_operator(rp, ep, operator_syntax, false, file)
                if (operator_result._tag == Result<Namespace, ModelError>::Error)
                    return Result<Namespace, ModelError> { ._tag = Result<Namespace, ModelError>::Error,
                        ._Error = operator_result._Error }
                auto operator_ = operator_result._Ok
                if (!symbols_builder.add(operator_.name, Nameable { ._tag = Nameable::Operator, ._Operator = operator_ }))
                    return Result<Namespace, ModelError> { ._tag = Result<Namespace, ModelError>::Error,
                        ._Error = ModelError(ModelBuilderError(DuplicateName(file, Span(operator_syntax.start, operator_syntax.end)))) }
                members_builder.add(Member { ._tag = Member::Operator, ._Operator = operator_ })
            }
            break
            case SymbolSyntax::Trait:
                return Result<Namespace, ModelError> { ._tag = Result<Namespace, ModelError>::Error, ._Error = ModelError(ModelBuilderError(NotImplemented(file, String(_ep, "Trait"), Span(declaration->symbol._Trait.start, declaration->symbol._Trait.end)))) }
            case SymbolSyntax::Macro:
                return Result<Namespace, ModelError> { ._tag = Result<Namespace, ModelError>::Error, ._Error = ModelError(ModelBuilderError(NotImplemented(file, String(_ep, "Macro"), Span(declaration->symbol._Macro.start, declaration->symbol._Macro.end)))) }
            case SymbolSyntax::Module: {
                auto module_syntax = declaration->symbol._Module
                auto module_result = handle_module(rp, ep, path, module_syntax, false)
                if (module_result._tag == Result<Namespace, ModelError>::Error)
                    return Result<Namespace, ModelError> { ._tag = Result<Namespace, ModelError>::Error,
                        ._Error = module_result._Error }
                auto module = module_result._Ok
                if (!modules_checker.add(module.name))
                    return Result<Namespace, ModelError> { ._tag = Result<Namespace, ModelError>::Error,
                        ._Error = ModelError(ModelBuilderError(NonFunctionSymbolExists(file, Span(module_syntax.start, module_syntax.end)))) }
                modules.add(module)
            }
            break
        }
    }

    auto multi_map = MultiMap<String, Function>(_r.get_page(), functions_builder)
    auto multi_map_iterator = multi_map.get_iterator()
    while (auto functions = multi_map_iterator.next()) {
        auto name = (*functions)[0]->name
        symbols_builder.add(String(name), Nameable { ._tag = Nameable::Functions, ._Functions = Vector<Function>(_rp, *functions) })
    }

    Span span(namespace_syntax.start, namespace_syntax.end)
    auto ret = Namespace(span, Vector<Module>(_rp, modules), Vector<Member>(_rp, members_builder), HashMap<String, Nameable>(_rp, symbols_builder))
    return Result<Namespace, ModelError> { ._tag = Result<Namespace, ModelError>::Ok, ._Ok = ret }
}

Result<Union, ModelError> handle_union(String name, String path, UnionSyntax& union_, bool private_, file: String) {    
    var r Region()
    Array<Variant>& variants_builder = *new(alignof(Array<Variant>), _r.get_page()) Array<Variant>()
    HashMapBuilder<String, Nameable>& symbols_builder = *new(alignof(HashMapBuilder<String, Nameable>), _r.get_page()) HashMapBuilder<String, Nameable>()
    auto variant_syntaxes = union_.variants
    auto _variants_iterator = variant_syntaxes->get_iterator()
    while (auto _variant_syntax = _variants_iterator.next()) {
        auto variant_syntax = *_variant_syntax
        Type* type null
        if (variant_syntax.annotation <> null) {
            auto _type_result = handle_type(rp, ep, variant_syntax.annotation->type, file)
            if (_type_result._tag == Result<Type, ModelError>::Error)
                return Result<Union, ModelError> { ._tag = Result<Union, ModelError>::Error, ._Error = _type_result._Error }
            type = _type_result._Ok
        }

        List<Attribute>& attributes = *new(alignof(List<Attribute>), _r.get_page()) List<Attribute>()
        if (variant_syntax.attributes <> null) {
            auto _attribute_iterator = variant_syntax.attributes->get_iterator()
            while (auto _attribute_syntax = _attribute_iterator.next()) {
                auto attribute_syntax = *_attribute_syntax
                auto _attribute_result = handle_attribute(rp, ep, attribute_syntax, file)
                if (_attribute_result._tag == Result<Attribute, ModelError>::Error)
                    return Result<Union, ModelError> { ._tag = Result<Union, ModelError>::Error, ._Error = _attribute_result._Error }
                auto attribute = _attribute_result._Ok
                attributes.add(attribute)
            }
        }
        auto variant = Variant(Span(variant_syntax.start, variant_syntax.end), variant_syntax.name, type, Vector<Attribute>(_rp, attributes))
        if (!symbols_builder.add(variant_syntax.name, Nameable { ._tag = Nameable::Variant, ._Variant = variant }))
            return Result<Union, ModelError> { ._tag = Result<Union, ModelError>::Error,
                ._Error = ModelError(ModelBuilderError(DuplicateName(variant_syntax.name, Span(variant_syntax.start, variant_syntax.end)))) }
        variants_builder.add(variant)
    }

    HashSetBuilder<String>& modules_checker = *new(alignof(HashSetBuilder<String>), _r.get_page()) HashSetBuilder<String>()
    List<Module>& modules = *new(alignof(List<Module>), _r.get_page()) List<Module>()
    List<Use>& uses = *new(alignof(List<Use>), _r.get_page()) List<Use>()
    MultiMapBuilder<String, Function>& functions_builder = *new(alignof(MultiMapBuilder<String, Function>), _r.get_page()) MultiMapBuilder<String, Function>()
    List<Initializer>& initializers_builder = *new(alignof(List<Initializer>), _r.get_page()) List<Initializer>()
    Array<Member>& members_builder = *new(alignof(Array<Member>), _r.get_page()) Array<Member>()
    DeInitializer* deInitializer null
    if (union_.body <> null) {
        {
            auto _deInitializer_result = handle_body(rp, ep, name, path, *union_.body, uses, modules_checker, modules, initializers_builder, functions_builder, members_builder, symbols_builder, file)
            if (_deInitializer_result._tag == Result<DeInitializer, ModelError>::Error)
                return Result<Union, ModelError> { ._tag = Result<Union, ModelError>::Error, ._Error = _deInitializer_result._Error }
            deInitializer = _deInitializer_result._Ok
        }
    }
    return Result<Union, ModelError> { ._tag = Result<Union, ModelError>::Ok,
        ._Ok = Union(Span(union_.start, union_.end), private_, Vector<Variant>(_rp, variants_builder), Vector<Member>(_rp, members_builder), HashMap<String, Nameable>(_rp, symbols_builder))
    }
}

Result<Vector<Operand>, ModelError> handle_operation(OperationSyntax& operation, file: String)

Result<Action, ModelError> handle_action(ActionSyntax& action, file: String)

*;

function handle_literal(literal: ref[LiteralSyntax], file: String) returns Constant throws ModelError {
    var r Region()
    choose literal.literal
        when boolean: Literal.Boolean
            return Constant(BooleanConstant(boolean.value))
        when integer: Literal.Integer
        {
            let value (size_t)strtol(integer.value.to_c_string(r.get_page()), nullptr, 10)
            if errno = ERANGE
                throw ModelError(ModelBuilderError(InvalidConstant(file, Span(literal.start, literal.end))))

            return Constant(IntegerConstant(value))
        }
        when hex: Literal.Hex
        {
            let value (size_t)strtoul(hex.value.to_c_string(r.get_page()), nullptr, 16)
            if errno = ERANGE
                throw ModelError(ModelBuilderError(InvalidConstant(file, Span(literal.start, literal.end))))

            return Constant(HexConstant(value))
        }
        when floating_point: Literal.FloatingPoint
        {
            let value strtod(floating_point.value.to_c_string(r.get_page()), nullptr)
            if errno = ERANGE
                throw ModelError(ModelBuilderError(InvalidConstant(file, Span(literal.start, literal.end))))

            return Constant(FloatingPointConstant(value))
        }
        when string: Literal.String
            Constant(StringConstant(string.value))
        when character: Literal.Character
            return Constant(CharacterConstant(character.value))
        when fragment: Literal.Fragment
            return Constant(FragmentConstant(fragment.value))

    throw ModelError(ModelBuilderError(InvalidConstant(file, Span(literal.start, literal.end))))
}

function handle_type(type_syntax: ref[TypeSyntax], file: String) returns pointer[Type] throws ModelError {
    var r Region()

    var path: ref[List[String]] *List[String]$()
    path.add(String(rp, type_syntax.name.name))
    if type_syntax.name.extensions <> null
    {
        for extension in (*type_syntax.name.extensions)
        {
            path.add(extension.name)
        }
    }

    var generics: pointer[Vector[Type]] null
    var lifetime Lifetime(Unspecified())
    var generics_builder: ref[List[Type]] *List[Type]$()
    if type_syntax.generics <> null
    {
        let generic_arguments (*type_syntax.generics).generics
        if generic_arguments <> null
        {
            for generic in (*generic_arguments)
            {
                try let type handle_type(rp, ep, generic.type, file)
                    else throw

                generics_builder.add(*type)
            }

            set generics: Vector[Type]#(rp, generics_builder)
        } else {
            set generics: Vector[Type]#()
        }
    }

    if type_syntax.lifetime <> null
    {
        let lifetime_syntax *type_syntax.lifetime
        choose lifetime_syntax
            when c: LifetimeSyntax.Call
                set lifetime: Lifetime(Call())
            when l: LifetimeSyntax.Local
                set lifetime: Lifetime(Local())
            when r: LifetimeSyntax.Reference
                set lifetime: Lifetime(Reference(String(rp, r.location)))
            when t: LifetimeSyntax.Thrown
                set lifetime: Lifetime(Thrown())
    }

    return Type#(Span(type_syntax.start, type_syntax.end), Vector[String](rp, path), generics, lifetime)
}

;*

Result<Type*, ModelError> handle_binding_annotation(BindingAnnotationSyntax& binding_annotation, file: String) {
    switch (binding_annotation.spec._tag) {
        case BindingSpecSyntax::Type: {
            auto type_result = handle_type(rp, ep, binding_annotation.spec._Type, file)
            if (type_result._tag == Result<Type, ModelError>::Error)
                return Result<Type*, ModelError> { ._tag = Result<Type*, ModelError>::Error, ._Error = type_result._Error }
            return Result<Type*, ModelError> { ._tag = Result<Type*, ModelError>::Ok, ._Ok = type_result._Ok }
        }
        case BindingSpecSyntax::Structure:
            return Result<Type*, ModelError> { ._tag = Result<Type*, ModelError>::Error, ._Error = ModelError(ModelBuilderError(NotImplemented(file, String(_ep, "Structure"), Span(binding_annotation.spec._Structure.start, binding_annotation.spec._Structure.end)))) }
        case BindingSpecSyntax::Array:
            return Result<Type*, ModelError> { ._tag = Result<Type*, ModelError>::Error, ._Error = ModelError(ModelBuilderError(NotImplemented(file, String(_ep, "Array"), Span(binding_annotation.spec._Array.start, binding_annotation.spec._Array.end)))) }

    }
}

Result<Break, ModelError> handle_break(BreakSyntax& break_, file: String) {
    var r Region()
    if (break_.result <> null) {
        auto result = break_.result
        auto result_result = handle_operands(rp, ep, result, file)
        if (result_result._tag == Result<Vector<Operand>, ModelError>::Error)
            return Result<Break, ModelError> { ._tag = Result<Break, ModelError>::Error, ._Error = result_result._Error }
        return Result<Break, ModelError> { ._tag = Result<Break, ModelError>::Ok, ._Ok = Break(Span(break_.start, break_.end), result_result._Ok) }
    }
    return Result<Break, ModelError> { ._tag = Result<Break, ModelError>::Ok, ._Ok = Break(Span(break_.start, break_.end), Vector<Operand>(_rp, 0)) }
}

Result<Continue, ModelError> handle_continue(ContinueSyntax& continue_, file: String) {
    var r Region()
    return Result<Continue, ModelError> { ._tag = Result<Continue, ModelError>::Ok, ._Ok = Continue(Span(continue_.start, continue_.end)) }
}

Result<Return, ModelError> handle_return(ReturnSyntax& return_, file: String) {
    var r Region()
    if (return_.result <> null) {
        auto result = return_.result
        auto result_result = handle_operands(rp, ep, result, file)
        if (result_result._tag == Result<Vector<Operand>, ModelError>::Error)
            return Result<Return, ModelError> { ._tag = Result<Return, ModelError>::Error, ._Error = result_result._Error }
        return Result<Return, ModelError> { ._tag = Result<Return, ModelError>::Ok, ._Ok = Return(Span(return_.start, return_.end), result_result._Ok) }
    }
    return Result<Return, ModelError> { ._tag = Result<Return, ModelError>::Ok, ._Ok = Return(Span(return_.start, return_.end), Vector<Operand>(_rp, 0)) }
}

Result<Return, ModelError> handle_throw(ThrowSyntax& throw_, file: String) {
    var r Region()
    if (throw_.result <> null) {
        auto result = throw_.result
        auto result_result = handle_operands(rp, ep, result, file)
        if (result_result._tag == Result<Vector<Operand>, ModelError>::Error)
            return Result<Return, ModelError> { ._tag = Result<Return, ModelError>::Error, ._Error = result_result._Error }
        return Result<Return, ModelError> { ._tag = Result<Return, ModelError>::Ok, ._Ok = Return(Span(throw_.start, throw_.end), result_result._Ok) }
    }
    return Result<Return, ModelError> { ._tag = Result<Return, ModelError>::Ok, ._Ok = Return(Span(throw_.start, throw_.end), Vector<Operand>(_rp, 0)) }
}

Result<Statement, ModelError> handle_command(CommandSyntax& command, file: String) {
    var r Region()
    switch (command._tag)
    {
        case CommandSyntax::Operation: {
            auto operation_result = handle_operation(rp, ep, command._Operation, file)
            if (operation_result._tag == Result<Vector<Operand>, ModelError>::Error)
                return Result<Statement, ModelError> { ._tag = Result<Statement, ModelError>::Error, ._Error = operation_result._Error }
            return Result<Statement, ModelError> { ._tag = Result<Statement, ModelError>::Ok, ._Ok = Statement { ._tag = Statement::Action, ._Action = Action(operation_result._Ok, Vector<Operand>())}}
        }
        case CommandSyntax::Let: {
            auto binding = command._Let.binding.operation
            Type* type null
            if (command._Let.binding.annotation <> null) {
                auto _type_result = handle_binding_annotation(rp, ep, *command._Let.binding.annotation, file)
                if (_type_result._tag == Result<Type, ModelError>::Error)
                    return Result<Statement, ModelError> { ._tag = Result<Statement, ModelError>::Error, ._Error = _type_result._Error }
                type = _type_result._Ok
            }
            auto operation_result = handle_operands(rp, ep, binding, file)
            if (operation_result._tag == Result<Vector<Operand>, ModelError>::Error)
                return Result<Statement, ModelError> { ._tag = Result<Statement, ModelError>::Error, ._Error = operation_result._Error }
            return Result<Statement, ModelError> { ._tag = Result<Statement, ModelError>::Ok, ._Ok = Statement { ._tag = Statement::Binding, ._Binding = Binding(String(_rp, "const"), Item(Span(command._Let.start, command._Let.end), false, new(alignof(String), _rp) String(_rp, command._Let.binding.name), type, Vector<Attribute>(_rp, 0)), operation_result._Ok) }}
        }
        case CommandSyntax::Var: {
            auto binding = command._Var.binding.operation
            Type* type null
            if (command._Var.binding.annotation <> null) {
                auto _type_result = handle_binding_annotation(rp, ep, *command._Var.binding.annotation, file)
                if (_type_result._tag == Result<Type, ModelError>::Error)
                    return Result<Statement, ModelError> { ._tag = Result<Statement, ModelError>::Error, ._Error = _type_result._Error }
                type = _type_result._Ok
            }
            auto operation_result = handle_operands(rp, ep, binding, file)
            if (operation_result._tag == Result<Vector<Operand>, ModelError>::Error)
                return Result<Statement, ModelError> { ._tag = Result<Statement, ModelError>::Error, ._Error = operation_result._Error }
            return Result<Statement, ModelError> { ._tag = Result<Statement, ModelError>::Ok, ._Ok = Statement { ._tag = Statement::Binding, ._Binding = Binding(String(_rp, "var"), Item(Span(command._Var.start, command._Var.end), false, new(alignof(String), _rp) String(_rp, command._Mutable.binding.name), type, Vector<Attribute>(_rp, 0)), operation_result._Ok) }}
        }
        case CommandSyntax::Mutable: {
            auto binding = command._Mutable.binding.operation
            Type* type null
            if (command._Mutable.binding.annotation <> null) {
                auto _type_result = handle_binding_annotation(rp, ep, *command._Mutable.binding.annotation, file)
                if (_type_result._tag == Result<Type, ModelError>::Error)
                    return Result<Statement, ModelError> { ._tag = Result<Statement, ModelError>::Error, ._Error = _type_result._Error }
                type = _type_result._Ok
            }
            auto operation_result = handle_operands(rp, ep, binding, file)
            if (operation_result._tag == Result<Vector<Operand>, ModelError>::Error)
                return Result<Statement, ModelError> { ._tag = Result<Statement, ModelError>::Error, ._Error = operation_result._Error }
            return Result<Statement, ModelError> { ._tag = Result<Statement, ModelError>::Ok, ._Ok = Statement { ._tag = Statement::Binding, ._Binding = Binding(String(_rp, "mutable"), Item(Span(command._Mutable.start, command._Mutable.end), false, new(alignof(String), _rp) String(_rp, command._Mutable.binding.name), type, Vector<Attribute>(_rp, 0)), operation_result._Ok) }}
        }
        case CommandSyntax::Set: {
            auto _target_result = handle_operands(rp, ep, command._Set.target, file)
            if (_target_result._tag == Result<Vector<Operand>, ModelError>::Error)
                return Result<Statement, ModelError> { ._tag = Result<Statement, ModelError>::Error, ._Error = _target_result._Error }
            auto target = _target_result._Ok
            auto _source_result = handle_operands(rp, ep, command._Set.source, file)
            if (_source_result._tag == Result<Vector<Operand>, ModelError>::Error)
                return Result<Statement, ModelError> { ._tag = Result<Statement, ModelError>::Error, ._Error = _source_result._Error }
            auto source = _source_result._Ok
            return Result<Statement, ModelError> { ._tag = Result<Statement, ModelError>::Ok, ._Ok = Statement { ._tag = Statement::Action, ._Action = Action(source, target)}}
        }
        case CommandSyntax::Continue: {
            auto continue_ = command._Continue
            auto continue_result = handle_continue(rp, ep, continue_, file)
            if (continue_result._tag == Result<Expression, ModelError>::Error)
                return Result<Statement, ModelError> { ._tag = Result<Statement, ModelError>::Error, ._Error = continue_result._Error }
            return Result<Statement, ModelError> { ._tag = Result<Statement, ModelError>::Ok, ._Ok = Statement { ._tag = Statement::Continue, ._Continue = continue_result._Ok}}
        }
        case CommandSyntax::Break: {
            auto break_ = command._Break
            auto break_result = handle_break(rp, ep, break_, file)
            if (break_result._tag == Result<Expression, ModelError>::Error)
                return Result<Statement, ModelError> { ._tag = Result<Statement, ModelError>::Error, ._Error = break_result._Error }
            return Result<Statement, ModelError> { ._tag = Result<Statement, ModelError>::Ok, ._Ok = Statement { ._tag = Statement::Break, ._Break = break_result._Ok}}
        }
        case CommandSyntax::Return: {
            auto return_ = command._Return
            auto return_result = handle_return(rp, ep, return_, file)
            if (return_result._tag == Result<Expression, ModelError>::Error)
                return Result<Statement, ModelError> { ._tag = Result<Statement, ModelError>::Error, ._Error = return_result._Error }
            return Result<Statement, ModelError> { ._tag = Result<Statement, ModelError>::Ok, ._Ok = Statement { ._tag = Statement::Return, ._Return = return_result._Ok}}
        }
        case CommandSyntax::Throw: {
            auto throw_ = command._Throw
            auto throw_result = handle_throw(rp, ep, throw_, file)
            if (throw_result._tag == Result<Expression, ModelError>::Error)
                return Result<Statement, ModelError> { ._tag = Result<Statement, ModelError>::Error, ._Error = throw_result._Error }
            return Result<Statement, ModelError> { ._tag = Result<Statement, ModelError>::Ok, ._Ok = Statement { ._tag = Statement::Throw, ._Return = throw_result._Ok}}
        }
    }
}

Result<Statement, ModelError> handle_statement(StatementSyntax& statement, file: String) {
    auto result = handle_command(rp, ep, statement.command, file)
    if (result._tag == Result<Statement, ModelError>::Error)
        return Result<Statement, ModelError> { ._tag = Result<Statement, ModelError>::Error, ._Error = result._Error }
    return Result<Statement, ModelError> { ._tag = Result<Statement, ModelError> ::Ok, ._Ok = result._Ok }
}

Result<Vector<Statement>, ModelError> handle_statements(Vector<StatementSyntax>& statements, file: String) {
    var r Region()
    List<Statement>& statements_builder = *new(alignof(List<Statement>), _r.get_page()) List<Statement>()
    auto _statements_iterator = statements.get_iterator()
    while (auto statement = _statements_iterator.next()) {
        auto _statement_result = handle_statement(rp, ep, *statement, file)
        if (_statement_result._tag == Result<Statement, ModelError>::Error)
            return Result<Vector<Statement>, ModelError> { ._tag = Result<Vector<Statement>, ModelError>::Error, ._Error = _statement_result._Error }
        statements_builder.add(_statement_result._Ok)
    }
    
    return Result<Vector<Statement>, ModelError> { ._tag = Result<Vector<Statement>, ModelError> ::Ok, ._Ok = Vector<Statement>(_rp, statements_builder) }
}

*;

function handle_component(component: ref[ComponentSyntax], file: String) returns Component throws ModelError {
    var r Region()
    var name: pointer[String] null

    var attributes *List[Attribute]$()
    if component.attributes <> null
    {
        for attribute_syntax in (*component.attributes)
        {
            try let attribute handle_attribute(rp, ep, attribute_syntax, file)
                else throw
            attributes.add(attribute)
        }
    }

    if component.value <> null
    {
        if component.operands <> null
        {
            var name_operands *component.operands
            if name_operands.length > 0
            {
                var name_operand *name_operands.get(0)
                if name_operands.length > 1
                    return ModelError(ModelBuilderError(InvalidComponentName(file, Span(name_operand.start, name_operand.end))))
                choose name_operand.expression
                    when type: ExpressionSyntax.Type
                        set name: String#(rp, type.name.name)
                    else {}
            }
        }

        let value (*component.value).value
        if value <> null
        {
            try let value_result handle_operands(rp, ep, value, file)
                else throw
            return Component(Span(component.start, component.end), name, value_result, Vector[Attribute](rp, attributes))
        } else {
            return Component(Span(component.start, component.end), name, Vector[Operand](), Vector[Attribute](rp, attributes))
        }
    } else {
        if component.operands <> null
        {
            try let value_result handle_operands(rp, ep, component.operands, file)
                else throw
            return Component(Span(component.start, component.end), name, value_result, Vector[Attribute](rp, attributes))
        } else {
            return Component(Span(component.start, component.end), name, Vector[Operand](), Vector[Attribute](rp, attributes))
        }
    }
}

function handle_object(object: ref[ObjectSyntax], file: String) returns Tuple throws ModelError {
    var r Region()
    var components_builder *List[Component]$()
    if object.components <> null
    {
        for component in (*object.components)
        {
            try let component_result handle_component(rp, ep, component, file)
                else throw

            components_builder.add(component_result)
        }
    }
    return Tuple(Span(object.start, object.end), Vector[Component](rp, components_builder))
}

function handle_vector(vector: ref[VectorSyntax], file: String) returns Matrix throws ModelError {
    var r Region()
    var operations_builder *List[Vector[Operand]]$()
    if vector.elements <> null
    {
        for element in (*vector.elements)
        {
            try let operation_result handle_operands(rp, ep, element.operation, file)
                else throw
            operations_builder.add(operation_result)
        }
    }
    return Matrix(Span(vector.start, vector.end), Vector[Vector[Operand]](rp, operations_builder))
}

function handle_model(model: ref[ModelSyntax], file: String) returns Model throws ModelError {
    choose model
        when literal: ModelSyntax.Literal
        {
            try let constant handle_literal(rp, ep, literal, file)
                else throw
            return constant
        }
        when name: ModelSyntax.Name
        {
            return String(rp, name.name)
        }
        when object_syntax: ModelSyntax.Object
        {
            try let tuple handle_object(rp, ep, object_syntax, file)
                else throw
            return tuple
        }
        when vector: ExpressionSyntax.Vector
        {
            try let matrix handle_vector(rp, ep, vector, file)
                else throw
            return matrix
        }
}

function handle_attribute(attribute: ref[AttributeSyntax], file: String) returns Attribute throws ModelError {
    try let model handle_model(rp, ep, attribute.model, file)
        else throw
    return Attribute(Span(attribute.start, attribute.end), attribute.name, model)
}

;*

Result<Block, ModelError> handle_block(BlockSyntax& block, file: String) {
    var r Region()
    if (block.statements <> null) {
        auto _statements_result = handle_statements(rp, ep, *block.statements, file)
        if (_statements_result._tag == Result<Vector<Statement>, ModelError>::Error)
            return Result<Block, ModelError> { ._tag = Result<Block, ModelError>::Error, ._Error = _statements_result._Error }
        auto statements = _statements_result._Ok
        return Result<Block, ModelError> { ._tag = Result<Block, ModelError>::Ok, ._Ok = Block(Span(block.start, block.end), statements) }
    }

    return Result<Block, ModelError> { ._tag = Result<Block, ModelError>::Ok, ._Ok = Block(Span(block.start, block.end), Vector<Statement>(_rp, 0)) }
}

Result<If, ModelError> handle_if(IfSyntax& if_, file: String) {
    var r Region()
    Property* property null
    auto condition_result = handle_operands(rp, ep, if_.condition, file)
    if (condition_result._tag == Result<Vector<Operand>, ModelError>::Error)
        return Result<If, ModelError> { ._tag = Result<If, ModelError>::Error, ._Error = condition_result._Error }
    auto condition = condition_result._Ok
    auto _consequent_result = handle_command(rp, ep, if_.consequent, file)
    if (_consequent_result._tag == Result<Action, ModelError>::Error)
        return Result<If, ModelError> { ._tag = Result<If, ModelError>::Error, ._Error = _consequent_result._Error }
    auto consequent = _consequent_result._Ok

    Statement* alternative null
    if (if_.alternative <> null) {
        auto _alternative_result = handle_command(rp, ep, if_.alternative->alternative, file)
        if (_alternative_result._tag == Result<Statement, ModelError>::Error)
            return Result<If, ModelError> { ._tag = Result<If, ModelError>::Error, ._Error = _alternative_result._Error }
        alternative = new(alignof(Statement), _rp) Statement(_alternative_result._Ok)
    }
    return Result<If, ModelError> { ._tag = Result<If, ModelError>::Ok, ._Ok = If(Span(if_.start, if_.end), condition, property, consequent, alternative) }
}

Result<Match, ModelError> handle_match(MatchSyntax& match_, file: String) {
    var r Region()
    Property* property null

    auto condition_result = handle_operands(rp, ep, match_.scrutinee, file)
    if (condition_result._tag == Result<Vector<Operand>, ModelError>::Error)
        return Result<Match, ModelError> { ._tag = Result<Match, ModelError>::Error, ._Error = condition_result._Error }
    auto condition = condition_result._Ok

    List<Branch>& branches_builder = *new(alignof(List<Branch>), _r.get_page()) List<Branch>()
    if (match_.branches <> null) {
        auto _branch_iterator = match_.branches->get_iterator()
        while (auto _branch = _branch_iterator.next()) {
            auto branch = *_branch

            List<Case>& cases_builder = *new(alignof(List<Case>), _r.get_page()) List<Case>()
            auto _case_iterator = branch.cases->get_iterator()
            while (auto _case = _case_iterator.next()) {
                auto case_ = *_case
                auto condition_result =  handle_operands(rp, ep, case_.condition, file)
                if (condition_result._tag == Result<Operand, ModelError>::Error)
                    return Result<Match, ModelError> { ._tag = Result<Match, ModelError>::Error, ._Error = condition_result._Error }
                auto condition =  Case(Span(case_.start, case_.end),  condition_result._Ok)
                cases_builder.add(condition)
            }

            auto _consequent_result = handle_statement(rp, ep, branch.consequent, file)
            if (_consequent_result._tag == Result<Action, ModelError>::Error)
                return Result<Match, ModelError> { ._tag = Result<Match, ModelError>::Error, ._Error = _consequent_result._Error }
            auto consequent = Branch(Span(branch.start, branch.end), Vector<Case>(_rp, cases_builder), _consequent_result._Ok)
            branches_builder.add(consequent)
        }
    }

    Statement* alternative null
    if (match_.alternative <> null) {
        auto _alternative_result = handle_command(rp, ep, match_.alternative->alternative, file)
        if (_alternative_result._tag == Result<Statement, ModelError>::Error)
            return Result<Match, ModelError> { ._tag = Result<Match, ModelError>::Error, ._Error = _alternative_result._Error }
        alternative = new(alignof(Statement), _rp) Statement(_alternative_result._Ok)
    }
    return Result<Match, ModelError> { ._tag = Result<Match, ModelError>::Ok, ._Ok = Match(Span(match_.start, match_.end), condition, Vector<Branch>(_rp, branches_builder), alternative) }
}

Result<When, ModelError> handle_when(WhenSyntax& when_, file: String) {
    var r Region()
    List<String>& name_builder = *new(alignof(List<String>), _r.get_page()) List<String>()
    name_builder.add(when_.variant.name)
    if (when_.variant.extensions <> null) {
        auto _name_iterator = when_.variant.extensions->get_iterator()
        while(auto _name = _name_iterator.next()) {
            name_builder.add(_name->name)
        }
    }
    auto _command_result = handle_command(rp, ep, when_.command, file)
    if (_command_result._tag == Result<Statement, ModelError>::Error)
        return Result<When, ModelError> { ._tag = Result<When, ModelError>::Error, ._Error = _command_result._Error }
    auto consequent = _command_result._Ok
    return Result<When, ModelError> { ._tag = Result<When, ModelError>::Ok, ._Ok = When(Span(when_.start, when_.end), when_.name, Vector<String>(_rp, name_builder), consequent)}
}

Result<Choose, ModelError> handle_choose(ChooseSyntax& choose_, file: String) {
    var r Region()
    Property* property null

    auto condition_result = handle_operands(rp, ep, choose_.condition, file)
    if (condition_result._tag == Result<Vector<Operand>, ModelError>::Error)
        return Result<Choose, ModelError> { ._tag = Result<Choose, ModelError>::Error, ._Error = condition_result._Error }
    auto condition = condition_result._Ok

    List<When>& cases_builder = *new(alignof(List<When>), _r.get_page()) List<When>()
    if (choose_.cases <> null) {
        auto when_syntaxes = choose_.cases
        auto _cases_iterator = when_syntaxes->get_iterator()
        while (auto _case_syntax = _cases_iterator.next()) {
            auto case_syntax = *_case_syntax
            auto _case_result = handle_when(rp, ep, case_syntax, file)
            if (_case_result._tag == Result<Choose, ModelError>::Error)
                return Result<Choose, ModelError> { ._tag = Result<Choose, ModelError>::Error, ._Error = _case_result._Error }
            auto case_ = _case_result._Ok
            cases_builder.add(case_)
        }
    }

    Statement* alternative null
    if (choose_.alternative <> null) {
        auto _alternative_result = handle_command(rp, ep, choose_.alternative->alternative, file)
        if (_alternative_result._tag == Result<Statement, ModelError>::Error)
            return Result<Choose, ModelError> { ._tag = Result<Choose, ModelError>::Error, ._Error = _alternative_result._Error }
        alternative = new(alignof(Statement), _rp) Statement(_alternative_result._Ok)
    }
    return Result<Choose, ModelError> { ._tag = Result<Choose, ModelError>::Ok, ._Ok = Choose(Span(choose_.start, choose_.end), condition, Vector<When>(_rp, cases_builder), alternative) }
}

Result<For, ModelError> handle_for(ForSyntax& for_, file: String) {
    var r Region()
    auto expression_result = handle_operands(rp, ep, for_.operation, file)
    if (expression_result._tag == Result<Vector<Operand>, ModelError>::Error)
        return Result<For, ModelError> { ._tag = Result<For, ModelError>::Error, ._Error = expression_result._Error }
    auto expression = expression_result._Ok
    if (for_.name <> null)
        return Result<For, ModelError> { ._tag = Result<For, ModelError>::Error, ._Error = ModelError(ModelBuilderError(NotImplemented(file, String(_ep, "Label in For"), Span(for_.name->start, for_.name->end)))) }

    auto _action_result = handle_action(rp, ep, for_.action, file)
    if (_action_result._tag == Result<Action, ModelError>::Error)
        return Result<For, ModelError> { ._tag = Result<For, ModelError>::Error, ._Error = _action_result._Error }
    auto action = Action(_action_result._Ok)
    return Result<For, ModelError> { ._tag = Result<For, ModelError>::Ok, ._Ok = For(Span(for_.start, for_.end), String(_rp, for_.variable), expression, action) }
}

Result<Binding, ModelError> handle_condition(ConditionSyntax& condition, file: String) {
    var r Region()
    switch (condition._tag)
    {
        case ConditionSyntax::Operation: {
            auto operation_result = handle_operation(rp, ep, condition._Operation, file)
            if (operation_result._tag == Result<Vector<Operand>, ModelError>::Error)
                return Result<Binding, ModelError> { ._tag = Result<Binding, ModelError>::Error, ._Error = operation_result._Error }
            return Result<Binding, ModelError> { ._tag = Result<Binding, ModelError>::Ok, ._Ok = Binding(String(_rp, "const"), Item(Span(condition._Operation.start, condition._Operation.end), false, nullptr, nullptr, Vector<Attribute>(_rp, 0)), operation_result._Ok)}
        }
        case ConditionSyntax::Let: {
            auto binding = condition._Let.binding.operation
            Type* type null
            if (condition._Let.binding.annotation <> null) {
                auto _type_result = handle_binding_annotation(rp, ep, *condition._Let.binding.annotation, file)
                if (_type_result._tag == Result<Type, ModelError>::Error)
                    return Result<Binding, ModelError> { ._tag = Result<Binding, ModelError>::Error, ._Error = _type_result._Error }
                type = _type_result._Ok
            }
            auto operation_result = handle_operands(rp, ep, binding, file)
            if (operation_result._tag == Result<Vector<Operand>, ModelError>::Error)
                return Result<Binding, ModelError> { ._tag = Result<Binding, ModelError>::Error, ._Error = operation_result._Error }
            return Result<Binding, ModelError> { ._tag = Result<Binding, ModelError>::Ok, ._Ok = Binding(String(_rp, "const"), Item(Span(condition._Let.start, condition._Let.end), false, new(alignof(String), _rp) String(_rp, condition._Let.binding.name), nullptr, Vector<Attribute>(_rp, 0)), operation_result._Ok)}
        }
    }
}

Result<While, ModelError> handle_while(WhileSyntax& while_, file: String) {
    var r Region()
    auto _condition_result = handle_condition(rp, ep, while_.condition, file)
    if (_condition_result._tag == Result<Vector<Operand>, ModelError>::Error)
        return Result<While, ModelError> { ._tag = Result<While, ModelError>::Error, ._Error = _condition_result._Error }
    auto condition = _condition_result._Ok
    if (while_.name <> null)
        return Result<While, ModelError> { ._tag = Result<While, ModelError>::Error, ._Error = ModelError(ModelBuilderError(NotImplemented(file, String(_ep, "Label in While"), Span(while_.name->start, while_.name->end)))) }

    auto _action_result = handle_action(rp, ep, while_.action, file)
    if (_action_result._tag == Result<Action, ModelError>::Error)
        return Result<While, ModelError> { ._tag = Result<While, ModelError>::Error, ._Error = _action_result._Error }
    auto action = Action(_action_result._Ok)
    return Result<While, ModelError> { ._tag = Result<While, ModelError>::Ok, ._Ok = While(Span(while_.start, while_.end), condition, action) }
}

Result<Try, ModelError> handle_try(TrySyntax& try_, file: String) {
    var r Region()
    auto _condition_result = handle_condition(rp, ep, try_.condition, file)
    if (_condition_result._tag == Result<Vector<Operand>, ModelError>::Error)
        return Result<Try, ModelError> { ._tag = Result<Try, ModelError>::Error, ._Error = _condition_result._Error }
    auto condition = _condition_result._Ok
    List<When>& catches_builder = *new(alignof(List<When>), _r.get_page()) List<When>()
    if (try_.cases <> null) {
        auto catch_syntaxes = try_.cases
        auto _catches_iterator = catch_syntaxes->get_iterator()
        while (auto _catch_syntax = _catches_iterator.next()) {
            auto catch_syntax = *_catch_syntax
            auto _catch_result = handle_when(rp, ep, catch_syntax, file)
            if (_catch_result._tag == Result<When, ModelError>::Error)
                return Result<Try, ModelError> { ._tag = Result<Try, ModelError>::Error, ._Error = _catch_result._Error }
            auto catch_ = _catch_result._Ok
            catches_builder.add(catch_)
        }
    }
    Statement* drop_ null
    if (try_.dropper <> null) {
        auto drop_syntax = *try_.dropper
        auto _drop_result = handle_command(rp, ep, drop_syntax.alternative, file)
        if (_drop_result._tag == Result<Drop, ModelError>::Error)
            return Result<Try, ModelError> { ._tag = Result<Try, ModelError>::Error, ._Error = _drop_result._Error }
        drop_ = new(alignof(Statement), _rp) Statement(_drop_result._Ok)
    }
    return Result<Try, ModelError> { ._tag = Result<Try, ModelError>::Ok, ._Ok = Try(Span(try_.start, try_.end), condition, Vector<When>(_rp, catches_builder), drop_) }
}

Result<SizeOf, ModelError> handle_size_of(SizeOfSyntax& size_of, file: String) {
    var r Region()
    auto type_result = handle_type(rp, ep, size_of.type, file)
    if (type_result._tag == Result<Vector<Operand>, ModelError>::Error)
        return Result<SizeOf, ModelError> { ._tag = Result<SizeOf, ModelError>::Error, ._Error = type_result._Error }
    auto type = type_result._Ok
    return Result<SizeOf, ModelError> { ._tag = Result<SizeOf, ModelError>::Ok, ._Ok = SizeOf(Span(size_of.start, size_of.end), *type) }
}

Result<Expression, ModelError> handle_expression(ExpressionSyntax& expression, file: String) {
    var r Region()
    switch (expression._tag) {
        case ExpressionSyntax::Literal: {
            auto literal = expression._Literal
            auto constant_result = handle_literal(rp, ep, literal, file)
            if (constant_result._tag == Result<Constant, ModelError>::Error)
                return Result<Expression, ModelError> { ._tag = Result<Expression, ModelError>::Error, ._Error = constant_result._Error }
            return Result<Expression, ModelError> { ._tag = Result<Expression, ModelError>::Ok, ._Ok = Expression { ._tag = Expression::Constant, ._Constant = constant_result._Ok} }
        }
        case ExpressionSyntax::Type: {
            auto type = expression._Type
            auto _type_result = handle_type(rp, ep, type, file)
            if (_type_result._tag == Result<Type, ModelError>::Error)
                return Result<Expression, ModelError> { ._tag = Result<Expression, ModelError>::Error, ._Error = _type_result._Error }
            return Result<Expression, ModelError> { ._tag = Result<Expression, ModelError>::Ok, ._Ok = Expression { ._tag = Expression::Type, ._Type = *_type_result._Ok} }
        }
        case ExpressionSyntax::Object: {
            auto object = expression._Object
            auto object_result = handle_object(rp, ep, object, file)
            if (object_result._tag == Result<Expression, ModelError>::Error)
                return Result<Expression, ModelError> { ._tag = Result<Expression, ModelError>::Error, ._Error = object_result._Error }
            return Result<Expression, ModelError> { ._tag = Result<Expression, ModelError>::Ok, ._Ok = Expression { ._tag = Expression::Tuple, ._Tuple = object_result._Ok} }
        }
        case ExpressionSyntax::Vector: {
            auto vector = expression._Vector
            auto vector_result = handle_vector(rp, ep, vector, file)
            if (vector_result._tag == Result<Expression, ModelError>::Error)
                return Result<Expression, ModelError> { ._tag = Result<Expression, ModelError>::Error, ._Error = vector_result._Error }
            return Result<Expression, ModelError> { ._tag = Result<Expression, ModelError>::Ok, ._Ok = Expression { ._tag = Expression::Matrix, ._Matrix = vector_result._Ok} }
        }
        case ExpressionSyntax::Block: {
            auto block = expression._Block
            auto block_result = handle_block(rp, ep, block, file)
            if (block_result._tag == Result<Expression, ModelError>::Error)
                return Result<Expression, ModelError> { ._tag = Result<Expression, ModelError>::Error, ._Error = block_result._Error }
            return Result<Expression, ModelError> { ._tag = Result<Expression, ModelError>::Ok, ._Ok = Expression { ._tag = Expression::Block, ._Block = block_result._Ok} }
        }
        case ExpressionSyntax::If: {
            auto if_ = expression._If
            auto if_result = handle_if(rp, ep, if_, file)
            if (if_result._tag == Result<Expression, ModelError>::Error)
                return Result<Expression, ModelError> { ._tag = Result<Expression, ModelError>::Error, ._Error = if_result._Error }
            return Result<Expression, ModelError> { ._tag = Result<Expression, ModelError>::Ok, ._Ok = Expression { ._tag = Expression::If, ._If = if_result._Ok} }
        }
        case ExpressionSyntax::Match: {
            auto match_ = expression._Match
            auto match_result = handle_match(rp, ep, match_, file)
            if (match_result._tag == Result<Expression, ModelError>::Error)
                return Result<Expression, ModelError> { ._tag = Result<Expression, ModelError>::Error, ._Error = match_result._Error }
            return Result<Expression, ModelError> { ._tag = Result<Expression, ModelError>::Ok, ._Ok = Expression { ._tag = Expression::Match, ._Match = match_result._Ok} }
        }
        case ExpressionSyntax::Lambda:
            return Result<Expression, ModelError> { ._tag = Result<Expression, ModelError>::Error, ._Error = ModelError(ModelBuilderError(NotImplemented(file, String(_ep, "Lambda"), Span(expression._Lambda.start, expression._Lambda.end)))) }
        case ExpressionSyntax::For: {
            auto for_ = expression._For
            auto for_result = handle_for(rp, ep, for_, file)
            if (for_result._tag == Result<Expression, ModelError>::Error)
                return Result<Expression, ModelError> { ._tag = Result<Expression, ModelError>::Error, ._Error = for_result._Error }
            return Result<Expression, ModelError> { ._tag = Result<Expression, ModelError>::Ok, ._Ok = Expression { ._tag = Expression::For, ._For = for_result._Ok} }
        }
        case ExpressionSyntax::While: {
            auto while_syntax = expression._While
            auto _while_result = handle_while(rp, ep, while_syntax, file)
            if (_while_result._tag == Result<Expression, ModelError>::Error)
                return Result<Expression, ModelError> { ._tag = Result<Expression, ModelError>::Error, ._Error = _while_result._Error }
            auto while_ = _while_result._Ok
            return Result<Expression, ModelError> { ._tag = Result<Expression, ModelError>::Ok, ._Ok = Expression { ._tag = Expression::While, ._While = while_} }
        }
        case ExpressionSyntax::Choose: {
            auto choose_ = expression._Choose
            auto choose_result = handle_choose(rp, ep, choose_, file)
            if (choose_result._tag == Result<Expression, ModelError>::Error)
                return Result<Expression, ModelError> { ._tag = Result<Expression, ModelError>::Error, ._Error = choose_result._Error }
            return Result<Expression, ModelError> { ._tag = Result<Expression, ModelError>::Ok, ._Ok = Expression { ._tag = Expression::Choose, ._Choose = choose_result._Ok} }
        }
        case ExpressionSyntax::Try: {
            auto try_syntax = expression._Try
            auto _try_result = handle_try(rp, ep, try_syntax, file)
            if (_try_result._tag == Result<Expression, ModelError>::Error)
                return Result<Expression, ModelError> { ._tag = Result<Expression, ModelError>::Error, ._Error = _try_result._Error }
            auto try_ = _try_result._Ok
            return Result<Expression, ModelError> { ._tag = Result<Expression, ModelError>::Ok, ._Ok = Expression { ._tag = Expression::Try, ._Try = try_} }
        }
        case ExpressionSyntax::Repeat:
            return Result<Expression, ModelError> { ._tag = Result<Expression, ModelError>::Error, ._Error = ModelError(ModelBuilderError(NotImplemented(file, String(_ep, "Repeat"), Span(expression._Repeat.start, expression._Repeat.end)))) }
        case ExpressionSyntax::SizeOf: {
            auto size_of = expression._SizeOf
            auto size_of_result = handle_size_of(rp, ep, size_of, file)
            if (size_of_result._tag == Result<Expression, ModelError>::Error)
                return Result<Expression, ModelError> { ._tag = Result<Expression, ModelError>::Error, ._Error = size_of_result._Error }
            return Result<Expression, ModelError> { ._tag = Result<Expression, ModelError>::Ok, ._Ok = Expression { ._tag = Expression::SizeOf, ._SizeOf = size_of_result._Ok} }
        }
    }
}

*;

function handle_operand(operand: ref[OperandSyntax], file: String) returns Operand throws ModelError {
    var r Region()
    var member_access: pointer[Vector[String]] null
    if operand.members <> null
    {
        var path: ref[List[String]] *List[String]$()
        for member in (*operand.members)
        {
            path.add(String(rp, member.name.name))
            if member.name.extensions <> null
            {
                for extension in (*member.name.extensions)
                {
                    path.add(extension.name)
                }
            }
        }
        set member_access: Vector[String]#(rp, path)
    }

    try let expression handle_expression(rp, ep, operand.expression, file)
        else throw

    return Operand(Span(operand.start, operand.end), expression, member_access)
}

function handle_operands(operands: pointer[Vector[OperandSyntax]], file: String) returns Vector[Operand] throws ModelError {
    var r Region()
    var operands_builder: ref[List[Operand]] *List[Operand]$()
    if operands <> null
    {
        for operand_syntax in (*operands)
        {
            try let operand handle_operand(rp, ep, operand_syntax, file)
                else throw
            operands_builder.add(operand)
        }
    }
    return Vector[Operand](rp, operands_builder)
}

;*

Result<Vector<Operand>, ModelError> handle_operation(OperationSyntax& operation, file: String) {
    if (operation.operands <> null) {
        auto operands_result = handle_operands(rp, ep, operation.operands, file)
        if (operands_result._tag == Result<Vector<Operand>, ModelError>::Error)
            return Result<Vector<Operand>, ModelError> { ._tag = Result<Vector<Operand>, ModelError>::Error, ._Error = operands_result._Error }
        return Result<Vector<Operand>, ModelError> { ._tag = Result<Vector<Operand>, ModelError>::Ok, ._Ok = operands_result._Ok }
    }
    return Result<Vector<Operand>, ModelError> { ._tag = Result<Vector<Operand>, ModelError>::Ok, ._Ok = Vector<Operand>(_rp, 0) }
}

Result<GenericParameter, ModelError> handle_generic_parameter(GenericParameterSyntax& generic_parameter, file: String) {
    var r Region()
    List<Attribute>& attributes = *new(alignof(List<Attribute>), _r.get_page()) List<Attribute>()
    if (generic_parameter.attributes <> null) {
        auto definition_attributes = generic_parameter.attributes
        auto _attribute_iterator = definition_attributes->get_iterator()
        while (auto _attribute_syntax = _attribute_iterator.next()) {
            auto attribute_syntax = *_attribute_syntax
            auto _attribute_result = handle_attribute(rp, ep, attribute_syntax, file)
            if (_attribute_result._tag == Result<Attribute, ModelError>::Error)
                return Result<GenericParameter, ModelError> { ._tag = Result<GenericParameter, ModelError>::Error, ._Error = _attribute_result._Error }
            auto attribute = _attribute_result._Ok
            attributes.add(attribute)
        }
    }
    return Result<GenericParameter, ModelError> { ._tag = Result<GenericParameter, ModelError>::Ok, ._Ok = GenericParameter(Span(generic_parameter.start, generic_parameter.end), String(_rp, generic_parameter.name), Vector<Attribute>(_rp, attributes)) }
}

Result<Use, ModelError> handle_use(UseSyntax& use_) {
    var r Region()
    List<String>& path = *new(alignof(List<String>), _r.get_page()) List<String>()
    path.add(String(_rp, use_.name.name))
    if (use_.name.extensions <> null) {
        auto extensions = use_.name.extensions
        auto _extensions_iterator = extensions->get_iterator()
        while (auto _extension = _extensions_iterator.next()) {
            auto extension = *_extension
            path.add(extension.name)
        }
    }

    return Result<Use, ModelError> { ._tag = Result<Use, ModelError>::Ok, ._Ok = Use(Span(use_.start, use_.end), Vector<String>(_rp, path)) }
}

Result<Concept, ModelError> handle_definition(String path, DefinitionSyntax& definition, bool private_, file: String) {
    var r Region()
    auto concept = definition.concept_
    Span span(definition.start, definition.end)

    List<GenericParameter>& parameters = *new(alignof(List<GenericParameter>), _r.get_page()) List<GenericParameter>()
    if (definition.parameters <> null) {
        auto generic_parameters = *definition.parameters
        if (generic_parameters.parameters <> null) {    
            auto _parameters_iterator = generic_parameters.parameters->get_iterator()
            while (auto _generic_parameter = _parameters_iterator.next()) {
                auto generic_parameter = *_generic_parameter
                auto _parameter_result = handle_generic_parameter(rp, ep, generic_parameter, file)
                if (_parameter_result._tag == Result<GenericParameter, ModelError>::Error)
                    return Result<Concept, ModelError> { ._tag = Result<Concept, ModelError>::Error, ._Error = _parameter_result._Error }
                auto parameter = _parameter_result._Ok
                parameters.add(parameter)

            }
        }
    }

    List<Attribute>& attributes = *new(alignof(List<Attribute>), _r.get_page()) List<Attribute>()
    if (definition.attributes <> null) {
        auto definition_attributes = definition.attributes
        auto _attribute_iterator = definition_attributes->get_iterator()
        while (auto _attribute_syntax = _attribute_iterator.next()) {
            auto attribute_syntax = *_attribute_syntax
            auto _attribute_result = handle_attribute(rp, ep, attribute_syntax, file)
            if (_attribute_result._tag == Result<Attribute, ModelError>::Error)
                return Result<Concept, ModelError> { ._tag = Result<Concept, ModelError>::Error, ._Error = _attribute_result._Error }
            auto attribute = _attribute_result._Ok
            attributes.add(attribute)
        }
    }

    switch (concept._tag)
    {
        case ConceptSyntax::Class: {
            auto class_ = concept._Class
            auto structure_result = handle_class(rp, ep, definition.name, path, class_, private_, file)
            if (structure_result._tag == Result<Structure, ModelError>::Error)
                return Result<Concept, ModelError> { ._tag = Result<Concept, ModelError>::Error, ._Error = structure_result._Error }
            auto structure = structure_result._Ok
            return Result<Concept, ModelError> { ._tag = Result<Concept, ModelError>::Ok, ._Ok = 
                Concept(span, String(_rp, definition.name), Vector<GenericParameter>(_rp, parameters), Vector<Attribute>(_rp, attributes),
                    Definition { ._tag = Definition::Structure, ._Structure = structure }
                )}
        }
        case ConceptSyntax::Namespace: {
            auto namespace_syntax = concept._Namespace
            auto _namespace_result = handle_namespace(rp, ep, definition.name, Path::join(_rp, path, definition.name), namespace_syntax, private_, file)
            if (_namespace_result._tag == Result<Namespace, ModelError>::Error)
                return Result<Concept, ModelError> { ._tag = Result<Concept, ModelError>::Error, ._Error = _namespace_result._Error }
            auto namespace_ = _namespace_result._Ok
            return Result<Concept, ModelError> { ._tag = Result<Concept, ModelError>::Ok, ._Ok = 
                Concept(span, String(_rp, definition.name), Vector<GenericParameter>(_rp, parameters), Vector<Attribute>(_rp, attributes),
                    Definition { ._tag = Definition::Namespace, ._Namespace = namespace_ }
                )}
        }
        case ConceptSyntax::Union: {
            auto union_syntax = concept._Union
            auto _union__result = handle_union(rp, ep, definition.name, path, union_syntax, private_, file)
            if (_union__result._tag == Result<Structure, ModelError>::Error)
                return Result<Concept, ModelError> { ._tag = Result<Concept, ModelError>::Error, ._Error = _union__result._Error }
            auto union_ = _union__result._Ok
            return Result<Concept, ModelError> { ._tag = Result<Concept, ModelError>::Ok, ._Ok = 
                Concept(span, String(_rp, definition.name), Vector<GenericParameter>(_rp, parameters), Vector<Attribute>(_rp, attributes),
                    Definition { ._tag = Definition::Union, ._Union = union_ }
                )}
        }
        case ConceptSyntax::Constant: {
            auto constant = concept._Constant
            auto operation_result = handle_operands(rp, ep, constant.operation, file)
            if (operation_result._tag == Result<Vector<Operand>, ModelError>::Error)
                return Result<Concept, ModelError> { ._tag = Result<Concept, ModelError>::Error, ._Error = operation_result._Error }
            auto _type_result = handle_type(rp, ep, constant.type, file)
            if (_type_result._tag == Result<Type, ModelError>::Error)
                return Result<Concept, ModelError> { ._tag = Result<Concept, ModelError>::Error, ._Error = _type_result._Error }
            auto type = _type_result._Ok
            auto operation = operation_result._Ok
            return Result<Concept, ModelError> { ._tag = Result<Concept, ModelError>::Ok, ._Ok = 
                Concept(span, String(_rp, definition.name), Vector<GenericParameter>(_rp, parameters), Vector<Attribute>(_rp, attributes),
                    Definition { ._tag = Definition::Global, ._Global = Global(span, *type, operation) }
                )}
        }
        case ConceptSyntax::Delegate:
            return Result<Concept, ModelError> { ._tag = Result<Concept, ModelError>::Error, ._Error = ModelError(ModelBuilderError(NotImplemented(file, String(_ep, "Delegate"), Span(concept._Delegate.start, concept._Delegate.end)))) }
        case ConceptSyntax::Intrinsic:
            return Result<Concept, ModelError> { ._tag = Result<Concept, ModelError>::Ok, ._Ok = 
                Concept(span, String(_rp, definition.name), Vector<GenericParameter>(_rp, parameters), Vector<Attribute>(_rp, attributes),
                    Definition { ._tag = Definition::Intrinsic }
                )}
    }
}

Result<Action, ModelError> handle_action(ActionSyntax& action, file: String) {
    switch (action._tag) {
        case ActionSyntax::Operation: {
            auto operation_result = handle_operation(rp, ep, action._Operation, file)
            if (operation_result._tag == Result<Vector<Operand>, ModelError>::Error)
                return Result<Action, ModelError> { ._tag = Result<Action, ModelError>::Error, ._Error = operation_result._Error }
            return Result<Action, ModelError> { ._tag = Result<Action, ModelError>::Ok, ._Ok = Action(operation_result._Ok, Vector<Operand>()) }
        }
        case ActionSyntax::Set: {
            auto _target_result = handle_operands(rp, ep, action._Set.target, file)
            if (_target_result._tag == Result<Vector<Operand>, ModelError>::Error)
                return Result<Action, ModelError> { ._tag = Result<Action, ModelError>::Error, ._Error = _target_result._Error }
            auto target = _target_result._Ok
            auto _source_result = handle_operands(rp, ep, action._Set.source, file)
            if (_source_result._tag == Result<Vector<Operand>, ModelError>::Error)
                return Result<Action, ModelError> { ._tag = Result<Action, ModelError>::Error, ._Error = _source_result._Error }
            auto source = _source_result._Ok
            return Result<Action, ModelError> { ._tag = Result<Action, ModelError>::Ok, ._Ok = Action(source, target) }
        }
    }
}

Result<Function, ModelError> build_function(size_t start, size_t end, TargetSyntax targetSyntax, bool private_, bool pure, file: String) {
    Vector<Item> input = Vector<Item>(_rp, 0)
    Vector<Item> output = Vector<Item>(_rp, 0)
    switch (targetSyntax._tag) {
        case TargetSyntax::Routine:
            return Result<Function, ModelError> { ._tag = Result<Function, ModelError>::Error, ._Error = ModelError(ModelBuilderError(NotImplemented(file, String(_ep, "Non-Symbol Function"), Span(start, end)))) }
        case TargetSyntax::Named:
            auto named = targetSyntax._Named

            if (named.routine.parameters <> null) {
                ParameterSetSyntax& parameterSetSyntax = *named.routine.parameters
                auto _input_result = handle_parameterset(rp, ep, parameterSetSyntax, file)
                if (_input_result._tag == Result<Vector<Item>, ModelError>::Error)
                    return Result<Function, ModelError> { ._tag = Result<Function, ModelError>::Error, ._Error = _input_result._Error }
                input = _input_result._Ok
            }

            Type* returns_ null
            if (named.routine.returns_ <> null) {
                auto _type_result = handle_type(rp, ep, named.routine.returns_->type, file)
                if (_type_result._tag == Result<Type, ModelError>::Error)
                    return Result<Function, ModelError> { ._tag = Result<Function, ModelError>::Error, ._Error = _type_result._Error }
                returns_ = _type_result._Ok
            }

            Type* throws_ null
            if (named.routine.throws_ <> null) {
                auto _type_result = handle_type(rp, ep, named.routine.throws_->type, file)
                if (_type_result._tag == Result<Type, ModelError>::Error)
                    return Result<Function, ModelError> { ._tag = Result<Function, ModelError>::Error, ._Error = _type_result._Error }
                throws_ = _type_result._Ok
            }

            auto lifetime = Lifetime(Unspecified())
            if (named.routine.lifetime <> null) {
                switch (named.routine.lifetime->_tag) {
                    case LifetimeSyntax::Call:
                        lifetime = Lifetime(Call())
                    break
                    case LifetimeSyntax::Local:
                        lifetime = Lifetime(Local())
                    break
                    case LifetimeSyntax::Reference:
                        lifetime = Lifetime(Reference(String(_rp, named.routine.lifetime->_Reference.location)))
                    break
                    case LifetimeSyntax::Thrown:
                        lifetime = Lifetime(Thrown())
                    break    
                }
            }

            switch (named.routine.implementation._tag) {
                case ImplementationSyntax::Action: {
                    auto action_result = handle_action(rp, ep, named.routine.implementation._Action, file)
                    if (action_result._tag == Result<Statement, ModelError>::Error)
                        return Result<Function, ModelError> { ._tag = Result<Function, ModelError>::Error, ._Error = action_result._Error }
                    return Result<Function, ModelError> { ._tag = Result<Function, ModelError>::Ok, ._Ok = Function(Span(start, end), private_, pure, String(_rp, named.name), input, returns_, throws_, lifetime, Implementation { ._tag = Implementation::Action, ._Action = action_result._Ok }) }
                }
                case ImplementationSyntax::Extern:
                    return Result<Function, ModelError> { ._tag = Result<Function, ModelError>::Ok, ._Ok = Function(Span(start, end), private_, pure, String(_rp, named.name), input, returns_, nullptr, lifetime, Implementation { ._tag = Implementation::Extern, ._Extern = Extern() }) }
                case ImplementationSyntax::Instruction:
                    return Result<Function, ModelError> { ._tag = Result<Function, ModelError>::Ok, ._Ok = Function(Span(start, end), private_, pure, String(_rp, named.name), input, returns_, nullptr, lifetime, Implementation { ._tag = Implementation::Instruction, ._Instruction = Instruction() }) }
                case ImplementationSyntax::Intrinsic:
                    return Result<Function, ModelError> { ._tag = Result<Function, ModelError>::Ok, ._Ok = Function(Span(start, end), private_, pure, String(_rp, named.end), input, returns_, nullptr, lifetime, Implementation { ._tag = Implementation::Intrinsic, ._Intrinsic = Intrinsic() }) }
                break

            }
    }

}

Result<Initializer, ModelError> handle_initializer(InitSyntax& initializer, bool private_, file: String) {
    Vector<Item> input = Vector<Item>(_rp, 0)

    if (initializer.parameters <> null) {
        ParameterSetSyntax& parameterSetSyntax = *initializer.parameters
        auto parameterset_result = handle_parameterset(rp, ep, parameterSetSyntax, file)
        input = parameterset_result._Ok
    }

    auto action_result = handle_action(rp, ep, initializer.action, file)
    if (action_result._tag == Result<Statement, ModelError>::Error)
        return Result<Initializer, ModelError> { ._tag = Result<Initializer, ModelError>::Error, ._Error = action_result._Error }

    return Result<Initializer, ModelError> { ._tag = Result<Initializer, ModelError>::Ok, ._Ok = Initializer(Span(initializer.start, initializer.end), private_, input, Implementation { ._tag = Implementation::Action, ._Action = action_result._Ok }) }
}

Result<DeInitializer*, ModelError> handle_deinitializer(DeInitSyntax& deinitializer, file: String) {
    auto action_result = handle_action(rp, ep, deinitializer.action, file)
    if (action_result._tag == Result<Statement, ModelError>::Error)
        return Result<DeInitializer*, ModelError> { ._tag = Result<DeInitializer*, ModelError>::Error, ._Error = action_result._Error }

    return Result<DeInitializer*, ModelError> { ._tag = Result<DeInitializer*, ModelError>::Ok, ._Ok = new(alignof(DeInitializer), _rp) DeInitializer(Span(deinitializer.start, deinitializer.end), Implementation { ._tag = Implementation::Action, ._Action = action_result._Ok }) }
}

Result<Operator, ModelError> handle_operator( OperatorSyntax& operator_syntax, bool private_, file: String) {
    Vector<Item> input = Vector<Item>(_rp, 0)
    auto start = operator_syntax.start
    auto end = operator_syntax.end
    Vector<Operand>* operation null
    switch (operator_syntax.target._tag) {
        case TargetSyntax::Routine: {
            auto routine = operator_syntax.target._Routine
            if (routine.generics <> null) {
                if (routine.parameters <> null) {
                    ParameterSetSyntax& parameterSetSyntax = *routine.parameters
                    auto _input_result = handle_parameterset(rp, ep, parameterSetSyntax, file)
                    if (_input_result._tag == Result<Vector<Item>, ModelError>::Error)
                        return Result<Operator, ModelError> { ._tag = Result<Operator, ModelError>::Error, ._Error = _input_result._Error }
                    input = _input_result._Ok
                }

                Type* returns_ null
                if (routine.returns_ <> null) {
                    auto _type_result = handle_type(rp, ep, routine.returns_->type, file)
                    if (_type_result._tag == Result<Type, ModelError>::Error)
                        return Result<Operator, ModelError> { ._tag = Result<Operator, ModelError>::Error, ._Error = _type_result._Error }
                    returns_ = _type_result._Ok
                }

                Type* throws_ null
                if (routine.throws_ <> null) {
                    auto _type_result = handle_type(rp, ep, routine.throws_->type, file)
                    if (_type_result._tag == Result<Type, ModelError>::Error)
                        return Result<Operator, ModelError> { ._tag = Result<Operator, ModelError>::Error, ._Error = _type_result._Error }
                    throws_ = _type_result._Ok
                }

                switch (routine.implementation._tag) {
                    case ImplementationSyntax::Action: {
                        auto action_result = handle_action(rp, ep, routine.implementation._Action, file)
                        if (action_result._tag == Result<Statement, ModelError>::Error)
                            return Result<Operator, ModelError> { ._tag = Result<Operator, ModelError>::Error, ._Error = action_result._Error }
                        return Result<Operator, ModelError> { ._tag = Result<Operator, ModelError>::Ok, ._Ok = Operator(Span(start, end), private_, String(_rp, "[]"), input, returns_, throws_, Implementation { ._tag = Implementation::Action, ._Action = action_result._Ok }) }
                    }
                    case ImplementationSyntax::Extern:
                        return Result<Operator, ModelError> { ._tag = Result<Operator, ModelError>::Ok, ._Ok = Operator(Span(start, end), private_, String(_rp, "[]"), input, returns_, throws_, Implementation { ._tag = Implementation::Extern, ._Extern = Extern() }) }
                    case ImplementationSyntax::Instruction:
                        return Result<Operator, ModelError> { ._tag = Result<Operator, ModelError>::Ok, ._Ok = Operator(Span(start, end), private_, String(_rp, "[]"), input, returns_, throws_, Implementation { ._tag = Implementation::Instruction, ._Instruction = Instruction() }) }
                    case ImplementationSyntax::Intrinsic:
                        return Result<Operator, ModelError> { ._tag = Result<Operator, ModelError>::Ok, ._Ok = Operator(Span(start, end), private_, String(_rp, "[]"), input, returns_, throws_, Implementation { ._tag = Implementation::Intrinsic, ._Intrinsic = Intrinsic() }) }
                }
            }
            return Result<Operator, ModelError> { ._tag = Result<Operator, ModelError>::Error, ._Error = ModelError(ModelBuilderError(NotImplemented(file, String(_ep, "Non-Symbol Operator"), Span(operator_syntax.start, operator_syntax.end)))) }
        }
        case TargetSyntax::Named: {
            auto named = operator_syntax.target._Named
            if (named.routine.parameters <> null) {
                ParameterSetSyntax& parameterSetSyntax = *named.routine.parameters
                auto _input_result = handle_parameterset(rp, ep, parameterSetSyntax, file)
                if (_input_result._tag == Result<Vector<Item>, ModelError>::Error)
                    return Result<Operator, ModelError> { ._tag = Result<Operator, ModelError>::Error, ._Error = _input_result._Error }
                input = _input_result._Ok
            }

            Type* returns_ null
            if (named.routine.returns_ <> null) {
                auto _type_result = handle_type(rp, ep, named.routine.returns_->type, file)
                if (_type_result._tag == Result<Type, ModelError>::Error)
                    return Result<Operator, ModelError> { ._tag = Result<Operator, ModelError>::Error, ._Error = _type_result._Error }
                returns_ = _type_result._Ok
            }

            Type* throws_ null
            if (named.routine.throws_ <> null) {
                auto _type_result = handle_type(rp, ep, named.routine.throws_->type, file)
                if (_type_result._tag == Result<Type, ModelError>::Error)
                    return Result<Operator, ModelError> { ._tag = Result<Operator, ModelError>::Error, ._Error = _type_result._Error }
                throws_ = _type_result._Ok
            }

            switch (named.routine.implementation._tag) {
                case ImplementationSyntax::Action: {
                    auto action_result = handle_action(rp, ep, named.routine.implementation._Action, file)
                    if (action_result._tag == Result<Statement, ModelError>::Error)
                        return Result<Operator, ModelError> { ._tag = Result<Operator, ModelError>::Error, ._Error = action_result._Error }
                    return Result<Operator, ModelError> { ._tag = Result<Operator, ModelError>::Ok, ._Ok = Operator(Span(start, end), private_, String(_rp, named.name), input, returns_, throws_, Implementation { ._tag = Implementation::Action, ._Action = action_result._Ok }) }
                }
                case ImplementationSyntax::Extern:
                    return Result<Operator, ModelError> { ._tag = Result<Operator, ModelError>::Ok, ._Ok = Operator(Span(start, end), private_, String(_rp, named.name), input, returns_, throws_, Implementation { ._tag = Implementation::Extern, ._Extern = Extern() }) }
                case ImplementationSyntax::Instruction:
                    return Result<Operator, ModelError> { ._tag = Result<Operator, ModelError>::Ok, ._Ok = Operator(Span(start, end), private_, String(_rp, named.name), input, returns_, throws_, Implementation { ._tag = Implementation::Instruction, ._Instruction = Instruction() }) }
                case ImplementationSyntax::Intrinsic:
                    return Result<Operator, ModelError> { ._tag = Result<Operator, ModelError>::Ok, ._Ok = Operator(Span(start, end), private_, String(_rp, named.name), input, returns_, throws_, Implementation { ._tag = Implementation::Intrinsic, ._Intrinsic = Intrinsic() }) }
                break
            }
        }
    }
}

Result<Module, ModelError> build_module(String path, String file_name, String name, FileSyntax& file_syntax, bool private_) {
    var r Region()
    List<Use>& uses = *new(alignof(List<Use>), _r.get_page()) List<Use>()
    if (file_syntax.uses <> null) {
        auto use_syntaxes = file_syntax.uses
        auto _uses_iterator = use_syntaxes->get_iterator()
        while (auto _use_ = _uses_iterator.next()) {
            auto use = *_use_
            auto _use_result = handle_use(rp, ep, use)
            if (_use_result._tag == Result<Use, ModelError>::Error)
                return Result<Module, ModelError> { ._tag = Result<Module, ModelError>::Error, ._Error = _use_result._Error }
            auto use_ = _use_result._Ok
            uses.add(use_)
        }
    }

    Array<Member>& members_builder = *new(alignof(Array<Member>), _r.get_page()) Array<Member>()
    HashMapBuilder<String, Nameable>& symbols_builder = *new(alignof(HashMapBuilder<String, Nameable>), _r.get_page()) HashMapBuilder<String, Nameable>()
    MultiMapBuilder<String, Function>& functions_builder = *new(alignof(MultiMapBuilder<String, Function>), _r.get_page()) MultiMapBuilder<String, Function>()
    HashSetBuilder<String>& modules_checker = *new(alignof(HashSetBuilder<String>), _r.get_page()) HashSetBuilder<String>()
    List<Module>& modules = *new(alignof(List<Module>), _r.get_page()) List<Module>()

    if (file_syntax.declarations <> null) {    
        auto declarations_iterator = file_syntax.declarations->get_iterator()
        while (auto declaration = declarations_iterator.next()) {
            switch (declaration->symbol._tag) {
                case SymbolSyntax::Private:{
                    auto export_ = declaration->symbol._Private.export_
                    switch (export_._tag) {
                        case ExportSyntax::Definition: {
                            auto concept_result = handle_definition(rp, ep, path, export_._Definition, true, file_name)
                            if (concept_result._tag == Result<Function, ModelError>::Error)
                                return Result<Module, ModelError> { ._tag = Result<Module, ModelError>::Error, ._Error = concept_result._Error }
                            auto concept = concept_result._Ok
                            if (functions_builder.contains(concept.name))
                                return Result<Module, ModelError> { ._tag = Result<Module, ModelError>::Error, ._Error = ModelError(ModelBuilderError(FunctionSymbolExists(file_name, Span(declaration->symbol._Definition.start, declaration->symbol._Definition.end)))) }

                            if (!symbols_builder.add(concept.name, Nameable { ._tag = Nameable::Concept, ._Concept = concept }))
                                return Result<Module, ModelError> { ._tag = Result<Module, ModelError>::Error,
                                    ._Error = ModelError(ModelBuilderError(DuplicateName(concept.name, Span(export_._Definition.start, export_._Definition.end)))) }
                            members_builder.add(Member { ._tag = Member::Concept, ._Concept = concept })
                        }
                        break
                        case ExportSyntax::Function: {
                            auto function_syntax = export_._Function
                            auto function_result = build_function(rp, ep, function_syntax.start, function_syntax.end, function_syntax.target, true, true, file_name)
                            if (function_result._tag == Result<Function, ModelError>::Error)
                                return Result<Module, ModelError> { ._tag = Result<Module, ModelError>::Error, ._Error = function_result._Error }
                            auto function = function_result._Ok
                            auto symbol_with_function_name = symbols_builder[function.name]
                            if (symbol_with_function_name <> null)
                                return Result<Module, ModelError> { ._tag = Result<Module, ModelError>::Error, ._Error = ModelError(ModelBuilderError(NonFunctionSymbolExists(file_name, Span(declaration->symbol._Function.start, declaration->symbol._Function.end)))) }
                            functions_builder.add(function.name, function)
                            members_builder.add(Member { ._tag = Member::Function, ._Function = function })
                        }
                        break
                        case ExportSyntax::Operator: {
                            auto operator_syntax = export_._Operator
                            auto operator_result = handle_operator(rp, ep, operator_syntax, true, file_name)
                            if (operator_result._tag == Result<Module, ModelError>::Error)
                                return Result<Module, ModelError> { ._tag = Result<Module, ModelError>::Error,
                                    ._Error = operator_result._Error }
                            auto operator_ = operator_result._Ok
                            if (!symbols_builder.add(operator_.name, Nameable { ._tag = Nameable::Operator, ._Operator = operator_ }))
                                return Result<Module, ModelError> { ._tag = Result<Module, ModelError>::Error,
                                    ._Error = ModelError(ModelBuilderError(DuplicateName(file_name, Span(operator_syntax.start, operator_syntax.end)))) }
                            members_builder.add(Member { ._tag = Member::Operator, ._Operator = operator_ })
                        }
                        break
                        case ExportSyntax::Trait:
                            return Result<Module, ModelError> { ._tag = Result<Module, ModelError>::Error, ._Error = ModelError(ModelBuilderError(NotImplemented(file_name, String(_ep, "Private Trait"), Span(declaration->symbol._Trait.start, declaration->symbol._Trait.end)))) }
                        case ExportSyntax::Module: {
                            auto module_syntax = export_._Module
                            auto module_result = handle_module(rp, ep, path, module_syntax, true)
                            if (module_result._tag == Result<Module, ModelError>::Error)
                                return Result<Module, ModelError> { ._tag = Result<Module, ModelError>::Error,
                                    ._Error = module_result._Error }
                            auto module = module_result._Ok
                            if (!modules_checker.add(module.name))
                                return Result<Module, ModelError> { ._tag = Result<Module, ModelError>::Error,
                                    ._Error = ModelError(ModelBuilderError(NonFunctionSymbolExists(file_name, Span(module_syntax.start, module_syntax.end)))) }
                            modules.add(module)
                        }
                        break
                    }
                }
                break
                case SymbolSyntax::Definition: {
                    auto concept_result = handle_definition(rp, ep, path, declaration->symbol._Definition, false, file_name)
                    if (concept_result._tag == Result<Function, ModelError>::Error)
                        return Result<Module, ModelError> { ._tag = Result<Module, ModelError>::Error, ._Error = concept_result._Error }
                    auto concept = concept_result._Ok
                    if (functions_builder.contains(concept.name))
                        return Result<Module, ModelError> { ._tag = Result<Module, ModelError>::Error, ._Error = ModelError(ModelBuilderError(FunctionSymbolExists(file_name, Span(declaration->symbol._Definition.start, declaration->symbol._Definition.end)))) }

                    if (!symbols_builder.add(concept.name, Nameable { ._tag = Nameable::Concept, ._Concept = concept }))
                        return Result<Module, ModelError> { ._tag = Result<Module, ModelError>::Error,
                            ._Error = ModelError(ModelBuilderError(DuplicateName(file_name, Span(declaration->symbol._Definition.start, declaration->symbol._Definition.end)))) }
                    members_builder.add(Member { ._tag = Member::Concept, ._Concept = concept })
                }
                break
                case SymbolSyntax::Function: {
                    auto function_syntax = declaration->symbol._Function
                    auto function_result = build_function(rp, ep, function_syntax.start, function_syntax.end, function_syntax.target, false, true, file_name)
                    if (function_result._tag == Result<Function, ModelError>::Error)
                        return Result<Module, ModelError> { ._tag = Result<Module, ModelError>::Error, ._Error = function_result._Error }
                    auto function = function_result._Ok
                    auto symbol_with_function_name = symbols_builder[function.name]
                    if (symbol_with_function_name <> null)
                        return Result<Module, ModelError> { ._tag = Result<Module, ModelError>::Error, ._Error = ModelError(ModelBuilderError(NonFunctionSymbolExists(file_name, Span(declaration->symbol._Function.start, declaration->symbol._Function.end)))) }
                    functions_builder.add(function.name, function)
                    members_builder.add(Member { ._tag = Member::Function, ._Function = function })
                }
                break
                case SymbolSyntax::Operator: {
                    auto operator_syntax = declaration->symbol._Operator
                    auto operator_result = handle_operator(rp, ep, operator_syntax, false, file_name)
                    if (operator_result._tag == Result<Module, ModelError>::Error)
                        return Result<Module, ModelError> { ._tag = Result<Module, ModelError>::Error,
                            ._Error = operator_result._Error }
                    auto operator_ = operator_result._Ok
                    if (!symbols_builder.add(operator_.name, Nameable { ._tag = Nameable::Operator, ._Operator = operator_ }))
                        return Result<Module, ModelError> { ._tag = Result<Module, ModelError>::Error,
                            ._Error = ModelError(ModelBuilderError(DuplicateName(file_name, Span(operator_syntax.start, operator_syntax.end)))) }
                    members_builder.add(Member { ._tag = Member::Operator, ._Operator = operator_ })
                }
                break
                case SymbolSyntax::Trait:
                    return Result<Module, ModelError> { ._tag = Result<Module, ModelError>::Error, ._Error = ModelError(ModelBuilderError(NotImplemented(file_name, String(_ep, "Trait"), Span(declaration->symbol._Trait.start, declaration->symbol._Trait.end)))) }
                case SymbolSyntax::Macro:
                    return Result<Module, ModelError> { ._tag = Result<Module, ModelError>::Error, ._Error = ModelError(ModelBuilderError(NotImplemented(file_name, String(_ep, "Macro"), Span(declaration->symbol._Macro.start, declaration->symbol._Macro.end)))) }
                case SymbolSyntax::Module: {
                    auto module_syntax = declaration->symbol._Module
                    auto module_result = handle_module(rp, ep, path, module_syntax, false)
                    if (module_result._tag == Result<Module, ModelError>::Error)
                        return Result<Module, ModelError> { ._tag = Result<Module, ModelError>::Error,
                            ._Error = module_result._Error }
                    auto module = module_result._Ok
                        if (!modules_checker.add(module.name))
                        return Result<Module, ModelError> { ._tag = Result<Module, ModelError>::Error,
                            ._Error = ModelError(ModelBuilderError(NonFunctionSymbolExists(file_name, Span(module_syntax.start, module_syntax.end)))) }
                    modules.add(module)
            }
                break
            }
        }
    }

    auto multi_map = MultiMap<String, Function>(_r.get_page(), functions_builder)
    auto multi_map_iterator = multi_map.get_iterator()
    while (auto functions = multi_map_iterator.next()) {
        auto name = (*functions)[0]->name
        symbols_builder.add(String(name), Nameable { ._tag = Nameable::Functions, ._Functions = Vector<Function>(_rp, *functions) })
    }

    Span span(file_syntax.start, file_syntax.end)
    auto ret = Module(private_, String(_rp, file_name), name, Vector<Module>(_rp, modules), Vector<Use>(_rp, uses), Vector<Member>(_rp, members_builder), HashMap<String, Nameable>(_rp, symbols_builder))
    
    return Result<Module, ModelError> { ._tag = Result<Module, ModelError>::Ok,
        ._Ok = ret
    }
}

Result<Module, ModelError> build_referenced_module(String path, String name, bool private_) {
    var r Region()
    StringBuilder& file_name_builder = *new(alignof(StringBuilder), _r.get_page()) StringBuilder(Path::join(_r.get_page(), path, name))
    file_name_builder.append(".scaly")
    auto file_name = file_name_builder.to_string(_r.get_page())
    auto module_text_result = File::read_to_string(_r.get_page(), _ep, file_name)
    if (module_text_result._tag == Result<String, FileError>::Error) {
        return Result<Module, ModelError> { ._tag = Result<Module, ModelError>::Error, ._Error = ModelError(module_text_result._Error) }
    }
    auto module_text = module_text_result._Ok

    Parser& parser = *new(alignof(Parser), _r.get_page()) Parser(module_text)
    auto file_syntax_result = parser.parse_file(_rp, _ep)
    if (file_syntax_result._tag == Result<ModuleSyntax*, ParserError>::Error)
        return Result<Module, ModelError> { ._tag = Result<Module, ModelError>::Error, ._Error = ModelError(ParserModelError(file_name, file_syntax_result._Error)) }
    auto file_syntax = file_syntax_result._Ok
    if (!parser.is_at_end())
        return Result<Module, ModelError> { ._tag = Result<Module, ModelError>::Error, ._Error = ModelError(ParserModelError(file_name, ParserError(InvalidSyntax(parser.lexer.previous_position, parser.lexer.position, String(_ep, "a valid declaration")))))}

    return build_module(rp, ep, path, file_name, name, file_syntax, private_)
}

Result<Module, ModelError> handle_module(String path, ModuleSyntax& module_syntax, bool private_) {
    return build_referenced_module(rp, ep, path, module_syntax.name, private_)
}

Result<Module, ModelError> handle_package(String path, PackageSyntax package_syntax) {
    return build_referenced_module(rp, ep, path, package_syntax.name.name, false)
}

Result<Program, ModelError> build_program(String file_name, String program_name) {
    var r Region()
    auto file_text_result = File::read_to_string(_r.get_page(), _r.get_page(), file_name)
    if (file_text_result._tag == Result<String, FileError>::Error) {
        return Result<Program, ModelError> { ._tag = Result<Program, ModelError>::Error, ._Error = ModelError(file_text_result._Error) }
    }
    auto file_text = file_text_result._Ok
    auto program_result = parse_program(rp, ep, file_text)
    if (program_result._tag == Result<Vector<DeclarationSyntax>*, ParserError>::Error)
        return Result<Program, ModelError> { ._tag = Result<Program, ModelError>::Error, ._Error = ModelError(ParserModelError(file_name, program_result._Error)) }
    auto program_syntax = program_result._Ok

    auto path = Path::get_directory_name(_rp, file_name)
    List<Module>& packages = *new(alignof(List<Module>), _r.get_page()) List<Module>()
    if (program_syntax.file.packages <> null) {
        auto file_packages = program_syntax.file.packages
        auto _package_iterator = file_packages->get_iterator()
        while (auto _package_syntax = _package_iterator.next()) {
            auto package_syntax = *_package_syntax
            auto _package_result = build_referenced_module(rp, ep, path, _package_syntax->name.name, false)
            if (_package_result._tag == Result<Module, ModelError>::Error)
                return Result<Program, ModelError> { ._tag = Result<Program, ModelError>::Error, ._Error = _package_result._Error }
            auto package = _package_result._Ok
            packages.add(package)
        }
    }

    auto module_result = build_module(rp, ep, Path::get_directory_name(_rp, file_name), file_name, program_name, program_syntax.file, false)
    if (module_result._tag == Result<Module, ModelError>::Error)
        return Result<Program, ModelError> { ._tag = Result<Program, ModelError>::Error, ._Error = module_result._Error }
    auto module = module_result._Ok

    Vector<Statement> statements = Vector<Statement>()
    if (program_syntax.statements <> null) {
        auto _statements_result = handle_statements(rp, ep, *program_syntax.statements, file_name)
        if (_statements_result._tag == Result<Vector<Statement>, ModelError>::Error)
            return Result<Program, ModelError> { ._tag = Result<Program, ModelError>::Error, ._Error = _statements_result._Error }
        statements = _statements_result._Ok
    }
    Program program(Vector<Module>(_rp, packages), module, statements)
    return Result<Program, ModelError> { ._tag = Result<Program, ModelError>::Ok, ._Ok = program }
}

*;
}

