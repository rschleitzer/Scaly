use scaly.containers
define IdentifierLiteral(name: String)
define StringLiteral(value: String)
define CharacterLiteral(value: String)
define FragmentLiteral(value: String)
define IntegerLiteral(value: String)
define BooleanLiteral(value: bool)
define FloatingPointLiteral(value: String)
define HexLiteral(value: String)

define Literal union (
    String: StringLiteral
    Character: CharacterLiteral
    Fragment: FragmentLiteral
    Integer: IntegerLiteral
    Boolean: BooleanLiteral
    FloatingPoint: FloatingPointLiteral
    Hex: HexLiteral
)

define ThrownSyntax
(
    start: size_t
    end: size_t
)

define ReferenceSyntax
(
    start: size_t
    end: size_t
    location: String
)

define LocalSyntax
(
    start: size_t
    end: size_t
)

define CallSyntax
(
    start: size_t
    end: size_t
)

define LifetimeSyntax union (
    Call: CallSyntax
    Local: LocalSyntax
    Reference: ReferenceSyntax
    Thrown: ThrownSyntax
)

define ExtensionSyntax
(
    start: size_t
    end: size_t
    name: String
)

define NameSyntax
(
    start: size_t
    end: size_t
    name: String
    extensions: pointer[Vector[ExtensionSyntax]]
)

define TypeSyntax
(
    start: size_t
    end: size_t
    name: NameSyntax
    generics: pointer[GenericArgumentsSyntax]
    optional: pointer[OptionalSyntax]
    lifetime: pointer[LifetimeSyntax]
)

define SizeOfSyntax
(
    start: size_t
    end: size_t
    type: TypeSyntax
)

define SetSyntax
(
    start: size_t
    end: size_t
    target: pointer[Vector[OperandSyntax]]
    source: pointer[Vector[OperandSyntax]]
)

define OperationSyntax
(
    start: size_t
    end: size_t
    operands: pointer[Vector[OperandSyntax]]
)

define ActionSyntax union (
    Operation: OperationSyntax
    Set: SetSyntax
)

define RepeatSyntax
(
    start: size_t
    end: size_t
    name: pointer[LabelSyntax]
    action: ActionSyntax
)

define LabelSyntax
(
    start: size_t
    end: size_t
    name: String
)

define ForSyntax
(
    start: size_t
    end: size_t
    variable: String
    annotation: pointer[TypeAnnotationSyntax]
    operation: pointer[Vector[OperandSyntax]]
    name: pointer[LabelSyntax]
    action: ActionSyntax
)

define LambdaSyntax
(
    start: size_t
    end: size_t
    input: pointer[Vector[OperandSyntax]]
    block: ActionSyntax
)

define ThrowSyntax
(
    start: size_t
    end: size_t
    result: pointer[Vector[OperandSyntax]]
)

define ReturnSyntax
(
    start: size_t
    end: size_t
    result: pointer[Vector[OperandSyntax]]
)

define LoopSyntax
(
    start: size_t
    end: size_t
    name: String
)

define BreakSyntax
(
    start: size_t
    end: size_t
    name: pointer[LoopSyntax]
    result: pointer[Vector[OperandSyntax]]
)

define ContinueSyntax
(
    start: size_t
    end: size_t
    name: pointer[LoopSyntax]
)

define TypeAnnotationSyntax
(
    start: size_t
    end: size_t
    type: TypeSyntax
)

define PropertySyntax
(
    start: size_t
    end: size_t
    name: String
    annotation: TypeAnnotationSyntax
    initializer: pointer[InitializerSyntax]
    attributes: pointer[Vector[AttributeSyntax]]
)

define FieldSyntax
(
    start: size_t
    end: size_t
    property: PropertySyntax
)

define PartSyntax union (
    Field: FieldSyntax
    Property: PropertySyntax
)

define StructureSyntax
(
    start: size_t
    end: size_t
    parts: pointer[Vector[PartSyntax]]
)

define ArraySyntax
(
    start: size_t
    end: size_t
    members: pointer[Vector[TypeSyntax]]
)

define BindingSpecSyntax union (
    Structure: StructureSyntax
    Type: TypeSyntax
    Array: ArraySyntax
)

define BindingAnnotationSyntax
(
    start: size_t
    end: size_t
    spec: BindingSpecSyntax
)

define BindingSyntax
(
    start: size_t
    end: size_t
    name: String
    annotation: pointer[BindingAnnotationSyntax]
    operation: pointer[Vector[OperandSyntax]]
)

define MutableSyntax
(
    start: size_t
    end: size_t
    binding: BindingSyntax
)

define VarSyntax
(
    start: size_t
    end: size_t
    binding: BindingSyntax
)

define LetSyntax
(
    start: size_t
    end: size_t
    binding: BindingSyntax
)

define CommandSyntax union (
    Operation: OperationSyntax
    Let: LetSyntax
    Var: VarSyntax
    Mutable: MutableSyntax
    Set: SetSyntax
    Continue: ContinueSyntax
    Break: BreakSyntax
    Return: ReturnSyntax
    Throw: ThrowSyntax
)

define WhenSyntax
(
    start: size_t
    end: size_t
    name: String
    variant: NameSyntax
    command: CommandSyntax
)

define ConditionSyntax union (
    Operation: OperationSyntax
    Let: LetSyntax
)

define TrySyntax
(
    start: size_t
    end: size_t
    condition: ConditionSyntax
    cases: pointer[Vector[WhenSyntax]]
    dropper: pointer[ElseSyntax]
)

define ChooseSyntax
(
    start: size_t
    end: size_t
    condition: pointer[Vector[OperandSyntax]]
    cases: pointer[Vector[WhenSyntax]]
    alternative: pointer[ElseSyntax]
)

define WhileSyntax
(
    start: size_t
    end: size_t
    condition: ConditionSyntax
    name: pointer[LabelSyntax]
    action: ActionSyntax
)

define StatementSyntax
(
    start: size_t
    end: size_t
    command: CommandSyntax
)

define CaseSyntax
(
    start: size_t
    end: size_t
    condition: pointer[Vector[OperandSyntax]]
)

define BranchSyntax
(
    start: size_t
    end: size_t
    cases: pointer[Vector[CaseSyntax]]
    consequent: StatementSyntax
)

define MatchSyntax
(
    start: size_t
    end: size_t
    scrutinee: pointer[Vector[OperandSyntax]]
    branches: pointer[Vector[BranchSyntax]]
    alternative: pointer[ElseSyntax]
)

define ElseSyntax
(
    start: size_t
    end: size_t
    alternative: CommandSyntax
)

define IfSyntax
(
    start: size_t
    end: size_t
    condition: pointer[Vector[OperandSyntax]]
    consequent: CommandSyntax
    alternative: pointer[ElseSyntax]
)

define BlockSyntax
(
    start: size_t
    end: size_t
    uses: pointer[Vector[UseSyntax]]
    statements: pointer[Vector[StatementSyntax]]
)

define ElementSyntax
(
    start: size_t
    end: size_t
    operation: pointer[Vector[OperandSyntax]]
    attributes: pointer[Vector[AttributeSyntax]]
)

define VectorSyntax
(
    start: size_t
    end: size_t
    elements: pointer[Vector[ElementSyntax]]
    lifetime: pointer[LifetimeSyntax]
)

define ValueSyntax
(
    start: size_t
    end: size_t
    value: pointer[Vector[OperandSyntax]]
    attributes: pointer[Vector[AttributeSyntax]]
)

define ComponentSyntax
(
    start: size_t
    end: size_t
    operands: pointer[Vector[OperandSyntax]]
    attributes: pointer[Vector[AttributeSyntax]]
    value: pointer[ValueSyntax]
)

define ObjectSyntax
(
    start: size_t
    end: size_t
    components: pointer[Vector[ComponentSyntax]]
)

define LiteralSyntax
(
    start: size_t
    end: size_t
    literal: Literal
)

define ExpressionSyntax union (
    Literal: LiteralSyntax
    Type: TypeSyntax
    Object: ObjectSyntax
    Vector: VectorSyntax
    Block: BlockSyntax
    If: IfSyntax
    Match: MatchSyntax
    Lambda: LambdaSyntax
    For: ForSyntax
    While: WhileSyntax
    Choose: ChooseSyntax
    Try: TrySyntax
    Repeat: RepeatSyntax
    SizeOf: SizeOfSyntax
)

define MemberAccessSyntax
(
    start: size_t
    end: size_t
    name: NameSyntax
)

define OperandSyntax
(
    start: size_t
    end: size_t
    expression: ExpressionSyntax
    members: pointer[Vector[MemberAccessSyntax]]
)

define InitializerSyntax
(
    start: size_t
    end: size_t
    operands: pointer[Vector[OperandSyntax]]
)

define PackageSyntax
(
    start: size_t
    end: size_t
    name: NameSyntax
)

define ModuleSyntax
(
    start: size_t
    end: size_t
    name: String
)

define ModelSyntax union (
    Literal: LiteralSyntax
    Name: NameSyntax
    Object: ObjectSyntax
    Vector: VectorSyntax
)

define AttributeSyntax
(
    start: size_t
    end: size_t
    name: String
    model: ModelSyntax
)

define MacroSyntax
(
    start: size_t
    end: size_t
    name: String
    model: ModelSyntax
    rule: pointer[Vector[OperandSyntax]]
)

define ExtendSyntax
(
    start: size_t
    end: size_t
    type: TypeSyntax
)

define ExtendsSyntax
(
    start: size_t
    end: size_t
    extensions: pointer[Vector[ExtendSyntax]]
)

define IntrinsicSyntax
(
    start: size_t
    end: size_t
)

define InstructionSyntax
(
    start: size_t
    end: size_t
)

define ExternSyntax
(
    start: size_t
    end: size_t
)

define ImplementationSyntax union (
    Action: ActionSyntax
    Extern: ExternSyntax
    Instruction: InstructionSyntax
    Intrinsic: IntrinsicSyntax
)

define RoutineSyntax
(
    start: size_t
    end: size_t
    generics: pointer[GenericArgumentsSyntax]
    lifetime: pointer[LifetimeSyntax]
    parameters: pointer[ParameterSetSyntax]
    attributes: pointer[Vector[AttributeSyntax]]
    returns_: pointer[ReturnsSyntax]
    throws_: pointer[ThrowsSyntax]
    implementation: ImplementationSyntax
)

define NamedSyntax
(
    start: size_t
    end: size_t
    name: String
    routine: RoutineSyntax
)

define TargetSyntax union (
    Named: NamedSyntax
    Routine: RoutineSyntax
)

define OperatorSyntax
(
    start: size_t
    end: size_t
    target: TargetSyntax
)

define ProcedureSyntax
(
    start: size_t
    end: size_t
    target: TargetSyntax
)

define FunctionSyntax
(
    start: size_t
    end: size_t
    target: TargetSyntax
)

define DeInitSyntax
(
    start: size_t
    end: size_t
    action: ActionSyntax
)

define InitSyntax
(
    start: size_t
    end: size_t
    parameters: pointer[ParameterSetSyntax]
    action: ActionSyntax
)

define MethodSyntax union (
    Function: FunctionSyntax
    Procedure: ProcedureSyntax
    Operator: OperatorSyntax
)

define TraitSyntax
(
    start: size_t
    end: size_t
    name: NameSyntax
    extension: pointer[ExtendsSyntax]
    attributes: pointer[Vector[AttributeSyntax]]
    uses: pointer[Vector[UseSyntax]]
    functions: pointer[Vector[MethodSyntax]]
)

define ImplementSyntax
(
    start: size_t
    end: size_t
    type: TypeSyntax
    attributes: pointer[Vector[AttributeSyntax]]
    uses: pointer[Vector[UseSyntax]]
    methods: pointer[Vector[MethodSyntax]]
)

define UseSyntax
(
    start: size_t
    end: size_t
    name: NameSyntax
)

define ThrowsSyntax
(
    start: size_t
    end: size_t
    type: TypeSyntax
    attributes: pointer[Vector[AttributeSyntax]]
)

define ReturnsSyntax
(
    start: size_t
    end: size_t
    type: TypeSyntax
    attributes: pointer[Vector[AttributeSyntax]]
)

define ItemSyntax
(
    start: size_t
    end: size_t
    name: String
    annotation: pointer[TypeAnnotationSyntax]
    attributes: pointer[Vector[AttributeSyntax]]
)

define ParametersSyntax
(
    start: size_t
    end: size_t
    items: pointer[Vector[ItemSyntax]]
)

define ParameterSetSyntax union (
    Parameters: ParametersSyntax
    Type: TypeSyntax
)

define OptionalSyntax
(
    start: size_t
    end: size_t
)

define GenericArgumentSyntax
(
    start: size_t
    end: size_t
    type: TypeSyntax
)

define GenericArgumentsSyntax
(
    start: size_t
    end: size_t
    generics: pointer[Vector[GenericArgumentSyntax]]
)

define DelegateSyntax
(
    start: size_t
    end: size_t
    parameters: pointer[ParameterSetSyntax]
    attributes: pointer[Vector[AttributeSyntax]]
    result: pointer[ReturnsSyntax]
    error: pointer[ThrowsSyntax]
)

define ConstantSyntax
(
    start: size_t
    end: size_t
    type: TypeSyntax
    operation: pointer[Vector[OperandSyntax]]
)

define VariantSyntax
(
    start: size_t
    end: size_t
    name: String
    attributes: pointer[Vector[AttributeSyntax]]
    annotation: pointer[TypeAnnotationSyntax]
)

define UnionSyntax
(
    start: size_t
    end: size_t
    variants: pointer[Vector[VariantSyntax]]
)

define NamespaceSyntax
(
    start: size_t
    end: size_t
    uses: pointer[Vector[UseSyntax]]
    declarations: pointer[Vector[DeclarationSyntax]]
)

define BodySyntax
(
    start: size_t
    end: size_t
    uses: pointer[Vector[UseSyntax]]
    inits: pointer[Vector[InitSyntax]]
    deInit: pointer[DeInitSyntax]
    members: pointer[Vector[MemberSyntax]]
)

define ClassSyntax
(
    start: size_t
    end: size_t
    structure: StructureSyntax
    body: pointer[BodySyntax]
)

define ConceptSyntax union (
    Class: ClassSyntax
    Namespace: NamespaceSyntax
    Union: UnionSyntax
    Constant: ConstantSyntax
    Delegate: DelegateSyntax
    Intrinsic: IntrinsicSyntax
)

define GenericParameterSyntax
(
    start: size_t
    end: size_t
    name: String
    attributes: pointer[Vector[AttributeSyntax]]
)

define GenericParametersSyntax
(
    start: size_t
    end: size_t
    parameters: pointer[Vector[GenericParameterSyntax]]
)

define DefinitionSyntax
(
    start: size_t
    end: size_t
    name: String
    parameters: pointer[GenericParametersSyntax]
    attributes: pointer[Vector[AttributeSyntax]]
    concept_: ConceptSyntax
)

define ConstituentSyntax union (
    Definition: DefinitionSyntax
    Function: FunctionSyntax
    Procedure: ProcedureSyntax
    Operator: OperatorSyntax
    Implement: ImplementSyntax
    Trait: TraitSyntax
    Macro: MacroSyntax
    Module: ModuleSyntax
)

define MemberSyntax
(
    start: size_t
    end: size_t
    constituent: ConstituentSyntax
)

define ExportSyntax union (
    Definition: DefinitionSyntax
    Function: FunctionSyntax
    Operator: OperatorSyntax
    Trait: TraitSyntax
    Module: ModuleSyntax
)

define PrivateSyntax
(
    start: size_t
    end: size_t
    export_: ExportSyntax
)

define SymbolSyntax union (
    Private: PrivateSyntax
    Definition: DefinitionSyntax
    Function: FunctionSyntax
    Operator: OperatorSyntax
    Trait: TraitSyntax
    Macro: MacroSyntax
    Module: ModuleSyntax
)

define DeclarationSyntax
(
    start: size_t
    end: size_t
    symbol: SymbolSyntax
)

define FileSyntax
(
    start: size_t
    end: size_t
    packages: pointer[Vector[PackageSyntax]]
    uses: pointer[Vector[UseSyntax]]
    declarations: pointer[Vector[DeclarationSyntax]]
)

define ProgramSyntax
(
    start: size_t
    end: size_t
    file: FileSyntax
    statements: pointer[Vector[StatementSyntax]]
)

define Parser
(
    lexer: Lexer
    keywords_index: Vector[String]
    keywords: HashSet[String]
)
{
    init(text: String) (lexer(Lexer(text))) (keywords_index(initialize_keywords_index())) (keywords(initialize_keywords())) {}

    function initialize_keywords_index(this: Parser) returns Vector[String]$ {
        var r Region()
        var keywords_builder Array[String]$()
        var p Page->get(this)
        (*keywords_builder).add(String(p, "break"))
        (*keywords_builder).add(String(p, "case"))
        (*keywords_builder).add(String(p, "choose"))
        (*keywords_builder).add(String(p, "continue"))
        (*keywords_builder).add(String(p, "define"))
        (*keywords_builder).add(String(p, "deinit"))
        (*keywords_builder).add(String(p, "delegate"))
        (*keywords_builder).add(String(p, "else"))
        (*keywords_builder).add(String(p, "extends"))
        (*keywords_builder).add(String(p, "extern"))
        (*keywords_builder).add(String(p, "for"))
        (*keywords_builder).add(String(p, "function"))
        (*keywords_builder).add(String(p, "if"))
        (*keywords_builder).add(String(p, "init"))
        (*keywords_builder).add(String(p, "implement"))
        (*keywords_builder).add(String(p, "in"))
        (*keywords_builder).add(String(p, "instruction"))
        (*keywords_builder).add(String(p, "intrinsic"))
        (*keywords_builder).add(String(p, "label"))
        (*keywords_builder).add(String(p, "lambda"))
        (*keywords_builder).add(String(p, "let"))
        (*keywords_builder).add(String(p, "loop"))
        (*keywords_builder).add(String(p, "macro"))
        (*keywords_builder).add(String(p, "match"))
        (*keywords_builder).add(String(p, "module"))
        (*keywords_builder).add(String(p, "mutable"))
        (*keywords_builder).add(String(p, "operator"))
        (*keywords_builder).add(String(p, "procedure"))
        (*keywords_builder).add(String(p, "private"))
        (*keywords_builder).add(String(p, "return"))
        (*keywords_builder).add(String(p, "returns"))
        (*keywords_builder).add(String(p, "repeat"))
        (*keywords_builder).add(String(p, "set"))
        (*keywords_builder).add(String(p, "sizeof"))
        (*keywords_builder).add(String(p, "throw"))
        (*keywords_builder).add(String(p, "throws"))
        (*keywords_builder).add(String(p, "trait"))
        (*keywords_builder).add(String(p, "try"))
        (*keywords_builder).add(String(p, "union"))
        (*keywords_builder).add(String(p, "use"))
        (*keywords_builder).add(String(p, "var"))
        (*keywords_builder).add(String(p, "when"))
        (*keywords_builder).add(String(p, "while"))
        (*keywords_builder).add(String(p, "package"))
        return Vector[String](p, *keywords_builder)
    }

    function initialize_keywords(this: Parser) returns HashSet[String]$ {
        var r Region()
        var hash_set_builder HashSetBuilder[String]$(keywords_index)
        return HashSet[String](Page->get(this), *hash_set_builder)
    }

    function parse_literal_token(this: Parser) returns Literal throws ParserError {
        choose lexer.token
            when empty: Token.Empty lexer.advance()
            else {}

        choose lexer.token
            when literal: Token.Literal
            {
                choose literal
                    when string: LiteralToken.String {
                        let ret Literal(StringLiteral(String(rp, string.value)))
                        lexer.empty()
                        return ret
                    }

                    when character: LiteralToken.Character {
                        let ret Literal(CharacterLiteral(String(rp, character.value)))
                        lexer.empty()
                        return ret
                    }

                    when integer: LiteralToken.Integer {
                        let ret Literal(IntegerLiteral(String(rp, integer.value)))
                        lexer.empty()
                        return ret
                    }

                    when fp: LiteralToken.FloatingPoint {
                        let ret Literal(FloatingPointLiteral(String(rp, fp.value)))
                        lexer.empty()
                        return ret
                    }

                    when hex: LiteralToken.Hex {
                        let ret Literal(HexLiteral(String(rp, hex.value)))
                        lexer.empty()
                        return ret
                    }

                    when boolean: LiteralToken.Boolean {
                        let ret Literal(BooleanLiteral(boolean.value))
                        lexer.empty()
                        return ret
                    }

                    when fragment: LiteralToken.Fragment {
                        let ret Literal(FragmentLiteral(String(rp, fragment.value)))
                        lexer.empty()
                        return ret
                    }
            }
            else
                return Result[Literal, ParserError](ParserError(DifferentSyntax()))
    }

    function parse_program(this: Parser) returns ProgramSyntax throws ParserError {
        let start lexer.previous_position

        let file_start lexer.position
        try let file parse_file(rp, ep)
            when d: ParserError.Different throw d
            when i: ParserError.Invalid throw i

        let statements_start lexer.position
        var statements: pointer[Vector[StatementSyntax]] null 
        choose parse_statement_list(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set statements: success

        let end lexer.position

        return ProgramSyntax(start, end, file, statements)
    }

    function parse_file(this: Parser) returns FileSyntax throws ParserError {
        let start lexer.previous_position

        let packages_start lexer.position
        var packages: pointer[Vector[PackageSyntax]] null 
        choose parse_package_list(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set packages: success

        let uses_start lexer.position
        var uses: pointer[Vector[UseSyntax]] null 
        choose parse_use_list(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set uses: success

        let declarations_start lexer.position
        var declarations: pointer[Vector[DeclarationSyntax]] null 
        choose parse_declaration_list(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set declarations: success

        let end lexer.position

        return FileSyntax(start, end, packages, uses, declarations)
    }

    function parse_declaration_list(this: Parser) returns pointer[Vector[DeclarationSyntax]] throws ParserError {
        var r Region()
        var list List[DeclarationSyntax]$()
        while true
        {
            try let node parse_declaration(rp, ep)
                when i: ParserError.Invalid
                    throw i
                when d: ParserError.Different
                {
                    if (*list).head = 0
                    {
                        throw d
                    } else {
                        return Vector[DeclarationSyntax]#(rp, *list)
                    }
                }

            (*list).add(node)
        }
    }

    function parse_declaration(this: Parser) returns DeclarationSyntax throws ParserError {
        let start lexer.previous_position

        let symbol_start lexer.position
        try let symbol parse_symbol(rp, ep)
            when d: ParserError.Different throw d
            when i: ParserError.Invalid throw i

        let start_colon_2 lexer.previous_position
        let success_colon_2 lexer.parse_colon()

        let end lexer.position

        return DeclarationSyntax(start, end, symbol)
    }

    function parse_symbol(this: Parser) returns SymbolSyntax throws ParserError {
        {
            choose parse_private(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return SymbolSyntax(PrivateSyntax(node))
        }
        {
            choose parse_definition(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return SymbolSyntax(DefinitionSyntax(node))
        }
        {
            choose parse_function(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return SymbolSyntax(FunctionSyntax(node))
        }
        {
            choose parse_operator(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return SymbolSyntax(OperatorSyntax(node))
        }
        {
            choose parse_trait(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return SymbolSyntax(TraitSyntax(node))
        }
        {
            choose parse_macro(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return SymbolSyntax(MacroSyntax(node))
        }
        {
            choose parse_module(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return SymbolSyntax(ModuleSyntax(node))
        }
        throw ParserError(DifferentSyntax())
    }

    function parse_private(this: Parser) returns PrivateSyntax throws ParserError {
        let start lexer.previous_position

        let start_private_1 lexer.previous_position
        let success_private_1 lexer.parse_keyword(*keywords_index.get(28))
        if success_private_1 = false
        {
            throw ParserError(DifferentSyntax())
        }

        let export__start lexer.position
        try let export_ parse_export(rp, ep)
            when d: ParserError.Different
                throw InvalidSyntax(export__start, lexer.position, String(ep, "a valid Export syntax"))
            when i: ParserError.Invalid throw i

        let end lexer.position

        return PrivateSyntax(start, end, export_)
    }

    function parse_export(this: Parser) returns ExportSyntax throws ParserError {
        {
            choose parse_definition(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return ExportSyntax(DefinitionSyntax(node))
        }
        {
            choose parse_function(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return ExportSyntax(FunctionSyntax(node))
        }
        {
            choose parse_operator(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return ExportSyntax(OperatorSyntax(node))
        }
        {
            choose parse_trait(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return ExportSyntax(TraitSyntax(node))
        }
        {
            choose parse_module(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return ExportSyntax(ModuleSyntax(node))
        }
        throw ParserError(DifferentSyntax())
    }

    function parse_member_list(this: Parser) returns pointer[Vector[MemberSyntax]] throws ParserError {
        var r Region()
        var list List[MemberSyntax]$()
        while true
        {
            try let node parse_member(rp, ep)
                when i: ParserError.Invalid
                    throw i
                when d: ParserError.Different
                {
                    if (*list).head = 0
                    {
                        throw d
                    } else {
                        return Vector[MemberSyntax]#(rp, *list)
                    }
                }

            (*list).add(node)
        }
    }

    function parse_member(this: Parser) returns MemberSyntax throws ParserError {
        let start lexer.previous_position

        let constituent_start lexer.position
        try let constituent parse_constituent(rp, ep)
            when d: ParserError.Different throw d
            when i: ParserError.Invalid throw i

        let start_colon_2 lexer.previous_position
        let success_colon_2 lexer.parse_colon()

        let end lexer.position

        return MemberSyntax(start, end, constituent)
    }

    function parse_constituent(this: Parser) returns ConstituentSyntax throws ParserError {
        {
            choose parse_definition(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return ConstituentSyntax(DefinitionSyntax(node))
        }
        {
            choose parse_function(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return ConstituentSyntax(FunctionSyntax(node))
        }
        {
            choose parse_procedure(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return ConstituentSyntax(ProcedureSyntax(node))
        }
        {
            choose parse_operator(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return ConstituentSyntax(OperatorSyntax(node))
        }
        {
            choose parse_implement(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return ConstituentSyntax(ImplementSyntax(node))
        }
        {
            choose parse_trait(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return ConstituentSyntax(TraitSyntax(node))
        }
        {
            choose parse_macro(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return ConstituentSyntax(MacroSyntax(node))
        }
        {
            choose parse_module(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return ConstituentSyntax(ModuleSyntax(node))
        }
        throw ParserError(DifferentSyntax())
    }

    function parse_definition(this: Parser) returns DefinitionSyntax throws ParserError {
        let start lexer.previous_position

        let start_define_1 lexer.previous_position
        let success_define_1 lexer.parse_keyword(*keywords_index.get(4))
        if success_define_1 = false
        {
            throw ParserError(DifferentSyntax())
        }

        let start_name lexer.previous_position
        let name lexer.parse_identifier(rp, keywords)
        if name = null
        {
            throw ParserError(InvalidSyntax(start_name, lexer.position, String(ep, "an identifier")))
        }

        let parameters_start lexer.position
        var parameters: pointer[GenericParametersSyntax] null 
        choose parse_genericparameters(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set parameters: GenericParametersSyntax#(success)

        let start_colon_4 lexer.previous_position
        let success_colon_4 lexer.parse_colon()

        let attributes_start lexer.position
        var attributes: pointer[Vector[AttributeSyntax]] null 
        choose parse_attribute_list(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set attributes: success

        let concept__start lexer.position
        try let concept_ parse_concept(rp, ep)
            when d: ParserError.Different
                throw InvalidSyntax(concept__start, lexer.position, String(ep, "a valid Concept syntax"))
            when i: ParserError.Invalid throw i

        let end lexer.position

        return DefinitionSyntax(start, end, *name, parameters, attributes, concept_)
    }

    function parse_genericparameters(this: Parser) returns GenericParametersSyntax throws ParserError {
        let start lexer.previous_position

        let start_left_bracket_1 lexer.previous_position
        let success_left_bracket_1 lexer.parse_punctuation('[')
        if success_left_bracket_1 = false
        {
            throw ParserError(DifferentSyntax())
        }

        let parameters_start lexer.position
        try let parameters parse_genericparameter_list(rp, ep)
            when d: ParserError.Different
                throw InvalidSyntax(parameters_start, lexer.position, String(ep, "a valid GenericParameter syntax"))
            when i: ParserError.Invalid throw i

        let start_right_bracket_3 lexer.previous_position
        let success_right_bracket_3 lexer.parse_punctuation(']')
        if success_right_bracket_3 = false
        {
            throw ParserError(InvalidSyntax(start_right_bracket_3, lexer.position, String(ep, "]")))        }

        let end lexer.position

        return GenericParametersSyntax(start, end, parameters)
    }

    function parse_genericparameter_list(this: Parser) returns pointer[Vector[GenericParameterSyntax]] throws ParserError {
        var r Region()
        var list List[GenericParameterSyntax]$()
        while true
        {
            try let node parse_genericparameter(rp, ep)
                when i: ParserError.Invalid
                    throw i
                when d: ParserError.Different
                {
                    if (*list).head = 0
                    {
                        throw d
                    } else {
                        return Vector[GenericParameterSyntax]#(rp, *list)
                    }
                }

            (*list).add(node)
        }
    }

    function parse_genericparameter(this: Parser) returns GenericParameterSyntax throws ParserError {
        let start lexer.previous_position

        let start_name lexer.previous_position
        let name lexer.parse_identifier(rp, keywords)
        if name = null
        {
            throw ParserError(DifferentSyntax())

        }

        let attributes_start lexer.position
        var attributes: pointer[Vector[AttributeSyntax]] null 
        choose parse_attribute_list(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set attributes: success

        let start_comma_3 lexer.previous_position
        let success_comma_3 lexer.parse_punctuation(',')

        let end lexer.position

        return GenericParameterSyntax(start, end, *name, attributes)
    }

    function parse_concept(this: Parser) returns ConceptSyntax throws ParserError {
        {
            choose parse_class(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return ConceptSyntax(ClassSyntax(node))
        }
        {
            choose parse_namespace(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return ConceptSyntax(NamespaceSyntax(node))
        }
        {
            choose parse_union(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return ConceptSyntax(UnionSyntax(node))
        }
        {
            choose parse_constant(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return ConceptSyntax(ConstantSyntax(node))
        }
        {
            choose parse_delegate(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return ConceptSyntax(DelegateSyntax(node))
        }
        {
            choose parse_intrinsic(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return ConceptSyntax(IntrinsicSyntax(node))
        }
        throw ParserError(DifferentSyntax())
    }

    function parse_class(this: Parser) returns ClassSyntax throws ParserError {
        let start lexer.previous_position

        let structure_start lexer.position
        try let structure parse_structure(rp, ep)
            when d: ParserError.Different throw d
            when i: ParserError.Invalid throw i

        let start_colon_2 lexer.previous_position
        let success_colon_2 lexer.parse_colon()

        let body_start lexer.position
        var body: pointer[BodySyntax] null 
        choose parse_body(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set body: BodySyntax#(success)

        let start_colon_4 lexer.previous_position
        let success_colon_4 lexer.parse_colon()

        let end lexer.position

        return ClassSyntax(start, end, structure, body)
    }

    function parse_body(this: Parser) returns BodySyntax throws ParserError {
        let start lexer.previous_position

        let start_left_curly_1 lexer.previous_position
        let success_left_curly_1 lexer.parse_punctuation('{')
        if success_left_curly_1 = false
        {
            throw ParserError(DifferentSyntax())
        }

        let uses_start lexer.position
        var uses: pointer[Vector[UseSyntax]] null 
        choose parse_use_list(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set uses: success

        let inits_start lexer.position
        var inits: pointer[Vector[InitSyntax]] null 
        choose parse_init_list(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set inits: success

        let deInit_start lexer.position
        var deInit: pointer[DeInitSyntax] null 
        choose parse_deinit(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set deInit: DeInitSyntax#(success)

        let members_start lexer.position
        var members: pointer[Vector[MemberSyntax]] null 
        choose parse_member_list(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set members: success

        let start_right_curly_6 lexer.previous_position
        let success_right_curly_6 lexer.parse_punctuation('}')
        if success_right_curly_6 = false
        {
            throw ParserError(InvalidSyntax(start_right_curly_6, lexer.position, String(ep, "}")))        }

        let start_colon_7 lexer.previous_position
        let success_colon_7 lexer.parse_colon()

        let end lexer.position

        return BodySyntax(start, end, uses, inits, deInit, members)
    }

    function parse_namespace(this: Parser) returns NamespaceSyntax throws ParserError {
        let start lexer.previous_position

        let start_left_curly_1 lexer.previous_position
        let success_left_curly_1 lexer.parse_punctuation('{')
        if success_left_curly_1 = false
        {
            throw ParserError(DifferentSyntax())
        }

        let uses_start lexer.position
        var uses: pointer[Vector[UseSyntax]] null 
        choose parse_use_list(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set uses: success

        let declarations_start lexer.position
        var declarations: pointer[Vector[DeclarationSyntax]] null 
        choose parse_declaration_list(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set declarations: success

        let start_right_curly_4 lexer.previous_position
        let success_right_curly_4 lexer.parse_punctuation('}')
        if success_right_curly_4 = false
        {
            throw ParserError(InvalidSyntax(start_right_curly_4, lexer.position, String(ep, "}")))        }

        let start_colon_5 lexer.previous_position
        let success_colon_5 lexer.parse_colon()

        let end lexer.position

        return NamespaceSyntax(start, end, uses, declarations)
    }

    function parse_union(this: Parser) returns UnionSyntax throws ParserError {
        let start lexer.previous_position

        let start_union_1 lexer.previous_position
        let success_union_1 lexer.parse_keyword(*keywords_index.get(38))
        if success_union_1 = false
        {
            throw ParserError(DifferentSyntax())
        }

        let start_colon_2 lexer.previous_position
        let success_colon_2 lexer.parse_colon()

        let start_left_paren_3 lexer.previous_position
        let success_left_paren_3 lexer.parse_punctuation('(')
        if success_left_paren_3 = false
        {
            throw ParserError(InvalidSyntax(start_left_paren_3, lexer.position, String(ep, "(")))        }

        let variants_start lexer.position
        try let variants parse_variant_list(rp, ep)
            when d: ParserError.Different
                throw InvalidSyntax(variants_start, lexer.position, String(ep, "a valid Variant syntax"))
            when i: ParserError.Invalid throw i

        let start_right_paren_5 lexer.previous_position
        let success_right_paren_5 lexer.parse_punctuation(')')
        if success_right_paren_5 = false
        {
            throw ParserError(InvalidSyntax(start_right_paren_5, lexer.position, String(ep, ")")))        }

        let start_colon_6 lexer.previous_position
        let success_colon_6 lexer.parse_colon()

        let end lexer.position

        return UnionSyntax(start, end, variants)
    }

    function parse_variant_list(this: Parser) returns pointer[Vector[VariantSyntax]] throws ParserError {
        var r Region()
        var list List[VariantSyntax]$()
        while true
        {
            try let node parse_variant(rp, ep)
                when i: ParserError.Invalid
                    throw i
                when d: ParserError.Different
                {
                    if (*list).head = 0
                    {
                        throw d
                    } else {
                        return Vector[VariantSyntax]#(rp, *list)
                    }
                }

            (*list).add(node)
        }
    }

    function parse_variant(this: Parser) returns VariantSyntax throws ParserError {
        let start lexer.previous_position

        let start_name lexer.previous_position
        let name lexer.parse_identifier(rp, keywords)
        if name = null
        {
            throw ParserError(DifferentSyntax())

        }

        let attributes_start lexer.position
        var attributes: pointer[Vector[AttributeSyntax]] null 
        choose parse_attribute_list(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set attributes: success

        let annotation_start lexer.position
        var annotation: pointer[TypeAnnotationSyntax] null 
        choose parse_typeannotation(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set annotation: TypeAnnotationSyntax#(success)

        let start_comma_4 lexer.previous_position
        let success_comma_4 lexer.parse_punctuation(',')

        let start_colon_5 lexer.previous_position
        let success_colon_5 lexer.parse_colon()

        let end lexer.position

        return VariantSyntax(start, end, *name, attributes, annotation)
    }

    function parse_constant(this: Parser) returns ConstantSyntax throws ParserError {
        let start lexer.previous_position

        let type_start lexer.position
        try let type parse_type(rp, ep)
            when d: ParserError.Different throw d
            when i: ParserError.Invalid throw i

        let operation_start lexer.position
        try let operation parse_operand_list(rp, ep)
            when d: ParserError.Different
                throw InvalidSyntax(operation_start, lexer.position, String(ep, "a valid Operand syntax"))
            when i: ParserError.Invalid throw i

        let start_colon_3 lexer.previous_position
        let success_colon_3 lexer.parse_colon()

        let end lexer.position

        return ConstantSyntax(start, end, type, operation)
    }

    function parse_delegate(this: Parser) returns DelegateSyntax throws ParserError {
        let start lexer.previous_position

        let start_delegate_1 lexer.previous_position
        let success_delegate_1 lexer.parse_keyword(*keywords_index.get(6))
        if success_delegate_1 = false
        {
            throw ParserError(DifferentSyntax())
        }

        let parameters_start lexer.position
        var parameters: pointer[ParameterSetSyntax] null 
        choose parse_parameterset(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set parameters: ParameterSetSyntax#(success)

        let attributes_start lexer.position
        var attributes: pointer[Vector[AttributeSyntax]] null 
        choose parse_attribute_list(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set attributes: success

        let result_start lexer.position
        var result: pointer[ReturnsSyntax] null 
        choose parse_returns(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set result: ReturnsSyntax#(success)

        let error_start lexer.position
        var error: pointer[ThrowsSyntax] null 
        choose parse_throws(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set error: ThrowsSyntax#(success)

        let end lexer.position

        return DelegateSyntax(start, end, parameters, attributes, result, error)
    }

    function parse_genericarguments(this: Parser) returns GenericArgumentsSyntax throws ParserError {
        let start lexer.previous_position

        let start_left_bracket_1 lexer.previous_position
        let success_left_bracket_1 lexer.parse_punctuation('[')
        if success_left_bracket_1 = false
        {
            throw ParserError(DifferentSyntax())
        }

        let generics_start lexer.position
        var generics: pointer[Vector[GenericArgumentSyntax]] null 
        choose parse_genericargument_list(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set generics: success

        let start_right_bracket_3 lexer.previous_position
        let success_right_bracket_3 lexer.parse_punctuation(']')
        if success_right_bracket_3 = false
        {
            throw ParserError(InvalidSyntax(start_right_bracket_3, lexer.position, String(ep, "]")))        }

        let end lexer.position

        return GenericArgumentsSyntax(start, end, generics)
    }

    function parse_genericargument_list(this: Parser) returns pointer[Vector[GenericArgumentSyntax]] throws ParserError {
        var r Region()
        var list List[GenericArgumentSyntax]$()
        while true
        {
            try let node parse_genericargument(rp, ep)
                when i: ParserError.Invalid
                    throw i
                when d: ParserError.Different
                {
                    if (*list).head = 0
                    {
                        throw d
                    } else {
                        return Vector[GenericArgumentSyntax]#(rp, *list)
                    }
                }

            (*list).add(node)
        }
    }

    function parse_genericargument(this: Parser) returns GenericArgumentSyntax throws ParserError {
        let start lexer.previous_position

        let type_start lexer.position
        try let type parse_type(rp, ep)
            when d: ParserError.Different throw d
            when i: ParserError.Invalid throw i

        let start_comma_2 lexer.previous_position
        let success_comma_2 lexer.parse_punctuation(',')

        let end lexer.position

        return GenericArgumentSyntax(start, end, type)
    }

    function parse_optional(this: Parser) returns OptionalSyntax throws ParserError {
        let start lexer.previous_position

        let start_question_1 lexer.previous_position
        let success_question_1 lexer.parse_punctuation('?')
        if success_question_1 = false
        {
            throw ParserError(DifferentSyntax())
        }

        let end lexer.position

        return OptionalSyntax(start, end)
    }

    function parse_parameterset(this: Parser) returns ParameterSetSyntax throws ParserError {
        {
            choose parse_parameters(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return ParameterSetSyntax(ParametersSyntax(node))
        }
        {
            choose parse_type(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return ParameterSetSyntax(TypeSyntax(node))
        }
        throw ParserError(DifferentSyntax())
    }

    function parse_parameters(this: Parser) returns ParametersSyntax throws ParserError {
        let start lexer.previous_position

        let start_left_paren_1 lexer.previous_position
        let success_left_paren_1 lexer.parse_punctuation('(')
        if success_left_paren_1 = false
        {
            throw ParserError(DifferentSyntax())
        }

        let items_start lexer.position
        var items: pointer[Vector[ItemSyntax]] null 
        choose parse_item_list(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set items: success

        let start_right_paren_3 lexer.previous_position
        let success_right_paren_3 lexer.parse_punctuation(')')
        if success_right_paren_3 = false
        {
            throw ParserError(InvalidSyntax(start_right_paren_3, lexer.position, String(ep, ")")))        }

        let end lexer.position

        return ParametersSyntax(start, end, items)
    }

    function parse_item_list(this: Parser) returns pointer[Vector[ItemSyntax]] throws ParserError {
        var r Region()
        var list List[ItemSyntax]$()
        while true
        {
            try let node parse_item(rp, ep)
                when i: ParserError.Invalid
                    throw i
                when d: ParserError.Different
                {
                    if (*list).head = 0
                    {
                        throw d
                    } else {
                        return Vector[ItemSyntax]#(rp, *list)
                    }
                }

            (*list).add(node)
        }
    }

    function parse_item(this: Parser) returns ItemSyntax throws ParserError {
        let start lexer.previous_position

        let start_name lexer.previous_position
        let name lexer.parse_identifier(rp, keywords)
        if name = null
        {
            throw ParserError(DifferentSyntax())

        }

        let annotation_start lexer.position
        var annotation: pointer[TypeAnnotationSyntax] null 
        choose parse_typeannotation(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set annotation: TypeAnnotationSyntax#(success)

        let start_comma_3 lexer.previous_position
        let success_comma_3 lexer.parse_punctuation(',')

        let start_colon_4 lexer.previous_position
        let success_colon_4 lexer.parse_colon()

        let attributes_start lexer.position
        var attributes: pointer[Vector[AttributeSyntax]] null 
        choose parse_attribute_list(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set attributes: success

        let start_colon_6 lexer.previous_position
        let success_colon_6 lexer.parse_colon()

        let end lexer.position

        return ItemSyntax(start, end, *name, annotation, attributes)
    }

    function parse_returns(this: Parser) returns ReturnsSyntax throws ParserError {
        let start lexer.previous_position

        let start_returns_1 lexer.previous_position
        let success_returns_1 lexer.parse_keyword(*keywords_index.get(30))
        if success_returns_1 = false
        {
            throw ParserError(DifferentSyntax())
        }

        let type_start lexer.position
        try let type parse_type(rp, ep)
            when d: ParserError.Different
                throw InvalidSyntax(type_start, lexer.position, String(ep, "a valid Type syntax"))
            when i: ParserError.Invalid throw i

        let attributes_start lexer.position
        var attributes: pointer[Vector[AttributeSyntax]] null 
        choose parse_attribute_list(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set attributes: success

        let end lexer.position

        return ReturnsSyntax(start, end, type, attributes)
    }

    function parse_throws(this: Parser) returns ThrowsSyntax throws ParserError {
        let start lexer.previous_position

        let start_throws_1 lexer.previous_position
        let success_throws_1 lexer.parse_keyword(*keywords_index.get(35))
        if success_throws_1 = false
        {
            throw ParserError(DifferentSyntax())
        }

        let type_start lexer.position
        try let type parse_type(rp, ep)
            when d: ParserError.Different
                throw InvalidSyntax(type_start, lexer.position, String(ep, "a valid Type syntax"))
            when i: ParserError.Invalid throw i

        let attributes_start lexer.position
        var attributes: pointer[Vector[AttributeSyntax]] null 
        choose parse_attribute_list(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set attributes: success

        let end lexer.position

        return ThrowsSyntax(start, end, type, attributes)
    }

    function parse_use_list(this: Parser) returns pointer[Vector[UseSyntax]] throws ParserError {
        var r Region()
        var list List[UseSyntax]$()
        while true
        {
            try let node parse_use(rp, ep)
                when i: ParserError.Invalid
                    throw i
                when d: ParserError.Different
                {
                    if (*list).head = 0
                    {
                        throw d
                    } else {
                        return Vector[UseSyntax]#(rp, *list)
                    }
                }

            (*list).add(node)
        }
    }

    function parse_use(this: Parser) returns UseSyntax throws ParserError {
        let start lexer.previous_position

        let start_use_1 lexer.previous_position
        let success_use_1 lexer.parse_keyword(*keywords_index.get(39))
        if success_use_1 = false
        {
            throw ParserError(DifferentSyntax())
        }

        let name_start lexer.position
        try let name parse_name(rp, ep)
            when d: ParserError.Different
                throw InvalidSyntax(name_start, lexer.position, String(ep, "a valid Name syntax"))
            when i: ParserError.Invalid throw i

        let start_colon_3 lexer.previous_position
        let success_colon_3 lexer.parse_colon()

        let end lexer.position

        return UseSyntax(start, end, name)
    }

    function parse_implement(this: Parser) returns ImplementSyntax throws ParserError {
        let start lexer.previous_position

        let start_implement_1 lexer.previous_position
        let success_implement_1 lexer.parse_keyword(*keywords_index.get(14))
        if success_implement_1 = false
        {
            throw ParserError(DifferentSyntax())
        }

        let type_start lexer.position
        try let type parse_type(rp, ep)
            when d: ParserError.Different
                throw InvalidSyntax(type_start, lexer.position, String(ep, "a valid Type syntax"))
            when i: ParserError.Invalid throw i

        let attributes_start lexer.position
        var attributes: pointer[Vector[AttributeSyntax]] null 
        choose parse_attribute_list(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set attributes: success

        let start_colon_4 lexer.previous_position
        let success_colon_4 lexer.parse_colon()

        let start_left_curly_5 lexer.previous_position
        let success_left_curly_5 lexer.parse_punctuation('{')
        if success_left_curly_5 = false
        {
            throw ParserError(InvalidSyntax(start_left_curly_5, lexer.position, String(ep, "{")))        }

        let uses_start lexer.position
        var uses: pointer[Vector[UseSyntax]] null 
        choose parse_use_list(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set uses: success

        let methods_start lexer.position
        var methods: pointer[Vector[MethodSyntax]] null 
        choose parse_method_list(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set methods: success

        let start_right_curly_8 lexer.previous_position
        let success_right_curly_8 lexer.parse_punctuation('}')
        if success_right_curly_8 = false
        {
            throw ParserError(InvalidSyntax(start_right_curly_8, lexer.position, String(ep, "}")))        }

        let start_colon_9 lexer.previous_position
        let success_colon_9 lexer.parse_colon()

        let end lexer.position

        return ImplementSyntax(start, end, type, attributes, uses, methods)
    }

    function parse_trait(this: Parser) returns TraitSyntax throws ParserError {
        let start lexer.previous_position

        let start_trait_1 lexer.previous_position
        let success_trait_1 lexer.parse_keyword(*keywords_index.get(36))
        if success_trait_1 = false
        {
            throw ParserError(DifferentSyntax())
        }

        let name_start lexer.position
        try let name parse_name(rp, ep)
            when d: ParserError.Different
                throw InvalidSyntax(name_start, lexer.position, String(ep, "a valid Name syntax"))
            when i: ParserError.Invalid throw i

        let extension_start lexer.position
        var extension: pointer[ExtendsSyntax] null 
        choose parse_extends(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set extension: ExtendsSyntax#(success)

        let attributes_start lexer.position
        var attributes: pointer[Vector[AttributeSyntax]] null 
        choose parse_attribute_list(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set attributes: success

        let start_left_curly_5 lexer.previous_position
        let success_left_curly_5 lexer.parse_punctuation('{')
        if success_left_curly_5 = false
        {
            throw ParserError(InvalidSyntax(start_left_curly_5, lexer.position, String(ep, "{")))        }

        let uses_start lexer.position
        var uses: pointer[Vector[UseSyntax]] null 
        choose parse_use_list(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set uses: success

        let functions_start lexer.position
        var functions: pointer[Vector[MethodSyntax]] null 
        choose parse_method_list(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set functions: success

        let start_right_curly_8 lexer.previous_position
        let success_right_curly_8 lexer.parse_punctuation('}')
        if success_right_curly_8 = false
        {
            throw ParserError(InvalidSyntax(start_right_curly_8, lexer.position, String(ep, "}")))        }

        let start_colon_9 lexer.previous_position
        let success_colon_9 lexer.parse_colon()

        let end lexer.position

        return TraitSyntax(start, end, name, extension, attributes, uses, functions)
    }

    function parse_method_list(this: Parser) returns pointer[Vector[MethodSyntax]] throws ParserError {
        var r Region()
        var list List[MethodSyntax]$()
        while true
        {
            try let node parse_method(rp, ep)
                when i: ParserError.Invalid
                    throw i
                when d: ParserError.Different
                {
                    if (*list).head = 0
                    {
                        throw d
                    } else {
                        return Vector[MethodSyntax]#(rp, *list)
                    }
                }

            (*list).add(node)
        }
    }

    function parse_method(this: Parser) returns MethodSyntax throws ParserError {
        {
            choose parse_function(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return MethodSyntax(FunctionSyntax(node))
        }
        {
            choose parse_procedure(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return MethodSyntax(ProcedureSyntax(node))
        }
        {
            choose parse_operator(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return MethodSyntax(OperatorSyntax(node))
        }
        throw ParserError(DifferentSyntax())
    }

    function parse_init_list(this: Parser) returns pointer[Vector[InitSyntax]] throws ParserError {
        var r Region()
        var list List[InitSyntax]$()
        while true
        {
            try let node parse_init(rp, ep)
                when i: ParserError.Invalid
                    throw i
                when d: ParserError.Different
                {
                    if (*list).head = 0
                    {
                        throw d
                    } else {
                        return Vector[InitSyntax]#(rp, *list)
                    }
                }

            (*list).add(node)
        }
    }

    function parse_init(this: Parser) returns InitSyntax throws ParserError {
        let start lexer.previous_position

        let start_init_1 lexer.previous_position
        let success_init_1 lexer.parse_keyword(*keywords_index.get(13))
        if success_init_1 = false
        {
            throw ParserError(DifferentSyntax())
        }

        let parameters_start lexer.position
        var parameters: pointer[ParameterSetSyntax] null 
        choose parse_parameterset(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set parameters: ParameterSetSyntax#(success)

        let start_colon_3 lexer.previous_position
        let success_colon_3 lexer.parse_colon()

        let action_start lexer.position
        try let action parse_action(rp, ep)
            when d: ParserError.Different
                throw InvalidSyntax(action_start, lexer.position, String(ep, "a valid Action syntax"))
            when i: ParserError.Invalid throw i

        let start_colon_5 lexer.previous_position
        let success_colon_5 lexer.parse_colon()

        let end lexer.position

        return InitSyntax(start, end, parameters, action)
    }

    function parse_deinit(this: Parser) returns DeInitSyntax throws ParserError {
        let start lexer.previous_position

        let start_deinit_1 lexer.previous_position
        let success_deinit_1 lexer.parse_keyword(*keywords_index.get(5))
        if success_deinit_1 = false
        {
            throw ParserError(DifferentSyntax())
        }

        let start_colon_2 lexer.previous_position
        let success_colon_2 lexer.parse_colon()

        let action_start lexer.position
        try let action parse_action(rp, ep)
            when d: ParserError.Different
                throw InvalidSyntax(action_start, lexer.position, String(ep, "a valid Action syntax"))
            when i: ParserError.Invalid throw i

        let start_colon_4 lexer.previous_position
        let success_colon_4 lexer.parse_colon()

        let end lexer.position

        return DeInitSyntax(start, end, action)
    }

    function parse_function(this: Parser) returns FunctionSyntax throws ParserError {
        let start lexer.previous_position

        let start_function_1 lexer.previous_position
        let success_function_1 lexer.parse_keyword(*keywords_index.get(11))
        if success_function_1 = false
        {
            throw ParserError(DifferentSyntax())
        }

        let target_start lexer.position
        try let target parse_target(rp, ep)
            when d: ParserError.Different
                throw InvalidSyntax(target_start, lexer.position, String(ep, "a valid Target syntax"))
            when i: ParserError.Invalid throw i

        let end lexer.position

        return FunctionSyntax(start, end, target)
    }

    function parse_procedure(this: Parser) returns ProcedureSyntax throws ParserError {
        let start lexer.previous_position

        let start_procedure_1 lexer.previous_position
        let success_procedure_1 lexer.parse_keyword(*keywords_index.get(27))
        if success_procedure_1 = false
        {
            throw ParserError(DifferentSyntax())
        }

        let target_start lexer.position
        try let target parse_target(rp, ep)
            when d: ParserError.Different
                throw InvalidSyntax(target_start, lexer.position, String(ep, "a valid Target syntax"))
            when i: ParserError.Invalid throw i

        let end lexer.position

        return ProcedureSyntax(start, end, target)
    }

    function parse_operator(this: Parser) returns OperatorSyntax throws ParserError {
        let start lexer.previous_position

        let start_operator_1 lexer.previous_position
        let success_operator_1 lexer.parse_keyword(*keywords_index.get(26))
        if success_operator_1 = false
        {
            throw ParserError(DifferentSyntax())
        }

        let target_start lexer.position
        try let target parse_target(rp, ep)
            when d: ParserError.Different
                throw InvalidSyntax(target_start, lexer.position, String(ep, "a valid Target syntax"))
            when i: ParserError.Invalid throw i

        let end lexer.position

        return OperatorSyntax(start, end, target)
    }

    function parse_target(this: Parser) returns TargetSyntax throws ParserError {
        {
            choose parse_named(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return TargetSyntax(NamedSyntax(node))
        }
        {
            choose parse_routine(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return TargetSyntax(RoutineSyntax(node))
        }
        throw ParserError(DifferentSyntax())
    }

    function parse_named(this: Parser) returns NamedSyntax throws ParserError {
        let start lexer.previous_position

        let start_name lexer.previous_position
        let name lexer.parse_identifier(rp, keywords)
        if name = null
        {
            throw ParserError(DifferentSyntax())

        }

        let routine_start lexer.position
        try let routine parse_routine(rp, ep)
            when d: ParserError.Different
                throw InvalidSyntax(routine_start, lexer.position, String(ep, "a valid Routine syntax"))
            when i: ParserError.Invalid throw i

        let end lexer.position

        return NamedSyntax(start, end, *name, routine)
    }

    function parse_routine(this: Parser) returns RoutineSyntax throws ParserError {
        let start lexer.previous_position

        let generics_start lexer.position
        var generics: pointer[GenericArgumentsSyntax] null 
        choose parse_genericarguments(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set generics: GenericArgumentsSyntax#(success)

        let lifetime_start lexer.position
        var lifetime: pointer[LifetimeSyntax] null 
        choose parse_lifetime(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set lifetime: LifetimeSyntax#(success)

        let parameters_start lexer.position
        var parameters: pointer[ParameterSetSyntax] null 
        choose parse_parameterset(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set parameters: ParameterSetSyntax#(success)

        let attributes_start lexer.position
        var attributes: pointer[Vector[AttributeSyntax]] null 
        choose parse_attribute_list(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set attributes: success

        let returns__start lexer.position
        var returns_: pointer[ReturnsSyntax] null 
        choose parse_returns(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set returns_: ReturnsSyntax#(success)

        let start_colon_6 lexer.previous_position
        let success_colon_6 lexer.parse_colon()

        let throws__start lexer.position
        var throws_: pointer[ThrowsSyntax] null 
        choose parse_throws(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set throws_: ThrowsSyntax#(success)

        let start_colon_8 lexer.previous_position
        let success_colon_8 lexer.parse_colon()

        let implementation_start lexer.position
        try let implementation parse_implementation(rp, ep)
            when d: ParserError.Different
                throw InvalidSyntax(implementation_start, lexer.position, String(ep, "a valid Implementation syntax"))
            when i: ParserError.Invalid throw i

        let end lexer.position

        return RoutineSyntax(start, end, generics, lifetime, parameters, attributes, returns_, throws_, implementation)
    }

    function parse_implementation(this: Parser) returns ImplementationSyntax throws ParserError {
        {
            choose parse_action(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return ImplementationSyntax(ActionSyntax(node))
        }
        {
            choose parse_extern(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return ImplementationSyntax(ExternSyntax(node))
        }
        {
            choose parse_instruction(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return ImplementationSyntax(InstructionSyntax(node))
        }
        {
            choose parse_intrinsic(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return ImplementationSyntax(IntrinsicSyntax(node))
        }
        throw ParserError(DifferentSyntax())
    }

    function parse_extern(this: Parser) returns ExternSyntax throws ParserError {
        let start lexer.previous_position

        let start_extern_1 lexer.previous_position
        let success_extern_1 lexer.parse_keyword(*keywords_index.get(9))
        if success_extern_1 = false
        {
            throw ParserError(DifferentSyntax())
        }

        let end lexer.position

        return ExternSyntax(start, end)
    }

    function parse_instruction(this: Parser) returns InstructionSyntax throws ParserError {
        let start lexer.previous_position

        let start_instruction_1 lexer.previous_position
        let success_instruction_1 lexer.parse_keyword(*keywords_index.get(16))
        if success_instruction_1 = false
        {
            throw ParserError(DifferentSyntax())
        }

        let start_colon_2 lexer.previous_position
        let success_colon_2 lexer.parse_colon()

        let end lexer.position

        return InstructionSyntax(start, end)
    }

    function parse_intrinsic(this: Parser) returns IntrinsicSyntax throws ParserError {
        let start lexer.previous_position

        let start_intrinsic_1 lexer.previous_position
        let success_intrinsic_1 lexer.parse_keyword(*keywords_index.get(17))
        if success_intrinsic_1 = false
        {
            throw ParserError(DifferentSyntax())
        }

        let start_colon_2 lexer.previous_position
        let success_colon_2 lexer.parse_colon()

        let end lexer.position

        return IntrinsicSyntax(start, end)
    }

    function parse_extends(this: Parser) returns ExtendsSyntax throws ParserError {
        let start lexer.previous_position

        let start_extends_1 lexer.previous_position
        let success_extends_1 lexer.parse_keyword(*keywords_index.get(8))
        if success_extends_1 = false
        {
            throw ParserError(DifferentSyntax())
        }

        let extensions_start lexer.position
        var extensions: pointer[Vector[ExtendSyntax]] null 
        choose parse_extend_list(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set extensions: success

        let end lexer.position

        return ExtendsSyntax(start, end, extensions)
    }

    function parse_extend_list(this: Parser) returns pointer[Vector[ExtendSyntax]] throws ParserError {
        var r Region()
        var list List[ExtendSyntax]$()
        while true
        {
            try let node parse_extend(rp, ep)
                when i: ParserError.Invalid
                    throw i
                when d: ParserError.Different
                {
                    if (*list).head = 0
                    {
                        throw d
                    } else {
                        return Vector[ExtendSyntax]#(rp, *list)
                    }
                }

            (*list).add(node)
        }
    }

    function parse_extend(this: Parser) returns ExtendSyntax throws ParserError {
        let start lexer.previous_position

        let type_start lexer.position
        try let type parse_type(rp, ep)
            when d: ParserError.Different throw d
            when i: ParserError.Invalid throw i

        let start_comma_2 lexer.previous_position
        let success_comma_2 lexer.parse_punctuation(',')

        let end lexer.position

        return ExtendSyntax(start, end, type)
    }

    function parse_macro(this: Parser) returns MacroSyntax throws ParserError {
        let start lexer.previous_position

        let start_macro_1 lexer.previous_position
        let success_macro_1 lexer.parse_keyword(*keywords_index.get(22))
        if success_macro_1 = false
        {
            throw ParserError(DifferentSyntax())
        }

        let start_name lexer.previous_position
        let name lexer.parse_identifier(rp, keywords)
        if name = null
        {
            throw ParserError(InvalidSyntax(start_name, lexer.position, String(ep, "an identifier")))
        }

        let model_start lexer.position
        try let model parse_model(rp, ep)
            when d: ParserError.Different
                throw InvalidSyntax(model_start, lexer.position, String(ep, "a valid Model syntax"))
            when i: ParserError.Invalid throw i

        let rule_start lexer.position
        try let rule parse_operand_list(rp, ep)
            when d: ParserError.Different
                throw InvalidSyntax(rule_start, lexer.position, String(ep, "a valid Operand syntax"))
            when i: ParserError.Invalid throw i

        let end lexer.position

        return MacroSyntax(start, end, *name, model, rule)
    }

    function parse_attribute_list(this: Parser) returns pointer[Vector[AttributeSyntax]] throws ParserError {
        var r Region()
        var list List[AttributeSyntax]$()
        while true
        {
            try let node parse_attribute(rp, ep)
                when i: ParserError.Invalid
                    throw i
                when d: ParserError.Different
                {
                    if (*list).head = 0
                    {
                        throw d
                    } else {
                        return Vector[AttributeSyntax]#(rp, *list)
                    }
                }

            (*list).add(node)
        }
    }

    function parse_attribute(this: Parser) returns AttributeSyntax throws ParserError {
        let start lexer.previous_position

        let start_name lexer.previous_position
        let name lexer.parse_attribute(rp)
        if name = null
        {

            throw ParserError(DifferentSyntax())
        }

        let model_start lexer.position
        try let model parse_model(rp, ep)
            when d: ParserError.Different
                throw InvalidSyntax(model_start, lexer.position, String(ep, "a valid Model syntax"))
            when i: ParserError.Invalid throw i

        let start_colon_3 lexer.previous_position
        let success_colon_3 lexer.parse_colon()

        let end lexer.position

        return AttributeSyntax(start, end, *name, model)
    }

    function parse_model(this: Parser) returns ModelSyntax throws ParserError {
        {
            choose parse_literal(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return ModelSyntax(LiteralSyntax(node))
        }
        {
            choose parse_name(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return ModelSyntax(NameSyntax(node))
        }
        {
            choose parse_object(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return ModelSyntax(ObjectSyntax(node))
        }
        {
            choose parse_vector(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return ModelSyntax(VectorSyntax(node))
        }
        throw ParserError(DifferentSyntax())
    }

    function parse_module(this: Parser) returns ModuleSyntax throws ParserError {
        let start lexer.previous_position

        let start_module_1 lexer.previous_position
        let success_module_1 lexer.parse_keyword(*keywords_index.get(24))
        if success_module_1 = false
        {
            throw ParserError(DifferentSyntax())
        }

        let start_name lexer.previous_position
        let name lexer.parse_identifier(rp, keywords)
        if name = null
        {
            throw ParserError(InvalidSyntax(start_name, lexer.position, String(ep, "an identifier")))
        }

        let start_colon_3 lexer.previous_position
        let success_colon_3 lexer.parse_colon()

        let end lexer.position

        return ModuleSyntax(start, end, *name)
    }

    function parse_package_list(this: Parser) returns pointer[Vector[PackageSyntax]] throws ParserError {
        var r Region()
        var list List[PackageSyntax]$()
        while true
        {
            try let node parse_package(rp, ep)
                when i: ParserError.Invalid
                    throw i
                when d: ParserError.Different
                {
                    if (*list).head = 0
                    {
                        throw d
                    } else {
                        return Vector[PackageSyntax]#(rp, *list)
                    }
                }

            (*list).add(node)
        }
    }

    function parse_package(this: Parser) returns PackageSyntax throws ParserError {
        let start lexer.previous_position

        let start_package_1 lexer.previous_position
        let success_package_1 lexer.parse_keyword(*keywords_index.get(43))
        if success_package_1 = false
        {
            throw ParserError(DifferentSyntax())
        }

        let name_start lexer.position
        try let name parse_name(rp, ep)
            when d: ParserError.Different
                throw InvalidSyntax(name_start, lexer.position, String(ep, "a valid Name syntax"))
            when i: ParserError.Invalid throw i

        let start_colon_3 lexer.previous_position
        let success_colon_3 lexer.parse_colon()

        let end lexer.position

        return PackageSyntax(start, end, name)
    }

    function parse_initializer(this: Parser) returns InitializerSyntax throws ParserError {
        let start lexer.previous_position

        let start_left_paren_1 lexer.previous_position
        let success_left_paren_1 lexer.parse_punctuation('(')
        if success_left_paren_1 = false
        {
            throw ParserError(DifferentSyntax())
        }

        let operands_start lexer.position
        try let operands parse_operand_list(rp, ep)
            when d: ParserError.Different
                throw InvalidSyntax(operands_start, lexer.position, String(ep, "a valid Operand syntax"))
            when i: ParserError.Invalid throw i

        let start_right_paren_3 lexer.previous_position
        let success_right_paren_3 lexer.parse_punctuation(')')
        if success_right_paren_3 = false
        {
            throw ParserError(InvalidSyntax(start_right_paren_3, lexer.position, String(ep, ")")))        }

        let end lexer.position

        return InitializerSyntax(start, end, operands)
    }

    function parse_operand_list(this: Parser) returns pointer[Vector[OperandSyntax]] throws ParserError {
        var r Region()
        var list List[OperandSyntax]$()
        while true
        {
            try let node parse_operand(rp, ep)
                when i: ParserError.Invalid
                    throw i
                when d: ParserError.Different
                {
                    if (*list).head = 0
                    {
                        throw d
                    } else {
                        return Vector[OperandSyntax]#(rp, *list)
                    }
                }

            (*list).add(node)
        }
    }

    function parse_operand(this: Parser) returns OperandSyntax throws ParserError {
        let start lexer.previous_position

        let expression_start lexer.position
        try let expression parse_expression(rp, ep)
            when d: ParserError.Different throw d
            when i: ParserError.Invalid throw i

        let members_start lexer.position
        var members: pointer[Vector[MemberAccessSyntax]] null 
        choose parse_memberaccess_list(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set members: success

        let end lexer.position

        return OperandSyntax(start, end, expression, members)
    }

    function parse_memberaccess_list(this: Parser) returns pointer[Vector[MemberAccessSyntax]] throws ParserError {
        var r Region()
        var list List[MemberAccessSyntax]$()
        while true
        {
            try let node parse_memberaccess(rp, ep)
                when i: ParserError.Invalid
                    throw i
                when d: ParserError.Different
                {
                    if (*list).head = 0
                    {
                        throw d
                    } else {
                        return Vector[MemberAccessSyntax]#(rp, *list)
                    }
                }

            (*list).add(node)
        }
    }

    function parse_memberaccess(this: Parser) returns MemberAccessSyntax throws ParserError {
        let start lexer.previous_position

        let start_dot_1 lexer.previous_position
        let success_dot_1 lexer.parse_punctuation('.')
        if success_dot_1 = false
        {
            throw ParserError(DifferentSyntax())
        }

        let name_start lexer.position
        try let name parse_name(rp, ep)
            when d: ParserError.Different
                throw InvalidSyntax(name_start, lexer.position, String(ep, "a valid Name syntax"))
            when i: ParserError.Invalid throw i

        let end lexer.position

        return MemberAccessSyntax(start, end, name)
    }

    function parse_expression(this: Parser) returns ExpressionSyntax throws ParserError {
        {
            choose parse_literal(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return ExpressionSyntax(LiteralSyntax(node))
        }
        {
            choose parse_type(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return ExpressionSyntax(TypeSyntax(node))
        }
        {
            choose parse_object(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return ExpressionSyntax(ObjectSyntax(node))
        }
        {
            choose parse_vector(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return ExpressionSyntax(VectorSyntax(node))
        }
        {
            choose parse_block(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return ExpressionSyntax(BlockSyntax(node))
        }
        {
            choose parse_if(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return ExpressionSyntax(IfSyntax(node))
        }
        {
            choose parse_match(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return ExpressionSyntax(MatchSyntax(node))
        }
        {
            choose parse_lambda(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return ExpressionSyntax(LambdaSyntax(node))
        }
        {
            choose parse_for(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return ExpressionSyntax(ForSyntax(node))
        }
        {
            choose parse_while(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return ExpressionSyntax(WhileSyntax(node))
        }
        {
            choose parse_choose(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return ExpressionSyntax(ChooseSyntax(node))
        }
        {
            choose parse_try(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return ExpressionSyntax(TrySyntax(node))
        }
        {
            choose parse_repeat(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return ExpressionSyntax(RepeatSyntax(node))
        }
        {
            choose parse_sizeof(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return ExpressionSyntax(SizeOfSyntax(node))
        }
        throw ParserError(DifferentSyntax())
    }

    function parse_literal(this: Parser) returns LiteralSyntax throws ParserError {
        let start lexer.previous_position

        try let literal parse_literal_token(rp, ep)
            else throw

        let end lexer.position

        return LiteralSyntax(start, end, literal)
    }

    function parse_object(this: Parser) returns ObjectSyntax throws ParserError {
        let start lexer.previous_position

        let start_left_paren_1 lexer.previous_position
        let success_left_paren_1 lexer.parse_punctuation('(')
        if success_left_paren_1 = false
        {
            throw ParserError(DifferentSyntax())
        }

        let components_start lexer.position
        var components: pointer[Vector[ComponentSyntax]] null 
        choose parse_component_list(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set components: success

        let start_right_paren_3 lexer.previous_position
        let success_right_paren_3 lexer.parse_punctuation(')')
        if success_right_paren_3 = false
        {
            throw ParserError(InvalidSyntax(start_right_paren_3, lexer.position, String(ep, ")")))        }

        let end lexer.position

        return ObjectSyntax(start, end, components)
    }

    function parse_component_list(this: Parser) returns pointer[Vector[ComponentSyntax]] throws ParserError {
        var r Region()
        var list List[ComponentSyntax]$()
        while true
        {
            try let node parse_component(rp, ep)
                when i: ParserError.Invalid
                    throw i
                when d: ParserError.Different
                {
                    if (*list).head = 0
                    {
                        throw d
                    } else {
                        return Vector[ComponentSyntax]#(rp, *list)
                    }
                }

            (*list).add(node)
        }
    }

    function parse_component(this: Parser) returns ComponentSyntax throws ParserError {
        let start lexer.previous_position

        let operands_start lexer.position
        try let operands parse_operand_list(rp, ep)
            when d: ParserError.Different throw d
            when i: ParserError.Invalid throw i

        let attributes_start lexer.position
        var attributes: pointer[Vector[AttributeSyntax]] null 
        choose parse_attribute_list(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set attributes: success

        let value_start lexer.position
        var value: pointer[ValueSyntax] null 
        choose parse_value(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set value: ValueSyntax#(success)

        let start_comma_4 lexer.previous_position
        let success_comma_4 lexer.parse_punctuation(',')

        let end lexer.position

        return ComponentSyntax(start, end, operands, attributes, value)
    }

    function parse_value(this: Parser) returns ValueSyntax throws ParserError {
        let start lexer.previous_position

        let start_colon_1 lexer.previous_position
        let success_colon_1 lexer.parse_colon()
        if success_colon_1 = false
        {
            throw ParserError(DifferentSyntax())
        }

        let value_start lexer.position
        try let value parse_operand_list(rp, ep)
            when d: ParserError.Different
                throw InvalidSyntax(value_start, lexer.position, String(ep, "a valid Operand syntax"))
            when i: ParserError.Invalid throw i

        let attributes_start lexer.position
        var attributes: pointer[Vector[AttributeSyntax]] null 
        choose parse_attribute_list(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set attributes: success

        let end lexer.position

        return ValueSyntax(start, end, value, attributes)
    }

    function parse_vector(this: Parser) returns VectorSyntax throws ParserError {
        let start lexer.previous_position

        let start_left_bracket_1 lexer.previous_position
        let success_left_bracket_1 lexer.parse_punctuation('[')
        if success_left_bracket_1 = false
        {
            throw ParserError(DifferentSyntax())
        }

        let elements_start lexer.position
        try let elements parse_element_list(rp, ep)
            when d: ParserError.Different
                throw InvalidSyntax(elements_start, lexer.position, String(ep, "a valid Element syntax"))
            when i: ParserError.Invalid throw i

        let start_right_bracket_3 lexer.previous_position
        let success_right_bracket_3 lexer.parse_punctuation(']')
        if success_right_bracket_3 = false
        {
            throw ParserError(InvalidSyntax(start_right_bracket_3, lexer.position, String(ep, "]")))        }

        let lifetime_start lexer.position
        var lifetime: pointer[LifetimeSyntax] null 
        choose parse_lifetime(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set lifetime: LifetimeSyntax#(success)

        let end lexer.position

        return VectorSyntax(start, end, elements, lifetime)
    }

    function parse_element_list(this: Parser) returns pointer[Vector[ElementSyntax]] throws ParserError {
        var r Region()
        var list List[ElementSyntax]$()
        while true
        {
            try let node parse_element(rp, ep)
                when i: ParserError.Invalid
                    throw i
                when d: ParserError.Different
                {
                    if (*list).head = 0
                    {
                        throw d
                    } else {
                        return Vector[ElementSyntax]#(rp, *list)
                    }
                }

            (*list).add(node)
        }
    }

    function parse_element(this: Parser) returns ElementSyntax throws ParserError {
        let start lexer.previous_position

        let operation_start lexer.position
        try let operation parse_operand_list(rp, ep)
            when d: ParserError.Different throw d
            when i: ParserError.Invalid throw i

        let attributes_start lexer.position
        var attributes: pointer[Vector[AttributeSyntax]] null 
        choose parse_attribute_list(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set attributes: success

        let start_comma_3 lexer.previous_position
        let success_comma_3 lexer.parse_punctuation(',')

        let end lexer.position

        return ElementSyntax(start, end, operation, attributes)
    }

    function parse_block(this: Parser) returns BlockSyntax throws ParserError {
        let start lexer.previous_position

        let start_left_curly_1 lexer.previous_position
        let success_left_curly_1 lexer.parse_punctuation('{')
        if success_left_curly_1 = false
        {
            throw ParserError(DifferentSyntax())
        }

        let uses_start lexer.position
        var uses: pointer[Vector[UseSyntax]] null 
        choose parse_use_list(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set uses: success

        let statements_start lexer.position
        var statements: pointer[Vector[StatementSyntax]] null 
        choose parse_statement_list(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set statements: success

        let start_right_curly_4 lexer.previous_position
        let success_right_curly_4 lexer.parse_punctuation('}')
        if success_right_curly_4 = false
        {
            throw ParserError(InvalidSyntax(start_right_curly_4, lexer.position, String(ep, "}")))        }

        let end lexer.position

        return BlockSyntax(start, end, uses, statements)
    }

    function parse_if(this: Parser) returns IfSyntax throws ParserError {
        let start lexer.previous_position

        let start_if_1 lexer.previous_position
        let success_if_1 lexer.parse_keyword(*keywords_index.get(12))
        if success_if_1 = false
        {
            throw ParserError(DifferentSyntax())
        }

        let condition_start lexer.position
        try let condition parse_operand_list(rp, ep)
            when d: ParserError.Different
                throw InvalidSyntax(condition_start, lexer.position, String(ep, "a valid Operand syntax"))
            when i: ParserError.Invalid throw i

        let start_colon_3 lexer.previous_position
        let success_colon_3 lexer.parse_colon()
        if success_colon_3 = false
        {
            throw ParserError(InvalidSyntax(start_colon_3, lexer.position, String(ep, "a colon or a line feed")))        }

        let consequent_start lexer.position
        try let consequent parse_command(rp, ep)
            when d: ParserError.Different
                throw InvalidSyntax(consequent_start, lexer.position, String(ep, "a valid Command syntax"))
            when i: ParserError.Invalid throw i

        let alternative_start lexer.position
        var alternative: pointer[ElseSyntax] null 
        choose parse_else(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set alternative: ElseSyntax#(success)

        let end lexer.position

        return IfSyntax(start, end, condition, consequent, alternative)
    }

    function parse_else(this: Parser) returns ElseSyntax throws ParserError {
        let start lexer.previous_position

        let start_else_1 lexer.previous_position
        let success_else_1 lexer.parse_keyword(*keywords_index.get(7))
        if success_else_1 = false
        {
            throw ParserError(DifferentSyntax())
        }

        let start_colon_2 lexer.previous_position
        let success_colon_2 lexer.parse_colon()

        let alternative_start lexer.position
        try let alternative parse_command(rp, ep)
            when d: ParserError.Different
                throw InvalidSyntax(alternative_start, lexer.position, String(ep, "a valid Command syntax"))
            when i: ParserError.Invalid throw i

        let end lexer.position

        return ElseSyntax(start, end, alternative)
    }

    function parse_match(this: Parser) returns MatchSyntax throws ParserError {
        let start lexer.previous_position

        let start_match_1 lexer.previous_position
        let success_match_1 lexer.parse_keyword(*keywords_index.get(23))
        if success_match_1 = false
        {
            throw ParserError(DifferentSyntax())
        }

        let scrutinee_start lexer.position
        try let scrutinee parse_operand_list(rp, ep)
            when d: ParserError.Different
                throw InvalidSyntax(scrutinee_start, lexer.position, String(ep, "a valid Operand syntax"))
            when i: ParserError.Invalid throw i

        let start_colon_3 lexer.previous_position
        let success_colon_3 lexer.parse_colon()
        if success_colon_3 = false
        {
            throw ParserError(InvalidSyntax(start_colon_3, lexer.position, String(ep, "a colon or a line feed")))        }

        let branches_start lexer.position
        try let branches parse_branch_list(rp, ep)
            when d: ParserError.Different
                throw InvalidSyntax(branches_start, lexer.position, String(ep, "a valid Branch syntax"))
            when i: ParserError.Invalid throw i

        let alternative_start lexer.position
        var alternative: pointer[ElseSyntax] null 
        choose parse_else(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set alternative: ElseSyntax#(success)

        let end lexer.position

        return MatchSyntax(start, end, scrutinee, branches, alternative)
    }

    function parse_branch_list(this: Parser) returns pointer[Vector[BranchSyntax]] throws ParserError {
        var r Region()
        var list List[BranchSyntax]$()
        while true
        {
            try let node parse_branch(rp, ep)
                when i: ParserError.Invalid
                    throw i
                when d: ParserError.Different
                {
                    if (*list).head = 0
                    {
                        throw d
                    } else {
                        return Vector[BranchSyntax]#(rp, *list)
                    }
                }

            (*list).add(node)
        }
    }

    function parse_branch(this: Parser) returns BranchSyntax throws ParserError {
        let start lexer.previous_position

        let cases_start lexer.position
        try let cases parse_case_list(rp, ep)
            when d: ParserError.Different throw d
            when i: ParserError.Invalid throw i

        let start_colon_2 lexer.previous_position
        let success_colon_2 lexer.parse_colon()
        if success_colon_2 = false
        {
            throw ParserError(InvalidSyntax(start_colon_2, lexer.position, String(ep, "a colon or a line feed")))        }

        let consequent_start lexer.position
        try let consequent parse_statement(rp, ep)
            when d: ParserError.Different
                throw InvalidSyntax(consequent_start, lexer.position, String(ep, "a valid Statement syntax"))
            when i: ParserError.Invalid throw i

        let end lexer.position

        return BranchSyntax(start, end, cases, consequent)
    }

    function parse_case_list(this: Parser) returns pointer[Vector[CaseSyntax]] throws ParserError {
        var r Region()
        var list List[CaseSyntax]$()
        while true
        {
            try let node parse_case(rp, ep)
                when i: ParserError.Invalid
                    throw i
                when d: ParserError.Different
                {
                    if (*list).head = 0
                    {
                        throw d
                    } else {
                        return Vector[CaseSyntax]#(rp, *list)
                    }
                }

            (*list).add(node)
        }
    }

    function parse_case(this: Parser) returns CaseSyntax throws ParserError {
        let start lexer.previous_position

        let start_case_1 lexer.previous_position
        let success_case_1 lexer.parse_keyword(*keywords_index.get(1))
        if success_case_1 = false
        {
            throw ParserError(DifferentSyntax())
        }

        let condition_start lexer.position
        try let condition parse_operand_list(rp, ep)
            when d: ParserError.Different
                throw InvalidSyntax(condition_start, lexer.position, String(ep, "a valid Operand syntax"))
            when i: ParserError.Invalid throw i

        let end lexer.position

        return CaseSyntax(start, end, condition)
    }

    function parse_statement_list(this: Parser) returns pointer[Vector[StatementSyntax]] throws ParserError {
        var r Region()
        var list List[StatementSyntax]$()
        while true
        {
            try let node parse_statement(rp, ep)
                when i: ParserError.Invalid
                    throw i
                when d: ParserError.Different
                {
                    if (*list).head = 0
                    {
                        throw d
                    } else {
                        return Vector[StatementSyntax]#(rp, *list)
                    }
                }

            (*list).add(node)
        }
    }

    function parse_statement(this: Parser) returns StatementSyntax throws ParserError {
        let start lexer.previous_position

        let command_start lexer.position
        try let command parse_command(rp, ep)
            when d: ParserError.Different throw d
            when i: ParserError.Invalid throw i

        let start_colon_2 lexer.previous_position
        let success_colon_2 lexer.parse_colon()

        let end lexer.position

        return StatementSyntax(start, end, command)
    }

    function parse_while(this: Parser) returns WhileSyntax throws ParserError {
        let start lexer.previous_position

        let start_while_1 lexer.previous_position
        let success_while_1 lexer.parse_keyword(*keywords_index.get(42))
        if success_while_1 = false
        {
            throw ParserError(DifferentSyntax())
        }

        let condition_start lexer.position
        try let condition parse_condition(rp, ep)
            when d: ParserError.Different
                throw InvalidSyntax(condition_start, lexer.position, String(ep, "a valid Condition syntax"))
            when i: ParserError.Invalid throw i

        let start_colon_3 lexer.previous_position
        let success_colon_3 lexer.parse_colon()
        if success_colon_3 = false
        {
            throw ParserError(InvalidSyntax(start_colon_3, lexer.position, String(ep, "a colon or a line feed")))        }

        let name_start lexer.position
        var name: pointer[LabelSyntax] null 
        choose parse_label(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set name: LabelSyntax#(success)

        let action_start lexer.position
        try let action parse_action(rp, ep)
            when d: ParserError.Different
                throw InvalidSyntax(action_start, lexer.position, String(ep, "a valid Action syntax"))
            when i: ParserError.Invalid throw i

        let end lexer.position

        return WhileSyntax(start, end, condition, name, action)
    }

    function parse_choose(this: Parser) returns ChooseSyntax throws ParserError {
        let start lexer.previous_position

        let start_choose_1 lexer.previous_position
        let success_choose_1 lexer.parse_keyword(*keywords_index.get(2))
        if success_choose_1 = false
        {
            throw ParserError(DifferentSyntax())
        }

        let condition_start lexer.position
        try let condition parse_operand_list(rp, ep)
            when d: ParserError.Different
                throw InvalidSyntax(condition_start, lexer.position, String(ep, "a valid Operand syntax"))
            when i: ParserError.Invalid throw i

        let start_colon_3 lexer.previous_position
        let success_colon_3 lexer.parse_colon()
        if success_colon_3 = false
        {
            throw ParserError(InvalidSyntax(start_colon_3, lexer.position, String(ep, "a colon or a line feed")))        }

        let cases_start lexer.position
        var cases: pointer[Vector[WhenSyntax]] null 
        choose parse_when_list(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set cases: success

        let alternative_start lexer.position
        var alternative: pointer[ElseSyntax] null 
        choose parse_else(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set alternative: ElseSyntax#(success)

        let end lexer.position

        return ChooseSyntax(start, end, condition, cases, alternative)
    }

    function parse_try(this: Parser) returns TrySyntax throws ParserError {
        let start lexer.previous_position

        let start_try_1 lexer.previous_position
        let success_try_1 lexer.parse_keyword(*keywords_index.get(37))
        if success_try_1 = false
        {
            throw ParserError(DifferentSyntax())
        }

        let condition_start lexer.position
        try let condition parse_condition(rp, ep)
            when d: ParserError.Different
                throw InvalidSyntax(condition_start, lexer.position, String(ep, "a valid Condition syntax"))
            when i: ParserError.Invalid throw i

        let start_colon_3 lexer.previous_position
        let success_colon_3 lexer.parse_colon()
        if success_colon_3 = false
        {
            throw ParserError(InvalidSyntax(start_colon_3, lexer.position, String(ep, "a colon or a line feed")))        }

        let cases_start lexer.position
        var cases: pointer[Vector[WhenSyntax]] null 
        choose parse_when_list(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set cases: success

        let dropper_start lexer.position
        var dropper: pointer[ElseSyntax] null 
        choose parse_else(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set dropper: ElseSyntax#(success)

        let end lexer.position

        return TrySyntax(start, end, condition, cases, dropper)
    }

    function parse_condition(this: Parser) returns ConditionSyntax throws ParserError {
        {
            choose parse_operation(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return ConditionSyntax(OperationSyntax(node))
        }
        {
            choose parse_let(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return ConditionSyntax(LetSyntax(node))
        }
        throw ParserError(DifferentSyntax())
    }

    function parse_when_list(this: Parser) returns pointer[Vector[WhenSyntax]] throws ParserError {
        var r Region()
        var list List[WhenSyntax]$()
        while true
        {
            try let node parse_when(rp, ep)
                when i: ParserError.Invalid
                    throw i
                when d: ParserError.Different
                {
                    if (*list).head = 0
                    {
                        throw d
                    } else {
                        return Vector[WhenSyntax]#(rp, *list)
                    }
                }

            (*list).add(node)
        }
    }

    function parse_when(this: Parser) returns WhenSyntax throws ParserError {
        let start lexer.previous_position

        let start_when_1 lexer.previous_position
        let success_when_1 lexer.parse_keyword(*keywords_index.get(41))
        if success_when_1 = false
        {
            throw ParserError(DifferentSyntax())
        }

        let start_name lexer.previous_position
        let name lexer.parse_identifier(rp, keywords)
        if name = null
        {
            throw ParserError(InvalidSyntax(start_name, lexer.position, String(ep, "an identifier")))
        }

        let start_colon_3 lexer.previous_position
        let success_colon_3 lexer.parse_colon()
        if success_colon_3 = false
        {
            throw ParserError(InvalidSyntax(start_colon_3, lexer.position, String(ep, "a colon or a line feed")))        }

        let variant_start lexer.position
        try let variant parse_name(rp, ep)
            when d: ParserError.Different
                throw InvalidSyntax(variant_start, lexer.position, String(ep, "a valid Name syntax"))
            when i: ParserError.Invalid throw i

        let start_colon_5 lexer.previous_position
        let success_colon_5 lexer.parse_colon()

        let command_start lexer.position
        try let command parse_command(rp, ep)
            when d: ParserError.Different
                throw InvalidSyntax(command_start, lexer.position, String(ep, "a valid Command syntax"))
            when i: ParserError.Invalid throw i

        let start_colon_7 lexer.previous_position
        let success_colon_7 lexer.parse_colon()

        let end lexer.position

        return WhenSyntax(start, end, *name, variant, command)
    }

    function parse_command(this: Parser) returns CommandSyntax throws ParserError {
        {
            choose parse_operation(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return CommandSyntax(OperationSyntax(node))
        }
        {
            choose parse_let(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return CommandSyntax(LetSyntax(node))
        }
        {
            choose parse_var(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return CommandSyntax(VarSyntax(node))
        }
        {
            choose parse_mutable(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return CommandSyntax(MutableSyntax(node))
        }
        {
            choose parse_set(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return CommandSyntax(SetSyntax(node))
        }
        {
            choose parse_continue(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return CommandSyntax(ContinueSyntax(node))
        }
        {
            choose parse_break(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return CommandSyntax(BreakSyntax(node))
        }
        {
            choose parse_return(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return CommandSyntax(ReturnSyntax(node))
        }
        {
            choose parse_throw(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return CommandSyntax(ThrowSyntax(node))
        }
        throw ParserError(DifferentSyntax())
    }

    function parse_let(this: Parser) returns LetSyntax throws ParserError {
        let start lexer.previous_position

        let start_let_1 lexer.previous_position
        let success_let_1 lexer.parse_keyword(*keywords_index.get(20))
        if success_let_1 = false
        {
            throw ParserError(DifferentSyntax())
        }

        let binding_start lexer.position
        try let binding parse_binding(rp, ep)
            when d: ParserError.Different
                throw InvalidSyntax(binding_start, lexer.position, String(ep, "a valid Binding syntax"))
            when i: ParserError.Invalid throw i

        let end lexer.position

        return LetSyntax(start, end, binding)
    }

    function parse_var(this: Parser) returns VarSyntax throws ParserError {
        let start lexer.previous_position

        let start_var_1 lexer.previous_position
        let success_var_1 lexer.parse_keyword(*keywords_index.get(40))
        if success_var_1 = false
        {
            throw ParserError(DifferentSyntax())
        }

        let binding_start lexer.position
        try let binding parse_binding(rp, ep)
            when d: ParserError.Different
                throw InvalidSyntax(binding_start, lexer.position, String(ep, "a valid Binding syntax"))
            when i: ParserError.Invalid throw i

        let end lexer.position

        return VarSyntax(start, end, binding)
    }

    function parse_mutable(this: Parser) returns MutableSyntax throws ParserError {
        let start lexer.previous_position

        let start_mutable_1 lexer.previous_position
        let success_mutable_1 lexer.parse_keyword(*keywords_index.get(25))
        if success_mutable_1 = false
        {
            throw ParserError(DifferentSyntax())
        }

        let binding_start lexer.position
        try let binding parse_binding(rp, ep)
            when d: ParserError.Different
                throw InvalidSyntax(binding_start, lexer.position, String(ep, "a valid Binding syntax"))
            when i: ParserError.Invalid throw i

        let end lexer.position

        return MutableSyntax(start, end, binding)
    }

    function parse_binding(this: Parser) returns BindingSyntax throws ParserError {
        let start lexer.previous_position

        let start_name lexer.previous_position
        let name lexer.parse_identifier(rp, keywords)
        if name = null
        {
            throw ParserError(DifferentSyntax())

        }

        let annotation_start lexer.position
        var annotation: pointer[BindingAnnotationSyntax] null 
        choose parse_bindingannotation(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set annotation: BindingAnnotationSyntax#(success)

        let operation_start lexer.position
        try let operation parse_operand_list(rp, ep)
            when d: ParserError.Different
                throw InvalidSyntax(operation_start, lexer.position, String(ep, "a valid Operand syntax"))
            when i: ParserError.Invalid throw i

        let end lexer.position

        return BindingSyntax(start, end, *name, annotation, operation)
    }

    function parse_bindingannotation(this: Parser) returns BindingAnnotationSyntax throws ParserError {
        let start lexer.previous_position

        let start_colon_1 lexer.previous_position
        let success_colon_1 lexer.parse_colon()
        if success_colon_1 = false
        {
            throw ParserError(DifferentSyntax())
        }

        let spec_start lexer.position
        try let spec parse_bindingspec(rp, ep)
            when d: ParserError.Different
                throw InvalidSyntax(spec_start, lexer.position, String(ep, "a valid BindingSpec syntax"))
            when i: ParserError.Invalid throw i

        let end lexer.position

        return BindingAnnotationSyntax(start, end, spec)
    }

    function parse_bindingspec_list(this: Parser) returns pointer[Vector[BindingSpecSyntax]] throws ParserError {
        var r Region()
        var list List[BindingSpecSyntax]$()
        while true
        {
            try let node parse_bindingspec(rp, ep)
                when i: ParserError.Invalid
                    throw i
                when d: ParserError.Different
                {
                    if (*list).head = 0
                    {
                        throw d
                    } else {
                        return Vector[BindingSpecSyntax]#(rp, *list)
                    }
                }

            (*list).add(node)
        }
    }

    function parse_bindingspec(this: Parser) returns BindingSpecSyntax throws ParserError {
        {
            choose parse_structure(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return BindingSpecSyntax(StructureSyntax(node))
        }
        {
            choose parse_type(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return BindingSpecSyntax(TypeSyntax(node))
        }
        {
            choose parse_array(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return BindingSpecSyntax(ArraySyntax(node))
        }
        throw ParserError(DifferentSyntax())
    }

    function parse_array(this: Parser) returns ArraySyntax throws ParserError {
        let start lexer.previous_position

        let start_left_bracket_1 lexer.previous_position
        let success_left_bracket_1 lexer.parse_punctuation('[')
        if success_left_bracket_1 = false
        {
            throw ParserError(DifferentSyntax())
        }

        let members_start lexer.position
        var members: pointer[Vector[TypeSyntax]] null 
        choose parse_type_list(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set members: success

        let start_right_bracket_3 lexer.previous_position
        let success_right_bracket_3 lexer.parse_punctuation(']')
        if success_right_bracket_3 = false
        {
            throw ParserError(InvalidSyntax(start_right_bracket_3, lexer.position, String(ep, "]")))        }

        let end lexer.position

        return ArraySyntax(start, end, members)
    }

    function parse_structure(this: Parser) returns StructureSyntax throws ParserError {
        let start lexer.previous_position

        let start_left_paren_1 lexer.previous_position
        let success_left_paren_1 lexer.parse_punctuation('(')
        if success_left_paren_1 = false
        {
            throw ParserError(DifferentSyntax())
        }

        let parts_start lexer.position
        var parts: pointer[Vector[PartSyntax]] null 
        choose parse_part_list(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set parts: success

        let start_right_paren_3 lexer.previous_position
        let success_right_paren_3 lexer.parse_punctuation(')')
        if success_right_paren_3 = false
        {
            throw ParserError(InvalidSyntax(start_right_paren_3, lexer.position, String(ep, ")")))        }

        let end lexer.position

        return StructureSyntax(start, end, parts)
    }

    function parse_part_list(this: Parser) returns pointer[Vector[PartSyntax]] throws ParserError {
        var r Region()
        var list List[PartSyntax]$()
        while true
        {
            try let node parse_part(rp, ep)
                when i: ParserError.Invalid
                    throw i
                when d: ParserError.Different
                {
                    if (*list).head = 0
                    {
                        throw d
                    } else {
                        return Vector[PartSyntax]#(rp, *list)
                    }
                }

            (*list).add(node)
        }
    }

    function parse_part(this: Parser) returns PartSyntax throws ParserError {
        {
            choose parse_field(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return PartSyntax(FieldSyntax(node))
        }
        {
            choose parse_property(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return PartSyntax(PropertySyntax(node))
        }
        throw ParserError(DifferentSyntax())
    }

    function parse_field(this: Parser) returns FieldSyntax throws ParserError {
        let start lexer.previous_position

        let start_private_1 lexer.previous_position
        let success_private_1 lexer.parse_keyword(*keywords_index.get(28))
        if success_private_1 = false
        {
            throw ParserError(DifferentSyntax())
        }

        let property_start lexer.position
        try let property parse_property(rp, ep)
            when d: ParserError.Different
                throw InvalidSyntax(property_start, lexer.position, String(ep, "a valid Property syntax"))
            when i: ParserError.Invalid throw i

        let end lexer.position

        return FieldSyntax(start, end, property)
    }

    function parse_property_list(this: Parser) returns pointer[Vector[PropertySyntax]] throws ParserError {
        var r Region()
        var list List[PropertySyntax]$()
        while true
        {
            try let node parse_property(rp, ep)
                when i: ParserError.Invalid
                    throw i
                when d: ParserError.Different
                {
                    if (*list).head = 0
                    {
                        throw d
                    } else {
                        return Vector[PropertySyntax]#(rp, *list)
                    }
                }

            (*list).add(node)
        }
    }

    function parse_property(this: Parser) returns PropertySyntax throws ParserError {
        let start lexer.previous_position

        let start_name lexer.previous_position
        let name lexer.parse_identifier(rp, keywords)
        if name = null
        {
            throw ParserError(DifferentSyntax())

        }

        let annotation_start lexer.position
        try let annotation parse_typeannotation(rp, ep)
            when d: ParserError.Different
                throw InvalidSyntax(annotation_start, lexer.position, String(ep, "a valid TypeAnnotation syntax"))
            when i: ParserError.Invalid throw i

        let initializer_start lexer.position
        var initializer: pointer[InitializerSyntax] null 
        choose parse_initializer(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set initializer: InitializerSyntax#(success)

        let start_comma_4 lexer.previous_position
        let success_comma_4 lexer.parse_punctuation(',')

        let start_colon_5 lexer.previous_position
        let success_colon_5 lexer.parse_colon()

        let attributes_start lexer.position
        var attributes: pointer[Vector[AttributeSyntax]] null 
        choose parse_attribute_list(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set attributes: success

        let start_colon_7 lexer.previous_position
        let success_colon_7 lexer.parse_colon()

        let end lexer.position

        return PropertySyntax(start, end, *name, annotation, initializer, attributes)
    }

    function parse_typeannotation(this: Parser) returns TypeAnnotationSyntax throws ParserError {
        let start lexer.previous_position

        let start_colon_1 lexer.previous_position
        let success_colon_1 lexer.parse_colon()
        if success_colon_1 = false
        {
            throw ParserError(DifferentSyntax())
        }

        let type_start lexer.position
        try let type parse_type(rp, ep)
            when d: ParserError.Different
                throw InvalidSyntax(type_start, lexer.position, String(ep, "a valid Type syntax"))
            when i: ParserError.Invalid throw i

        let end lexer.position

        return TypeAnnotationSyntax(start, end, type)
    }

    function parse_continue(this: Parser) returns ContinueSyntax throws ParserError {
        let start lexer.previous_position

        let start_continue_1 lexer.previous_position
        let success_continue_1 lexer.parse_keyword(*keywords_index.get(3))
        if success_continue_1 = false
        {
            throw ParserError(DifferentSyntax())
        }

        let name_start lexer.position
        var name: pointer[LoopSyntax] null 
        choose parse_loop(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set name: LoopSyntax#(success)

        let start_colon_3 lexer.previous_position
        let success_colon_3 lexer.parse_colon()

        let end lexer.position

        return ContinueSyntax(start, end, name)
    }

    function parse_break(this: Parser) returns BreakSyntax throws ParserError {
        let start lexer.previous_position

        let start_break_1 lexer.previous_position
        let success_break_1 lexer.parse_keyword(*keywords_index.get(0))
        if success_break_1 = false
        {
            throw ParserError(DifferentSyntax())
        }

        let name_start lexer.position
        var name: pointer[LoopSyntax] null 
        choose parse_loop(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set name: LoopSyntax#(success)

        let result_start lexer.position
        var result: pointer[Vector[OperandSyntax]] null 
        choose parse_operand_list(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set result: success

        let start_colon_4 lexer.previous_position
        let success_colon_4 lexer.parse_colon()

        let end lexer.position

        return BreakSyntax(start, end, name, result)
    }

    function parse_loop(this: Parser) returns LoopSyntax throws ParserError {
        let start lexer.previous_position

        let start_loop_1 lexer.previous_position
        let success_loop_1 lexer.parse_keyword(*keywords_index.get(21))
        if success_loop_1 = false
        {
            throw ParserError(DifferentSyntax())
        }

        let start_name lexer.previous_position
        let name lexer.parse_identifier(rp, keywords)
        if name = null
        {
            throw ParserError(InvalidSyntax(start_name, lexer.position, String(ep, "an identifier")))
        }

        let end lexer.position

        return LoopSyntax(start, end, *name)
    }

    function parse_return(this: Parser) returns ReturnSyntax throws ParserError {
        let start lexer.previous_position

        let start_return_1 lexer.previous_position
        let success_return_1 lexer.parse_keyword(*keywords_index.get(29))
        if success_return_1 = false
        {
            throw ParserError(DifferentSyntax())
        }

        let result_start lexer.position
        var result: pointer[Vector[OperandSyntax]] null 
        choose parse_operand_list(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set result: success

        let end lexer.position

        return ReturnSyntax(start, end, result)
    }

    function parse_throw(this: Parser) returns ThrowSyntax throws ParserError {
        let start lexer.previous_position

        let start_throw_1 lexer.previous_position
        let success_throw_1 lexer.parse_keyword(*keywords_index.get(34))
        if success_throw_1 = false
        {
            throw ParserError(DifferentSyntax())
        }

        let result_start lexer.position
        var result: pointer[Vector[OperandSyntax]] null 
        choose parse_operand_list(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set result: success

        let end lexer.position

        return ThrowSyntax(start, end, result)
    }

    function parse_lambda(this: Parser) returns LambdaSyntax throws ParserError {
        let start lexer.previous_position

        let start_lambda_1 lexer.previous_position
        let success_lambda_1 lexer.parse_keyword(*keywords_index.get(19))
        if success_lambda_1 = false
        {
            throw ParserError(DifferentSyntax())
        }

        let input_start lexer.position
        try let input parse_operand_list(rp, ep)
            when d: ParserError.Different
                throw InvalidSyntax(input_start, lexer.position, String(ep, "a valid Operand syntax"))
            when i: ParserError.Invalid throw i

        let start_colon_3 lexer.previous_position
        let success_colon_3 lexer.parse_colon()
        if success_colon_3 = false
        {
            throw ParserError(InvalidSyntax(start_colon_3, lexer.position, String(ep, "a colon or a line feed")))        }

        let block_start lexer.position
        try let block parse_action(rp, ep)
            when d: ParserError.Different
                throw InvalidSyntax(block_start, lexer.position, String(ep, "a valid Action syntax"))
            when i: ParserError.Invalid throw i

        let end lexer.position

        return LambdaSyntax(start, end, input, block)
    }

    function parse_for(this: Parser) returns ForSyntax throws ParserError {
        let start lexer.previous_position

        let start_for_1 lexer.previous_position
        let success_for_1 lexer.parse_keyword(*keywords_index.get(10))
        if success_for_1 = false
        {
            throw ParserError(DifferentSyntax())
        }

        let start_variable lexer.previous_position
        let variable lexer.parse_identifier(rp, keywords)
        if variable = null
        {
            throw ParserError(InvalidSyntax(start_variable, lexer.position, String(ep, "an identifier")))
        }

        let annotation_start lexer.position
        var annotation: pointer[TypeAnnotationSyntax] null 
        choose parse_typeannotation(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set annotation: TypeAnnotationSyntax#(success)

        let start_in_4 lexer.previous_position
        let success_in_4 lexer.parse_keyword(*keywords_index.get(15))
        if success_in_4 = false
        {
            throw ParserError(InvalidSyntax(start_in_4, lexer.position, String(ep, "in")))        }

        let operation_start lexer.position
        try let operation parse_operand_list(rp, ep)
            when d: ParserError.Different
                throw InvalidSyntax(operation_start, lexer.position, String(ep, "a valid Operand syntax"))
            when i: ParserError.Invalid throw i

        let start_colon_6 lexer.previous_position
        let success_colon_6 lexer.parse_colon()
        if success_colon_6 = false
        {
            throw ParserError(InvalidSyntax(start_colon_6, lexer.position, String(ep, "a colon or a line feed")))        }

        let name_start lexer.position
        var name: pointer[LabelSyntax] null 
        choose parse_label(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set name: LabelSyntax#(success)

        let action_start lexer.position
        try let action parse_action(rp, ep)
            when d: ParserError.Different
                throw InvalidSyntax(action_start, lexer.position, String(ep, "a valid Action syntax"))
            when i: ParserError.Invalid throw i

        let end lexer.position

        return ForSyntax(start, end, *variable, annotation, operation, name, action)
    }

    function parse_label(this: Parser) returns LabelSyntax throws ParserError {
        let start lexer.previous_position

        let start_label_1 lexer.previous_position
        let success_label_1 lexer.parse_keyword(*keywords_index.get(18))
        if success_label_1 = false
        {
            throw ParserError(DifferentSyntax())
        }

        let start_name lexer.previous_position
        let name lexer.parse_identifier(rp, keywords)
        if name = null
        {
            throw ParserError(InvalidSyntax(start_name, lexer.position, String(ep, "an identifier")))
        }

        let start_colon_3 lexer.previous_position
        let success_colon_3 lexer.parse_colon()

        let end lexer.position

        return LabelSyntax(start, end, *name)
    }

    function parse_repeat(this: Parser) returns RepeatSyntax throws ParserError {
        let start lexer.previous_position

        let start_repeat_1 lexer.previous_position
        let success_repeat_1 lexer.parse_keyword(*keywords_index.get(31))
        if success_repeat_1 = false
        {
            throw ParserError(DifferentSyntax())
        }

        let name_start lexer.position
        var name: pointer[LabelSyntax] null 
        choose parse_label(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set name: LabelSyntax#(success)

        let action_start lexer.position
        try let action parse_action(rp, ep)
            when d: ParserError.Different
                throw InvalidSyntax(action_start, lexer.position, String(ep, "a valid Action syntax"))
            when i: ParserError.Invalid throw i

        let end lexer.position

        return RepeatSyntax(start, end, name, action)
    }

    function parse_action_list(this: Parser) returns pointer[Vector[ActionSyntax]] throws ParserError {
        var r Region()
        var list List[ActionSyntax]$()
        while true
        {
            try let node parse_action(rp, ep)
                when i: ParserError.Invalid
                    throw i
                when d: ParserError.Different
                {
                    if (*list).head = 0
                    {
                        throw d
                    } else {
                        return Vector[ActionSyntax]#(rp, *list)
                    }
                }

            (*list).add(node)
        }
    }

    function parse_action(this: Parser) returns ActionSyntax throws ParserError {
        {
            choose parse_operation(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return ActionSyntax(OperationSyntax(node))
        }
        {
            choose parse_set(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return ActionSyntax(SetSyntax(node))
        }
        throw ParserError(DifferentSyntax())
    }

    function parse_operation(this: Parser) returns OperationSyntax throws ParserError {
        let start lexer.previous_position

        let operands_start lexer.position
        try let operands parse_operand_list(rp, ep)
            when d: ParserError.Different throw d
            when i: ParserError.Invalid throw i

        let end lexer.position

        return OperationSyntax(start, end, operands)
    }

    function parse_set(this: Parser) returns SetSyntax throws ParserError {
        let start lexer.previous_position

        let start_set_1 lexer.previous_position
        let success_set_1 lexer.parse_keyword(*keywords_index.get(32))
        if success_set_1 = false
        {
            throw ParserError(DifferentSyntax())
        }

        let target_start lexer.position
        try let target parse_operand_list(rp, ep)
            when d: ParserError.Different
                throw InvalidSyntax(target_start, lexer.position, String(ep, "a valid Operand syntax"))
            when i: ParserError.Invalid throw i

        let start_colon_3 lexer.previous_position
        let success_colon_3 lexer.parse_colon()
        if success_colon_3 = false
        {
            throw ParserError(InvalidSyntax(start_colon_3, lexer.position, String(ep, "a colon or a line feed")))        }

        let source_start lexer.position
        try let source parse_operand_list(rp, ep)
            when d: ParserError.Different
                throw InvalidSyntax(source_start, lexer.position, String(ep, "a valid Operand syntax"))
            when i: ParserError.Invalid throw i

        let end lexer.position

        return SetSyntax(start, end, target, source)
    }

    function parse_sizeof(this: Parser) returns SizeOfSyntax throws ParserError {
        let start lexer.previous_position

        let start_sizeof_1 lexer.previous_position
        let success_sizeof_1 lexer.parse_keyword(*keywords_index.get(33))
        if success_sizeof_1 = false
        {
            throw ParserError(DifferentSyntax())
        }

        let type_start lexer.position
        try let type parse_type(rp, ep)
            when d: ParserError.Different
                throw InvalidSyntax(type_start, lexer.position, String(ep, "a valid Type syntax"))
            when i: ParserError.Invalid throw i

        let end lexer.position

        return SizeOfSyntax(start, end, type)
    }

    function parse_type_list(this: Parser) returns pointer[Vector[TypeSyntax]] throws ParserError {
        var r Region()
        var list List[TypeSyntax]$()
        while true
        {
            try let node parse_type(rp, ep)
                when i: ParserError.Invalid
                    throw i
                when d: ParserError.Different
                {
                    if (*list).head = 0
                    {
                        throw d
                    } else {
                        return Vector[TypeSyntax]#(rp, *list)
                    }
                }

            (*list).add(node)
        }
    }

    function parse_type(this: Parser) returns TypeSyntax throws ParserError {
        let start lexer.previous_position

        let name_start lexer.position
        try let name parse_name(rp, ep)
            when d: ParserError.Different throw d
            when i: ParserError.Invalid throw i

        let generics_start lexer.position
        var generics: pointer[GenericArgumentsSyntax] null 
        choose parse_genericarguments(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set generics: GenericArgumentsSyntax#(success)

        let optional_start lexer.position
        var optional: pointer[OptionalSyntax] null 
        choose parse_optional(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set optional: OptionalSyntax#(success)

        let lifetime_start lexer.position
        var lifetime: pointer[LifetimeSyntax] null 
        choose parse_lifetime(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set lifetime: LifetimeSyntax#(success)

        let end lexer.position

        return TypeSyntax(start, end, name, generics, optional, lifetime)
    }

    function parse_name(this: Parser) returns NameSyntax throws ParserError {
        let start lexer.previous_position

        let start_name lexer.previous_position
        let name lexer.parse_identifier(rp, keywords)
        if name = null
        {
            throw ParserError(DifferentSyntax())

        }

        let extensions_start lexer.position
        var extensions: pointer[Vector[ExtensionSyntax]] null 
        choose parse_extension_list(rp, ep)
            when error: Success.Error
            {
                choose error
                    when d: ParserError.Different {}
                    when i: ParserError.Invalid
                        throw i
            }
            when success: Success.Ok
                set extensions: success

        let end lexer.position

        return NameSyntax(start, end, *name, extensions)
    }

    function parse_extension_list(this: Parser) returns pointer[Vector[ExtensionSyntax]] throws ParserError {
        var r Region()
        var list List[ExtensionSyntax]$()
        while true
        {
            try let node parse_extension(rp, ep)
                when i: ParserError.Invalid
                    throw i
                when d: ParserError.Different
                {
                    if (*list).head = 0
                    {
                        throw d
                    } else {
                        return Vector[ExtensionSyntax]#(rp, *list)
                    }
                }

            (*list).add(node)
        }
    }

    function parse_extension(this: Parser) returns ExtensionSyntax throws ParserError {
        let start lexer.previous_position

        let start_dot_1 lexer.previous_position
        let success_dot_1 lexer.parse_punctuation('.')
        if success_dot_1 = false
        {
            throw ParserError(DifferentSyntax())
        }

        let start_name lexer.previous_position
        let name lexer.parse_identifier(rp, keywords)
        if name = null
        {
            throw ParserError(InvalidSyntax(start_name, lexer.position, String(ep, "an identifier")))
        }

        let end lexer.position

        return ExtensionSyntax(start, end, *name)
    }

    function parse_lifetime(this: Parser) returns LifetimeSyntax throws ParserError {
        {
            choose parse_call(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return LifetimeSyntax(CallSyntax(node))
        }
        {
            choose parse_local(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return LifetimeSyntax(LocalSyntax(node))
        }
        {
            choose parse_reference(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return LifetimeSyntax(ReferenceSyntax(node))
        }
        {
            choose parse_thrown(rp, ep)
                when error: Success.Error
                {
                    choose error
                        when i: ParserError.Invalid throw i
                        when d: ParserError.Different {}
                }
                when node: Success.Ok
                    return LifetimeSyntax(ThrownSyntax(node))
        }
        throw ParserError(DifferentSyntax())
    }

    function parse_call(this: Parser) returns CallSyntax throws ParserError {
        let start lexer.previous_position

        let start_hash_1 lexer.previous_position
        let success_hash_1 lexer.parse_punctuation('#')
        if success_hash_1 = false
        {
            throw ParserError(DifferentSyntax())
        }

        let end lexer.position

        return CallSyntax(start, end)
    }

    function parse_local(this: Parser) returns LocalSyntax throws ParserError {
        let start lexer.previous_position

        let start_dollar_1 lexer.previous_position
        let success_dollar_1 lexer.parse_punctuation('$')
        if success_dollar_1 = false
        {
            throw ParserError(DifferentSyntax())
        }

        let end lexer.position

        return LocalSyntax(start, end)
    }

    function parse_reference(this: Parser) returns ReferenceSyntax throws ParserError {
        let start lexer.previous_position

        let start_caret_1 lexer.previous_position
        let success_caret_1 lexer.parse_punctuation('^')
        if success_caret_1 = false
        {
            throw ParserError(DifferentSyntax())
        }

        let start_location lexer.previous_position
        let location lexer.parse_identifier(rp, keywords)
        if location = null
        {
            throw ParserError(InvalidSyntax(start_location, lexer.position, String(ep, "an identifier")))
        }

        let end lexer.position

        return ReferenceSyntax(start, end, *location)
    }

    function parse_thrown(this: Parser) returns ThrownSyntax throws ParserError {
        let start lexer.previous_position

        let start_exclamation_1 lexer.previous_position
        let success_exclamation_1 lexer.parse_punctuation('!')
        if success_exclamation_1 = false
        {
            throw ParserError(DifferentSyntax())
        }

        let end lexer.position

        return ThrownSyntax(start, end)
    }

    function is_at_end(this: Parser) returns bool {
        return lexer.is_at_end()
    }
}

