use scaly.containers
define IdentifierLiteral(name: String)
define StringLiteral(value: String)
define CharacterLiteral(value: String)
define FragmentLiteral(value: String)
define IntegerLiteral(value: String)
define BooleanLiteral(value: bool)
define FloatingPointLiteral(value: String)
define HexLiteral(value: String)

define Literal union (
    String: StringLiteral
    Character: CharacterLiteral
    Fragment: FragmentLiteral
    Integer: IntegerLiteral
    Boolean: BooleanLiteral
    FloatingPoint: FloatingPointLiteral
    Hex: HexLiteral
)

define ThrownSyntax
(
    start: size_t
    end: size_t
)

define ReferenceSyntax
(
    start: size_t
    end: size_t
    location: String
)

define LocalSyntax
(
    start: size_t
    end: size_t
)

define CallSyntax
(
    start: size_t
    end: size_t
)

define LifetimeSyntax union (
    Call: CallSyntax
    Local: LocalSyntax
    Reference: ReferenceSyntax
    Thrown: ThrownSyntax
)

define ExtensionSyntax
(
    start: size_t
    end: size_t
    name: String
)

define NameSyntax
(
    start: size_t
    end: size_t
    name: String
    extensions: pointer[Vector[ExtensionSyntax]]
)

define TypeSyntax
(
    start: size_t
    end: size_t
    name: NameSyntax
    generics: pointer[GenericArgumentsSyntax]
    optional: pointer[OptionalSyntax]
    lifetime: pointer[LifetimeSyntax]
)

define SizeOfSyntax
(
    start: size_t
    end: size_t
    type: TypeSyntax
)

define SetSyntax
(
    start: size_t
    end: size_t
    target: Vector[OperandSyntax]
    source: Vector[OperandSyntax]
)

define OperationSyntax
(
    start: size_t
    end: size_t
    operands: Vector[OperandSyntax]
)

define ActionSyntax union (
    Operation: OperationSyntax
    Set: SetSyntax
)

define RepeatSyntax
(
    start: size_t
    end: size_t
    name: pointer[LabelSyntax]
    action: ActionSyntax
)

define LabelSyntax
(
    start: size_t
    end: size_t
    name: String
)

define ForSyntax
(
    start: size_t
    end: size_t
    variable: String
    annotation: pointer[TypeAnnotationSyntax]
    operation: Vector[OperandSyntax]
    name: pointer[LabelSyntax]
    action: ActionSyntax
)

define LambdaSyntax
(
    start: size_t
    end: size_t
    input: Vector[OperandSyntax]
    block: ActionSyntax
)

define ThrowSyntax
(
    start: size_t
    end: size_t
    result: pointer[Vector[OperandSyntax]]
)

define ReturnSyntax
(
    start: size_t
    end: size_t
    result: pointer[Vector[OperandSyntax]]
)

define LoopSyntax
(
    start: size_t
    end: size_t
    name: String
)

define BreakSyntax
(
    start: size_t
    end: size_t
    name: pointer[LoopSyntax]
    result: pointer[Vector[OperandSyntax]]
)

define ContinueSyntax
(
    start: size_t
    end: size_t
    name: pointer[LoopSyntax]
)

define TypeAnnotationSyntax
(
    start: size_t
    end: size_t
    type: TypeSyntax
)

define PropertySyntax
(
    start: size_t
    end: size_t
    name: String
    annotation: TypeAnnotationSyntax
    initializer: pointer[InitializerSyntax]
    attributes: pointer[Vector[AttributeSyntax]]
)

define FieldSyntax
(
    start: size_t
    end: size_t
    property: PropertySyntax
)

define PartSyntax union (
    Field: FieldSyntax
    Property: PropertySyntax
)

define StructureSyntax
(
    start: size_t
    end: size_t
    parts: pointer[Vector[PartSyntax]]
)

define ArraySyntax
(
    start: size_t
    end: size_t
    members: pointer[Vector[TypeSyntax]]
)

define BindingSpecSyntax union (
    Structure: StructureSyntax
    Type: TypeSyntax
    Array: ArraySyntax
)

define BindingAnnotationSyntax
(
    start: size_t
    end: size_t
    spec: BindingSpecSyntax
)

define BindingSyntax
(
    start: size_t
    end: size_t
    name: String
    annotation: pointer[BindingAnnotationSyntax]
    operation: Vector[OperandSyntax]
)

define MutableSyntax
(
    start: size_t
    end: size_t
    binding: BindingSyntax
)

define VarSyntax
(
    start: size_t
    end: size_t
    binding: BindingSyntax
)

define LetSyntax
(
    start: size_t
    end: size_t
    binding: BindingSyntax
)

define WhenSyntax
(
    start: size_t
    end: size_t
    name: String
    variant: NameSyntax
    action: ActionSyntax
)

define ConditionSyntax union (
    Operation: OperationSyntax
    Let: LetSyntax
)

define TrySyntax
(
    start: size_t
    end: size_t
    condition: ConditionSyntax
    cases: pointer[Vector[WhenSyntax]]
    dropper: pointer[DefaultSyntax]
)

define ChooseSyntax
(
    start: size_t
    end: size_t
    condition: Vector[OperandSyntax]
    cases: pointer[Vector[WhenSyntax]]
    alternative: pointer[DefaultSyntax]
)

define WhileSyntax
(
    start: size_t
    end: size_t
    condition: ConditionSyntax
    name: pointer[LabelSyntax]
    action: ActionSyntax
)

define CommandSyntax union (
    Operation: OperationSyntax
    Let: LetSyntax
    Var: VarSyntax
    Mutable: MutableSyntax
    Set: SetSyntax
    Continue: ContinueSyntax
    Break: BreakSyntax
    Return: ReturnSyntax
    Throw: ThrowSyntax
)

define StatementSyntax
(
    start: size_t
    end: size_t
    command: CommandSyntax
)

define DefaultSyntax
(
    start: size_t
    end: size_t
    alternative: CommandSyntax
)

define CaseSyntax
(
    start: size_t
    end: size_t
    condition: Vector[OperandSyntax]
)

define BranchSyntax
(
    start: size_t
    end: size_t
    cases: Vector[CaseSyntax]
    consequent: StatementSyntax
)

define MatchSyntax
(
    start: size_t
    end: size_t
    scrutinee: Vector[OperandSyntax]
    branches: Vector[BranchSyntax]
    alternative: pointer[DefaultSyntax]
)

define ElseSyntax
(
    start: size_t
    end: size_t
    alternative: CommandSyntax
)

define IfSyntax
(
    start: size_t
    end: size_t
    condition: Vector[OperandSyntax]
    consequent: CommandSyntax
    alternative: pointer[ElseSyntax]
)

define BlockSyntax
(
    start: size_t
    end: size_t
    uses: pointer[Vector[UseSyntax]]
    statements: pointer[Vector[StatementSyntax]]
)

define ElementSyntax
(
    start: size_t
    end: size_t
    operation: Vector[OperandSyntax]
    attributes: pointer[Vector[AttributeSyntax]]
)

define VectorSyntax
(
    start: size_t
    end: size_t
    elements: Vector[ElementSyntax]
    lifetime: pointer[LifetimeSyntax]
)

define ValueSyntax
(
    start: size_t
    end: size_t
    value: Vector[OperandSyntax]
    attributes: pointer[Vector[AttributeSyntax]]
)

define ComponentSyntax
(
    start: size_t
    end: size_t
    operands: Vector[OperandSyntax]
    attributes: pointer[Vector[AttributeSyntax]]
    value: pointer[ValueSyntax]
)

define ObjectSyntax
(
    start: size_t
    end: size_t
    components: pointer[Vector[ComponentSyntax]]
)

define LiteralSyntax
(
    start: size_t
    end: size_t
    literal: Literal
)

define ExpressionSyntax union (
    Literal: LiteralSyntax
    Type: TypeSyntax
    Object: ObjectSyntax
    Vector: VectorSyntax
    Block: BlockSyntax
    If: IfSyntax
    Match: MatchSyntax
    Lambda: LambdaSyntax
    For: ForSyntax
    While: WhileSyntax
    Choose: ChooseSyntax
    Try: TrySyntax
    Repeat: RepeatSyntax
    SizeOf: SizeOfSyntax
)

define MemberAccessSyntax
(
    start: size_t
    end: size_t
    name: NameSyntax
)

define OperandSyntax
(
    start: size_t
    end: size_t
    expression: ExpressionSyntax
    members: pointer[Vector[MemberAccessSyntax]]
)

define InitializerSyntax
(
    start: size_t
    end: size_t
    operands: Vector[OperandSyntax]
)

define PackageSyntax
(
    start: size_t
    end: size_t
    name: NameSyntax
)

define ModuleSyntax
(
    start: size_t
    end: size_t
    name: String
)

define ModelSyntax union (
    Literal: LiteralSyntax
    Name: NameSyntax
    Object: ObjectSyntax
    Vector: VectorSyntax
)

define AttributeSyntax
(
    start: size_t
    end: size_t
    name: String
    model: ModelSyntax
)

define MacroSyntax
(
    start: size_t
    end: size_t
    name: String
    model: ModelSyntax
    rule: Vector[OperandSyntax]
)

define ExtendSyntax
(
    start: size_t
    end: size_t
    type: TypeSyntax
)

define ExtendsSyntax
(
    start: size_t
    end: size_t
    extensions: pointer[Vector[ExtendSyntax]]
)

define IntrinsicSyntax
(
    start: size_t
    end: size_t
)

define InstructionSyntax
(
    start: size_t
    end: size_t
)

define ExternSyntax
(
    start: size_t
    end: size_t
)

define ImplementationSyntax union (
    Action: ActionSyntax
    Extern: ExternSyntax
    Instruction: InstructionSyntax
    Intrinsic: IntrinsicSyntax
)

define RoutineSyntax
(
    start: size_t
    end: size_t
    generics: pointer[GenericArgumentsSyntax]
    lifetime: pointer[LifetimeSyntax]
    parameters: pointer[ParameterSetSyntax]
    attributes: pointer[Vector[AttributeSyntax]]
    returns_: pointer[ReturnsSyntax]
    throws_: pointer[ThrowsSyntax]
    implementation: ImplementationSyntax
)

define NamedSyntax
(
    start: size_t
    end: size_t
    name: String
    routine: RoutineSyntax
)

define TargetSyntax union (
    Named: NamedSyntax
    Routine: RoutineSyntax
)

define OperatorSyntax
(
    start: size_t
    end: size_t
    target: TargetSyntax
)

define ProcedureSyntax
(
    start: size_t
    end: size_t
    target: TargetSyntax
)

define FunctionSyntax
(
    start: size_t
    end: size_t
    target: TargetSyntax
)

define DeInitSyntax
(
    start: size_t
    end: size_t
    action: ActionSyntax
)

define InitSyntax
(
    start: size_t
    end: size_t
    parameters: pointer[ParameterSetSyntax]
    action: ActionSyntax
)

define MethodSyntax union (
    Function: FunctionSyntax
    Procedure: ProcedureSyntax
    Operator: OperatorSyntax
)

define TraitSyntax
(
    start: size_t
    end: size_t
    name: NameSyntax
    extension: pointer[ExtendsSyntax]
    attributes: pointer[Vector[AttributeSyntax]]
    uses: pointer[Vector[UseSyntax]]
    functions: pointer[Vector[MethodSyntax]]
)

define ImplementSyntax
(
    start: size_t
    end: size_t
    type: TypeSyntax
    attributes: pointer[Vector[AttributeSyntax]]
    uses: pointer[Vector[UseSyntax]]
    methods: pointer[Vector[MethodSyntax]]
)

define UseSyntax
(
    start: size_t
    end: size_t
    name: NameSyntax
)

define ThrowsSyntax
(
    start: size_t
    end: size_t
    type: TypeSyntax
    attributes: pointer[Vector[AttributeSyntax]]
)

define ReturnsSyntax
(
    start: size_t
    end: size_t
    type: TypeSyntax
    attributes: pointer[Vector[AttributeSyntax]]
)

define ItemSyntax
(
    start: size_t
    end: size_t
    name: String
    annotation: pointer[TypeAnnotationSyntax]
    attributes: pointer[Vector[AttributeSyntax]]
)

define ParametersSyntax
(
    start: size_t
    end: size_t
    items: pointer[Vector[ItemSyntax]]
)

define ParameterSetSyntax union (
    Parameters: ParametersSyntax
    Type: TypeSyntax
)

define OptionalSyntax
(
    start: size_t
    end: size_t
)

define GenericArgumentSyntax
(
    start: size_t
    end: size_t
    type: TypeSyntax
)

define GenericArgumentsSyntax
(
    start: size_t
    end: size_t
    generics: pointer[Vector[GenericArgumentSyntax]]
)

define DelegateSyntax
(
    start: size_t
    end: size_t
    parameters: pointer[ParameterSetSyntax]
    attributes: pointer[Vector[AttributeSyntax]]
    result: pointer[ReturnsSyntax]
    error: pointer[ThrowsSyntax]
)

define ConstantSyntax
(
    start: size_t
    end: size_t
    type: TypeSyntax
    operation: Vector[OperandSyntax]
)

define VariantSyntax
(
    start: size_t
    end: size_t
    name: String
    attributes: pointer[Vector[AttributeSyntax]]
    annotation: pointer[TypeAnnotationSyntax]
)

define UnionSyntax
(
    start: size_t
    end: size_t
    variants: Vector[VariantSyntax]
)

define NamespaceSyntax
(
    start: size_t
    end: size_t
    uses: pointer[Vector[UseSyntax]]
    declarations: pointer[Vector[DeclarationSyntax]]
)

define BodySyntax
(
    start: size_t
    end: size_t
    uses: pointer[Vector[UseSyntax]]
    inits: pointer[Vector[InitSyntax]]
    deInit: pointer[DeInitSyntax]
    members: pointer[Vector[MemberSyntax]]
)

define ClassSyntax
(
    start: size_t
    end: size_t
    structure: StructureSyntax
    body: pointer[BodySyntax]
)

define ConceptSyntax union (
    Class: ClassSyntax
    Namespace: NamespaceSyntax
    Union: UnionSyntax
    Constant: ConstantSyntax
    Delegate: DelegateSyntax
    Intrinsic: IntrinsicSyntax
)

define GenericParameterSyntax
(
    start: size_t
    end: size_t
    name: String
    attributes: pointer[Vector[AttributeSyntax]]
)

define GenericParametersSyntax
(
    start: size_t
    end: size_t
    parameters: Vector[GenericParameterSyntax]
)

define DefinitionSyntax
(
    start: size_t
    end: size_t
    name: String
    parameters: pointer[GenericParametersSyntax]
    attributes: pointer[Vector[AttributeSyntax]]
    concept_: ConceptSyntax
)

define ConstituentSyntax union (
    Definition: DefinitionSyntax
    Function: FunctionSyntax
    Procedure: ProcedureSyntax
    Operator: OperatorSyntax
    Implement: ImplementSyntax
    Trait: TraitSyntax
    Macro: MacroSyntax
    Module: ModuleSyntax
)

define MemberSyntax
(
    start: size_t
    end: size_t
    constituent: ConstituentSyntax
)

define ExportSyntax union (
    Definition: DefinitionSyntax
    Function: FunctionSyntax
    Operator: OperatorSyntax
    Trait: TraitSyntax
    Module: ModuleSyntax
)

define PrivateSyntax
(
    start: size_t
    end: size_t
    export_: ExportSyntax
)

define SymbolSyntax union (
    Private: PrivateSyntax
    Definition: DefinitionSyntax
    Function: FunctionSyntax
    Operator: OperatorSyntax
    Trait: TraitSyntax
    Macro: MacroSyntax
    Module: ModuleSyntax
)

define DeclarationSyntax
(
    start: size_t
    end: size_t
    symbol: SymbolSyntax
)

define FileSyntax
(
    start: size_t
    end: size_t
    packages: pointer[Vector[PackageSyntax]]
    uses: pointer[Vector[UseSyntax]]
    declarations: pointer[Vector[DeclarationSyntax]]
)

define ProgramSyntax
(
    start: size_t
    end: size_t
    file: FileSyntax
    statements: pointer[Vector[StatementSyntax]]
)

define Parser
(
    lexer: Lexer
    keywords_index: Vector[String]
    keywords: HashSet[String]
)
{
    init(text: String) (lexer(Lexer(text))) (keywords_index(initialize_keywords_index())) (keywords(initialize_keywords())) {}

    function initialize_keywords_index(this: Parser) returns Vector[String]$ {
        var r Region()
        var keywords_builder Array[String]$()
        var p Page->get(this)
        (*keywords_builder).add(String(p, "break"))
        (*keywords_builder).add(String(p, "case"))
        (*keywords_builder).add(String(p, "choose"))
        (*keywords_builder).add(String(p, "continue"))
        (*keywords_builder).add(String(p, "define"))
        (*keywords_builder).add(String(p, "default"))
        (*keywords_builder).add(String(p, "deinit"))
        (*keywords_builder).add(String(p, "delegate"))
        (*keywords_builder).add(String(p, "else"))
        (*keywords_builder).add(String(p, "extends"))
        (*keywords_builder).add(String(p, "extern"))
        (*keywords_builder).add(String(p, "for"))
        (*keywords_builder).add(String(p, "function"))
        (*keywords_builder).add(String(p, "if"))
        (*keywords_builder).add(String(p, "init"))
        (*keywords_builder).add(String(p, "implement"))
        (*keywords_builder).add(String(p, "in"))
        (*keywords_builder).add(String(p, "instruction"))
        (*keywords_builder).add(String(p, "intrinsic"))
        (*keywords_builder).add(String(p, "label"))
        (*keywords_builder).add(String(p, "lambda"))
        (*keywords_builder).add(String(p, "let"))
        (*keywords_builder).add(String(p, "loop"))
        (*keywords_builder).add(String(p, "macro"))
        (*keywords_builder).add(String(p, "match"))
        (*keywords_builder).add(String(p, "module"))
        (*keywords_builder).add(String(p, "mutable"))
        (*keywords_builder).add(String(p, "operator"))
        (*keywords_builder).add(String(p, "procedure"))
        (*keywords_builder).add(String(p, "private"))
        (*keywords_builder).add(String(p, "return"))
        (*keywords_builder).add(String(p, "returns"))
        (*keywords_builder).add(String(p, "repeat"))
        (*keywords_builder).add(String(p, "set"))
        (*keywords_builder).add(String(p, "sizeof"))
        (*keywords_builder).add(String(p, "throw"))
        (*keywords_builder).add(String(p, "throws"))
        (*keywords_builder).add(String(p, "trait"))
        (*keywords_builder).add(String(p, "try"))
        (*keywords_builder).add(String(p, "union"))
        (*keywords_builder).add(String(p, "use"))
        (*keywords_builder).add(String(p, "var"))
        (*keywords_builder).add(String(p, "when"))
        (*keywords_builder).add(String(p, "while"))
        (*keywords_builder).add(String(p, "package"))
        return Vector[String](p, *keywords_builder)
    }

    function initialize_keywords(this: Parser) returns HashSet[String]$ {
        var r Region()
        var hash_set_builder HashSetBuilder[String]$(keywords_index)
        return HashSet[String](Page->get(this), *hash_set_builder)
    }

    function parse_literal_token(this: Parser) returns Literal throws ParserError {
        choose lexer.token
            when empty: Token.Empty lexer.advance()
            default {}

        choose lexer.token
            when literal: Token.Literal
            {
                choose literal
                    when string: LiteralToken.String {
                        let ret Literal(StringLiteral(String(rp, string.value)))
                        lexer.empty()
                        return ret
                    }

                    when character: LiteralToken.Character {
                        let ret Literal(CharacterLiteral(String(rp, character.value)))
                        lexer.empty()
                        return ret
                    }

                    when integer: LiteralToken.Integer {
                        let ret Literal(IntegerLiteral(String(rp, integer.value)))
                        lexer.empty()
                        return ret
                    }

                    when fp: LiteralToken.FloatingPoint {
                        let ret Literal(FloatingPointLiteral(String(rp, fp.value)))
                        lexer.empty()
                        return ret
                    }

                    when hex: LiteralToken.Hex {
                        let ret Literal(HexLiteral(String(rp, hex.value)))
                        lexer.empty()
                        return ret
                    }

                    when boolean: LiteralToken.Boolean {
                        let ret Literal(BooleanLiteral(boolean.value))
                        lexer.empty()
                        return ret
                    }

                    when fragment: LiteralToken.Fragment {
                        let ret Literal(FragmentLiteral(String(rp, fragment.value)))
                        lexer.empty()
                        return ret
                    }
            }
            default
                return Result[Literal, ParserError](ParserError(DifferentSyntax()))
    }

    function parse_program(this: Parser) returns ProgramSyntax throws ParserError {
        let start = lexer.previous_position

        let file_start = lexer.position
        let file_result = parse_file(rp, ep)
        choose file_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax throw d
                    when i: ParserError.InvalidSyntax throw i
            }
        let file = file_result._Ok
    
        let statements_start = lexer.position
        let statements_result = parse_statement_list(rp, ep)
        choose statements_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax {}
                    when i: ParserError.InvalidSyntax throw i
            }
        let statements = statements_result._tag == Result[Vector[StatementSyntax], ParserError]::Error ? nullptr : statements_result._Ok
    
        let end = lexer.position

        let ret = ProgramSyntax(start, end, file, statements)

        return Result[ProgramSyntax, ParserError] { ._tag = Result[ProgramSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_file(this: Parser) returns FileSyntax throws ParserError {
        let start = lexer.previous_position

        let packages_start = lexer.position
        let packages_result = parse_package_list(rp, ep)
        choose packages_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax {}
                    when i: ParserError.InvalidSyntax throw i
            }
        let packages = packages_result._tag == Result[Vector[PackageSyntax], ParserError]::Error ? nullptr : packages_result._Ok
    
        let uses_start = lexer.position
        let uses_result = parse_use_list(rp, ep)
        choose uses_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax {}
                    when i: ParserError.InvalidSyntax throw i
            }
        let uses = uses_result._tag == Result[Vector[UseSyntax], ParserError]::Error ? nullptr : uses_result._Ok
    
        let declarations_start = lexer.position
        let declarations_result = parse_declaration_list(rp, ep)
        choose declarations_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax {}
                    when i: ParserError.InvalidSyntax throw i
            }
        let declarations = declarations_result._tag == Result[Vector[DeclarationSyntax], ParserError]::Error ? nullptr : declarations_result._Ok
    
        let end = lexer.position

        let ret = FileSyntax(start, end, packages, uses, declarations)

        return Result[FileSyntax, ParserError] { ._tag = Result[FileSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_declaration_list(this: Parser) returns pointer[Vector[DeclarationSyntax]] throws ParserError {
        var r Region()
        List<DeclarationSyntax]& list = *new(alignof(List<DeclarationSyntax]), _r.get_page()) List<DeclarationSyntax]()
        while(true) {
            let node_result = parse_declaration(rp, ep)
            if ((node_result._tag == Result[DeclarationSyntax, ParserError]::Error) && (node_result._Error._tag == ParserError::InvalidSyntax))
                return Result[Vector<DeclarationSyntax]*, ParserError] { ._tag = Result[Vector<DeclarationSyntax]*, ParserError]::Error, ._Error = node_result._Error }
            if (node_result._tag == Result[DeclarationSyntax, ParserError]::Ok) {
                let node = node_result._Ok
                list.add(node)
            } else {
                if ((list.count() == 0) && (node_result._tag == Result[DeclarationSyntax, ParserError]::Error) && (node_result._Error._tag == ParserError::DifferentSyntax))
                    return Result[Vector<DeclarationSyntax]*, ParserError] { ._tag = Result[Vector<DeclarationSyntax]*, ParserError]::Error, ._Error = node_result._Error }
                break
            }
        }

        if (list.count() == 0)
            return Result[Vector<DeclarationSyntax]*, ParserError] { ._tag = Result[Vector<DeclarationSyntax]*, ParserError]::Ok, ._Ok = nullptr }
        
        return Result[Vector<DeclarationSyntax]*, ParserError] {
            ._tag = Result[Vector<DeclarationSyntax]*, ParserError]::Ok,
            ._Ok = new(alignof(Vector<DeclarationSyntax]), _rp) Vector<DeclarationSyntax](_rp, list) }
    }

    function parse_declaration(this: Parser) returns DeclarationSyntax throws ParserError {
        let start = lexer.previous_position

        let symbol_start = lexer.position
        let symbol_result = parse_symbol(rp, ep)
        choose symbol_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax throw d
                    when i: ParserError.InvalidSyntax throw i
            }
        let symbol = symbol_result._Ok
    
        let start_colon_2 = lexer.previous_position
        let success_colon_2 = lexer.parse_colon(_rp)
        if (!success_colon_2) {
        }

        let end = lexer.position

        let ret = DeclarationSyntax(start, end, symbol)

        return Result[DeclarationSyntax, ParserError] { ._tag = Result[DeclarationSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_symbol(this: Parser) returns SymbolSyntax throws ParserError {
        try let node parse_private(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnSymbolSyntax(PrivateSyntax(node))
        try let node parse_definition(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnSymbolSyntax(DefinitionSyntax(node))
        try let node parse_function(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnSymbolSyntax(FunctionSyntax(node))
        try let node parse_operator(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnSymbolSyntax(OperatorSyntax(node))
        try let node parse_trait(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnSymbolSyntax(TraitSyntax(node))
        try let node parse_macro(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnSymbolSyntax(MacroSyntax(node))
        try let node parse_module(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnSymbolSyntax(ModuleSyntax(node))
        throw ParserError(DifferentSyntax())
    }

    function parse_private(this: Parser) returns PrivateSyntax throws ParserError {
        let start = lexer.previous_position

        let start_private_1 = lexer.previous_position
        let success_private_1 = lexer.parse_keyword(_rp, *keywords_index[29])
        if (!success_private_1) {
            return Result[PrivateSyntax, ParserError] { ._tag = Result[PrivateSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }
        }

        let export__start = lexer.position
        let export__result = parse_export(rp, ep)
        choose export__result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax
                        throw InvalidSyntax(export__start, lexer.position, String(ep, "a valid Export syntax"))
                    when i: ParserError.InvalidSyntax throw i
            }
        let export_ = export__result._Ok
    
        let end = lexer.position

        let ret = PrivateSyntax(start, end, export_)

        return Result[PrivateSyntax, ParserError] { ._tag = Result[PrivateSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_export(this: Parser) returns ExportSyntax throws ParserError {
        try let node parse_definition(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnExportSyntax(DefinitionSyntax(node))
        try let node parse_function(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnExportSyntax(FunctionSyntax(node))
        try let node parse_operator(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnExportSyntax(OperatorSyntax(node))
        try let node parse_trait(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnExportSyntax(TraitSyntax(node))
        try let node parse_module(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnExportSyntax(ModuleSyntax(node))
        throw ParserError(DifferentSyntax())
    }

    function parse_member_list(this: Parser) returns pointer[Vector[MemberSyntax]] throws ParserError {
        var r Region()
        List<MemberSyntax]& list = *new(alignof(List<MemberSyntax]), _r.get_page()) List<MemberSyntax]()
        while(true) {
            let node_result = parse_member(rp, ep)
            if ((node_result._tag == Result[MemberSyntax, ParserError]::Error) && (node_result._Error._tag == ParserError::InvalidSyntax))
                return Result[Vector<MemberSyntax]*, ParserError] { ._tag = Result[Vector<MemberSyntax]*, ParserError]::Error, ._Error = node_result._Error }
            if (node_result._tag == Result[MemberSyntax, ParserError]::Ok) {
                let node = node_result._Ok
                list.add(node)
            } else {
                if ((list.count() == 0) && (node_result._tag == Result[MemberSyntax, ParserError]::Error) && (node_result._Error._tag == ParserError::DifferentSyntax))
                    return Result[Vector<MemberSyntax]*, ParserError] { ._tag = Result[Vector<MemberSyntax]*, ParserError]::Error, ._Error = node_result._Error }
                break
            }
        }

        if (list.count() == 0)
            return Result[Vector<MemberSyntax]*, ParserError] { ._tag = Result[Vector<MemberSyntax]*, ParserError]::Ok, ._Ok = nullptr }
        
        return Result[Vector<MemberSyntax]*, ParserError] {
            ._tag = Result[Vector<MemberSyntax]*, ParserError]::Ok,
            ._Ok = new(alignof(Vector<MemberSyntax]), _rp) Vector<MemberSyntax](_rp, list) }
    }

    function parse_member(this: Parser) returns MemberSyntax throws ParserError {
        let start = lexer.previous_position

        let constituent_start = lexer.position
        let constituent_result = parse_constituent(rp, ep)
        choose constituent_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax throw d
                    when i: ParserError.InvalidSyntax throw i
            }
        let constituent = constituent_result._Ok
    
        let start_colon_2 = lexer.previous_position
        let success_colon_2 = lexer.parse_colon(_rp)
        if (!success_colon_2) {
        }

        let end = lexer.position

        let ret = MemberSyntax(start, end, constituent)

        return Result[MemberSyntax, ParserError] { ._tag = Result[MemberSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_constituent(this: Parser) returns ConstituentSyntax throws ParserError {
        try let node parse_definition(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnConstituentSyntax(DefinitionSyntax(node))
        try let node parse_function(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnConstituentSyntax(FunctionSyntax(node))
        try let node parse_procedure(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnConstituentSyntax(ProcedureSyntax(node))
        try let node parse_operator(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnConstituentSyntax(OperatorSyntax(node))
        try let node parse_implement(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnConstituentSyntax(ImplementSyntax(node))
        try let node parse_trait(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnConstituentSyntax(TraitSyntax(node))
        try let node parse_macro(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnConstituentSyntax(MacroSyntax(node))
        try let node parse_module(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnConstituentSyntax(ModuleSyntax(node))
        throw ParserError(DifferentSyntax())
    }

    function parse_definition(this: Parser) returns DefinitionSyntax throws ParserError {
        let start = lexer.previous_position

        let start_define_1 = lexer.previous_position
        let success_define_1 = lexer.parse_keyword(_rp, *keywords_index[4])
        if (!success_define_1) {
            return Result[DefinitionSyntax, ParserError] { ._tag = Result[DefinitionSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }
        }

        let start_name = lexer.previous_position
        let name = lexer.parse_identifier(_rp, keywords)
        if (name == nullptr)
        {
            return Result[DefinitionSyntax, ParserError] { ._tag = Result[DefinitionSyntax, ParserError]::Error, ._Error = ParserError(InvalidSyntax(start_name, lexer.position, String(_ep, "an identifier"))) }
        }

        let parameters_start = lexer.position
        let parameters_result = parse_genericparameters(rp, ep)
        if (parameters_result._tag == Result[GenericParametersSyntax, ParserError]::Error)
        {
            switch (parameters_result._Error._tag) {
                case ParserError::DifferentSyntax:
                    break
                case ParserError::InvalidSyntax:
                    return Result[DefinitionSyntax, ParserError] { ._tag = Result[DefinitionSyntax, ParserError]::Error, ._Error = parameters_result._Error }
            }
        }

        GenericParametersSyntax* parameters = parameters_result._tag == Result[GenericParametersSyntax, ParserError]::Error ? nullptr : new(alignof(GenericParametersSyntax), _rp) GenericParametersSyntax(parameters_result._Ok)
    
        let start_colon_4 = lexer.previous_position
        let success_colon_4 = lexer.parse_colon(_rp)
        if (!success_colon_4) {
        }

        let attributes_start = lexer.position
        let attributes_result = parse_attribute_list(rp, ep)
        choose attributes_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax {}
                    when i: ParserError.InvalidSyntax throw i
            }
        let attributes = attributes_result._tag == Result[Vector[AttributeSyntax], ParserError]::Error ? nullptr : attributes_result._Ok
    
        let concept__start = lexer.position
        let concept__result = parse_concept(rp, ep)
        choose concept__result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax
                        throw InvalidSyntax(concept__start, lexer.position, String(ep, "a valid Concept syntax"))
                    when i: ParserError.InvalidSyntax throw i
            }
        let concept_ = concept__result._Ok
    
        let end = lexer.position

        let ret = DefinitionSyntax(start, end, *name, parameters, attributes, concept_)

        return Result[DefinitionSyntax, ParserError] { ._tag = Result[DefinitionSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_genericparameters(this: Parser) returns GenericParametersSyntax throws ParserError {
        let start = lexer.previous_position

        let start_left_bracket_1 = lexer.previous_position
        let success_left_bracket_1 = lexer.parse_punctuation('[')
        if (!success_left_bracket_1) {
            return Result[GenericParametersSyntax, ParserError] { ._tag = Result[GenericParametersSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }
        }

        let parameters_start = lexer.position
        let parameters_result = parse_genericparameter_list(rp, ep)
        choose parameters_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax
                        throw InvalidSyntax(parameters_start, lexer.position, String(ep, "a valid GenericParameter syntax"))
                    when i: ParserError.InvalidSyntax throw i
            }
        let parameters = parameters_result._Ok
    
        let start_right_bracket_3 = lexer.previous_position
        let success_right_bracket_3 = lexer.parse_punctuation(']')
        if (!success_right_bracket_3) {
            return Result[GenericParametersSyntax, ParserError] { ._tag = Result[GenericParametersSyntax, ParserError]::Error, ._Error = ParserError(InvalidSyntax(start_right_bracket_3, lexer.position, String(_ep, "]"))) }        }

        let end = lexer.position

        let ret = GenericParametersSyntax(start, end, parameters)

        return Result[GenericParametersSyntax, ParserError] { ._tag = Result[GenericParametersSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_genericparameter_list(this: Parser) returns pointer[Vector[GenericParameterSyntax]] throws ParserError {
        var r Region()
        List<GenericParameterSyntax]& list = *new(alignof(List<GenericParameterSyntax]), _r.get_page()) List<GenericParameterSyntax]()
        while(true) {
            let node_result = parse_genericparameter(rp, ep)
            if ((node_result._tag == Result[GenericParameterSyntax, ParserError]::Error) && (node_result._Error._tag == ParserError::InvalidSyntax))
                return Result[Vector<GenericParameterSyntax]*, ParserError] { ._tag = Result[Vector<GenericParameterSyntax]*, ParserError]::Error, ._Error = node_result._Error }
            if (node_result._tag == Result[GenericParameterSyntax, ParserError]::Ok) {
                let node = node_result._Ok
                list.add(node)
            } else {
                if ((list.count() == 0) && (node_result._tag == Result[GenericParameterSyntax, ParserError]::Error) && (node_result._Error._tag == ParserError::DifferentSyntax))
                    return Result[Vector<GenericParameterSyntax]*, ParserError] { ._tag = Result[Vector<GenericParameterSyntax]*, ParserError]::Error, ._Error = node_result._Error }
                break
            }
        }

        if (list.count() == 0)
            return Result[Vector<GenericParameterSyntax]*, ParserError] { ._tag = Result[Vector<GenericParameterSyntax]*, ParserError]::Ok, ._Ok = nullptr }
        
        return Result[Vector<GenericParameterSyntax]*, ParserError] {
            ._tag = Result[Vector<GenericParameterSyntax]*, ParserError]::Ok,
            ._Ok = new(alignof(Vector<GenericParameterSyntax]), _rp) Vector<GenericParameterSyntax](_rp, list) }
    }

    function parse_genericparameter(this: Parser) returns GenericParameterSyntax throws ParserError {
        let start = lexer.previous_position

        let start_name = lexer.previous_position
        let name = lexer.parse_identifier(_rp, keywords)
        if (name == nullptr)
        {
            return Result[GenericParameterSyntax, ParserError] { ._tag = Result[GenericParameterSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }

        }

        let attributes_start = lexer.position
        let attributes_result = parse_attribute_list(rp, ep)
        choose attributes_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax {}
                    when i: ParserError.InvalidSyntax throw i
            }
        let attributes = attributes_result._tag == Result[Vector[AttributeSyntax], ParserError]::Error ? nullptr : attributes_result._Ok
    
        let start_comma_3 = lexer.previous_position
        let success_comma_3 = lexer.parse_punctuation(',')
        if (!success_comma_3) {
        }

        let end = lexer.position

        let ret = GenericParameterSyntax(start, end, *name, attributes)

        return Result[GenericParameterSyntax, ParserError] { ._tag = Result[GenericParameterSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_concept(this: Parser) returns ConceptSyntax throws ParserError {
        try let node parse_class(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnConceptSyntax(ClassSyntax(node))
        try let node parse_namespace(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnConceptSyntax(NamespaceSyntax(node))
        try let node parse_union(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnConceptSyntax(UnionSyntax(node))
        try let node parse_constant(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnConceptSyntax(ConstantSyntax(node))
        try let node parse_delegate(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnConceptSyntax(DelegateSyntax(node))
        try let node parse_intrinsic(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnConceptSyntax(IntrinsicSyntax(node))
        throw ParserError(DifferentSyntax())
    }

    function parse_class(this: Parser) returns ClassSyntax throws ParserError {
        let start = lexer.previous_position

        let structure_start = lexer.position
        let structure_result = parse_structure(rp, ep)
        choose structure_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax throw d
                    when i: ParserError.InvalidSyntax throw i
            }
        let structure = structure_result._Ok
    
        let start_colon_2 = lexer.previous_position
        let success_colon_2 = lexer.parse_colon(_rp)
        if (!success_colon_2) {
        }

        let body_start = lexer.position
        let body_result = parse_body(rp, ep)
        if (body_result._tag == Result[BodySyntax, ParserError]::Error)
        {
            switch (body_result._Error._tag) {
                case ParserError::DifferentSyntax:
                    break
                case ParserError::InvalidSyntax:
                    return Result[ClassSyntax, ParserError] { ._tag = Result[ClassSyntax, ParserError]::Error, ._Error = body_result._Error }
            }
        }

        BodySyntax* body = body_result._tag == Result[BodySyntax, ParserError]::Error ? nullptr : new(alignof(BodySyntax), _rp) BodySyntax(body_result._Ok)
    
        let start_colon_4 = lexer.previous_position
        let success_colon_4 = lexer.parse_colon(_rp)
        if (!success_colon_4) {
        }

        let end = lexer.position

        let ret = ClassSyntax(start, end, structure, body)

        return Result[ClassSyntax, ParserError] { ._tag = Result[ClassSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_body(this: Parser) returns BodySyntax throws ParserError {
        let start = lexer.previous_position

        let start_left_curly_1 = lexer.previous_position
        let success_left_curly_1 = lexer.parse_punctuation('{')
        if (!success_left_curly_1) {
            return Result[BodySyntax, ParserError] { ._tag = Result[BodySyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }
        }

        let uses_start = lexer.position
        let uses_result = parse_use_list(rp, ep)
        choose uses_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax {}
                    when i: ParserError.InvalidSyntax throw i
            }
        let uses = uses_result._tag == Result[Vector[UseSyntax], ParserError]::Error ? nullptr : uses_result._Ok
    
        let inits_start = lexer.position
        let inits_result = parse_init_list(rp, ep)
        choose inits_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax {}
                    when i: ParserError.InvalidSyntax throw i
            }
        let inits = inits_result._tag == Result[Vector[InitSyntax], ParserError]::Error ? nullptr : inits_result._Ok
    
        let deInit_start = lexer.position
        let deInit_result = parse_deinit(rp, ep)
        if (deInit_result._tag == Result[DeInitSyntax, ParserError]::Error)
        {
            switch (deInit_result._Error._tag) {
                case ParserError::DifferentSyntax:
                    break
                case ParserError::InvalidSyntax:
                    return Result[BodySyntax, ParserError] { ._tag = Result[BodySyntax, ParserError]::Error, ._Error = deInit_result._Error }
            }
        }

        DeInitSyntax* deInit = deInit_result._tag == Result[DeInitSyntax, ParserError]::Error ? nullptr : new(alignof(DeInitSyntax), _rp) DeInitSyntax(deInit_result._Ok)
    
        let members_start = lexer.position
        let members_result = parse_member_list(rp, ep)
        choose members_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax {}
                    when i: ParserError.InvalidSyntax throw i
            }
        let members = members_result._tag == Result[Vector[MemberSyntax], ParserError]::Error ? nullptr : members_result._Ok
    
        let start_right_curly_6 = lexer.previous_position
        let success_right_curly_6 = lexer.parse_punctuation('}')
        if (!success_right_curly_6) {
            return Result[BodySyntax, ParserError] { ._tag = Result[BodySyntax, ParserError]::Error, ._Error = ParserError(InvalidSyntax(start_right_curly_6, lexer.position, String(_ep, "}"))) }        }

        let start_colon_7 = lexer.previous_position
        let success_colon_7 = lexer.parse_colon(_rp)
        if (!success_colon_7) {
        }

        let end = lexer.position

        let ret = BodySyntax(start, end, uses, inits, deInit, members)

        return Result[BodySyntax, ParserError] { ._tag = Result[BodySyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_namespace(this: Parser) returns NamespaceSyntax throws ParserError {
        let start = lexer.previous_position

        let start_left_curly_1 = lexer.previous_position
        let success_left_curly_1 = lexer.parse_punctuation('{')
        if (!success_left_curly_1) {
            return Result[NamespaceSyntax, ParserError] { ._tag = Result[NamespaceSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }
        }

        let uses_start = lexer.position
        let uses_result = parse_use_list(rp, ep)
        choose uses_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax {}
                    when i: ParserError.InvalidSyntax throw i
            }
        let uses = uses_result._tag == Result[Vector[UseSyntax], ParserError]::Error ? nullptr : uses_result._Ok
    
        let declarations_start = lexer.position
        let declarations_result = parse_declaration_list(rp, ep)
        choose declarations_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax {}
                    when i: ParserError.InvalidSyntax throw i
            }
        let declarations = declarations_result._tag == Result[Vector[DeclarationSyntax], ParserError]::Error ? nullptr : declarations_result._Ok
    
        let start_right_curly_4 = lexer.previous_position
        let success_right_curly_4 = lexer.parse_punctuation('}')
        if (!success_right_curly_4) {
            return Result[NamespaceSyntax, ParserError] { ._tag = Result[NamespaceSyntax, ParserError]::Error, ._Error = ParserError(InvalidSyntax(start_right_curly_4, lexer.position, String(_ep, "}"))) }        }

        let start_colon_5 = lexer.previous_position
        let success_colon_5 = lexer.parse_colon(_rp)
        if (!success_colon_5) {
        }

        let end = lexer.position

        let ret = NamespaceSyntax(start, end, uses, declarations)

        return Result[NamespaceSyntax, ParserError] { ._tag = Result[NamespaceSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_union(this: Parser) returns UnionSyntax throws ParserError {
        let start = lexer.previous_position

        let start_union_1 = lexer.previous_position
        let success_union_1 = lexer.parse_keyword(_rp, *keywords_index[39])
        if (!success_union_1) {
            return Result[UnionSyntax, ParserError] { ._tag = Result[UnionSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }
        }

        let start_colon_2 = lexer.previous_position
        let success_colon_2 = lexer.parse_colon(_rp)
        if (!success_colon_2) {
        }

        let start_left_paren_3 = lexer.previous_position
        let success_left_paren_3 = lexer.parse_punctuation('(')
        if (!success_left_paren_3) {
            return Result[UnionSyntax, ParserError] { ._tag = Result[UnionSyntax, ParserError]::Error, ._Error = ParserError(InvalidSyntax(start_left_paren_3, lexer.position, String(_ep, "("))) }        }

        let variants_start = lexer.position
        let variants_result = parse_variant_list(rp, ep)
        choose variants_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax
                        throw InvalidSyntax(variants_start, lexer.position, String(ep, "a valid Variant syntax"))
                    when i: ParserError.InvalidSyntax throw i
            }
        let variants = variants_result._Ok
    
        let start_right_paren_5 = lexer.previous_position
        let success_right_paren_5 = lexer.parse_punctuation(')')
        if (!success_right_paren_5) {
            return Result[UnionSyntax, ParserError] { ._tag = Result[UnionSyntax, ParserError]::Error, ._Error = ParserError(InvalidSyntax(start_right_paren_5, lexer.position, String(_ep, ")"))) }        }

        let start_colon_6 = lexer.previous_position
        let success_colon_6 = lexer.parse_colon(_rp)
        if (!success_colon_6) {
        }

        let end = lexer.position

        let ret = UnionSyntax(start, end, variants)

        return Result[UnionSyntax, ParserError] { ._tag = Result[UnionSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_variant_list(this: Parser) returns pointer[Vector[VariantSyntax]] throws ParserError {
        var r Region()
        List<VariantSyntax]& list = *new(alignof(List<VariantSyntax]), _r.get_page()) List<VariantSyntax]()
        while(true) {
            let node_result = parse_variant(rp, ep)
            if ((node_result._tag == Result[VariantSyntax, ParserError]::Error) && (node_result._Error._tag == ParserError::InvalidSyntax))
                return Result[Vector<VariantSyntax]*, ParserError] { ._tag = Result[Vector<VariantSyntax]*, ParserError]::Error, ._Error = node_result._Error }
            if (node_result._tag == Result[VariantSyntax, ParserError]::Ok) {
                let node = node_result._Ok
                list.add(node)
            } else {
                if ((list.count() == 0) && (node_result._tag == Result[VariantSyntax, ParserError]::Error) && (node_result._Error._tag == ParserError::DifferentSyntax))
                    return Result[Vector<VariantSyntax]*, ParserError] { ._tag = Result[Vector<VariantSyntax]*, ParserError]::Error, ._Error = node_result._Error }
                break
            }
        }

        if (list.count() == 0)
            return Result[Vector<VariantSyntax]*, ParserError] { ._tag = Result[Vector<VariantSyntax]*, ParserError]::Ok, ._Ok = nullptr }
        
        return Result[Vector<VariantSyntax]*, ParserError] {
            ._tag = Result[Vector<VariantSyntax]*, ParserError]::Ok,
            ._Ok = new(alignof(Vector<VariantSyntax]), _rp) Vector<VariantSyntax](_rp, list) }
    }

    function parse_variant(this: Parser) returns VariantSyntax throws ParserError {
        let start = lexer.previous_position

        let start_name = lexer.previous_position
        let name = lexer.parse_identifier(_rp, keywords)
        if (name == nullptr)
        {
            return Result[VariantSyntax, ParserError] { ._tag = Result[VariantSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }

        }

        let attributes_start = lexer.position
        let attributes_result = parse_attribute_list(rp, ep)
        choose attributes_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax {}
                    when i: ParserError.InvalidSyntax throw i
            }
        let attributes = attributes_result._tag == Result[Vector[AttributeSyntax], ParserError]::Error ? nullptr : attributes_result._Ok
    
        let annotation_start = lexer.position
        let annotation_result = parse_typeannotation(rp, ep)
        if (annotation_result._tag == Result[TypeAnnotationSyntax, ParserError]::Error)
        {
            switch (annotation_result._Error._tag) {
                case ParserError::DifferentSyntax:
                    break
                case ParserError::InvalidSyntax:
                    return Result[VariantSyntax, ParserError] { ._tag = Result[VariantSyntax, ParserError]::Error, ._Error = annotation_result._Error }
            }
        }

        TypeAnnotationSyntax* annotation = annotation_result._tag == Result[TypeAnnotationSyntax, ParserError]::Error ? nullptr : new(alignof(TypeAnnotationSyntax), _rp) TypeAnnotationSyntax(annotation_result._Ok)
    
        let start_comma_4 = lexer.previous_position
        let success_comma_4 = lexer.parse_punctuation(',')
        if (!success_comma_4) {
        }

        let start_colon_5 = lexer.previous_position
        let success_colon_5 = lexer.parse_colon(_rp)
        if (!success_colon_5) {
        }

        let end = lexer.position

        let ret = VariantSyntax(start, end, *name, attributes, annotation)

        return Result[VariantSyntax, ParserError] { ._tag = Result[VariantSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_constant(this: Parser) returns ConstantSyntax throws ParserError {
        let start = lexer.previous_position

        let type_start = lexer.position
        let type_result = parse_type(rp, ep)
        choose type_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax throw d
                    when i: ParserError.InvalidSyntax throw i
            }
        let type = type_result._Ok
    
        let operation_start = lexer.position
        let operation_result = parse_operand_list(rp, ep)
        choose operation_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax
                        throw InvalidSyntax(operation_start, lexer.position, String(ep, "a valid Operand syntax"))
                    when i: ParserError.InvalidSyntax throw i
            }
        let operation = operation_result._Ok
    
        let start_colon_3 = lexer.previous_position
        let success_colon_3 = lexer.parse_colon(_rp)
        if (!success_colon_3) {
        }

        let end = lexer.position

        let ret = ConstantSyntax(start, end, type, operation)

        return Result[ConstantSyntax, ParserError] { ._tag = Result[ConstantSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_delegate(this: Parser) returns DelegateSyntax throws ParserError {
        let start = lexer.previous_position

        let start_delegate_1 = lexer.previous_position
        let success_delegate_1 = lexer.parse_keyword(_rp, *keywords_index[7])
        if (!success_delegate_1) {
            return Result[DelegateSyntax, ParserError] { ._tag = Result[DelegateSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }
        }

        let parameters_start = lexer.position
        let parameters_result = parse_parameterset(rp, ep)
        if (parameters_result._tag == Result[ParameterSetSyntax, ParserError]::Error)
        {
            switch (parameters_result._Error._tag) {
                case ParserError::DifferentSyntax:
                    break
                case ParserError::InvalidSyntax:
                    return Result[DelegateSyntax, ParserError] { ._tag = Result[DelegateSyntax, ParserError]::Error, ._Error = parameters_result._Error }
            }
        }

        ParameterSetSyntax* parameters = parameters_result._tag == Result[ParameterSetSyntax, ParserError]::Error ? nullptr : new(alignof(ParameterSetSyntax), _rp) ParameterSetSyntax(parameters_result._Ok)
    
        let attributes_start = lexer.position
        let attributes_result = parse_attribute_list(rp, ep)
        choose attributes_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax {}
                    when i: ParserError.InvalidSyntax throw i
            }
        let attributes = attributes_result._tag == Result[Vector[AttributeSyntax], ParserError]::Error ? nullptr : attributes_result._Ok
    
        let result_start = lexer.position
        let result_result = parse_returns(rp, ep)
        if (result_result._tag == Result[ReturnsSyntax, ParserError]::Error)
        {
            switch (result_result._Error._tag) {
                case ParserError::DifferentSyntax:
                    break
                case ParserError::InvalidSyntax:
                    return Result[DelegateSyntax, ParserError] { ._tag = Result[DelegateSyntax, ParserError]::Error, ._Error = result_result._Error }
            }
        }

        ReturnsSyntax* result = result_result._tag == Result[ReturnsSyntax, ParserError]::Error ? nullptr : new(alignof(ReturnsSyntax), _rp) ReturnsSyntax(result_result._Ok)
    
        let error_start = lexer.position
        let error_result = parse_throws(rp, ep)
        if (error_result._tag == Result[ThrowsSyntax, ParserError]::Error)
        {
            switch (error_result._Error._tag) {
                case ParserError::DifferentSyntax:
                    break
                case ParserError::InvalidSyntax:
                    return Result[DelegateSyntax, ParserError] { ._tag = Result[DelegateSyntax, ParserError]::Error, ._Error = error_result._Error }
            }
        }

        ThrowsSyntax* error = error_result._tag == Result[ThrowsSyntax, ParserError]::Error ? nullptr : new(alignof(ThrowsSyntax), _rp) ThrowsSyntax(error_result._Ok)
    
        let end = lexer.position

        let ret = DelegateSyntax(start, end, parameters, attributes, result, error)

        return Result[DelegateSyntax, ParserError] { ._tag = Result[DelegateSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_genericarguments(this: Parser) returns GenericArgumentsSyntax throws ParserError {
        let start = lexer.previous_position

        let start_left_bracket_1 = lexer.previous_position
        let success_left_bracket_1 = lexer.parse_punctuation('[')
        if (!success_left_bracket_1) {
            return Result[GenericArgumentsSyntax, ParserError] { ._tag = Result[GenericArgumentsSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }
        }

        let generics_start = lexer.position
        let generics_result = parse_genericargument_list(rp, ep)
        choose generics_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax {}
                    when i: ParserError.InvalidSyntax throw i
            }
        let generics = generics_result._tag == Result[Vector[GenericArgumentSyntax], ParserError]::Error ? nullptr : generics_result._Ok
    
        let start_right_bracket_3 = lexer.previous_position
        let success_right_bracket_3 = lexer.parse_punctuation(']')
        if (!success_right_bracket_3) {
            return Result[GenericArgumentsSyntax, ParserError] { ._tag = Result[GenericArgumentsSyntax, ParserError]::Error, ._Error = ParserError(InvalidSyntax(start_right_bracket_3, lexer.position, String(_ep, "]"))) }        }

        let end = lexer.position

        let ret = GenericArgumentsSyntax(start, end, generics)

        return Result[GenericArgumentsSyntax, ParserError] { ._tag = Result[GenericArgumentsSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_genericargument_list(this: Parser) returns pointer[Vector[GenericArgumentSyntax]] throws ParserError {
        var r Region()
        List<GenericArgumentSyntax]& list = *new(alignof(List<GenericArgumentSyntax]), _r.get_page()) List<GenericArgumentSyntax]()
        while(true) {
            let node_result = parse_genericargument(rp, ep)
            if ((node_result._tag == Result[GenericArgumentSyntax, ParserError]::Error) && (node_result._Error._tag == ParserError::InvalidSyntax))
                return Result[Vector<GenericArgumentSyntax]*, ParserError] { ._tag = Result[Vector<GenericArgumentSyntax]*, ParserError]::Error, ._Error = node_result._Error }
            if (node_result._tag == Result[GenericArgumentSyntax, ParserError]::Ok) {
                let node = node_result._Ok
                list.add(node)
            } else {
                if ((list.count() == 0) && (node_result._tag == Result[GenericArgumentSyntax, ParserError]::Error) && (node_result._Error._tag == ParserError::DifferentSyntax))
                    return Result[Vector<GenericArgumentSyntax]*, ParserError] { ._tag = Result[Vector<GenericArgumentSyntax]*, ParserError]::Error, ._Error = node_result._Error }
                break
            }
        }

        if (list.count() == 0)
            return Result[Vector<GenericArgumentSyntax]*, ParserError] { ._tag = Result[Vector<GenericArgumentSyntax]*, ParserError]::Ok, ._Ok = nullptr }
        
        return Result[Vector<GenericArgumentSyntax]*, ParserError] {
            ._tag = Result[Vector<GenericArgumentSyntax]*, ParserError]::Ok,
            ._Ok = new(alignof(Vector<GenericArgumentSyntax]), _rp) Vector<GenericArgumentSyntax](_rp, list) }
    }

    function parse_genericargument(this: Parser) returns GenericArgumentSyntax throws ParserError {
        let start = lexer.previous_position

        let type_start = lexer.position
        let type_result = parse_type(rp, ep)
        choose type_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax throw d
                    when i: ParserError.InvalidSyntax throw i
            }
        let type = type_result._Ok
    
        let start_comma_2 = lexer.previous_position
        let success_comma_2 = lexer.parse_punctuation(',')
        if (!success_comma_2) {
        }

        let end = lexer.position

        let ret = GenericArgumentSyntax(start, end, type)

        return Result[GenericArgumentSyntax, ParserError] { ._tag = Result[GenericArgumentSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_optional(this: Parser) returns OptionalSyntax throws ParserError {
        let start = lexer.previous_position

        let start_question_1 = lexer.previous_position
        let success_question_1 = lexer.parse_punctuation('?')
        if (!success_question_1) {
            return Result[OptionalSyntax, ParserError] { ._tag = Result[OptionalSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }
        }

        let end = lexer.position

        let ret = OptionalSyntax(start, end)

        return Result[OptionalSyntax, ParserError] { ._tag = Result[OptionalSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_parameterset(this: Parser) returns ParameterSetSyntax throws ParserError {
        try let node parse_parameters(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnParameterSetSyntax(ParametersSyntax(node))
        try let node parse_type(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnParameterSetSyntax(TypeSyntax(node))
        throw ParserError(DifferentSyntax())
    }

    function parse_parameters(this: Parser) returns ParametersSyntax throws ParserError {
        let start = lexer.previous_position

        let start_left_paren_1 = lexer.previous_position
        let success_left_paren_1 = lexer.parse_punctuation('(')
        if (!success_left_paren_1) {
            return Result[ParametersSyntax, ParserError] { ._tag = Result[ParametersSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }
        }

        let items_start = lexer.position
        let items_result = parse_item_list(rp, ep)
        choose items_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax {}
                    when i: ParserError.InvalidSyntax throw i
            }
        let items = items_result._tag == Result[Vector[ItemSyntax], ParserError]::Error ? nullptr : items_result._Ok
    
        let start_right_paren_3 = lexer.previous_position
        let success_right_paren_3 = lexer.parse_punctuation(')')
        if (!success_right_paren_3) {
            return Result[ParametersSyntax, ParserError] { ._tag = Result[ParametersSyntax, ParserError]::Error, ._Error = ParserError(InvalidSyntax(start_right_paren_3, lexer.position, String(_ep, ")"))) }        }

        let end = lexer.position

        let ret = ParametersSyntax(start, end, items)

        return Result[ParametersSyntax, ParserError] { ._tag = Result[ParametersSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_item_list(this: Parser) returns pointer[Vector[ItemSyntax]] throws ParserError {
        var r Region()
        List<ItemSyntax]& list = *new(alignof(List<ItemSyntax]), _r.get_page()) List<ItemSyntax]()
        while(true) {
            let node_result = parse_item(rp, ep)
            if ((node_result._tag == Result[ItemSyntax, ParserError]::Error) && (node_result._Error._tag == ParserError::InvalidSyntax))
                return Result[Vector<ItemSyntax]*, ParserError] { ._tag = Result[Vector<ItemSyntax]*, ParserError]::Error, ._Error = node_result._Error }
            if (node_result._tag == Result[ItemSyntax, ParserError]::Ok) {
                let node = node_result._Ok
                list.add(node)
            } else {
                if ((list.count() == 0) && (node_result._tag == Result[ItemSyntax, ParserError]::Error) && (node_result._Error._tag == ParserError::DifferentSyntax))
                    return Result[Vector<ItemSyntax]*, ParserError] { ._tag = Result[Vector<ItemSyntax]*, ParserError]::Error, ._Error = node_result._Error }
                break
            }
        }

        if (list.count() == 0)
            return Result[Vector<ItemSyntax]*, ParserError] { ._tag = Result[Vector<ItemSyntax]*, ParserError]::Ok, ._Ok = nullptr }
        
        return Result[Vector<ItemSyntax]*, ParserError] {
            ._tag = Result[Vector<ItemSyntax]*, ParserError]::Ok,
            ._Ok = new(alignof(Vector<ItemSyntax]), _rp) Vector<ItemSyntax](_rp, list) }
    }

    function parse_item(this: Parser) returns ItemSyntax throws ParserError {
        let start = lexer.previous_position

        let start_name = lexer.previous_position
        let name = lexer.parse_identifier(_rp, keywords)
        if (name == nullptr)
        {
            return Result[ItemSyntax, ParserError] { ._tag = Result[ItemSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }

        }

        let annotation_start = lexer.position
        let annotation_result = parse_typeannotation(rp, ep)
        if (annotation_result._tag == Result[TypeAnnotationSyntax, ParserError]::Error)
        {
            switch (annotation_result._Error._tag) {
                case ParserError::DifferentSyntax:
                    break
                case ParserError::InvalidSyntax:
                    return Result[ItemSyntax, ParserError] { ._tag = Result[ItemSyntax, ParserError]::Error, ._Error = annotation_result._Error }
            }
        }

        TypeAnnotationSyntax* annotation = annotation_result._tag == Result[TypeAnnotationSyntax, ParserError]::Error ? nullptr : new(alignof(TypeAnnotationSyntax), _rp) TypeAnnotationSyntax(annotation_result._Ok)
    
        let start_comma_3 = lexer.previous_position
        let success_comma_3 = lexer.parse_punctuation(',')
        if (!success_comma_3) {
        }

        let start_colon_4 = lexer.previous_position
        let success_colon_4 = lexer.parse_colon(_rp)
        if (!success_colon_4) {
        }

        let attributes_start = lexer.position
        let attributes_result = parse_attribute_list(rp, ep)
        choose attributes_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax {}
                    when i: ParserError.InvalidSyntax throw i
            }
        let attributes = attributes_result._tag == Result[Vector[AttributeSyntax], ParserError]::Error ? nullptr : attributes_result._Ok
    
        let start_colon_6 = lexer.previous_position
        let success_colon_6 = lexer.parse_colon(_rp)
        if (!success_colon_6) {
        }

        let end = lexer.position

        let ret = ItemSyntax(start, end, *name, annotation, attributes)

        return Result[ItemSyntax, ParserError] { ._tag = Result[ItemSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_returns(this: Parser) returns ReturnsSyntax throws ParserError {
        let start = lexer.previous_position

        let start_returns_1 = lexer.previous_position
        let success_returns_1 = lexer.parse_keyword(_rp, *keywords_index[31])
        if (!success_returns_1) {
            return Result[ReturnsSyntax, ParserError] { ._tag = Result[ReturnsSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }
        }

        let type_start = lexer.position
        let type_result = parse_type(rp, ep)
        choose type_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax
                        throw InvalidSyntax(type_start, lexer.position, String(ep, "a valid Type syntax"))
                    when i: ParserError.InvalidSyntax throw i
            }
        let type = type_result._Ok
    
        let attributes_start = lexer.position
        let attributes_result = parse_attribute_list(rp, ep)
        choose attributes_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax {}
                    when i: ParserError.InvalidSyntax throw i
            }
        let attributes = attributes_result._tag == Result[Vector[AttributeSyntax], ParserError]::Error ? nullptr : attributes_result._Ok
    
        let end = lexer.position

        let ret = ReturnsSyntax(start, end, type, attributes)

        return Result[ReturnsSyntax, ParserError] { ._tag = Result[ReturnsSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_throws(this: Parser) returns ThrowsSyntax throws ParserError {
        let start = lexer.previous_position

        let start_throws_1 = lexer.previous_position
        let success_throws_1 = lexer.parse_keyword(_rp, *keywords_index[36])
        if (!success_throws_1) {
            return Result[ThrowsSyntax, ParserError] { ._tag = Result[ThrowsSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }
        }

        let type_start = lexer.position
        let type_result = parse_type(rp, ep)
        choose type_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax
                        throw InvalidSyntax(type_start, lexer.position, String(ep, "a valid Type syntax"))
                    when i: ParserError.InvalidSyntax throw i
            }
        let type = type_result._Ok
    
        let attributes_start = lexer.position
        let attributes_result = parse_attribute_list(rp, ep)
        choose attributes_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax {}
                    when i: ParserError.InvalidSyntax throw i
            }
        let attributes = attributes_result._tag == Result[Vector[AttributeSyntax], ParserError]::Error ? nullptr : attributes_result._Ok
    
        let end = lexer.position

        let ret = ThrowsSyntax(start, end, type, attributes)

        return Result[ThrowsSyntax, ParserError] { ._tag = Result[ThrowsSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_use_list(this: Parser) returns pointer[Vector[UseSyntax]] throws ParserError {
        var r Region()
        List<UseSyntax]& list = *new(alignof(List<UseSyntax]), _r.get_page()) List<UseSyntax]()
        while(true) {
            let node_result = parse_use(rp, ep)
            if ((node_result._tag == Result[UseSyntax, ParserError]::Error) && (node_result._Error._tag == ParserError::InvalidSyntax))
                return Result[Vector<UseSyntax]*, ParserError] { ._tag = Result[Vector<UseSyntax]*, ParserError]::Error, ._Error = node_result._Error }
            if (node_result._tag == Result[UseSyntax, ParserError]::Ok) {
                let node = node_result._Ok
                list.add(node)
            } else {
                if ((list.count() == 0) && (node_result._tag == Result[UseSyntax, ParserError]::Error) && (node_result._Error._tag == ParserError::DifferentSyntax))
                    return Result[Vector<UseSyntax]*, ParserError] { ._tag = Result[Vector<UseSyntax]*, ParserError]::Error, ._Error = node_result._Error }
                break
            }
        }

        if (list.count() == 0)
            return Result[Vector<UseSyntax]*, ParserError] { ._tag = Result[Vector<UseSyntax]*, ParserError]::Ok, ._Ok = nullptr }
        
        return Result[Vector<UseSyntax]*, ParserError] {
            ._tag = Result[Vector<UseSyntax]*, ParserError]::Ok,
            ._Ok = new(alignof(Vector<UseSyntax]), _rp) Vector<UseSyntax](_rp, list) }
    }

    function parse_use(this: Parser) returns UseSyntax throws ParserError {
        let start = lexer.previous_position

        let start_use_1 = lexer.previous_position
        let success_use_1 = lexer.parse_keyword(_rp, *keywords_index[40])
        if (!success_use_1) {
            return Result[UseSyntax, ParserError] { ._tag = Result[UseSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }
        }

        let name_start = lexer.position
        let name_result = parse_name(rp, ep)
        choose name_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax
                        throw InvalidSyntax(name_start, lexer.position, String(ep, "a valid Name syntax"))
                    when i: ParserError.InvalidSyntax throw i
            }
        let name = name_result._Ok
    
        let start_colon_3 = lexer.previous_position
        let success_colon_3 = lexer.parse_colon(_rp)
        if (!success_colon_3) {
        }

        let end = lexer.position

        let ret = UseSyntax(start, end, name)

        return Result[UseSyntax, ParserError] { ._tag = Result[UseSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_implement(this: Parser) returns ImplementSyntax throws ParserError {
        let start = lexer.previous_position

        let start_implement_1 = lexer.previous_position
        let success_implement_1 = lexer.parse_keyword(_rp, *keywords_index[15])
        if (!success_implement_1) {
            return Result[ImplementSyntax, ParserError] { ._tag = Result[ImplementSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }
        }

        let type_start = lexer.position
        let type_result = parse_type(rp, ep)
        choose type_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax
                        throw InvalidSyntax(type_start, lexer.position, String(ep, "a valid Type syntax"))
                    when i: ParserError.InvalidSyntax throw i
            }
        let type = type_result._Ok
    
        let attributes_start = lexer.position
        let attributes_result = parse_attribute_list(rp, ep)
        choose attributes_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax {}
                    when i: ParserError.InvalidSyntax throw i
            }
        let attributes = attributes_result._tag == Result[Vector[AttributeSyntax], ParserError]::Error ? nullptr : attributes_result._Ok
    
        let start_colon_4 = lexer.previous_position
        let success_colon_4 = lexer.parse_colon(_rp)
        if (!success_colon_4) {
        }

        let start_left_curly_5 = lexer.previous_position
        let success_left_curly_5 = lexer.parse_punctuation('{')
        if (!success_left_curly_5) {
            return Result[ImplementSyntax, ParserError] { ._tag = Result[ImplementSyntax, ParserError]::Error, ._Error = ParserError(InvalidSyntax(start_left_curly_5, lexer.position, String(_ep, "{"))) }        }

        let uses_start = lexer.position
        let uses_result = parse_use_list(rp, ep)
        choose uses_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax {}
                    when i: ParserError.InvalidSyntax throw i
            }
        let uses = uses_result._tag == Result[Vector[UseSyntax], ParserError]::Error ? nullptr : uses_result._Ok
    
        let methods_start = lexer.position
        let methods_result = parse_method_list(rp, ep)
        choose methods_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax {}
                    when i: ParserError.InvalidSyntax throw i
            }
        let methods = methods_result._tag == Result[Vector[MethodSyntax], ParserError]::Error ? nullptr : methods_result._Ok
    
        let start_right_curly_8 = lexer.previous_position
        let success_right_curly_8 = lexer.parse_punctuation('}')
        if (!success_right_curly_8) {
            return Result[ImplementSyntax, ParserError] { ._tag = Result[ImplementSyntax, ParserError]::Error, ._Error = ParserError(InvalidSyntax(start_right_curly_8, lexer.position, String(_ep, "}"))) }        }

        let start_colon_9 = lexer.previous_position
        let success_colon_9 = lexer.parse_colon(_rp)
        if (!success_colon_9) {
        }

        let end = lexer.position

        let ret = ImplementSyntax(start, end, type, attributes, uses, methods)

        return Result[ImplementSyntax, ParserError] { ._tag = Result[ImplementSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_trait(this: Parser) returns TraitSyntax throws ParserError {
        let start = lexer.previous_position

        let start_trait_1 = lexer.previous_position
        let success_trait_1 = lexer.parse_keyword(_rp, *keywords_index[37])
        if (!success_trait_1) {
            return Result[TraitSyntax, ParserError] { ._tag = Result[TraitSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }
        }

        let name_start = lexer.position
        let name_result = parse_name(rp, ep)
        choose name_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax
                        throw InvalidSyntax(name_start, lexer.position, String(ep, "a valid Name syntax"))
                    when i: ParserError.InvalidSyntax throw i
            }
        let name = name_result._Ok
    
        let extension_start = lexer.position
        let extension_result = parse_extends(rp, ep)
        if (extension_result._tag == Result[ExtendsSyntax, ParserError]::Error)
        {
            switch (extension_result._Error._tag) {
                case ParserError::DifferentSyntax:
                    break
                case ParserError::InvalidSyntax:
                    return Result[TraitSyntax, ParserError] { ._tag = Result[TraitSyntax, ParserError]::Error, ._Error = extension_result._Error }
            }
        }

        ExtendsSyntax* extension = extension_result._tag == Result[ExtendsSyntax, ParserError]::Error ? nullptr : new(alignof(ExtendsSyntax), _rp) ExtendsSyntax(extension_result._Ok)
    
        let attributes_start = lexer.position
        let attributes_result = parse_attribute_list(rp, ep)
        choose attributes_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax {}
                    when i: ParserError.InvalidSyntax throw i
            }
        let attributes = attributes_result._tag == Result[Vector[AttributeSyntax], ParserError]::Error ? nullptr : attributes_result._Ok
    
        let start_left_curly_5 = lexer.previous_position
        let success_left_curly_5 = lexer.parse_punctuation('{')
        if (!success_left_curly_5) {
            return Result[TraitSyntax, ParserError] { ._tag = Result[TraitSyntax, ParserError]::Error, ._Error = ParserError(InvalidSyntax(start_left_curly_5, lexer.position, String(_ep, "{"))) }        }

        let uses_start = lexer.position
        let uses_result = parse_use_list(rp, ep)
        choose uses_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax {}
                    when i: ParserError.InvalidSyntax throw i
            }
        let uses = uses_result._tag == Result[Vector[UseSyntax], ParserError]::Error ? nullptr : uses_result._Ok
    
        let functions_start = lexer.position
        let functions_result = parse_method_list(rp, ep)
        choose functions_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax {}
                    when i: ParserError.InvalidSyntax throw i
            }
        let functions = functions_result._tag == Result[Vector[MethodSyntax], ParserError]::Error ? nullptr : functions_result._Ok
    
        let start_right_curly_8 = lexer.previous_position
        let success_right_curly_8 = lexer.parse_punctuation('}')
        if (!success_right_curly_8) {
            return Result[TraitSyntax, ParserError] { ._tag = Result[TraitSyntax, ParserError]::Error, ._Error = ParserError(InvalidSyntax(start_right_curly_8, lexer.position, String(_ep, "}"))) }        }

        let start_colon_9 = lexer.previous_position
        let success_colon_9 = lexer.parse_colon(_rp)
        if (!success_colon_9) {
        }

        let end = lexer.position

        let ret = TraitSyntax(start, end, name, extension, attributes, uses, functions)

        return Result[TraitSyntax, ParserError] { ._tag = Result[TraitSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_method_list(this: Parser) returns pointer[Vector[MethodSyntax]] throws ParserError {
        var r Region()
        List<MethodSyntax]& list = *new(alignof(List<MethodSyntax]), _r.get_page()) List<MethodSyntax]()
        while(true) {
            let node_result = parse_method(rp, ep)
            if ((node_result._tag == Result[MethodSyntax, ParserError]::Error) && (node_result._Error._tag == ParserError::InvalidSyntax))
                return Result[Vector<MethodSyntax]*, ParserError] { ._tag = Result[Vector<MethodSyntax]*, ParserError]::Error, ._Error = node_result._Error }
            if (node_result._tag == Result[MethodSyntax, ParserError]::Ok) {
                let node = node_result._Ok
                list.add(node)
            } else {
                if ((list.count() == 0) && (node_result._tag == Result[MethodSyntax, ParserError]::Error) && (node_result._Error._tag == ParserError::DifferentSyntax))
                    return Result[Vector<MethodSyntax]*, ParserError] { ._tag = Result[Vector<MethodSyntax]*, ParserError]::Error, ._Error = node_result._Error }
                break
            }
        }

        if (list.count() == 0)
            return Result[Vector<MethodSyntax]*, ParserError] { ._tag = Result[Vector<MethodSyntax]*, ParserError]::Ok, ._Ok = nullptr }
        
        return Result[Vector<MethodSyntax]*, ParserError] {
            ._tag = Result[Vector<MethodSyntax]*, ParserError]::Ok,
            ._Ok = new(alignof(Vector<MethodSyntax]), _rp) Vector<MethodSyntax](_rp, list) }
    }

    function parse_method(this: Parser) returns MethodSyntax throws ParserError {
        try let node parse_function(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnMethodSyntax(FunctionSyntax(node))
        try let node parse_procedure(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnMethodSyntax(ProcedureSyntax(node))
        try let node parse_operator(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnMethodSyntax(OperatorSyntax(node))
        throw ParserError(DifferentSyntax())
    }

    function parse_init_list(this: Parser) returns pointer[Vector[InitSyntax]] throws ParserError {
        var r Region()
        List<InitSyntax]& list = *new(alignof(List<InitSyntax]), _r.get_page()) List<InitSyntax]()
        while(true) {
            let node_result = parse_init(rp, ep)
            if ((node_result._tag == Result[InitSyntax, ParserError]::Error) && (node_result._Error._tag == ParserError::InvalidSyntax))
                return Result[Vector<InitSyntax]*, ParserError] { ._tag = Result[Vector<InitSyntax]*, ParserError]::Error, ._Error = node_result._Error }
            if (node_result._tag == Result[InitSyntax, ParserError]::Ok) {
                let node = node_result._Ok
                list.add(node)
            } else {
                if ((list.count() == 0) && (node_result._tag == Result[InitSyntax, ParserError]::Error) && (node_result._Error._tag == ParserError::DifferentSyntax))
                    return Result[Vector<InitSyntax]*, ParserError] { ._tag = Result[Vector<InitSyntax]*, ParserError]::Error, ._Error = node_result._Error }
                break
            }
        }

        if (list.count() == 0)
            return Result[Vector<InitSyntax]*, ParserError] { ._tag = Result[Vector<InitSyntax]*, ParserError]::Ok, ._Ok = nullptr }
        
        return Result[Vector<InitSyntax]*, ParserError] {
            ._tag = Result[Vector<InitSyntax]*, ParserError]::Ok,
            ._Ok = new(alignof(Vector<InitSyntax]), _rp) Vector<InitSyntax](_rp, list) }
    }

    function parse_init(this: Parser) returns InitSyntax throws ParserError {
        let start = lexer.previous_position

        let start_init_1 = lexer.previous_position
        let success_init_1 = lexer.parse_keyword(_rp, *keywords_index[14])
        if (!success_init_1) {
            return Result[InitSyntax, ParserError] { ._tag = Result[InitSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }
        }

        let parameters_start = lexer.position
        let parameters_result = parse_parameterset(rp, ep)
        if (parameters_result._tag == Result[ParameterSetSyntax, ParserError]::Error)
        {
            switch (parameters_result._Error._tag) {
                case ParserError::DifferentSyntax:
                    break
                case ParserError::InvalidSyntax:
                    return Result[InitSyntax, ParserError] { ._tag = Result[InitSyntax, ParserError]::Error, ._Error = parameters_result._Error }
            }
        }

        ParameterSetSyntax* parameters = parameters_result._tag == Result[ParameterSetSyntax, ParserError]::Error ? nullptr : new(alignof(ParameterSetSyntax), _rp) ParameterSetSyntax(parameters_result._Ok)
    
        let start_colon_3 = lexer.previous_position
        let success_colon_3 = lexer.parse_colon(_rp)
        if (!success_colon_3) {
        }

        let action_start = lexer.position
        let action_result = parse_action(rp, ep)
        choose action_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax
                        throw InvalidSyntax(action_start, lexer.position, String(ep, "a valid Action syntax"))
                    when i: ParserError.InvalidSyntax throw i
            }
        let action = action_result._Ok
    
        let start_colon_5 = lexer.previous_position
        let success_colon_5 = lexer.parse_colon(_rp)
        if (!success_colon_5) {
        }

        let end = lexer.position

        let ret = InitSyntax(start, end, parameters, action)

        return Result[InitSyntax, ParserError] { ._tag = Result[InitSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_deinit(this: Parser) returns DeInitSyntax throws ParserError {
        let start = lexer.previous_position

        let start_deinit_1 = lexer.previous_position
        let success_deinit_1 = lexer.parse_keyword(_rp, *keywords_index[6])
        if (!success_deinit_1) {
            return Result[DeInitSyntax, ParserError] { ._tag = Result[DeInitSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }
        }

        let start_colon_2 = lexer.previous_position
        let success_colon_2 = lexer.parse_colon(_rp)
        if (!success_colon_2) {
        }

        let action_start = lexer.position
        let action_result = parse_action(rp, ep)
        choose action_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax
                        throw InvalidSyntax(action_start, lexer.position, String(ep, "a valid Action syntax"))
                    when i: ParserError.InvalidSyntax throw i
            }
        let action = action_result._Ok
    
        let start_colon_4 = lexer.previous_position
        let success_colon_4 = lexer.parse_colon(_rp)
        if (!success_colon_4) {
        }

        let end = lexer.position

        let ret = DeInitSyntax(start, end, action)

        return Result[DeInitSyntax, ParserError] { ._tag = Result[DeInitSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_function(this: Parser) returns FunctionSyntax throws ParserError {
        let start = lexer.previous_position

        let start_function_1 = lexer.previous_position
        let success_function_1 = lexer.parse_keyword(_rp, *keywords_index[12])
        if (!success_function_1) {
            return Result[FunctionSyntax, ParserError] { ._tag = Result[FunctionSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }
        }

        let target_start = lexer.position
        let target_result = parse_target(rp, ep)
        choose target_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax
                        throw InvalidSyntax(target_start, lexer.position, String(ep, "a valid Target syntax"))
                    when i: ParserError.InvalidSyntax throw i
            }
        let target = target_result._Ok
    
        let end = lexer.position

        let ret = FunctionSyntax(start, end, target)

        return Result[FunctionSyntax, ParserError] { ._tag = Result[FunctionSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_procedure(this: Parser) returns ProcedureSyntax throws ParserError {
        let start = lexer.previous_position

        let start_procedure_1 = lexer.previous_position
        let success_procedure_1 = lexer.parse_keyword(_rp, *keywords_index[28])
        if (!success_procedure_1) {
            return Result[ProcedureSyntax, ParserError] { ._tag = Result[ProcedureSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }
        }

        let target_start = lexer.position
        let target_result = parse_target(rp, ep)
        choose target_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax
                        throw InvalidSyntax(target_start, lexer.position, String(ep, "a valid Target syntax"))
                    when i: ParserError.InvalidSyntax throw i
            }
        let target = target_result._Ok
    
        let end = lexer.position

        let ret = ProcedureSyntax(start, end, target)

        return Result[ProcedureSyntax, ParserError] { ._tag = Result[ProcedureSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_operator(this: Parser) returns OperatorSyntax throws ParserError {
        let start = lexer.previous_position

        let start_operator_1 = lexer.previous_position
        let success_operator_1 = lexer.parse_keyword(_rp, *keywords_index[27])
        if (!success_operator_1) {
            return Result[OperatorSyntax, ParserError] { ._tag = Result[OperatorSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }
        }

        let target_start = lexer.position
        let target_result = parse_target(rp, ep)
        choose target_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax
                        throw InvalidSyntax(target_start, lexer.position, String(ep, "a valid Target syntax"))
                    when i: ParserError.InvalidSyntax throw i
            }
        let target = target_result._Ok
    
        let end = lexer.position

        let ret = OperatorSyntax(start, end, target)

        return Result[OperatorSyntax, ParserError] { ._tag = Result[OperatorSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_target(this: Parser) returns TargetSyntax throws ParserError {
        try let node parse_named(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnTargetSyntax(NamedSyntax(node))
        try let node parse_routine(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnTargetSyntax(RoutineSyntax(node))
        throw ParserError(DifferentSyntax())
    }

    function parse_named(this: Parser) returns NamedSyntax throws ParserError {
        let start = lexer.previous_position

        let start_name = lexer.previous_position
        let name = lexer.parse_identifier(_rp, keywords)
        if (name == nullptr)
        {
            return Result[NamedSyntax, ParserError] { ._tag = Result[NamedSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }

        }

        let routine_start = lexer.position
        let routine_result = parse_routine(rp, ep)
        choose routine_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax
                        throw InvalidSyntax(routine_start, lexer.position, String(ep, "a valid Routine syntax"))
                    when i: ParserError.InvalidSyntax throw i
            }
        let routine = routine_result._Ok
    
        let end = lexer.position

        let ret = NamedSyntax(start, end, *name, routine)

        return Result[NamedSyntax, ParserError] { ._tag = Result[NamedSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_routine(this: Parser) returns RoutineSyntax throws ParserError {
        let start = lexer.previous_position

        let generics_start = lexer.position
        let generics_result = parse_genericarguments(rp, ep)
        if (generics_result._tag == Result[GenericArgumentsSyntax, ParserError]::Error)
        {
            switch (generics_result._Error._tag) {
                case ParserError::DifferentSyntax:
                    break
                case ParserError::InvalidSyntax:
                    return Result[RoutineSyntax, ParserError] { ._tag = Result[RoutineSyntax, ParserError]::Error, ._Error = generics_result._Error }
            }
        }

        GenericArgumentsSyntax* generics = generics_result._tag == Result[GenericArgumentsSyntax, ParserError]::Error ? nullptr : new(alignof(GenericArgumentsSyntax), _rp) GenericArgumentsSyntax(generics_result._Ok)
    
        let lifetime_start = lexer.position
        let lifetime_result = parse_lifetime(rp, ep)
        if (lifetime_result._tag == Result[LifetimeSyntax, ParserError]::Error)
        {
            switch (lifetime_result._Error._tag) {
                case ParserError::DifferentSyntax:
                    break
                case ParserError::InvalidSyntax:
                    return Result[RoutineSyntax, ParserError] { ._tag = Result[RoutineSyntax, ParserError]::Error, ._Error = lifetime_result._Error }
            }
        }

        LifetimeSyntax* lifetime = lifetime_result._tag == Result[LifetimeSyntax, ParserError]::Error ? nullptr : new(alignof(LifetimeSyntax), _rp) LifetimeSyntax(lifetime_result._Ok)
    
        let parameters_start = lexer.position
        let parameters_result = parse_parameterset(rp, ep)
        if (parameters_result._tag == Result[ParameterSetSyntax, ParserError]::Error)
        {
            switch (parameters_result._Error._tag) {
                case ParserError::DifferentSyntax:
                    break
                case ParserError::InvalidSyntax:
                    return Result[RoutineSyntax, ParserError] { ._tag = Result[RoutineSyntax, ParserError]::Error, ._Error = parameters_result._Error }
            }
        }

        ParameterSetSyntax* parameters = parameters_result._tag == Result[ParameterSetSyntax, ParserError]::Error ? nullptr : new(alignof(ParameterSetSyntax), _rp) ParameterSetSyntax(parameters_result._Ok)
    
        let attributes_start = lexer.position
        let attributes_result = parse_attribute_list(rp, ep)
        choose attributes_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax {}
                    when i: ParserError.InvalidSyntax throw i
            }
        let attributes = attributes_result._tag == Result[Vector[AttributeSyntax], ParserError]::Error ? nullptr : attributes_result._Ok
    
        let returns__start = lexer.position
        let returns__result = parse_returns(rp, ep)
        if (returns__result._tag == Result[ReturnsSyntax, ParserError]::Error)
        {
            switch (returns__result._Error._tag) {
                case ParserError::DifferentSyntax:
                    break
                case ParserError::InvalidSyntax:
                    return Result[RoutineSyntax, ParserError] { ._tag = Result[RoutineSyntax, ParserError]::Error, ._Error = returns__result._Error }
            }
        }

        ReturnsSyntax* returns_ = returns__result._tag == Result[ReturnsSyntax, ParserError]::Error ? nullptr : new(alignof(ReturnsSyntax), _rp) ReturnsSyntax(returns__result._Ok)
    
        let start_colon_6 = lexer.previous_position
        let success_colon_6 = lexer.parse_colon(_rp)
        if (!success_colon_6) {
        }

        let throws__start = lexer.position
        let throws__result = parse_throws(rp, ep)
        if (throws__result._tag == Result[ThrowsSyntax, ParserError]::Error)
        {
            switch (throws__result._Error._tag) {
                case ParserError::DifferentSyntax:
                    break
                case ParserError::InvalidSyntax:
                    return Result[RoutineSyntax, ParserError] { ._tag = Result[RoutineSyntax, ParserError]::Error, ._Error = throws__result._Error }
            }
        }

        ThrowsSyntax* throws_ = throws__result._tag == Result[ThrowsSyntax, ParserError]::Error ? nullptr : new(alignof(ThrowsSyntax), _rp) ThrowsSyntax(throws__result._Ok)
    
        let start_colon_8 = lexer.previous_position
        let success_colon_8 = lexer.parse_colon(_rp)
        if (!success_colon_8) {
        }

        let implementation_start = lexer.position
        let implementation_result = parse_implementation(rp, ep)
        choose implementation_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax
                        throw InvalidSyntax(implementation_start, lexer.position, String(ep, "a valid Implementation syntax"))
                    when i: ParserError.InvalidSyntax throw i
            }
        let implementation = implementation_result._Ok
    
        let end = lexer.position

        let ret = RoutineSyntax(start, end, generics, lifetime, parameters, attributes, returns_, throws_, implementation)

        return Result[RoutineSyntax, ParserError] { ._tag = Result[RoutineSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_implementation(this: Parser) returns ImplementationSyntax throws ParserError {
        try let node parse_action(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnImplementationSyntax(ActionSyntax(node))
        try let node parse_extern(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnImplementationSyntax(ExternSyntax(node))
        try let node parse_instruction(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnImplementationSyntax(InstructionSyntax(node))
        try let node parse_intrinsic(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnImplementationSyntax(IntrinsicSyntax(node))
        throw ParserError(DifferentSyntax())
    }

    function parse_extern(this: Parser) returns ExternSyntax throws ParserError {
        let start = lexer.previous_position

        let start_extern_1 = lexer.previous_position
        let success_extern_1 = lexer.parse_keyword(_rp, *keywords_index[10])
        if (!success_extern_1) {
            return Result[ExternSyntax, ParserError] { ._tag = Result[ExternSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }
        }

        let end = lexer.position

        let ret = ExternSyntax(start, end)

        return Result[ExternSyntax, ParserError] { ._tag = Result[ExternSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_instruction(this: Parser) returns InstructionSyntax throws ParserError {
        let start = lexer.previous_position

        let start_instruction_1 = lexer.previous_position
        let success_instruction_1 = lexer.parse_keyword(_rp, *keywords_index[17])
        if (!success_instruction_1) {
            return Result[InstructionSyntax, ParserError] { ._tag = Result[InstructionSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }
        }

        let start_colon_2 = lexer.previous_position
        let success_colon_2 = lexer.parse_colon(_rp)
        if (!success_colon_2) {
        }

        let end = lexer.position

        let ret = InstructionSyntax(start, end)

        return Result[InstructionSyntax, ParserError] { ._tag = Result[InstructionSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_intrinsic(this: Parser) returns IntrinsicSyntax throws ParserError {
        let start = lexer.previous_position

        let start_intrinsic_1 = lexer.previous_position
        let success_intrinsic_1 = lexer.parse_keyword(_rp, *keywords_index[18])
        if (!success_intrinsic_1) {
            return Result[IntrinsicSyntax, ParserError] { ._tag = Result[IntrinsicSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }
        }

        let start_colon_2 = lexer.previous_position
        let success_colon_2 = lexer.parse_colon(_rp)
        if (!success_colon_2) {
        }

        let end = lexer.position

        let ret = IntrinsicSyntax(start, end)

        return Result[IntrinsicSyntax, ParserError] { ._tag = Result[IntrinsicSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_extends(this: Parser) returns ExtendsSyntax throws ParserError {
        let start = lexer.previous_position

        let start_extends_1 = lexer.previous_position
        let success_extends_1 = lexer.parse_keyword(_rp, *keywords_index[9])
        if (!success_extends_1) {
            return Result[ExtendsSyntax, ParserError] { ._tag = Result[ExtendsSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }
        }

        let extensions_start = lexer.position
        let extensions_result = parse_extend_list(rp, ep)
        choose extensions_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax {}
                    when i: ParserError.InvalidSyntax throw i
            }
        let extensions = extensions_result._tag == Result[Vector[ExtendSyntax], ParserError]::Error ? nullptr : extensions_result._Ok
    
        let end = lexer.position

        let ret = ExtendsSyntax(start, end, extensions)

        return Result[ExtendsSyntax, ParserError] { ._tag = Result[ExtendsSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_extend_list(this: Parser) returns pointer[Vector[ExtendSyntax]] throws ParserError {
        var r Region()
        List<ExtendSyntax]& list = *new(alignof(List<ExtendSyntax]), _r.get_page()) List<ExtendSyntax]()
        while(true) {
            let node_result = parse_extend(rp, ep)
            if ((node_result._tag == Result[ExtendSyntax, ParserError]::Error) && (node_result._Error._tag == ParserError::InvalidSyntax))
                return Result[Vector<ExtendSyntax]*, ParserError] { ._tag = Result[Vector<ExtendSyntax]*, ParserError]::Error, ._Error = node_result._Error }
            if (node_result._tag == Result[ExtendSyntax, ParserError]::Ok) {
                let node = node_result._Ok
                list.add(node)
            } else {
                if ((list.count() == 0) && (node_result._tag == Result[ExtendSyntax, ParserError]::Error) && (node_result._Error._tag == ParserError::DifferentSyntax))
                    return Result[Vector<ExtendSyntax]*, ParserError] { ._tag = Result[Vector<ExtendSyntax]*, ParserError]::Error, ._Error = node_result._Error }
                break
            }
        }

        if (list.count() == 0)
            return Result[Vector<ExtendSyntax]*, ParserError] { ._tag = Result[Vector<ExtendSyntax]*, ParserError]::Ok, ._Ok = nullptr }
        
        return Result[Vector<ExtendSyntax]*, ParserError] {
            ._tag = Result[Vector<ExtendSyntax]*, ParserError]::Ok,
            ._Ok = new(alignof(Vector<ExtendSyntax]), _rp) Vector<ExtendSyntax](_rp, list) }
    }

    function parse_extend(this: Parser) returns ExtendSyntax throws ParserError {
        let start = lexer.previous_position

        let type_start = lexer.position
        let type_result = parse_type(rp, ep)
        choose type_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax throw d
                    when i: ParserError.InvalidSyntax throw i
            }
        let type = type_result._Ok
    
        let start_comma_2 = lexer.previous_position
        let success_comma_2 = lexer.parse_punctuation(',')
        if (!success_comma_2) {
        }

        let end = lexer.position

        let ret = ExtendSyntax(start, end, type)

        return Result[ExtendSyntax, ParserError] { ._tag = Result[ExtendSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_macro(this: Parser) returns MacroSyntax throws ParserError {
        let start = lexer.previous_position

        let start_macro_1 = lexer.previous_position
        let success_macro_1 = lexer.parse_keyword(_rp, *keywords_index[23])
        if (!success_macro_1) {
            return Result[MacroSyntax, ParserError] { ._tag = Result[MacroSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }
        }

        let start_name = lexer.previous_position
        let name = lexer.parse_identifier(_rp, keywords)
        if (name == nullptr)
        {
            return Result[MacroSyntax, ParserError] { ._tag = Result[MacroSyntax, ParserError]::Error, ._Error = ParserError(InvalidSyntax(start_name, lexer.position, String(_ep, "an identifier"))) }
        }

        let model_start = lexer.position
        let model_result = parse_model(rp, ep)
        choose model_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax
                        throw InvalidSyntax(model_start, lexer.position, String(ep, "a valid Model syntax"))
                    when i: ParserError.InvalidSyntax throw i
            }
        let model = model_result._Ok
    
        let rule_start = lexer.position
        let rule_result = parse_operand_list(rp, ep)
        choose rule_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax
                        throw InvalidSyntax(rule_start, lexer.position, String(ep, "a valid Operand syntax"))
                    when i: ParserError.InvalidSyntax throw i
            }
        let rule = rule_result._Ok
    
        let end = lexer.position

        let ret = MacroSyntax(start, end, *name, model, rule)

        return Result[MacroSyntax, ParserError] { ._tag = Result[MacroSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_attribute_list(this: Parser) returns pointer[Vector[AttributeSyntax]] throws ParserError {
        var r Region()
        List<AttributeSyntax]& list = *new(alignof(List<AttributeSyntax]), _r.get_page()) List<AttributeSyntax]()
        while(true) {
            let node_result = parse_attribute(rp, ep)
            if ((node_result._tag == Result[AttributeSyntax, ParserError]::Error) && (node_result._Error._tag == ParserError::InvalidSyntax))
                return Result[Vector<AttributeSyntax]*, ParserError] { ._tag = Result[Vector<AttributeSyntax]*, ParserError]::Error, ._Error = node_result._Error }
            if (node_result._tag == Result[AttributeSyntax, ParserError]::Ok) {
                let node = node_result._Ok
                list.add(node)
            } else {
                if ((list.count() == 0) && (node_result._tag == Result[AttributeSyntax, ParserError]::Error) && (node_result._Error._tag == ParserError::DifferentSyntax))
                    return Result[Vector<AttributeSyntax]*, ParserError] { ._tag = Result[Vector<AttributeSyntax]*, ParserError]::Error, ._Error = node_result._Error }
                break
            }
        }

        if (list.count() == 0)
            return Result[Vector<AttributeSyntax]*, ParserError] { ._tag = Result[Vector<AttributeSyntax]*, ParserError]::Ok, ._Ok = nullptr }
        
        return Result[Vector<AttributeSyntax]*, ParserError] {
            ._tag = Result[Vector<AttributeSyntax]*, ParserError]::Ok,
            ._Ok = new(alignof(Vector<AttributeSyntax]), _rp) Vector<AttributeSyntax](_rp, list) }
    }

    function parse_attribute(this: Parser) returns AttributeSyntax throws ParserError {
        let start = lexer.previous_position

        let start_name = lexer.previous_position
        let name = lexer.parse_attribute(_rp)
        if (name == nullptr) {

            return Result[AttributeSyntax, ParserError] { ._tag = Result[AttributeSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }
        }

        let model_start = lexer.position
        let model_result = parse_model(rp, ep)
        choose model_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax
                        throw InvalidSyntax(model_start, lexer.position, String(ep, "a valid Model syntax"))
                    when i: ParserError.InvalidSyntax throw i
            }
        let model = model_result._Ok
    
        let start_colon_3 = lexer.previous_position
        let success_colon_3 = lexer.parse_colon(_rp)
        if (!success_colon_3) {
        }

        let end = lexer.position

        let ret = AttributeSyntax(start, end, *name, model)

        return Result[AttributeSyntax, ParserError] { ._tag = Result[AttributeSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_model(this: Parser) returns ModelSyntax throws ParserError {
        try let node parse_literal(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnModelSyntax(LiteralSyntax(node))
        try let node parse_name(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnModelSyntax(NameSyntax(node))
        try let node parse_object(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnModelSyntax(ObjectSyntax(node))
        try let node parse_vector(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnModelSyntax(VectorSyntax(node))
        throw ParserError(DifferentSyntax())
    }

    function parse_module(this: Parser) returns ModuleSyntax throws ParserError {
        let start = lexer.previous_position

        let start_module_1 = lexer.previous_position
        let success_module_1 = lexer.parse_keyword(_rp, *keywords_index[25])
        if (!success_module_1) {
            return Result[ModuleSyntax, ParserError] { ._tag = Result[ModuleSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }
        }

        let start_name = lexer.previous_position
        let name = lexer.parse_identifier(_rp, keywords)
        if (name == nullptr)
        {
            return Result[ModuleSyntax, ParserError] { ._tag = Result[ModuleSyntax, ParserError]::Error, ._Error = ParserError(InvalidSyntax(start_name, lexer.position, String(_ep, "an identifier"))) }
        }

        let start_colon_3 = lexer.previous_position
        let success_colon_3 = lexer.parse_colon(_rp)
        if (!success_colon_3) {
        }

        let end = lexer.position

        let ret = ModuleSyntax(start, end, *name)

        return Result[ModuleSyntax, ParserError] { ._tag = Result[ModuleSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_package_list(this: Parser) returns pointer[Vector[PackageSyntax]] throws ParserError {
        var r Region()
        List<PackageSyntax]& list = *new(alignof(List<PackageSyntax]), _r.get_page()) List<PackageSyntax]()
        while(true) {
            let node_result = parse_package(rp, ep)
            if ((node_result._tag == Result[PackageSyntax, ParserError]::Error) && (node_result._Error._tag == ParserError::InvalidSyntax))
                return Result[Vector<PackageSyntax]*, ParserError] { ._tag = Result[Vector<PackageSyntax]*, ParserError]::Error, ._Error = node_result._Error }
            if (node_result._tag == Result[PackageSyntax, ParserError]::Ok) {
                let node = node_result._Ok
                list.add(node)
            } else {
                if ((list.count() == 0) && (node_result._tag == Result[PackageSyntax, ParserError]::Error) && (node_result._Error._tag == ParserError::DifferentSyntax))
                    return Result[Vector<PackageSyntax]*, ParserError] { ._tag = Result[Vector<PackageSyntax]*, ParserError]::Error, ._Error = node_result._Error }
                break
            }
        }

        if (list.count() == 0)
            return Result[Vector<PackageSyntax]*, ParserError] { ._tag = Result[Vector<PackageSyntax]*, ParserError]::Ok, ._Ok = nullptr }
        
        return Result[Vector<PackageSyntax]*, ParserError] {
            ._tag = Result[Vector<PackageSyntax]*, ParserError]::Ok,
            ._Ok = new(alignof(Vector<PackageSyntax]), _rp) Vector<PackageSyntax](_rp, list) }
    }

    function parse_package(this: Parser) returns PackageSyntax throws ParserError {
        let start = lexer.previous_position

        let start_package_1 = lexer.previous_position
        let success_package_1 = lexer.parse_keyword(_rp, *keywords_index[44])
        if (!success_package_1) {
            return Result[PackageSyntax, ParserError] { ._tag = Result[PackageSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }
        }

        let name_start = lexer.position
        let name_result = parse_name(rp, ep)
        choose name_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax
                        throw InvalidSyntax(name_start, lexer.position, String(ep, "a valid Name syntax"))
                    when i: ParserError.InvalidSyntax throw i
            }
        let name = name_result._Ok
    
        let start_colon_3 = lexer.previous_position
        let success_colon_3 = lexer.parse_colon(_rp)
        if (!success_colon_3) {
        }

        let end = lexer.position

        let ret = PackageSyntax(start, end, name)

        return Result[PackageSyntax, ParserError] { ._tag = Result[PackageSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_initializer(this: Parser) returns InitializerSyntax throws ParserError {
        let start = lexer.previous_position

        let start_left_paren_1 = lexer.previous_position
        let success_left_paren_1 = lexer.parse_punctuation('(')
        if (!success_left_paren_1) {
            return Result[InitializerSyntax, ParserError] { ._tag = Result[InitializerSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }
        }

        let operands_start = lexer.position
        let operands_result = parse_operand_list(rp, ep)
        choose operands_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax
                        throw InvalidSyntax(operands_start, lexer.position, String(ep, "a valid Operand syntax"))
                    when i: ParserError.InvalidSyntax throw i
            }
        let operands = operands_result._Ok
    
        let start_right_paren_3 = lexer.previous_position
        let success_right_paren_3 = lexer.parse_punctuation(')')
        if (!success_right_paren_3) {
            return Result[InitializerSyntax, ParserError] { ._tag = Result[InitializerSyntax, ParserError]::Error, ._Error = ParserError(InvalidSyntax(start_right_paren_3, lexer.position, String(_ep, ")"))) }        }

        let end = lexer.position

        let ret = InitializerSyntax(start, end, operands)

        return Result[InitializerSyntax, ParserError] { ._tag = Result[InitializerSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_operand_list(this: Parser) returns pointer[Vector[OperandSyntax]] throws ParserError {
        var r Region()
        List<OperandSyntax]& list = *new(alignof(List<OperandSyntax]), _r.get_page()) List<OperandSyntax]()
        while(true) {
            let node_result = parse_operand(rp, ep)
            if ((node_result._tag == Result[OperandSyntax, ParserError]::Error) && (node_result._Error._tag == ParserError::InvalidSyntax))
                return Result[Vector<OperandSyntax]*, ParserError] { ._tag = Result[Vector<OperandSyntax]*, ParserError]::Error, ._Error = node_result._Error }
            if (node_result._tag == Result[OperandSyntax, ParserError]::Ok) {
                let node = node_result._Ok
                list.add(node)
            } else {
                if ((list.count() == 0) && (node_result._tag == Result[OperandSyntax, ParserError]::Error) && (node_result._Error._tag == ParserError::DifferentSyntax))
                    return Result[Vector<OperandSyntax]*, ParserError] { ._tag = Result[Vector<OperandSyntax]*, ParserError]::Error, ._Error = node_result._Error }
                break
            }
        }

        if (list.count() == 0)
            return Result[Vector<OperandSyntax]*, ParserError] { ._tag = Result[Vector<OperandSyntax]*, ParserError]::Ok, ._Ok = nullptr }
        
        return Result[Vector<OperandSyntax]*, ParserError] {
            ._tag = Result[Vector<OperandSyntax]*, ParserError]::Ok,
            ._Ok = new(alignof(Vector<OperandSyntax]), _rp) Vector<OperandSyntax](_rp, list) }
    }

    function parse_operand(this: Parser) returns OperandSyntax throws ParserError {
        let start = lexer.previous_position

        let expression_start = lexer.position
        let expression_result = parse_expression(rp, ep)
        choose expression_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax throw d
                    when i: ParserError.InvalidSyntax throw i
            }
        let expression = expression_result._Ok
    
        let members_start = lexer.position
        let members_result = parse_memberaccess_list(rp, ep)
        choose members_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax {}
                    when i: ParserError.InvalidSyntax throw i
            }
        let members = members_result._tag == Result[Vector[MemberAccessSyntax], ParserError]::Error ? nullptr : members_result._Ok
    
        let end = lexer.position

        let ret = OperandSyntax(start, end, expression, members)

        return Result[OperandSyntax, ParserError] { ._tag = Result[OperandSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_memberaccess_list(this: Parser) returns pointer[Vector[MemberAccessSyntax]] throws ParserError {
        var r Region()
        List<MemberAccessSyntax]& list = *new(alignof(List<MemberAccessSyntax]), _r.get_page()) List<MemberAccessSyntax]()
        while(true) {
            let node_result = parse_memberaccess(rp, ep)
            if ((node_result._tag == Result[MemberAccessSyntax, ParserError]::Error) && (node_result._Error._tag == ParserError::InvalidSyntax))
                return Result[Vector<MemberAccessSyntax]*, ParserError] { ._tag = Result[Vector<MemberAccessSyntax]*, ParserError]::Error, ._Error = node_result._Error }
            if (node_result._tag == Result[MemberAccessSyntax, ParserError]::Ok) {
                let node = node_result._Ok
                list.add(node)
            } else {
                if ((list.count() == 0) && (node_result._tag == Result[MemberAccessSyntax, ParserError]::Error) && (node_result._Error._tag == ParserError::DifferentSyntax))
                    return Result[Vector<MemberAccessSyntax]*, ParserError] { ._tag = Result[Vector<MemberAccessSyntax]*, ParserError]::Error, ._Error = node_result._Error }
                break
            }
        }

        if (list.count() == 0)
            return Result[Vector<MemberAccessSyntax]*, ParserError] { ._tag = Result[Vector<MemberAccessSyntax]*, ParserError]::Ok, ._Ok = nullptr }
        
        return Result[Vector<MemberAccessSyntax]*, ParserError] {
            ._tag = Result[Vector<MemberAccessSyntax]*, ParserError]::Ok,
            ._Ok = new(alignof(Vector<MemberAccessSyntax]), _rp) Vector<MemberAccessSyntax](_rp, list) }
    }

    function parse_memberaccess(this: Parser) returns MemberAccessSyntax throws ParserError {
        let start = lexer.previous_position

        let start_dot_1 = lexer.previous_position
        let success_dot_1 = lexer.parse_punctuation('.')
        if (!success_dot_1) {
            return Result[MemberAccessSyntax, ParserError] { ._tag = Result[MemberAccessSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }
        }

        let name_start = lexer.position
        let name_result = parse_name(rp, ep)
        choose name_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax
                        throw InvalidSyntax(name_start, lexer.position, String(ep, "a valid Name syntax"))
                    when i: ParserError.InvalidSyntax throw i
            }
        let name = name_result._Ok
    
        let end = lexer.position

        let ret = MemberAccessSyntax(start, end, name)

        return Result[MemberAccessSyntax, ParserError] { ._tag = Result[MemberAccessSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_expression(this: Parser) returns ExpressionSyntax throws ParserError {
        try let node parse_literal(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnExpressionSyntax(LiteralSyntax(node))
        try let node parse_type(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnExpressionSyntax(TypeSyntax(node))
        try let node parse_object(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnExpressionSyntax(ObjectSyntax(node))
        try let node parse_vector(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnExpressionSyntax(VectorSyntax(node))
        try let node parse_block(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnExpressionSyntax(BlockSyntax(node))
        try let node parse_if(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnExpressionSyntax(IfSyntax(node))
        try let node parse_match(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnExpressionSyntax(MatchSyntax(node))
        try let node parse_lambda(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnExpressionSyntax(LambdaSyntax(node))
        try let node parse_for(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnExpressionSyntax(ForSyntax(node))
        try let node parse_while(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnExpressionSyntax(WhileSyntax(node))
        try let node parse_choose(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnExpressionSyntax(ChooseSyntax(node))
        try let node parse_try(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnExpressionSyntax(TrySyntax(node))
        try let node parse_repeat(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnExpressionSyntax(RepeatSyntax(node))
        try let node parse_sizeof(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnExpressionSyntax(SizeOfSyntax(node))
        throw ParserError(DifferentSyntax())
    }

    function parse_literal(this: Parser) returns LiteralSyntax throws ParserError {
        let start = lexer.previous_position

        let literal_start = lexer.previous_position
        let literal_result = parse_literal_token(_rp)
        if (literal_result._tag == Result[Literal, ParserError]::Error)
        {
            if (literal_result._Error._tag == ParserError::DifferentSyntax)
               return Result[LiteralSyntax, ParserError] { ._tag = Result[LiteralSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }
        }

        let literal = literal_result._Ok

        let end = lexer.position

        let ret = LiteralSyntax(start, end, literal)

        return Result[LiteralSyntax, ParserError] { ._tag = Result[LiteralSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_object(this: Parser) returns ObjectSyntax throws ParserError {
        let start = lexer.previous_position

        let start_left_paren_1 = lexer.previous_position
        let success_left_paren_1 = lexer.parse_punctuation('(')
        if (!success_left_paren_1) {
            return Result[ObjectSyntax, ParserError] { ._tag = Result[ObjectSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }
        }

        let components_start = lexer.position
        let components_result = parse_component_list(rp, ep)
        choose components_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax {}
                    when i: ParserError.InvalidSyntax throw i
            }
        let components = components_result._tag == Result[Vector[ComponentSyntax], ParserError]::Error ? nullptr : components_result._Ok
    
        let start_right_paren_3 = lexer.previous_position
        let success_right_paren_3 = lexer.parse_punctuation(')')
        if (!success_right_paren_3) {
            return Result[ObjectSyntax, ParserError] { ._tag = Result[ObjectSyntax, ParserError]::Error, ._Error = ParserError(InvalidSyntax(start_right_paren_3, lexer.position, String(_ep, ")"))) }        }

        let end = lexer.position

        let ret = ObjectSyntax(start, end, components)

        return Result[ObjectSyntax, ParserError] { ._tag = Result[ObjectSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_component_list(this: Parser) returns pointer[Vector[ComponentSyntax]] throws ParserError {
        var r Region()
        List<ComponentSyntax]& list = *new(alignof(List<ComponentSyntax]), _r.get_page()) List<ComponentSyntax]()
        while(true) {
            let node_result = parse_component(rp, ep)
            if ((node_result._tag == Result[ComponentSyntax, ParserError]::Error) && (node_result._Error._tag == ParserError::InvalidSyntax))
                return Result[Vector<ComponentSyntax]*, ParserError] { ._tag = Result[Vector<ComponentSyntax]*, ParserError]::Error, ._Error = node_result._Error }
            if (node_result._tag == Result[ComponentSyntax, ParserError]::Ok) {
                let node = node_result._Ok
                list.add(node)
            } else {
                if ((list.count() == 0) && (node_result._tag == Result[ComponentSyntax, ParserError]::Error) && (node_result._Error._tag == ParserError::DifferentSyntax))
                    return Result[Vector<ComponentSyntax]*, ParserError] { ._tag = Result[Vector<ComponentSyntax]*, ParserError]::Error, ._Error = node_result._Error }
                break
            }
        }

        if (list.count() == 0)
            return Result[Vector<ComponentSyntax]*, ParserError] { ._tag = Result[Vector<ComponentSyntax]*, ParserError]::Ok, ._Ok = nullptr }
        
        return Result[Vector<ComponentSyntax]*, ParserError] {
            ._tag = Result[Vector<ComponentSyntax]*, ParserError]::Ok,
            ._Ok = new(alignof(Vector<ComponentSyntax]), _rp) Vector<ComponentSyntax](_rp, list) }
    }

    function parse_component(this: Parser) returns ComponentSyntax throws ParserError {
        let start = lexer.previous_position

        let operands_start = lexer.position
        let operands_result = parse_operand_list(rp, ep)
        choose operands_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax throw d
                    when i: ParserError.InvalidSyntax throw i
            }
        let operands = operands_result._Ok
    
        let attributes_start = lexer.position
        let attributes_result = parse_attribute_list(rp, ep)
        choose attributes_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax {}
                    when i: ParserError.InvalidSyntax throw i
            }
        let attributes = attributes_result._tag == Result[Vector[AttributeSyntax], ParserError]::Error ? nullptr : attributes_result._Ok
    
        let value_start = lexer.position
        let value_result = parse_value(rp, ep)
        if (value_result._tag == Result[ValueSyntax, ParserError]::Error)
        {
            switch (value_result._Error._tag) {
                case ParserError::DifferentSyntax:
                    break
                case ParserError::InvalidSyntax:
                    return Result[ComponentSyntax, ParserError] { ._tag = Result[ComponentSyntax, ParserError]::Error, ._Error = value_result._Error }
            }
        }

        ValueSyntax* value = value_result._tag == Result[ValueSyntax, ParserError]::Error ? nullptr : new(alignof(ValueSyntax), _rp) ValueSyntax(value_result._Ok)
    
        let start_comma_4 = lexer.previous_position
        let success_comma_4 = lexer.parse_punctuation(',')
        if (!success_comma_4) {
        }

        let end = lexer.position

        let ret = ComponentSyntax(start, end, operands, attributes, value)

        return Result[ComponentSyntax, ParserError] { ._tag = Result[ComponentSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_value(this: Parser) returns ValueSyntax throws ParserError {
        let start = lexer.previous_position

        let start_colon_1 = lexer.previous_position
        let success_colon_1 = lexer.parse_colon(_rp)
        if (!success_colon_1) {
            return Result[ValueSyntax, ParserError] { ._tag = Result[ValueSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }
        }

        let value_start = lexer.position
        let value_result = parse_operand_list(rp, ep)
        choose value_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax
                        throw InvalidSyntax(value_start, lexer.position, String(ep, "a valid Operand syntax"))
                    when i: ParserError.InvalidSyntax throw i
            }
        let value = value_result._Ok
    
        let attributes_start = lexer.position
        let attributes_result = parse_attribute_list(rp, ep)
        choose attributes_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax {}
                    when i: ParserError.InvalidSyntax throw i
            }
        let attributes = attributes_result._tag == Result[Vector[AttributeSyntax], ParserError]::Error ? nullptr : attributes_result._Ok
    
        let end = lexer.position

        let ret = ValueSyntax(start, end, value, attributes)

        return Result[ValueSyntax, ParserError] { ._tag = Result[ValueSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_vector(this: Parser) returns VectorSyntax throws ParserError {
        let start = lexer.previous_position

        let start_left_bracket_1 = lexer.previous_position
        let success_left_bracket_1 = lexer.parse_punctuation('[')
        if (!success_left_bracket_1) {
            return Result[VectorSyntax, ParserError] { ._tag = Result[VectorSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }
        }

        let elements_start = lexer.position
        let elements_result = parse_element_list(rp, ep)
        choose elements_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax
                        throw InvalidSyntax(elements_start, lexer.position, String(ep, "a valid Element syntax"))
                    when i: ParserError.InvalidSyntax throw i
            }
        let elements = elements_result._Ok
    
        let start_right_bracket_3 = lexer.previous_position
        let success_right_bracket_3 = lexer.parse_punctuation(']')
        if (!success_right_bracket_3) {
            return Result[VectorSyntax, ParserError] { ._tag = Result[VectorSyntax, ParserError]::Error, ._Error = ParserError(InvalidSyntax(start_right_bracket_3, lexer.position, String(_ep, "]"))) }        }

        let lifetime_start = lexer.position
        let lifetime_result = parse_lifetime(rp, ep)
        if (lifetime_result._tag == Result[LifetimeSyntax, ParserError]::Error)
        {
            switch (lifetime_result._Error._tag) {
                case ParserError::DifferentSyntax:
                    break
                case ParserError::InvalidSyntax:
                    return Result[VectorSyntax, ParserError] { ._tag = Result[VectorSyntax, ParserError]::Error, ._Error = lifetime_result._Error }
            }
        }

        LifetimeSyntax* lifetime = lifetime_result._tag == Result[LifetimeSyntax, ParserError]::Error ? nullptr : new(alignof(LifetimeSyntax), _rp) LifetimeSyntax(lifetime_result._Ok)
    
        let end = lexer.position

        let ret = VectorSyntax(start, end, elements, lifetime)

        return Result[VectorSyntax, ParserError] { ._tag = Result[VectorSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_element_list(this: Parser) returns pointer[Vector[ElementSyntax]] throws ParserError {
        var r Region()
        List<ElementSyntax]& list = *new(alignof(List<ElementSyntax]), _r.get_page()) List<ElementSyntax]()
        while(true) {
            let node_result = parse_element(rp, ep)
            if ((node_result._tag == Result[ElementSyntax, ParserError]::Error) && (node_result._Error._tag == ParserError::InvalidSyntax))
                return Result[Vector<ElementSyntax]*, ParserError] { ._tag = Result[Vector<ElementSyntax]*, ParserError]::Error, ._Error = node_result._Error }
            if (node_result._tag == Result[ElementSyntax, ParserError]::Ok) {
                let node = node_result._Ok
                list.add(node)
            } else {
                if ((list.count() == 0) && (node_result._tag == Result[ElementSyntax, ParserError]::Error) && (node_result._Error._tag == ParserError::DifferentSyntax))
                    return Result[Vector<ElementSyntax]*, ParserError] { ._tag = Result[Vector<ElementSyntax]*, ParserError]::Error, ._Error = node_result._Error }
                break
            }
        }

        if (list.count() == 0)
            return Result[Vector<ElementSyntax]*, ParserError] { ._tag = Result[Vector<ElementSyntax]*, ParserError]::Ok, ._Ok = nullptr }
        
        return Result[Vector<ElementSyntax]*, ParserError] {
            ._tag = Result[Vector<ElementSyntax]*, ParserError]::Ok,
            ._Ok = new(alignof(Vector<ElementSyntax]), _rp) Vector<ElementSyntax](_rp, list) }
    }

    function parse_element(this: Parser) returns ElementSyntax throws ParserError {
        let start = lexer.previous_position

        let operation_start = lexer.position
        let operation_result = parse_operand_list(rp, ep)
        choose operation_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax throw d
                    when i: ParserError.InvalidSyntax throw i
            }
        let operation = operation_result._Ok
    
        let attributes_start = lexer.position
        let attributes_result = parse_attribute_list(rp, ep)
        choose attributes_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax {}
                    when i: ParserError.InvalidSyntax throw i
            }
        let attributes = attributes_result._tag == Result[Vector[AttributeSyntax], ParserError]::Error ? nullptr : attributes_result._Ok
    
        let start_comma_3 = lexer.previous_position
        let success_comma_3 = lexer.parse_punctuation(',')
        if (!success_comma_3) {
        }

        let end = lexer.position

        let ret = ElementSyntax(start, end, operation, attributes)

        return Result[ElementSyntax, ParserError] { ._tag = Result[ElementSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_block(this: Parser) returns BlockSyntax throws ParserError {
        let start = lexer.previous_position

        let start_left_curly_1 = lexer.previous_position
        let success_left_curly_1 = lexer.parse_punctuation('{')
        if (!success_left_curly_1) {
            return Result[BlockSyntax, ParserError] { ._tag = Result[BlockSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }
        }

        let uses_start = lexer.position
        let uses_result = parse_use_list(rp, ep)
        choose uses_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax {}
                    when i: ParserError.InvalidSyntax throw i
            }
        let uses = uses_result._tag == Result[Vector[UseSyntax], ParserError]::Error ? nullptr : uses_result._Ok
    
        let statements_start = lexer.position
        let statements_result = parse_statement_list(rp, ep)
        choose statements_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax {}
                    when i: ParserError.InvalidSyntax throw i
            }
        let statements = statements_result._tag == Result[Vector[StatementSyntax], ParserError]::Error ? nullptr : statements_result._Ok
    
        let start_right_curly_4 = lexer.previous_position
        let success_right_curly_4 = lexer.parse_punctuation('}')
        if (!success_right_curly_4) {
            return Result[BlockSyntax, ParserError] { ._tag = Result[BlockSyntax, ParserError]::Error, ._Error = ParserError(InvalidSyntax(start_right_curly_4, lexer.position, String(_ep, "}"))) }        }

        let end = lexer.position

        let ret = BlockSyntax(start, end, uses, statements)

        return Result[BlockSyntax, ParserError] { ._tag = Result[BlockSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_if(this: Parser) returns IfSyntax throws ParserError {
        let start = lexer.previous_position

        let start_if_1 = lexer.previous_position
        let success_if_1 = lexer.parse_keyword(_rp, *keywords_index[13])
        if (!success_if_1) {
            return Result[IfSyntax, ParserError] { ._tag = Result[IfSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }
        }

        let condition_start = lexer.position
        let condition_result = parse_operand_list(rp, ep)
        choose condition_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax
                        throw InvalidSyntax(condition_start, lexer.position, String(ep, "a valid Operand syntax"))
                    when i: ParserError.InvalidSyntax throw i
            }
        let condition = condition_result._Ok
    
        let start_colon_3 = lexer.previous_position
        let success_colon_3 = lexer.parse_colon(_rp)
        if (!success_colon_3) {
            return Result[IfSyntax, ParserError] { ._tag = Result[IfSyntax, ParserError]::Error, ._Error = ParserError(InvalidSyntax(start_colon_3, lexer.position, String(_ep, "a colon or a line feed"))) }        }

        let consequent_start = lexer.position
        let consequent_result = parse_command(rp, ep)
        choose consequent_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax
                        throw InvalidSyntax(consequent_start, lexer.position, String(ep, "a valid Command syntax"))
                    when i: ParserError.InvalidSyntax throw i
            }
        let consequent = consequent_result._Ok
    
        let alternative_start = lexer.position
        let alternative_result = parse_else(rp, ep)
        if (alternative_result._tag == Result[ElseSyntax, ParserError]::Error)
        {
            switch (alternative_result._Error._tag) {
                case ParserError::DifferentSyntax:
                    break
                case ParserError::InvalidSyntax:
                    return Result[IfSyntax, ParserError] { ._tag = Result[IfSyntax, ParserError]::Error, ._Error = alternative_result._Error }
            }
        }

        ElseSyntax* alternative = alternative_result._tag == Result[ElseSyntax, ParserError]::Error ? nullptr : new(alignof(ElseSyntax), _rp) ElseSyntax(alternative_result._Ok)
    
        let end = lexer.position

        let ret = IfSyntax(start, end, condition, consequent, alternative)

        return Result[IfSyntax, ParserError] { ._tag = Result[IfSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_else(this: Parser) returns ElseSyntax throws ParserError {
        let start = lexer.previous_position

        let start_else_1 = lexer.previous_position
        let success_else_1 = lexer.parse_keyword(_rp, *keywords_index[8])
        if (!success_else_1) {
            return Result[ElseSyntax, ParserError] { ._tag = Result[ElseSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }
        }

        let start_colon_2 = lexer.previous_position
        let success_colon_2 = lexer.parse_colon(_rp)
        if (!success_colon_2) {
        }

        let alternative_start = lexer.position
        let alternative_result = parse_command(rp, ep)
        choose alternative_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax
                        throw InvalidSyntax(alternative_start, lexer.position, String(ep, "a valid Command syntax"))
                    when i: ParserError.InvalidSyntax throw i
            }
        let alternative = alternative_result._Ok
    
        let end = lexer.position

        let ret = ElseSyntax(start, end, alternative)

        return Result[ElseSyntax, ParserError] { ._tag = Result[ElseSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_match(this: Parser) returns MatchSyntax throws ParserError {
        let start = lexer.previous_position

        let start_match_1 = lexer.previous_position
        let success_match_1 = lexer.parse_keyword(_rp, *keywords_index[24])
        if (!success_match_1) {
            return Result[MatchSyntax, ParserError] { ._tag = Result[MatchSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }
        }

        let scrutinee_start = lexer.position
        let scrutinee_result = parse_operand_list(rp, ep)
        choose scrutinee_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax
                        throw InvalidSyntax(scrutinee_start, lexer.position, String(ep, "a valid Operand syntax"))
                    when i: ParserError.InvalidSyntax throw i
            }
        let scrutinee = scrutinee_result._Ok
    
        let start_colon_3 = lexer.previous_position
        let success_colon_3 = lexer.parse_colon(_rp)
        if (!success_colon_3) {
            return Result[MatchSyntax, ParserError] { ._tag = Result[MatchSyntax, ParserError]::Error, ._Error = ParserError(InvalidSyntax(start_colon_3, lexer.position, String(_ep, "a colon or a line feed"))) }        }

        let branches_start = lexer.position
        let branches_result = parse_branch_list(rp, ep)
        choose branches_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax
                        throw InvalidSyntax(branches_start, lexer.position, String(ep, "a valid Branch syntax"))
                    when i: ParserError.InvalidSyntax throw i
            }
        let branches = branches_result._Ok
    
        let alternative_start = lexer.position
        let alternative_result = parse_default(rp, ep)
        if (alternative_result._tag == Result[DefaultSyntax, ParserError]::Error)
        {
            switch (alternative_result._Error._tag) {
                case ParserError::DifferentSyntax:
                    break
                case ParserError::InvalidSyntax:
                    return Result[MatchSyntax, ParserError] { ._tag = Result[MatchSyntax, ParserError]::Error, ._Error = alternative_result._Error }
            }
        }

        DefaultSyntax* alternative = alternative_result._tag == Result[DefaultSyntax, ParserError]::Error ? nullptr : new(alignof(DefaultSyntax), _rp) DefaultSyntax(alternative_result._Ok)
    
        let end = lexer.position

        let ret = MatchSyntax(start, end, scrutinee, branches, alternative)

        return Result[MatchSyntax, ParserError] { ._tag = Result[MatchSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_branch_list(this: Parser) returns pointer[Vector[BranchSyntax]] throws ParserError {
        var r Region()
        List<BranchSyntax]& list = *new(alignof(List<BranchSyntax]), _r.get_page()) List<BranchSyntax]()
        while(true) {
            let node_result = parse_branch(rp, ep)
            if ((node_result._tag == Result[BranchSyntax, ParserError]::Error) && (node_result._Error._tag == ParserError::InvalidSyntax))
                return Result[Vector<BranchSyntax]*, ParserError] { ._tag = Result[Vector<BranchSyntax]*, ParserError]::Error, ._Error = node_result._Error }
            if (node_result._tag == Result[BranchSyntax, ParserError]::Ok) {
                let node = node_result._Ok
                list.add(node)
            } else {
                if ((list.count() == 0) && (node_result._tag == Result[BranchSyntax, ParserError]::Error) && (node_result._Error._tag == ParserError::DifferentSyntax))
                    return Result[Vector<BranchSyntax]*, ParserError] { ._tag = Result[Vector<BranchSyntax]*, ParserError]::Error, ._Error = node_result._Error }
                break
            }
        }

        if (list.count() == 0)
            return Result[Vector<BranchSyntax]*, ParserError] { ._tag = Result[Vector<BranchSyntax]*, ParserError]::Ok, ._Ok = nullptr }
        
        return Result[Vector<BranchSyntax]*, ParserError] {
            ._tag = Result[Vector<BranchSyntax]*, ParserError]::Ok,
            ._Ok = new(alignof(Vector<BranchSyntax]), _rp) Vector<BranchSyntax](_rp, list) }
    }

    function parse_branch(this: Parser) returns BranchSyntax throws ParserError {
        let start = lexer.previous_position

        let cases_start = lexer.position
        let cases_result = parse_case_list(rp, ep)
        choose cases_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax throw d
                    when i: ParserError.InvalidSyntax throw i
            }
        let cases = cases_result._Ok
    
        let start_colon_2 = lexer.previous_position
        let success_colon_2 = lexer.parse_colon(_rp)
        if (!success_colon_2) {
            return Result[BranchSyntax, ParserError] { ._tag = Result[BranchSyntax, ParserError]::Error, ._Error = ParserError(InvalidSyntax(start_colon_2, lexer.position, String(_ep, "a colon or a line feed"))) }        }

        let consequent_start = lexer.position
        let consequent_result = parse_statement(rp, ep)
        choose consequent_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax
                        throw InvalidSyntax(consequent_start, lexer.position, String(ep, "a valid Statement syntax"))
                    when i: ParserError.InvalidSyntax throw i
            }
        let consequent = consequent_result._Ok
    
        let end = lexer.position

        let ret = BranchSyntax(start, end, cases, consequent)

        return Result[BranchSyntax, ParserError] { ._tag = Result[BranchSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_case_list(this: Parser) returns pointer[Vector[CaseSyntax]] throws ParserError {
        var r Region()
        List<CaseSyntax]& list = *new(alignof(List<CaseSyntax]), _r.get_page()) List<CaseSyntax]()
        while(true) {
            let node_result = parse_case(rp, ep)
            if ((node_result._tag == Result[CaseSyntax, ParserError]::Error) && (node_result._Error._tag == ParserError::InvalidSyntax))
                return Result[Vector<CaseSyntax]*, ParserError] { ._tag = Result[Vector<CaseSyntax]*, ParserError]::Error, ._Error = node_result._Error }
            if (node_result._tag == Result[CaseSyntax, ParserError]::Ok) {
                let node = node_result._Ok
                list.add(node)
            } else {
                if ((list.count() == 0) && (node_result._tag == Result[CaseSyntax, ParserError]::Error) && (node_result._Error._tag == ParserError::DifferentSyntax))
                    return Result[Vector<CaseSyntax]*, ParserError] { ._tag = Result[Vector<CaseSyntax]*, ParserError]::Error, ._Error = node_result._Error }
                break
            }
        }

        if (list.count() == 0)
            return Result[Vector<CaseSyntax]*, ParserError] { ._tag = Result[Vector<CaseSyntax]*, ParserError]::Ok, ._Ok = nullptr }
        
        return Result[Vector<CaseSyntax]*, ParserError] {
            ._tag = Result[Vector<CaseSyntax]*, ParserError]::Ok,
            ._Ok = new(alignof(Vector<CaseSyntax]), _rp) Vector<CaseSyntax](_rp, list) }
    }

    function parse_case(this: Parser) returns CaseSyntax throws ParserError {
        let start = lexer.previous_position

        let start_case_1 = lexer.previous_position
        let success_case_1 = lexer.parse_keyword(_rp, *keywords_index[1])
        if (!success_case_1) {
            return Result[CaseSyntax, ParserError] { ._tag = Result[CaseSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }
        }

        let condition_start = lexer.position
        let condition_result = parse_operand_list(rp, ep)
        choose condition_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax
                        throw InvalidSyntax(condition_start, lexer.position, String(ep, "a valid Operand syntax"))
                    when i: ParserError.InvalidSyntax throw i
            }
        let condition = condition_result._Ok
    
        let end = lexer.position

        let ret = CaseSyntax(start, end, condition)

        return Result[CaseSyntax, ParserError] { ._tag = Result[CaseSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_default(this: Parser) returns DefaultSyntax throws ParserError {
        let start = lexer.previous_position

        let start_default_1 = lexer.previous_position
        let success_default_1 = lexer.parse_keyword(_rp, *keywords_index[5])
        if (!success_default_1) {
            return Result[DefaultSyntax, ParserError] { ._tag = Result[DefaultSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }
        }

        let start_colon_2 = lexer.previous_position
        let success_colon_2 = lexer.parse_colon(_rp)
        if (!success_colon_2) {
        }

        let alternative_start = lexer.position
        let alternative_result = parse_command(rp, ep)
        choose alternative_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax
                        throw InvalidSyntax(alternative_start, lexer.position, String(ep, "a valid Command syntax"))
                    when i: ParserError.InvalidSyntax throw i
            }
        let alternative = alternative_result._Ok
    
        let end = lexer.position

        let ret = DefaultSyntax(start, end, alternative)

        return Result[DefaultSyntax, ParserError] { ._tag = Result[DefaultSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_statement_list(this: Parser) returns pointer[Vector[StatementSyntax]] throws ParserError {
        var r Region()
        List<StatementSyntax]& list = *new(alignof(List<StatementSyntax]), _r.get_page()) List<StatementSyntax]()
        while(true) {
            let node_result = parse_statement(rp, ep)
            if ((node_result._tag == Result[StatementSyntax, ParserError]::Error) && (node_result._Error._tag == ParserError::InvalidSyntax))
                return Result[Vector<StatementSyntax]*, ParserError] { ._tag = Result[Vector<StatementSyntax]*, ParserError]::Error, ._Error = node_result._Error }
            if (node_result._tag == Result[StatementSyntax, ParserError]::Ok) {
                let node = node_result._Ok
                list.add(node)
            } else {
                if ((list.count() == 0) && (node_result._tag == Result[StatementSyntax, ParserError]::Error) && (node_result._Error._tag == ParserError::DifferentSyntax))
                    return Result[Vector<StatementSyntax]*, ParserError] { ._tag = Result[Vector<StatementSyntax]*, ParserError]::Error, ._Error = node_result._Error }
                break
            }
        }

        if (list.count() == 0)
            return Result[Vector<StatementSyntax]*, ParserError] { ._tag = Result[Vector<StatementSyntax]*, ParserError]::Ok, ._Ok = nullptr }
        
        return Result[Vector<StatementSyntax]*, ParserError] {
            ._tag = Result[Vector<StatementSyntax]*, ParserError]::Ok,
            ._Ok = new(alignof(Vector<StatementSyntax]), _rp) Vector<StatementSyntax](_rp, list) }
    }

    function parse_statement(this: Parser) returns StatementSyntax throws ParserError {
        let start = lexer.previous_position

        let command_start = lexer.position
        let command_result = parse_command(rp, ep)
        choose command_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax throw d
                    when i: ParserError.InvalidSyntax throw i
            }
        let command = command_result._Ok
    
        let start_colon_2 = lexer.previous_position
        let success_colon_2 = lexer.parse_colon(_rp)
        if (!success_colon_2) {
        }

        let end = lexer.position

        let ret = StatementSyntax(start, end, command)

        return Result[StatementSyntax, ParserError] { ._tag = Result[StatementSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_command(this: Parser) returns CommandSyntax throws ParserError {
        try let node parse_operation(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnCommandSyntax(OperationSyntax(node))
        try let node parse_let(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnCommandSyntax(LetSyntax(node))
        try let node parse_var(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnCommandSyntax(VarSyntax(node))
        try let node parse_mutable(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnCommandSyntax(MutableSyntax(node))
        try let node parse_set(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnCommandSyntax(SetSyntax(node))
        try let node parse_continue(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnCommandSyntax(ContinueSyntax(node))
        try let node parse_break(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnCommandSyntax(BreakSyntax(node))
        try let node parse_return(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnCommandSyntax(ReturnSyntax(node))
        try let node parse_throw(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnCommandSyntax(ThrowSyntax(node))
        throw ParserError(DifferentSyntax())
    }

    function parse_while(this: Parser) returns WhileSyntax throws ParserError {
        let start = lexer.previous_position

        let start_while_1 = lexer.previous_position
        let success_while_1 = lexer.parse_keyword(_rp, *keywords_index[43])
        if (!success_while_1) {
            return Result[WhileSyntax, ParserError] { ._tag = Result[WhileSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }
        }

        let condition_start = lexer.position
        let condition_result = parse_condition(rp, ep)
        choose condition_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax
                        throw InvalidSyntax(condition_start, lexer.position, String(ep, "a valid Condition syntax"))
                    when i: ParserError.InvalidSyntax throw i
            }
        let condition = condition_result._Ok
    
        let start_colon_3 = lexer.previous_position
        let success_colon_3 = lexer.parse_colon(_rp)
        if (!success_colon_3) {
            return Result[WhileSyntax, ParserError] { ._tag = Result[WhileSyntax, ParserError]::Error, ._Error = ParserError(InvalidSyntax(start_colon_3, lexer.position, String(_ep, "a colon or a line feed"))) }        }

        let name_start = lexer.position
        let name_result = parse_label(rp, ep)
        if (name_result._tag == Result[LabelSyntax, ParserError]::Error)
        {
            switch (name_result._Error._tag) {
                case ParserError::DifferentSyntax:
                    break
                case ParserError::InvalidSyntax:
                    return Result[WhileSyntax, ParserError] { ._tag = Result[WhileSyntax, ParserError]::Error, ._Error = name_result._Error }
            }
        }

        LabelSyntax* name = name_result._tag == Result[LabelSyntax, ParserError]::Error ? nullptr : new(alignof(LabelSyntax), _rp) LabelSyntax(name_result._Ok)
    
        let action_start = lexer.position
        let action_result = parse_action(rp, ep)
        choose action_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax
                        throw InvalidSyntax(action_start, lexer.position, String(ep, "a valid Action syntax"))
                    when i: ParserError.InvalidSyntax throw i
            }
        let action = action_result._Ok
    
        let end = lexer.position

        let ret = WhileSyntax(start, end, condition, name, action)

        return Result[WhileSyntax, ParserError] { ._tag = Result[WhileSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_choose(this: Parser) returns ChooseSyntax throws ParserError {
        let start = lexer.previous_position

        let start_choose_1 = lexer.previous_position
        let success_choose_1 = lexer.parse_keyword(_rp, *keywords_index[2])
        if (!success_choose_1) {
            return Result[ChooseSyntax, ParserError] { ._tag = Result[ChooseSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }
        }

        let condition_start = lexer.position
        let condition_result = parse_operand_list(rp, ep)
        choose condition_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax
                        throw InvalidSyntax(condition_start, lexer.position, String(ep, "a valid Operand syntax"))
                    when i: ParserError.InvalidSyntax throw i
            }
        let condition = condition_result._Ok
    
        let start_colon_3 = lexer.previous_position
        let success_colon_3 = lexer.parse_colon(_rp)
        if (!success_colon_3) {
            return Result[ChooseSyntax, ParserError] { ._tag = Result[ChooseSyntax, ParserError]::Error, ._Error = ParserError(InvalidSyntax(start_colon_3, lexer.position, String(_ep, "a colon or a line feed"))) }        }

        let cases_start = lexer.position
        let cases_result = parse_when_list(rp, ep)
        choose cases_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax {}
                    when i: ParserError.InvalidSyntax throw i
            }
        let cases = cases_result._tag == Result[Vector[WhenSyntax], ParserError]::Error ? nullptr : cases_result._Ok
    
        let alternative_start = lexer.position
        let alternative_result = parse_default(rp, ep)
        if (alternative_result._tag == Result[DefaultSyntax, ParserError]::Error)
        {
            switch (alternative_result._Error._tag) {
                case ParserError::DifferentSyntax:
                    break
                case ParserError::InvalidSyntax:
                    return Result[ChooseSyntax, ParserError] { ._tag = Result[ChooseSyntax, ParserError]::Error, ._Error = alternative_result._Error }
            }
        }

        DefaultSyntax* alternative = alternative_result._tag == Result[DefaultSyntax, ParserError]::Error ? nullptr : new(alignof(DefaultSyntax), _rp) DefaultSyntax(alternative_result._Ok)
    
        let end = lexer.position

        let ret = ChooseSyntax(start, end, condition, cases, alternative)

        return Result[ChooseSyntax, ParserError] { ._tag = Result[ChooseSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_try(this: Parser) returns TrySyntax throws ParserError {
        let start = lexer.previous_position

        let start_try_1 = lexer.previous_position
        let success_try_1 = lexer.parse_keyword(_rp, *keywords_index[38])
        if (!success_try_1) {
            return Result[TrySyntax, ParserError] { ._tag = Result[TrySyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }
        }

        let condition_start = lexer.position
        let condition_result = parse_condition(rp, ep)
        choose condition_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax
                        throw InvalidSyntax(condition_start, lexer.position, String(ep, "a valid Condition syntax"))
                    when i: ParserError.InvalidSyntax throw i
            }
        let condition = condition_result._Ok
    
        let start_colon_3 = lexer.previous_position
        let success_colon_3 = lexer.parse_colon(_rp)
        if (!success_colon_3) {
            return Result[TrySyntax, ParserError] { ._tag = Result[TrySyntax, ParserError]::Error, ._Error = ParserError(InvalidSyntax(start_colon_3, lexer.position, String(_ep, "a colon or a line feed"))) }        }

        let cases_start = lexer.position
        let cases_result = parse_when_list(rp, ep)
        choose cases_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax {}
                    when i: ParserError.InvalidSyntax throw i
            }
        let cases = cases_result._tag == Result[Vector[WhenSyntax], ParserError]::Error ? nullptr : cases_result._Ok
    
        let dropper_start = lexer.position
        let dropper_result = parse_default(rp, ep)
        if (dropper_result._tag == Result[DefaultSyntax, ParserError]::Error)
        {
            switch (dropper_result._Error._tag) {
                case ParserError::DifferentSyntax:
                    break
                case ParserError::InvalidSyntax:
                    return Result[TrySyntax, ParserError] { ._tag = Result[TrySyntax, ParserError]::Error, ._Error = dropper_result._Error }
            }
        }

        DefaultSyntax* dropper = dropper_result._tag == Result[DefaultSyntax, ParserError]::Error ? nullptr : new(alignof(DefaultSyntax), _rp) DefaultSyntax(dropper_result._Ok)
    
        let end = lexer.position

        let ret = TrySyntax(start, end, condition, cases, dropper)

        return Result[TrySyntax, ParserError] { ._tag = Result[TrySyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_condition(this: Parser) returns ConditionSyntax throws ParserError {
        try let node parse_operation(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnConditionSyntax(OperationSyntax(node))
        try let node parse_let(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnConditionSyntax(LetSyntax(node))
        throw ParserError(DifferentSyntax())
    }

    function parse_when_list(this: Parser) returns pointer[Vector[WhenSyntax]] throws ParserError {
        var r Region()
        List<WhenSyntax]& list = *new(alignof(List<WhenSyntax]), _r.get_page()) List<WhenSyntax]()
        while(true) {
            let node_result = parse_when(rp, ep)
            if ((node_result._tag == Result[WhenSyntax, ParserError]::Error) && (node_result._Error._tag == ParserError::InvalidSyntax))
                return Result[Vector<WhenSyntax]*, ParserError] { ._tag = Result[Vector<WhenSyntax]*, ParserError]::Error, ._Error = node_result._Error }
            if (node_result._tag == Result[WhenSyntax, ParserError]::Ok) {
                let node = node_result._Ok
                list.add(node)
            } else {
                if ((list.count() == 0) && (node_result._tag == Result[WhenSyntax, ParserError]::Error) && (node_result._Error._tag == ParserError::DifferentSyntax))
                    return Result[Vector<WhenSyntax]*, ParserError] { ._tag = Result[Vector<WhenSyntax]*, ParserError]::Error, ._Error = node_result._Error }
                break
            }
        }

        if (list.count() == 0)
            return Result[Vector<WhenSyntax]*, ParserError] { ._tag = Result[Vector<WhenSyntax]*, ParserError]::Ok, ._Ok = nullptr }
        
        return Result[Vector<WhenSyntax]*, ParserError] {
            ._tag = Result[Vector<WhenSyntax]*, ParserError]::Ok,
            ._Ok = new(alignof(Vector<WhenSyntax]), _rp) Vector<WhenSyntax](_rp, list) }
    }

    function parse_when(this: Parser) returns WhenSyntax throws ParserError {
        let start = lexer.previous_position

        let start_when_1 = lexer.previous_position
        let success_when_1 = lexer.parse_keyword(_rp, *keywords_index[42])
        if (!success_when_1) {
            return Result[WhenSyntax, ParserError] { ._tag = Result[WhenSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }
        }

        let start_name = lexer.previous_position
        let name = lexer.parse_identifier(_rp, keywords)
        if (name == nullptr)
        {
            return Result[WhenSyntax, ParserError] { ._tag = Result[WhenSyntax, ParserError]::Error, ._Error = ParserError(InvalidSyntax(start_name, lexer.position, String(_ep, "an identifier"))) }
        }

        let start_colon_3 = lexer.previous_position
        let success_colon_3 = lexer.parse_colon(_rp)
        if (!success_colon_3) {
            return Result[WhenSyntax, ParserError] { ._tag = Result[WhenSyntax, ParserError]::Error, ._Error = ParserError(InvalidSyntax(start_colon_3, lexer.position, String(_ep, "a colon or a line feed"))) }        }

        let variant_start = lexer.position
        let variant_result = parse_name(rp, ep)
        choose variant_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax
                        throw InvalidSyntax(variant_start, lexer.position, String(ep, "a valid Name syntax"))
                    when i: ParserError.InvalidSyntax throw i
            }
        let variant = variant_result._Ok
    
        let start_colon_5 = lexer.previous_position
        let success_colon_5 = lexer.parse_colon(_rp)
        if (!success_colon_5) {
        }

        let action_start = lexer.position
        let action_result = parse_action(rp, ep)
        choose action_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax
                        throw InvalidSyntax(action_start, lexer.position, String(ep, "a valid Action syntax"))
                    when i: ParserError.InvalidSyntax throw i
            }
        let action = action_result._Ok
    
        let start_colon_7 = lexer.previous_position
        let success_colon_7 = lexer.parse_colon(_rp)
        if (!success_colon_7) {
        }

        let end = lexer.position

        let ret = WhenSyntax(start, end, *name, variant, action)

        return Result[WhenSyntax, ParserError] { ._tag = Result[WhenSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_let(this: Parser) returns LetSyntax throws ParserError {
        let start = lexer.previous_position

        let start_let_1 = lexer.previous_position
        let success_let_1 = lexer.parse_keyword(_rp, *keywords_index[21])
        if (!success_let_1) {
            return Result[LetSyntax, ParserError] { ._tag = Result[LetSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }
        }

        let binding_start = lexer.position
        let binding_result = parse_binding(rp, ep)
        choose binding_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax
                        throw InvalidSyntax(binding_start, lexer.position, String(ep, "a valid Binding syntax"))
                    when i: ParserError.InvalidSyntax throw i
            }
        let binding = binding_result._Ok
    
        let end = lexer.position

        let ret = LetSyntax(start, end, binding)

        return Result[LetSyntax, ParserError] { ._tag = Result[LetSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_var(this: Parser) returns VarSyntax throws ParserError {
        let start = lexer.previous_position

        let start_var_1 = lexer.previous_position
        let success_var_1 = lexer.parse_keyword(_rp, *keywords_index[41])
        if (!success_var_1) {
            return Result[VarSyntax, ParserError] { ._tag = Result[VarSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }
        }

        let binding_start = lexer.position
        let binding_result = parse_binding(rp, ep)
        choose binding_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax
                        throw InvalidSyntax(binding_start, lexer.position, String(ep, "a valid Binding syntax"))
                    when i: ParserError.InvalidSyntax throw i
            }
        let binding = binding_result._Ok
    
        let end = lexer.position

        let ret = VarSyntax(start, end, binding)

        return Result[VarSyntax, ParserError] { ._tag = Result[VarSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_mutable(this: Parser) returns MutableSyntax throws ParserError {
        let start = lexer.previous_position

        let start_mutable_1 = lexer.previous_position
        let success_mutable_1 = lexer.parse_keyword(_rp, *keywords_index[26])
        if (!success_mutable_1) {
            return Result[MutableSyntax, ParserError] { ._tag = Result[MutableSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }
        }

        let binding_start = lexer.position
        let binding_result = parse_binding(rp, ep)
        choose binding_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax
                        throw InvalidSyntax(binding_start, lexer.position, String(ep, "a valid Binding syntax"))
                    when i: ParserError.InvalidSyntax throw i
            }
        let binding = binding_result._Ok
    
        let end = lexer.position

        let ret = MutableSyntax(start, end, binding)

        return Result[MutableSyntax, ParserError] { ._tag = Result[MutableSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_binding(this: Parser) returns BindingSyntax throws ParserError {
        let start = lexer.previous_position

        let start_name = lexer.previous_position
        let name = lexer.parse_identifier(_rp, keywords)
        if (name == nullptr)
        {
            return Result[BindingSyntax, ParserError] { ._tag = Result[BindingSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }

        }

        let annotation_start = lexer.position
        let annotation_result = parse_bindingannotation(rp, ep)
        if (annotation_result._tag == Result[BindingAnnotationSyntax, ParserError]::Error)
        {
            switch (annotation_result._Error._tag) {
                case ParserError::DifferentSyntax:
                    break
                case ParserError::InvalidSyntax:
                    return Result[BindingSyntax, ParserError] { ._tag = Result[BindingSyntax, ParserError]::Error, ._Error = annotation_result._Error }
            }
        }

        BindingAnnotationSyntax* annotation = annotation_result._tag == Result[BindingAnnotationSyntax, ParserError]::Error ? nullptr : new(alignof(BindingAnnotationSyntax), _rp) BindingAnnotationSyntax(annotation_result._Ok)
    
        let operation_start = lexer.position
        let operation_result = parse_operand_list(rp, ep)
        choose operation_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax
                        throw InvalidSyntax(operation_start, lexer.position, String(ep, "a valid Operand syntax"))
                    when i: ParserError.InvalidSyntax throw i
            }
        let operation = operation_result._Ok
    
        let end = lexer.position

        let ret = BindingSyntax(start, end, *name, annotation, operation)

        return Result[BindingSyntax, ParserError] { ._tag = Result[BindingSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_bindingannotation(this: Parser) returns BindingAnnotationSyntax throws ParserError {
        let start = lexer.previous_position

        let start_colon_1 = lexer.previous_position
        let success_colon_1 = lexer.parse_colon(_rp)
        if (!success_colon_1) {
            return Result[BindingAnnotationSyntax, ParserError] { ._tag = Result[BindingAnnotationSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }
        }

        let spec_start = lexer.position
        let spec_result = parse_bindingspec(rp, ep)
        choose spec_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax
                        throw InvalidSyntax(spec_start, lexer.position, String(ep, "a valid BindingSpec syntax"))
                    when i: ParserError.InvalidSyntax throw i
            }
        let spec = spec_result._Ok
    
        let end = lexer.position

        let ret = BindingAnnotationSyntax(start, end, spec)

        return Result[BindingAnnotationSyntax, ParserError] { ._tag = Result[BindingAnnotationSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_bindingspec_list(this: Parser) returns pointer[Vector[BindingSpecSyntax]] throws ParserError {
        var r Region()
        List<BindingSpecSyntax]& list = *new(alignof(List<BindingSpecSyntax]), _r.get_page()) List<BindingSpecSyntax]()
        while(true) {
            let node_result = parse_bindingspec(rp, ep)
            if ((node_result._tag == Result[BindingSpecSyntax, ParserError]::Error) && (node_result._Error._tag == ParserError::InvalidSyntax))
                return Result[Vector<BindingSpecSyntax]*, ParserError] { ._tag = Result[Vector<BindingSpecSyntax]*, ParserError]::Error, ._Error = node_result._Error }
            if (node_result._tag == Result[BindingSpecSyntax, ParserError]::Ok) {
                let node = node_result._Ok
                list.add(node)
            } else {
                if ((list.count() == 0) && (node_result._tag == Result[BindingSpecSyntax, ParserError]::Error) && (node_result._Error._tag == ParserError::DifferentSyntax))
                    return Result[Vector<BindingSpecSyntax]*, ParserError] { ._tag = Result[Vector<BindingSpecSyntax]*, ParserError]::Error, ._Error = node_result._Error }
                break
            }
        }

        if (list.count() == 0)
            return Result[Vector<BindingSpecSyntax]*, ParserError] { ._tag = Result[Vector<BindingSpecSyntax]*, ParserError]::Ok, ._Ok = nullptr }
        
        return Result[Vector<BindingSpecSyntax]*, ParserError] {
            ._tag = Result[Vector<BindingSpecSyntax]*, ParserError]::Ok,
            ._Ok = new(alignof(Vector<BindingSpecSyntax]), _rp) Vector<BindingSpecSyntax](_rp, list) }
    }

    function parse_bindingspec(this: Parser) returns BindingSpecSyntax throws ParserError {
        try let node parse_structure(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnBindingSpecSyntax(StructureSyntax(node))
        try let node parse_type(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnBindingSpecSyntax(TypeSyntax(node))
        try let node parse_array(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnBindingSpecSyntax(ArraySyntax(node))
        throw ParserError(DifferentSyntax())
    }

    function parse_array(this: Parser) returns ArraySyntax throws ParserError {
        let start = lexer.previous_position

        let start_left_bracket_1 = lexer.previous_position
        let success_left_bracket_1 = lexer.parse_punctuation('[')
        if (!success_left_bracket_1) {
            return Result[ArraySyntax, ParserError] { ._tag = Result[ArraySyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }
        }

        let members_start = lexer.position
        let members_result = parse_type_list(rp, ep)
        choose members_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax {}
                    when i: ParserError.InvalidSyntax throw i
            }
        let members = members_result._tag == Result[Vector[TypeSyntax], ParserError]::Error ? nullptr : members_result._Ok
    
        let start_right_bracket_3 = lexer.previous_position
        let success_right_bracket_3 = lexer.parse_punctuation(']')
        if (!success_right_bracket_3) {
            return Result[ArraySyntax, ParserError] { ._tag = Result[ArraySyntax, ParserError]::Error, ._Error = ParserError(InvalidSyntax(start_right_bracket_3, lexer.position, String(_ep, "]"))) }        }

        let end = lexer.position

        let ret = ArraySyntax(start, end, members)

        return Result[ArraySyntax, ParserError] { ._tag = Result[ArraySyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_structure(this: Parser) returns StructureSyntax throws ParserError {
        let start = lexer.previous_position

        let start_left_paren_1 = lexer.previous_position
        let success_left_paren_1 = lexer.parse_punctuation('(')
        if (!success_left_paren_1) {
            return Result[StructureSyntax, ParserError] { ._tag = Result[StructureSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }
        }

        let parts_start = lexer.position
        let parts_result = parse_part_list(rp, ep)
        choose parts_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax {}
                    when i: ParserError.InvalidSyntax throw i
            }
        let parts = parts_result._tag == Result[Vector[PartSyntax], ParserError]::Error ? nullptr : parts_result._Ok
    
        let start_right_paren_3 = lexer.previous_position
        let success_right_paren_3 = lexer.parse_punctuation(')')
        if (!success_right_paren_3) {
            return Result[StructureSyntax, ParserError] { ._tag = Result[StructureSyntax, ParserError]::Error, ._Error = ParserError(InvalidSyntax(start_right_paren_3, lexer.position, String(_ep, ")"))) }        }

        let end = lexer.position

        let ret = StructureSyntax(start, end, parts)

        return Result[StructureSyntax, ParserError] { ._tag = Result[StructureSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_part_list(this: Parser) returns pointer[Vector[PartSyntax]] throws ParserError {
        var r Region()
        List<PartSyntax]& list = *new(alignof(List<PartSyntax]), _r.get_page()) List<PartSyntax]()
        while(true) {
            let node_result = parse_part(rp, ep)
            if ((node_result._tag == Result[PartSyntax, ParserError]::Error) && (node_result._Error._tag == ParserError::InvalidSyntax))
                return Result[Vector<PartSyntax]*, ParserError] { ._tag = Result[Vector<PartSyntax]*, ParserError]::Error, ._Error = node_result._Error }
            if (node_result._tag == Result[PartSyntax, ParserError]::Ok) {
                let node = node_result._Ok
                list.add(node)
            } else {
                if ((list.count() == 0) && (node_result._tag == Result[PartSyntax, ParserError]::Error) && (node_result._Error._tag == ParserError::DifferentSyntax))
                    return Result[Vector<PartSyntax]*, ParserError] { ._tag = Result[Vector<PartSyntax]*, ParserError]::Error, ._Error = node_result._Error }
                break
            }
        }

        if (list.count() == 0)
            return Result[Vector<PartSyntax]*, ParserError] { ._tag = Result[Vector<PartSyntax]*, ParserError]::Ok, ._Ok = nullptr }
        
        return Result[Vector<PartSyntax]*, ParserError] {
            ._tag = Result[Vector<PartSyntax]*, ParserError]::Ok,
            ._Ok = new(alignof(Vector<PartSyntax]), _rp) Vector<PartSyntax](_rp, list) }
    }

    function parse_part(this: Parser) returns PartSyntax throws ParserError {
        try let node parse_field(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnPartSyntax(FieldSyntax(node))
        try let node parse_property(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnPartSyntax(PropertySyntax(node))
        throw ParserError(DifferentSyntax())
    }

    function parse_field(this: Parser) returns FieldSyntax throws ParserError {
        let start = lexer.previous_position

        let start_private_1 = lexer.previous_position
        let success_private_1 = lexer.parse_keyword(_rp, *keywords_index[29])
        if (!success_private_1) {
            return Result[FieldSyntax, ParserError] { ._tag = Result[FieldSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }
        }

        let property_start = lexer.position
        let property_result = parse_property(rp, ep)
        choose property_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax
                        throw InvalidSyntax(property_start, lexer.position, String(ep, "a valid Property syntax"))
                    when i: ParserError.InvalidSyntax throw i
            }
        let property = property_result._Ok
    
        let end = lexer.position

        let ret = FieldSyntax(start, end, property)

        return Result[FieldSyntax, ParserError] { ._tag = Result[FieldSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_property_list(this: Parser) returns pointer[Vector[PropertySyntax]] throws ParserError {
        var r Region()
        List<PropertySyntax]& list = *new(alignof(List<PropertySyntax]), _r.get_page()) List<PropertySyntax]()
        while(true) {
            let node_result = parse_property(rp, ep)
            if ((node_result._tag == Result[PropertySyntax, ParserError]::Error) && (node_result._Error._tag == ParserError::InvalidSyntax))
                return Result[Vector<PropertySyntax]*, ParserError] { ._tag = Result[Vector<PropertySyntax]*, ParserError]::Error, ._Error = node_result._Error }
            if (node_result._tag == Result[PropertySyntax, ParserError]::Ok) {
                let node = node_result._Ok
                list.add(node)
            } else {
                if ((list.count() == 0) && (node_result._tag == Result[PropertySyntax, ParserError]::Error) && (node_result._Error._tag == ParserError::DifferentSyntax))
                    return Result[Vector<PropertySyntax]*, ParserError] { ._tag = Result[Vector<PropertySyntax]*, ParserError]::Error, ._Error = node_result._Error }
                break
            }
        }

        if (list.count() == 0)
            return Result[Vector<PropertySyntax]*, ParserError] { ._tag = Result[Vector<PropertySyntax]*, ParserError]::Ok, ._Ok = nullptr }
        
        return Result[Vector<PropertySyntax]*, ParserError] {
            ._tag = Result[Vector<PropertySyntax]*, ParserError]::Ok,
            ._Ok = new(alignof(Vector<PropertySyntax]), _rp) Vector<PropertySyntax](_rp, list) }
    }

    function parse_property(this: Parser) returns PropertySyntax throws ParserError {
        let start = lexer.previous_position

        let start_name = lexer.previous_position
        let name = lexer.parse_identifier(_rp, keywords)
        if (name == nullptr)
        {
            return Result[PropertySyntax, ParserError] { ._tag = Result[PropertySyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }

        }

        let annotation_start = lexer.position
        let annotation_result = parse_typeannotation(rp, ep)
        choose annotation_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax
                        throw InvalidSyntax(annotation_start, lexer.position, String(ep, "a valid TypeAnnotation syntax"))
                    when i: ParserError.InvalidSyntax throw i
            }
        let annotation = annotation_result._Ok
    
        let initializer_start = lexer.position
        let initializer_result = parse_initializer(rp, ep)
        if (initializer_result._tag == Result[InitializerSyntax, ParserError]::Error)
        {
            switch (initializer_result._Error._tag) {
                case ParserError::DifferentSyntax:
                    break
                case ParserError::InvalidSyntax:
                    return Result[PropertySyntax, ParserError] { ._tag = Result[PropertySyntax, ParserError]::Error, ._Error = initializer_result._Error }
            }
        }

        InitializerSyntax* initializer = initializer_result._tag == Result[InitializerSyntax, ParserError]::Error ? nullptr : new(alignof(InitializerSyntax), _rp) InitializerSyntax(initializer_result._Ok)
    
        let start_comma_4 = lexer.previous_position
        let success_comma_4 = lexer.parse_punctuation(',')
        if (!success_comma_4) {
        }

        let start_colon_5 = lexer.previous_position
        let success_colon_5 = lexer.parse_colon(_rp)
        if (!success_colon_5) {
        }

        let attributes_start = lexer.position
        let attributes_result = parse_attribute_list(rp, ep)
        choose attributes_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax {}
                    when i: ParserError.InvalidSyntax throw i
            }
        let attributes = attributes_result._tag == Result[Vector[AttributeSyntax], ParserError]::Error ? nullptr : attributes_result._Ok
    
        let start_colon_7 = lexer.previous_position
        let success_colon_7 = lexer.parse_colon(_rp)
        if (!success_colon_7) {
        }

        let end = lexer.position

        let ret = PropertySyntax(start, end, *name, annotation, initializer, attributes)

        return Result[PropertySyntax, ParserError] { ._tag = Result[PropertySyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_typeannotation(this: Parser) returns TypeAnnotationSyntax throws ParserError {
        let start = lexer.previous_position

        let start_colon_1 = lexer.previous_position
        let success_colon_1 = lexer.parse_colon(_rp)
        if (!success_colon_1) {
            return Result[TypeAnnotationSyntax, ParserError] { ._tag = Result[TypeAnnotationSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }
        }

        let type_start = lexer.position
        let type_result = parse_type(rp, ep)
        choose type_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax
                        throw InvalidSyntax(type_start, lexer.position, String(ep, "a valid Type syntax"))
                    when i: ParserError.InvalidSyntax throw i
            }
        let type = type_result._Ok
    
        let end = lexer.position

        let ret = TypeAnnotationSyntax(start, end, type)

        return Result[TypeAnnotationSyntax, ParserError] { ._tag = Result[TypeAnnotationSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_continue(this: Parser) returns ContinueSyntax throws ParserError {
        let start = lexer.previous_position

        let start_continue_1 = lexer.previous_position
        let success_continue_1 = lexer.parse_keyword(_rp, *keywords_index[3])
        if (!success_continue_1) {
            return Result[ContinueSyntax, ParserError] { ._tag = Result[ContinueSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }
        }

        let name_start = lexer.position
        let name_result = parse_loop(rp, ep)
        if (name_result._tag == Result[LoopSyntax, ParserError]::Error)
        {
            switch (name_result._Error._tag) {
                case ParserError::DifferentSyntax:
                    break
                case ParserError::InvalidSyntax:
                    return Result[ContinueSyntax, ParserError] { ._tag = Result[ContinueSyntax, ParserError]::Error, ._Error = name_result._Error }
            }
        }

        LoopSyntax* name = name_result._tag == Result[LoopSyntax, ParserError]::Error ? nullptr : new(alignof(LoopSyntax), _rp) LoopSyntax(name_result._Ok)
    
        let start_colon_3 = lexer.previous_position
        let success_colon_3 = lexer.parse_colon(_rp)
        if (!success_colon_3) {
        }

        let end = lexer.position

        let ret = ContinueSyntax(start, end, name)

        return Result[ContinueSyntax, ParserError] { ._tag = Result[ContinueSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_break(this: Parser) returns BreakSyntax throws ParserError {
        let start = lexer.previous_position

        let start_break_1 = lexer.previous_position
        let success_break_1 = lexer.parse_keyword(_rp, *keywords_index[0])
        if (!success_break_1) {
            return Result[BreakSyntax, ParserError] { ._tag = Result[BreakSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }
        }

        let name_start = lexer.position
        let name_result = parse_loop(rp, ep)
        if (name_result._tag == Result[LoopSyntax, ParserError]::Error)
        {
            switch (name_result._Error._tag) {
                case ParserError::DifferentSyntax:
                    break
                case ParserError::InvalidSyntax:
                    return Result[BreakSyntax, ParserError] { ._tag = Result[BreakSyntax, ParserError]::Error, ._Error = name_result._Error }
            }
        }

        LoopSyntax* name = name_result._tag == Result[LoopSyntax, ParserError]::Error ? nullptr : new(alignof(LoopSyntax), _rp) LoopSyntax(name_result._Ok)
    
        let result_start = lexer.position
        let result_result = parse_operand_list(rp, ep)
        choose result_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax {}
                    when i: ParserError.InvalidSyntax throw i
            }
        let result = result_result._tag == Result[Vector[OperandSyntax], ParserError]::Error ? nullptr : result_result._Ok
    
        let start_colon_4 = lexer.previous_position
        let success_colon_4 = lexer.parse_colon(_rp)
        if (!success_colon_4) {
        }

        let end = lexer.position

        let ret = BreakSyntax(start, end, name, result)

        return Result[BreakSyntax, ParserError] { ._tag = Result[BreakSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_loop(this: Parser) returns LoopSyntax throws ParserError {
        let start = lexer.previous_position

        let start_loop_1 = lexer.previous_position
        let success_loop_1 = lexer.parse_keyword(_rp, *keywords_index[22])
        if (!success_loop_1) {
            return Result[LoopSyntax, ParserError] { ._tag = Result[LoopSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }
        }

        let start_name = lexer.previous_position
        let name = lexer.parse_identifier(_rp, keywords)
        if (name == nullptr)
        {
            return Result[LoopSyntax, ParserError] { ._tag = Result[LoopSyntax, ParserError]::Error, ._Error = ParserError(InvalidSyntax(start_name, lexer.position, String(_ep, "an identifier"))) }
        }

        let end = lexer.position

        let ret = LoopSyntax(start, end, *name)

        return Result[LoopSyntax, ParserError] { ._tag = Result[LoopSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_return(this: Parser) returns ReturnSyntax throws ParserError {
        let start = lexer.previous_position

        let start_return_1 = lexer.previous_position
        let success_return_1 = lexer.parse_keyword(_rp, *keywords_index[30])
        if (!success_return_1) {
            return Result[ReturnSyntax, ParserError] { ._tag = Result[ReturnSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }
        }

        let result_start = lexer.position
        let result_result = parse_operand_list(rp, ep)
        choose result_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax {}
                    when i: ParserError.InvalidSyntax throw i
            }
        let result = result_result._tag == Result[Vector[OperandSyntax], ParserError]::Error ? nullptr : result_result._Ok
    
        let end = lexer.position

        let ret = ReturnSyntax(start, end, result)

        return Result[ReturnSyntax, ParserError] { ._tag = Result[ReturnSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_throw(this: Parser) returns ThrowSyntax throws ParserError {
        let start = lexer.previous_position

        let start_throw_1 = lexer.previous_position
        let success_throw_1 = lexer.parse_keyword(_rp, *keywords_index[35])
        if (!success_throw_1) {
            return Result[ThrowSyntax, ParserError] { ._tag = Result[ThrowSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }
        }

        let result_start = lexer.position
        let result_result = parse_operand_list(rp, ep)
        choose result_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax {}
                    when i: ParserError.InvalidSyntax throw i
            }
        let result = result_result._tag == Result[Vector[OperandSyntax], ParserError]::Error ? nullptr : result_result._Ok
    
        let end = lexer.position

        let ret = ThrowSyntax(start, end, result)

        return Result[ThrowSyntax, ParserError] { ._tag = Result[ThrowSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_lambda(this: Parser) returns LambdaSyntax throws ParserError {
        let start = lexer.previous_position

        let start_lambda_1 = lexer.previous_position
        let success_lambda_1 = lexer.parse_keyword(_rp, *keywords_index[20])
        if (!success_lambda_1) {
            return Result[LambdaSyntax, ParserError] { ._tag = Result[LambdaSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }
        }

        let input_start = lexer.position
        let input_result = parse_operand_list(rp, ep)
        choose input_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax
                        throw InvalidSyntax(input_start, lexer.position, String(ep, "a valid Operand syntax"))
                    when i: ParserError.InvalidSyntax throw i
            }
        let input = input_result._Ok
    
        let start_colon_3 = lexer.previous_position
        let success_colon_3 = lexer.parse_colon(_rp)
        if (!success_colon_3) {
            return Result[LambdaSyntax, ParserError] { ._tag = Result[LambdaSyntax, ParserError]::Error, ._Error = ParserError(InvalidSyntax(start_colon_3, lexer.position, String(_ep, "a colon or a line feed"))) }        }

        let block_start = lexer.position
        let block_result = parse_action(rp, ep)
        choose block_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax
                        throw InvalidSyntax(block_start, lexer.position, String(ep, "a valid Action syntax"))
                    when i: ParserError.InvalidSyntax throw i
            }
        let block = block_result._Ok
    
        let end = lexer.position

        let ret = LambdaSyntax(start, end, input, block)

        return Result[LambdaSyntax, ParserError] { ._tag = Result[LambdaSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_for(this: Parser) returns ForSyntax throws ParserError {
        let start = lexer.previous_position

        let start_for_1 = lexer.previous_position
        let success_for_1 = lexer.parse_keyword(_rp, *keywords_index[11])
        if (!success_for_1) {
            return Result[ForSyntax, ParserError] { ._tag = Result[ForSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }
        }

        let start_variable = lexer.previous_position
        let variable = lexer.parse_identifier(_rp, keywords)
        if (variable == nullptr)
        {
            return Result[ForSyntax, ParserError] { ._tag = Result[ForSyntax, ParserError]::Error, ._Error = ParserError(InvalidSyntax(start_variable, lexer.position, String(_ep, "an identifier"))) }
        }

        let annotation_start = lexer.position
        let annotation_result = parse_typeannotation(rp, ep)
        if (annotation_result._tag == Result[TypeAnnotationSyntax, ParserError]::Error)
        {
            switch (annotation_result._Error._tag) {
                case ParserError::DifferentSyntax:
                    break
                case ParserError::InvalidSyntax:
                    return Result[ForSyntax, ParserError] { ._tag = Result[ForSyntax, ParserError]::Error, ._Error = annotation_result._Error }
            }
        }

        TypeAnnotationSyntax* annotation = annotation_result._tag == Result[TypeAnnotationSyntax, ParserError]::Error ? nullptr : new(alignof(TypeAnnotationSyntax), _rp) TypeAnnotationSyntax(annotation_result._Ok)
    
        let start_in_4 = lexer.previous_position
        let success_in_4 = lexer.parse_keyword(_rp, *keywords_index[16])
        if (!success_in_4) {
            return Result[ForSyntax, ParserError] { ._tag = Result[ForSyntax, ParserError]::Error, ._Error = ParserError(InvalidSyntax(start_in_4, lexer.position, String(_ep, "in"))) }        }

        let operation_start = lexer.position
        let operation_result = parse_operand_list(rp, ep)
        choose operation_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax
                        throw InvalidSyntax(operation_start, lexer.position, String(ep, "a valid Operand syntax"))
                    when i: ParserError.InvalidSyntax throw i
            }
        let operation = operation_result._Ok
    
        let start_colon_6 = lexer.previous_position
        let success_colon_6 = lexer.parse_colon(_rp)
        if (!success_colon_6) {
            return Result[ForSyntax, ParserError] { ._tag = Result[ForSyntax, ParserError]::Error, ._Error = ParserError(InvalidSyntax(start_colon_6, lexer.position, String(_ep, "a colon or a line feed"))) }        }

        let name_start = lexer.position
        let name_result = parse_label(rp, ep)
        if (name_result._tag == Result[LabelSyntax, ParserError]::Error)
        {
            switch (name_result._Error._tag) {
                case ParserError::DifferentSyntax:
                    break
                case ParserError::InvalidSyntax:
                    return Result[ForSyntax, ParserError] { ._tag = Result[ForSyntax, ParserError]::Error, ._Error = name_result._Error }
            }
        }

        LabelSyntax* name = name_result._tag == Result[LabelSyntax, ParserError]::Error ? nullptr : new(alignof(LabelSyntax), _rp) LabelSyntax(name_result._Ok)
    
        let action_start = lexer.position
        let action_result = parse_action(rp, ep)
        choose action_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax
                        throw InvalidSyntax(action_start, lexer.position, String(ep, "a valid Action syntax"))
                    when i: ParserError.InvalidSyntax throw i
            }
        let action = action_result._Ok
    
        let end = lexer.position

        let ret = ForSyntax(start, end, *variable, annotation, operation, name, action)

        return Result[ForSyntax, ParserError] { ._tag = Result[ForSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_label(this: Parser) returns LabelSyntax throws ParserError {
        let start = lexer.previous_position

        let start_label_1 = lexer.previous_position
        let success_label_1 = lexer.parse_keyword(_rp, *keywords_index[19])
        if (!success_label_1) {
            return Result[LabelSyntax, ParserError] { ._tag = Result[LabelSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }
        }

        let start_name = lexer.previous_position
        let name = lexer.parse_identifier(_rp, keywords)
        if (name == nullptr)
        {
            return Result[LabelSyntax, ParserError] { ._tag = Result[LabelSyntax, ParserError]::Error, ._Error = ParserError(InvalidSyntax(start_name, lexer.position, String(_ep, "an identifier"))) }
        }

        let start_colon_3 = lexer.previous_position
        let success_colon_3 = lexer.parse_colon(_rp)
        if (!success_colon_3) {
        }

        let end = lexer.position

        let ret = LabelSyntax(start, end, *name)

        return Result[LabelSyntax, ParserError] { ._tag = Result[LabelSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_repeat(this: Parser) returns RepeatSyntax throws ParserError {
        let start = lexer.previous_position

        let start_repeat_1 = lexer.previous_position
        let success_repeat_1 = lexer.parse_keyword(_rp, *keywords_index[32])
        if (!success_repeat_1) {
            return Result[RepeatSyntax, ParserError] { ._tag = Result[RepeatSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }
        }

        let name_start = lexer.position
        let name_result = parse_label(rp, ep)
        if (name_result._tag == Result[LabelSyntax, ParserError]::Error)
        {
            switch (name_result._Error._tag) {
                case ParserError::DifferentSyntax:
                    break
                case ParserError::InvalidSyntax:
                    return Result[RepeatSyntax, ParserError] { ._tag = Result[RepeatSyntax, ParserError]::Error, ._Error = name_result._Error }
            }
        }

        LabelSyntax* name = name_result._tag == Result[LabelSyntax, ParserError]::Error ? nullptr : new(alignof(LabelSyntax), _rp) LabelSyntax(name_result._Ok)
    
        let action_start = lexer.position
        let action_result = parse_action(rp, ep)
        choose action_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax
                        throw InvalidSyntax(action_start, lexer.position, String(ep, "a valid Action syntax"))
                    when i: ParserError.InvalidSyntax throw i
            }
        let action = action_result._Ok
    
        let end = lexer.position

        let ret = RepeatSyntax(start, end, name, action)

        return Result[RepeatSyntax, ParserError] { ._tag = Result[RepeatSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_action_list(this: Parser) returns pointer[Vector[ActionSyntax]] throws ParserError {
        var r Region()
        List<ActionSyntax]& list = *new(alignof(List<ActionSyntax]), _r.get_page()) List<ActionSyntax]()
        while(true) {
            let node_result = parse_action(rp, ep)
            if ((node_result._tag == Result[ActionSyntax, ParserError]::Error) && (node_result._Error._tag == ParserError::InvalidSyntax))
                return Result[Vector<ActionSyntax]*, ParserError] { ._tag = Result[Vector<ActionSyntax]*, ParserError]::Error, ._Error = node_result._Error }
            if (node_result._tag == Result[ActionSyntax, ParserError]::Ok) {
                let node = node_result._Ok
                list.add(node)
            } else {
                if ((list.count() == 0) && (node_result._tag == Result[ActionSyntax, ParserError]::Error) && (node_result._Error._tag == ParserError::DifferentSyntax))
                    return Result[Vector<ActionSyntax]*, ParserError] { ._tag = Result[Vector<ActionSyntax]*, ParserError]::Error, ._Error = node_result._Error }
                break
            }
        }

        if (list.count() == 0)
            return Result[Vector<ActionSyntax]*, ParserError] { ._tag = Result[Vector<ActionSyntax]*, ParserError]::Ok, ._Ok = nullptr }
        
        return Result[Vector<ActionSyntax]*, ParserError] {
            ._tag = Result[Vector<ActionSyntax]*, ParserError]::Ok,
            ._Ok = new(alignof(Vector<ActionSyntax]), _rp) Vector<ActionSyntax](_rp, list) }
    }

    function parse_action(this: Parser) returns ActionSyntax throws ParserError {
        try let node parse_operation(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnActionSyntax(OperationSyntax(node))
        try let node parse_set(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnActionSyntax(SetSyntax(node))
        throw ParserError(DifferentSyntax())
    }

    function parse_operation(this: Parser) returns OperationSyntax throws ParserError {
        let start = lexer.previous_position

        let operands_start = lexer.position
        let operands_result = parse_operand_list(rp, ep)
        choose operands_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax throw d
                    when i: ParserError.InvalidSyntax throw i
            }
        let operands = operands_result._Ok
    
        let end = lexer.position

        let ret = OperationSyntax(start, end, operands)

        return Result[OperationSyntax, ParserError] { ._tag = Result[OperationSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_set(this: Parser) returns SetSyntax throws ParserError {
        let start = lexer.previous_position

        let start_set_1 = lexer.previous_position
        let success_set_1 = lexer.parse_keyword(_rp, *keywords_index[33])
        if (!success_set_1) {
            return Result[SetSyntax, ParserError] { ._tag = Result[SetSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }
        }

        let target_start = lexer.position
        let target_result = parse_operand_list(rp, ep)
        choose target_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax
                        throw InvalidSyntax(target_start, lexer.position, String(ep, "a valid Operand syntax"))
                    when i: ParserError.InvalidSyntax throw i
            }
        let target = target_result._Ok
    
        let start_colon_3 = lexer.previous_position
        let success_colon_3 = lexer.parse_colon(_rp)
        if (!success_colon_3) {
            return Result[SetSyntax, ParserError] { ._tag = Result[SetSyntax, ParserError]::Error, ._Error = ParserError(InvalidSyntax(start_colon_3, lexer.position, String(_ep, "a colon or a line feed"))) }        }

        let source_start = lexer.position
        let source_result = parse_operand_list(rp, ep)
        choose source_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax
                        throw InvalidSyntax(source_start, lexer.position, String(ep, "a valid Operand syntax"))
                    when i: ParserError.InvalidSyntax throw i
            }
        let source = source_result._Ok
    
        let end = lexer.position

        let ret = SetSyntax(start, end, target, source)

        return Result[SetSyntax, ParserError] { ._tag = Result[SetSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_sizeof(this: Parser) returns SizeOfSyntax throws ParserError {
        let start = lexer.previous_position

        let start_sizeof_1 = lexer.previous_position
        let success_sizeof_1 = lexer.parse_keyword(_rp, *keywords_index[34])
        if (!success_sizeof_1) {
            return Result[SizeOfSyntax, ParserError] { ._tag = Result[SizeOfSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }
        }

        let type_start = lexer.position
        let type_result = parse_type(rp, ep)
        choose type_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax
                        throw InvalidSyntax(type_start, lexer.position, String(ep, "a valid Type syntax"))
                    when i: ParserError.InvalidSyntax throw i
            }
        let type = type_result._Ok
    
        let end = lexer.position

        let ret = SizeOfSyntax(start, end, type)

        return Result[SizeOfSyntax, ParserError] { ._tag = Result[SizeOfSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_type_list(this: Parser) returns pointer[Vector[TypeSyntax]] throws ParserError {
        var r Region()
        List<TypeSyntax]& list = *new(alignof(List<TypeSyntax]), _r.get_page()) List<TypeSyntax]()
        while(true) {
            let node_result = parse_type(rp, ep)
            if ((node_result._tag == Result[TypeSyntax, ParserError]::Error) && (node_result._Error._tag == ParserError::InvalidSyntax))
                return Result[Vector<TypeSyntax]*, ParserError] { ._tag = Result[Vector<TypeSyntax]*, ParserError]::Error, ._Error = node_result._Error }
            if (node_result._tag == Result[TypeSyntax, ParserError]::Ok) {
                let node = node_result._Ok
                list.add(node)
            } else {
                if ((list.count() == 0) && (node_result._tag == Result[TypeSyntax, ParserError]::Error) && (node_result._Error._tag == ParserError::DifferentSyntax))
                    return Result[Vector<TypeSyntax]*, ParserError] { ._tag = Result[Vector<TypeSyntax]*, ParserError]::Error, ._Error = node_result._Error }
                break
            }
        }

        if (list.count() == 0)
            return Result[Vector<TypeSyntax]*, ParserError] { ._tag = Result[Vector<TypeSyntax]*, ParserError]::Ok, ._Ok = nullptr }
        
        return Result[Vector<TypeSyntax]*, ParserError] {
            ._tag = Result[Vector<TypeSyntax]*, ParserError]::Ok,
            ._Ok = new(alignof(Vector<TypeSyntax]), _rp) Vector<TypeSyntax](_rp, list) }
    }

    function parse_type(this: Parser) returns TypeSyntax throws ParserError {
        let start = lexer.previous_position

        let name_start = lexer.position
        let name_result = parse_name(rp, ep)
        choose name_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax throw d
                    when i: ParserError.InvalidSyntax throw i
            }
        let name = name_result._Ok
    
        let generics_start = lexer.position
        let generics_result = parse_genericarguments(rp, ep)
        if (generics_result._tag == Result[GenericArgumentsSyntax, ParserError]::Error)
        {
            switch (generics_result._Error._tag) {
                case ParserError::DifferentSyntax:
                    break
                case ParserError::InvalidSyntax:
                    return Result[TypeSyntax, ParserError] { ._tag = Result[TypeSyntax, ParserError]::Error, ._Error = generics_result._Error }
            }
        }

        GenericArgumentsSyntax* generics = generics_result._tag == Result[GenericArgumentsSyntax, ParserError]::Error ? nullptr : new(alignof(GenericArgumentsSyntax), _rp) GenericArgumentsSyntax(generics_result._Ok)
    
        let optional_start = lexer.position
        let optional_result = parse_optional(rp, ep)
        if (optional_result._tag == Result[OptionalSyntax, ParserError]::Error)
        {
            switch (optional_result._Error._tag) {
                case ParserError::DifferentSyntax:
                    break
                case ParserError::InvalidSyntax:
                    return Result[TypeSyntax, ParserError] { ._tag = Result[TypeSyntax, ParserError]::Error, ._Error = optional_result._Error }
            }
        }

        OptionalSyntax* optional = optional_result._tag == Result[OptionalSyntax, ParserError]::Error ? nullptr : new(alignof(OptionalSyntax), _rp) OptionalSyntax(optional_result._Ok)
    
        let lifetime_start = lexer.position
        let lifetime_result = parse_lifetime(rp, ep)
        if (lifetime_result._tag == Result[LifetimeSyntax, ParserError]::Error)
        {
            switch (lifetime_result._Error._tag) {
                case ParserError::DifferentSyntax:
                    break
                case ParserError::InvalidSyntax:
                    return Result[TypeSyntax, ParserError] { ._tag = Result[TypeSyntax, ParserError]::Error, ._Error = lifetime_result._Error }
            }
        }

        LifetimeSyntax* lifetime = lifetime_result._tag == Result[LifetimeSyntax, ParserError]::Error ? nullptr : new(alignof(LifetimeSyntax), _rp) LifetimeSyntax(lifetime_result._Ok)
    
        let end = lexer.position

        let ret = TypeSyntax(start, end, name, generics, optional, lifetime)

        return Result[TypeSyntax, ParserError] { ._tag = Result[TypeSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_name(this: Parser) returns NameSyntax throws ParserError {
        let start = lexer.previous_position

        let start_name = lexer.previous_position
        let name = lexer.parse_identifier(_rp, keywords)
        if (name == nullptr)
        {
            return Result[NameSyntax, ParserError] { ._tag = Result[NameSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }

        }

        let extensions_start = lexer.position
        let extensions_result = parse_extension_list(rp, ep)
        choose extensions_result
            when error: Success.Error
            {
                choose error
                    when d: ParserError.DifferentSyntax {}
                    when i: ParserError.InvalidSyntax throw i
            }
        let extensions = extensions_result._tag == Result[Vector[ExtensionSyntax], ParserError]::Error ? nullptr : extensions_result._Ok
    
        let end = lexer.position

        let ret = NameSyntax(start, end, *name, extensions)

        return Result[NameSyntax, ParserError] { ._tag = Result[NameSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_extension_list(this: Parser) returns pointer[Vector[ExtensionSyntax]] throws ParserError {
        var r Region()
        List<ExtensionSyntax]& list = *new(alignof(List<ExtensionSyntax]), _r.get_page()) List<ExtensionSyntax]()
        while(true) {
            let node_result = parse_extension(rp, ep)
            if ((node_result._tag == Result[ExtensionSyntax, ParserError]::Error) && (node_result._Error._tag == ParserError::InvalidSyntax))
                return Result[Vector<ExtensionSyntax]*, ParserError] { ._tag = Result[Vector<ExtensionSyntax]*, ParserError]::Error, ._Error = node_result._Error }
            if (node_result._tag == Result[ExtensionSyntax, ParserError]::Ok) {
                let node = node_result._Ok
                list.add(node)
            } else {
                if ((list.count() == 0) && (node_result._tag == Result[ExtensionSyntax, ParserError]::Error) && (node_result._Error._tag == ParserError::DifferentSyntax))
                    return Result[Vector<ExtensionSyntax]*, ParserError] { ._tag = Result[Vector<ExtensionSyntax]*, ParserError]::Error, ._Error = node_result._Error }
                break
            }
        }

        if (list.count() == 0)
            return Result[Vector<ExtensionSyntax]*, ParserError] { ._tag = Result[Vector<ExtensionSyntax]*, ParserError]::Ok, ._Ok = nullptr }
        
        return Result[Vector<ExtensionSyntax]*, ParserError] {
            ._tag = Result[Vector<ExtensionSyntax]*, ParserError]::Ok,
            ._Ok = new(alignof(Vector<ExtensionSyntax]), _rp) Vector<ExtensionSyntax](_rp, list) }
    }

    function parse_extension(this: Parser) returns ExtensionSyntax throws ParserError {
        let start = lexer.previous_position

        let start_dot_1 = lexer.previous_position
        let success_dot_1 = lexer.parse_punctuation('.')
        if (!success_dot_1) {
            return Result[ExtensionSyntax, ParserError] { ._tag = Result[ExtensionSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }
        }

        let start_name = lexer.previous_position
        let name = lexer.parse_identifier(_rp, keywords)
        if (name == nullptr)
        {
            return Result[ExtensionSyntax, ParserError] { ._tag = Result[ExtensionSyntax, ParserError]::Error, ._Error = ParserError(InvalidSyntax(start_name, lexer.position, String(_ep, "an identifier"))) }
        }

        let end = lexer.position

        let ret = ExtensionSyntax(start, end, *name)

        return Result[ExtensionSyntax, ParserError] { ._tag = Result[ExtensionSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_lifetime(this: Parser) returns LifetimeSyntax throws ParserError {
        try let node parse_call(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnLifetimeSyntax(CallSyntax(node))
        try let node parse_local(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnLifetimeSyntax(LocalSyntax(node))
        try let node parse_reference(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnLifetimeSyntax(ReferenceSyntax(node))
        try let node parse_thrown(rp, ep)
            when error: ParserError.InvalidSyntax
                throw error
        returnLifetimeSyntax(ThrownSyntax(node))
        throw ParserError(DifferentSyntax())
    }

    function parse_call(this: Parser) returns CallSyntax throws ParserError {
        let start = lexer.previous_position

        let start_hash_1 = lexer.previous_position
        let success_hash_1 = lexer.parse_punctuation('#')
        if (!success_hash_1) {
            return Result[CallSyntax, ParserError] { ._tag = Result[CallSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }
        }

        let end = lexer.position

        let ret = CallSyntax(start, end)

        return Result[CallSyntax, ParserError] { ._tag = Result[CallSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_local(this: Parser) returns LocalSyntax throws ParserError {
        let start = lexer.previous_position

        let start_dollar_1 = lexer.previous_position
        let success_dollar_1 = lexer.parse_punctuation('$')
        if (!success_dollar_1) {
            return Result[LocalSyntax, ParserError] { ._tag = Result[LocalSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }
        }

        let end = lexer.position

        let ret = LocalSyntax(start, end)

        return Result[LocalSyntax, ParserError] { ._tag = Result[LocalSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_reference(this: Parser) returns ReferenceSyntax throws ParserError {
        let start = lexer.previous_position

        let start_caret_1 = lexer.previous_position
        let success_caret_1 = lexer.parse_punctuation('^')
        if (!success_caret_1) {
            return Result[ReferenceSyntax, ParserError] { ._tag = Result[ReferenceSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }
        }

        let start_location = lexer.previous_position
        let location = lexer.parse_identifier(_rp, keywords)
        if (location == nullptr)
        {
            return Result[ReferenceSyntax, ParserError] { ._tag = Result[ReferenceSyntax, ParserError]::Error, ._Error = ParserError(InvalidSyntax(start_location, lexer.position, String(_ep, "an identifier"))) }
        }

        let end = lexer.position

        let ret = ReferenceSyntax(start, end, *location)

        return Result[ReferenceSyntax, ParserError] { ._tag = Result[ReferenceSyntax, ParserError]::Ok, ._Ok = ret }
    }

    function parse_thrown(this: Parser) returns ThrownSyntax throws ParserError {
        let start = lexer.previous_position

        let start_exclamation_1 = lexer.previous_position
        let success_exclamation_1 = lexer.parse_punctuation('!')
        if (!success_exclamation_1) {
            return Result[ThrownSyntax, ParserError] { ._tag = Result[ThrownSyntax, ParserError]::Error, ._Error = ParserError(DifferentSyntax()) }
        }

        let end = lexer.position

        let ret = ThrownSyntax(start, end)

        return Result[ThrownSyntax, ParserError] { ._tag = Result[ThrownSyntax, ParserError]::Ok, ._Ok = ret }
    }

    bool is_at_end() {
        return lexer.is_at_end()
    }
}

