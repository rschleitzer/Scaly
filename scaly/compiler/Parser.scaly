use scaly.containers
define IdentifierLiteral(name: String)
define StringLiteral(value: String)
define CharacterLiteral(value: String)
define FragmentLiteral(value: String)
define IntegerLiteral(value: String)
define BooleanLiteral(value: bool)
define FloatingPointLiteral(value: String)
define HexLiteral(value: String)

define Literal union (
    String: StringLiteral
    Character: CharacterLiteral
    Fragment: FragmentLiteral
    Integer: IntegerLiteral
    Boolean: BooleanLiteral
    FloatingPoint: FloatingPointLiteral
    Hex: HexLiteral
)

define ThrownSyntax
(
    start: size_t
    end: size_t
)

define ReferenceSyntax
(
    start: size_t
    end: size_t
    location: String
)

define LocalSyntax
(
    start: size_t
    end: size_t
)

define CallSyntax
(
    start: size_t
    end: size_t
)

define LifetimeSyntax union (
    Call: CallSyntax
    Local: LocalSyntax
    Reference: ReferenceSyntax
    Thrown: ThrownSyntax
)

define ExtensionSyntax
(
    start: size_t
    end: size_t
    name: String
)

define NameSyntax
(
    start: size_t
    end: size_t
    name: String
    extensions: pointer[Vector[ExtensionSyntax]]
)

define TypeSyntax
(
    start: size_t
    end: size_t
    name: NameSyntax
    generics: pointer[GenericArgumentsSyntax]
    optional: pointer[OptionalSyntax]
    lifetime: pointer[LifetimeSyntax]
)

define SizeOfSyntax
(
    start: size_t
    end: size_t
    type: TypeSyntax
)

define SetSyntax
(
    start: size_t
    end: size_t
    target: Vector[OperandSyntax]
    source: Vector[OperandSyntax]
)

define OperationSyntax
(
    start: size_t
    end: size_t
    operands: Vector[OperandSyntax]
)

define ActionSyntax union (
    Operation: OperationSyntax
    Set: SetSyntax
)

define RepeatSyntax
(
    start: size_t
    end: size_t
    name: pointer[LabelSyntax]
    action: ActionSyntax
)

define LabelSyntax
(
    start: size_t
    end: size_t
    name: String
)

define ForSyntax
(
    start: size_t
    end: size_t
    variable: String
    annotation: pointer[TypeAnnotationSyntax]
    operation: Vector[OperandSyntax]
    name: pointer[LabelSyntax]
    action: ActionSyntax
)

define LambdaSyntax
(
    start: size_t
    end: size_t
    input: Vector[OperandSyntax]
    block: ActionSyntax
)

define ThrowSyntax
(
    start: size_t
    end: size_t
    result: pointer[Vector[OperandSyntax]]
)

define ReturnSyntax
(
    start: size_t
    end: size_t
    result: pointer[Vector[OperandSyntax]]
)

define LoopSyntax
(
    start: size_t
    end: size_t
    name: String
)

define BreakSyntax
(
    start: size_t
    end: size_t
    name: pointer[LoopSyntax]
    result: pointer[Vector[OperandSyntax]]
)

define ContinueSyntax
(
    start: size_t
    end: size_t
    name: pointer[LoopSyntax]
)

define TypeAnnotationSyntax
(
    start: size_t
    end: size_t
    type: TypeSyntax
)

define PropertySyntax
(
    start: size_t
    end: size_t
    name: String
    annotation: TypeAnnotationSyntax
    initializer: pointer[InitializerSyntax]
    attributes: pointer[Vector[AttributeSyntax]]
)

define FieldSyntax
(
    start: size_t
    end: size_t
    property: PropertySyntax
)

define PartSyntax union (
    Field: FieldSyntax
    Property: PropertySyntax
)

define StructureSyntax
(
    start: size_t
    end: size_t
    parts: pointer[Vector[PartSyntax]]
)

define ArraySyntax
(
    start: size_t
    end: size_t
    members: pointer[Vector[TypeSyntax]]
)

define BindingSpecSyntax union (
    Structure: StructureSyntax
    Type: TypeSyntax
    Array: ArraySyntax
)

define BindingAnnotationSyntax
(
    start: size_t
    end: size_t
    spec: BindingSpecSyntax
)

define BindingSyntax
(
    start: size_t
    end: size_t
    name: String
    annotation: pointer[BindingAnnotationSyntax]
    operation: Vector[OperandSyntax]
)

define MutableSyntax
(
    start: size_t
    end: size_t
    binding: BindingSyntax
)

define VarSyntax
(
    start: size_t
    end: size_t
    binding: BindingSyntax
)

define LetSyntax
(
    start: size_t
    end: size_t
    binding: BindingSyntax
)

define WhenSyntax
(
    start: size_t
    end: size_t
    name: String
    variant: NameSyntax
    action: ActionSyntax
)

define ConditionSyntax union (
    Operation: OperationSyntax
    Let: LetSyntax
)

define TrySyntax
(
    start: size_t
    end: size_t
    condition: ConditionSyntax
    cases: pointer[Vector[WhenSyntax]]
    dropper: pointer[DefaultSyntax]
)

define ChooseSyntax
(
    start: size_t
    end: size_t
    condition: Vector[OperandSyntax]
    cases: pointer[Vector[WhenSyntax]]
    alternative: pointer[DefaultSyntax]
)

define WhileSyntax
(
    start: size_t
    end: size_t
    condition: ConditionSyntax
    name: pointer[LabelSyntax]
    action: ActionSyntax
)

define CommandSyntax union (
    Operation: OperationSyntax
    Let: LetSyntax
    Var: VarSyntax
    Mutable: MutableSyntax
    Set: SetSyntax
    Continue: ContinueSyntax
    Break: BreakSyntax
    Return: ReturnSyntax
    Throw: ThrowSyntax
)

define StatementSyntax
(
    start: size_t
    end: size_t
    command: CommandSyntax
)

define DefaultSyntax
(
    start: size_t
    end: size_t
    alternative: CommandSyntax
)

define CaseSyntax
(
    start: size_t
    end: size_t
    condition: Vector[OperandSyntax]
)

define BranchSyntax
(
    start: size_t
    end: size_t
    cases: Vector[CaseSyntax]
    consequent: StatementSyntax
)

define MatchSyntax
(
    start: size_t
    end: size_t
    scrutinee: Vector[OperandSyntax]
    branches: Vector[BranchSyntax]
    alternative: pointer[DefaultSyntax]
)

define ElseSyntax
(
    start: size_t
    end: size_t
    alternative: CommandSyntax
)

define IfSyntax
(
    start: size_t
    end: size_t
    condition: Vector[OperandSyntax]
    consequent: CommandSyntax
    alternative: pointer[ElseSyntax]
)

define BlockSyntax
(
    start: size_t
    end: size_t
    uses: pointer[Vector[UseSyntax]]
    statements: pointer[Vector[StatementSyntax]]
)

define ElementSyntax
(
    start: size_t
    end: size_t
    operation: Vector[OperandSyntax]
    attributes: pointer[Vector[AttributeSyntax]]
)

define VectorSyntax
(
    start: size_t
    end: size_t
    elements: Vector[ElementSyntax]
    lifetime: pointer[LifetimeSyntax]
)

define ValueSyntax
(
    start: size_t
    end: size_t
    value: Vector[OperandSyntax]
    attributes: pointer[Vector[AttributeSyntax]]
)

define ComponentSyntax
(
    start: size_t
    end: size_t
    operands: Vector[OperandSyntax]
    attributes: pointer[Vector[AttributeSyntax]]
    value: pointer[ValueSyntax]
)

define ObjectSyntax
(
    start: size_t
    end: size_t
    components: pointer[Vector[ComponentSyntax]]
)

define LiteralSyntax
(
    start: size_t
    end: size_t
    literal: Literal
)

define ExpressionSyntax union (
    Literal: LiteralSyntax
    Type: TypeSyntax
    Object: ObjectSyntax
    Vector: VectorSyntax
    Block: BlockSyntax
    If: IfSyntax
    Match: MatchSyntax
    Lambda: LambdaSyntax
    For: ForSyntax
    While: WhileSyntax
    Choose: ChooseSyntax
    Try: TrySyntax
    Repeat: RepeatSyntax
    SizeOf: SizeOfSyntax
)

define MemberAccessSyntax
(
    start: size_t
    end: size_t
    name: NameSyntax
)

define OperandSyntax
(
    start: size_t
    end: size_t
    expression: ExpressionSyntax
    members: pointer[Vector[MemberAccessSyntax]]
)

define InitializerSyntax
(
    start: size_t
    end: size_t
    operands: Vector[OperandSyntax]
)

define PackageSyntax
(
    start: size_t
    end: size_t
    name: NameSyntax
)

define ModuleSyntax
(
    start: size_t
    end: size_t
    name: String
)

define ModelSyntax union (
    Literal: LiteralSyntax
    Name: NameSyntax
    Object: ObjectSyntax
    Vector: VectorSyntax
)

define AttributeSyntax
(
    start: size_t
    end: size_t
    name: String
    model: ModelSyntax
)

define MacroSyntax
(
    start: size_t
    end: size_t
    name: String
    model: ModelSyntax
    rule: Vector[OperandSyntax]
)

define ExtendSyntax
(
    start: size_t
    end: size_t
    type: TypeSyntax
)

define ExtendsSyntax
(
    start: size_t
    end: size_t
    extensions: pointer[Vector[ExtendSyntax]]
)

define IntrinsicSyntax
(
    start: size_t
    end: size_t
)

define InstructionSyntax
(
    start: size_t
    end: size_t
)

define ExternSyntax
(
    start: size_t
    end: size_t
)

define ImplementationSyntax union (
    Action: ActionSyntax
    Extern: ExternSyntax
    Instruction: InstructionSyntax
    Intrinsic: IntrinsicSyntax
)

define RoutineSyntax
(
    start: size_t
    end: size_t
    generics: pointer[GenericArgumentsSyntax]
    lifetime: pointer[LifetimeSyntax]
    parameters: pointer[ParameterSetSyntax]
    attributes: pointer[Vector[AttributeSyntax]]
    returns_: pointer[ReturnsSyntax]
    throws_: pointer[ThrowsSyntax]
    implementation: ImplementationSyntax
)

define NamedSyntax
(
    start: size_t
    end: size_t
    name: String
    routine: RoutineSyntax
)

define TargetSyntax union (
    Named: NamedSyntax
    Routine: RoutineSyntax
)

define OperatorSyntax
(
    start: size_t
    end: size_t
    target: TargetSyntax
)

define ProcedureSyntax
(
    start: size_t
    end: size_t
    target: TargetSyntax
)

define FunctionSyntax
(
    start: size_t
    end: size_t
    target: TargetSyntax
)

define DeInitSyntax
(
    start: size_t
    end: size_t
    action: ActionSyntax
)

define InitSyntax
(
    start: size_t
    end: size_t
    parameters: pointer[ParameterSetSyntax]
    action: ActionSyntax
)

define MethodSyntax union (
    Function: FunctionSyntax
    Procedure: ProcedureSyntax
    Operator: OperatorSyntax
)

define TraitSyntax
(
    start: size_t
    end: size_t
    name: NameSyntax
    extension: pointer[ExtendsSyntax]
    attributes: pointer[Vector[AttributeSyntax]]
    uses: pointer[Vector[UseSyntax]]
    functions: pointer[Vector[MethodSyntax]]
)

define ImplementSyntax
(
    start: size_t
    end: size_t
    type: TypeSyntax
    attributes: pointer[Vector[AttributeSyntax]]
    uses: pointer[Vector[UseSyntax]]
    methods: pointer[Vector[MethodSyntax]]
)

define UseSyntax
(
    start: size_t
    end: size_t
    name: NameSyntax
)

define ThrowsSyntax
(
    start: size_t
    end: size_t
    type: TypeSyntax
    attributes: pointer[Vector[AttributeSyntax]]
)

define ReturnsSyntax
(
    start: size_t
    end: size_t
    type: TypeSyntax
    attributes: pointer[Vector[AttributeSyntax]]
)

define ItemSyntax
(
    start: size_t
    end: size_t
    name: String
    annotation: pointer[TypeAnnotationSyntax]
    attributes: pointer[Vector[AttributeSyntax]]
)

define ParametersSyntax
(
    start: size_t
    end: size_t
    items: pointer[Vector[ItemSyntax]]
)

define ParameterSetSyntax union (
    Parameters: ParametersSyntax
    Type: TypeSyntax
)

define OptionalSyntax
(
    start: size_t
    end: size_t
)

define GenericArgumentSyntax
(
    start: size_t
    end: size_t
    type: TypeSyntax
)

define GenericArgumentsSyntax
(
    start: size_t
    end: size_t
    generics: pointer[Vector[GenericArgumentSyntax]]
)

define DelegateSyntax
(
    start: size_t
    end: size_t
    parameters: pointer[ParameterSetSyntax]
    attributes: pointer[Vector[AttributeSyntax]]
    result: pointer[ReturnsSyntax]
    error: pointer[ThrowsSyntax]
)

define ConstantSyntax
(
    start: size_t
    end: size_t
    type: TypeSyntax
    operation: Vector[OperandSyntax]
)

define VariantSyntax
(
    start: size_t
    end: size_t
    name: String
    attributes: pointer[Vector[AttributeSyntax]]
    annotation: pointer[TypeAnnotationSyntax]
)

define UnionSyntax
(
    start: size_t
    end: size_t
    variants: Vector[VariantSyntax]
)

define NamespaceSyntax
(
    start: size_t
    end: size_t
    uses: pointer[Vector[UseSyntax]]
    declarations: pointer[Vector[DeclarationSyntax]]
)

define BodySyntax
(
    start: size_t
    end: size_t
    uses: pointer[Vector[UseSyntax]]
    inits: pointer[Vector[InitSyntax]]
    deInit: pointer[DeInitSyntax]
    members: pointer[Vector[MemberSyntax]]
)

define ClassSyntax
(
    start: size_t
    end: size_t
    structure: StructureSyntax
    body: pointer[BodySyntax]
)

define ConceptSyntax union (
    Class: ClassSyntax
    Namespace: NamespaceSyntax
    Union: UnionSyntax
    Constant: ConstantSyntax
    Delegate: DelegateSyntax
    Intrinsic: IntrinsicSyntax
)

define GenericParameterSyntax
(
    start: size_t
    end: size_t
    name: String
    attributes: pointer[Vector[AttributeSyntax]]
)

define GenericParametersSyntax
(
    start: size_t
    end: size_t
    parameters: Vector[GenericParameterSyntax]
)

define DefinitionSyntax
(
    start: size_t
    end: size_t
    name: String
    parameters: pointer[GenericParametersSyntax]
    attributes: pointer[Vector[AttributeSyntax]]
    concept_: ConceptSyntax
)

define ConstituentSyntax union (
    Definition: DefinitionSyntax
    Function: FunctionSyntax
    Procedure: ProcedureSyntax
    Operator: OperatorSyntax
    Implement: ImplementSyntax
    Trait: TraitSyntax
    Macro: MacroSyntax
    Module: ModuleSyntax
)

define MemberSyntax
(
    start: size_t
    end: size_t
    constituent: ConstituentSyntax
)

define ExportSyntax union (
    Definition: DefinitionSyntax
    Function: FunctionSyntax
    Operator: OperatorSyntax
    Trait: TraitSyntax
    Module: ModuleSyntax
)

define PrivateSyntax
(
    start: size_t
    end: size_t
    export_: ExportSyntax
)

define SymbolSyntax union (
    Private: PrivateSyntax
    Definition: DefinitionSyntax
    Function: FunctionSyntax
    Operator: OperatorSyntax
    Trait: TraitSyntax
    Macro: MacroSyntax
    Module: ModuleSyntax
)

define DeclarationSyntax
(
    start: size_t
    end: size_t
    symbol: SymbolSyntax
)

define FileSyntax
(
    start: size_t
    end: size_t
    packages: pointer[Vector[PackageSyntax]]
    uses: pointer[Vector[UseSyntax]]
    declarations: pointer[Vector[DeclarationSyntax]]
)

define ProgramSyntax
(
    start: size_t
    end: size_t
    file: FileSyntax
    statements: pointer[Vector[StatementSyntax]]
)

define Parser
(
    lexer: Lexer
    keywords_index: Vector[String]
    keywords: HashSet[String]
)
{
    init(text: String) (lexer(Lexer(text))) (keywords_index(initialize_keywords_index())) (keywords(initialize_keywords())) {}

    function initialize_keywords_index(this: Parser) returns Vector[String]$ {
        var r Region()
        var keywords_builder Array[String]$()
        var p Page->get(this)
        (*keywords_builder).add(String(p, "break"))
        (*keywords_builder).add(String(p, "case"))
        (*keywords_builder).add(String(p, "choose"))
        (*keywords_builder).add(String(p, "continue"))
        (*keywords_builder).add(String(p, "define"))
        (*keywords_builder).add(String(p, "default"))
        (*keywords_builder).add(String(p, "deinit"))
        (*keywords_builder).add(String(p, "delegate"))
        (*keywords_builder).add(String(p, "else"))
        (*keywords_builder).add(String(p, "extends"))
        (*keywords_builder).add(String(p, "extern"))
        (*keywords_builder).add(String(p, "for"))
        (*keywords_builder).add(String(p, "function"))
        (*keywords_builder).add(String(p, "if"))
        (*keywords_builder).add(String(p, "init"))
        (*keywords_builder).add(String(p, "implement"))
        (*keywords_builder).add(String(p, "in"))
        (*keywords_builder).add(String(p, "instruction"))
        (*keywords_builder).add(String(p, "intrinsic"))
        (*keywords_builder).add(String(p, "label"))
        (*keywords_builder).add(String(p, "lambda"))
        (*keywords_builder).add(String(p, "let"))
        (*keywords_builder).add(String(p, "loop"))
        (*keywords_builder).add(String(p, "macro"))
        (*keywords_builder).add(String(p, "match"))
        (*keywords_builder).add(String(p, "module"))
        (*keywords_builder).add(String(p, "mutable"))
        (*keywords_builder).add(String(p, "operator"))
        (*keywords_builder).add(String(p, "procedure"))
        (*keywords_builder).add(String(p, "private"))
        (*keywords_builder).add(String(p, "return"))
        (*keywords_builder).add(String(p, "returns"))
        (*keywords_builder).add(String(p, "repeat"))
        (*keywords_builder).add(String(p, "set"))
        (*keywords_builder).add(String(p, "sizeof"))
        (*keywords_builder).add(String(p, "throw"))
        (*keywords_builder).add(String(p, "throws"))
        (*keywords_builder).add(String(p, "trait"))
        (*keywords_builder).add(String(p, "try"))
        (*keywords_builder).add(String(p, "union"))
        (*keywords_builder).add(String(p, "use"))
        (*keywords_builder).add(String(p, "var"))
        (*keywords_builder).add(String(p, "when"))
        (*keywords_builder).add(String(p, "while"))
        (*keywords_builder).add(String(p, "package"))
        return Vector[String](p, *keywords_builder)
    }

    function initialize_keywords(this: Parser) returns HashSet[String]$ {
        var r Region()
        var hash_set_builder HashSetBuilder[String]$(keywords_index)
        return HashSet[String](Page->get(this), *hash_set_builder)
    }

    function parse_literal_token(this: Parser) returns Literal throws ParserError {
        choose lexer.token
            when empty: Token.Empty lexer.advance()
            default {}

        choose lexer.token
            when literal: Token.Literal
            {
                choose literal
                    when string: LiteralToken.String {
                        let ret Literal(StringLiteral(String(rp, string.value)))
                        lexer.empty()
                        return ret
                    }

                    when character: LiteralToken.Character {
                        let ret Literal(CharacterLiteral(String(rp, character.value)))
                        lexer.empty()
                        return ret
                    }

                    when integer: LiteralToken.Integer {
                        let ret Literal(IntegerLiteral(String(rp, integer.value)))
                        lexer.empty()
                        return ret
                    }

                    when fp: LiteralToken.FloatingPoint {
                        let ret Literal(FloatingPointLiteral(String(rp, fp.value)))
                        lexer.empty()
                        return ret
                    }

                    when hex: LiteralToken.Hex {
                        let ret Literal(HexLiteral(String(rp, hex.value)))
                        lexer.empty()
                        return ret
                    }

                    when boolean: LiteralToken.Boolean {
                        let ret Literal(BooleanLiteral(boolean.value))
                        lexer.empty()
                        return ret
                    }

                    when fragment: LiteralToken.Fragment {
                        let ret Literal(FragmentLiteral(String(rp, fragment.value)))
                        lexer.empty()
                        return ret
                    }
            }
            default
                return Result[Literal, ParserError](ParserError(DifferentSyntax()))
    }
}

