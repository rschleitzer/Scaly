// ChooseTests.cpp - Generated from tests/Choose.sgm
// DO NOT EDIT - generated by codegen

#include "ChooseTests.h"
#include "Parser.h"
#include "Modeler.h"
#include "Planner.h"
#include "Emitter.h"
#include "llvm/Support/raw_ostream.h"
#include <iostream>
#include <cmath>

namespace scaly {

namespace {

static int TestsPassed = 0;
static int TestsFailed = 0;

static void pass(const char* Name) {
    ++TestsPassed;
    llvm::outs() << "    PASS: " << Name << "\n";
    llvm::outs().flush();
}

static void fail(const char* Name, const char* Message) {
    ++TestsFailed;
    llvm::outs() << "    FAIL: " << Name << " - " << Message << "\n";
    llvm::outs().flush();
}

// Helper to compile source to Plan
static llvm::Expected<Plan> compileToPlan(llvm::StringRef Source) {
    Parser P(Source);
    auto ParseResult = P.parseProgram();
    if (!ParseResult)
        return ParseResult.takeError();

    Modeler M("<test>");
    auto ModelResult = M.buildProgram(*ParseResult);
    if (!ModelResult)
        return ModelResult.takeError();

    Planner Pl("<test>");
    return Pl.plan(*ModelResult);
}

// Helper to evaluate int expression
static llvm::Expected<int64_t> evalInt(llvm::StringRef Source) {
    auto PlanResult = compileToPlan(Source);
    if (!PlanResult)
        return PlanResult.takeError();

    EmitterConfig Config;
    Config.EmitDebugInfo = false;
    Emitter E(Config);
    return E.jitExecuteInt(*PlanResult);
}

// Helper to evaluate bool expression
static llvm::Expected<bool> evalBool(llvm::StringRef Source) {
    auto PlanResult = compileToPlan(Source);
    if (!PlanResult)
        return PlanResult.takeError();

    EmitterConfig Config;
    Config.EmitDebugInfo = false;
    Emitter E(Config);
    return E.jitExecuteBool(*PlanResult);
}

// Helper to evaluate float expression
static llvm::Expected<double> evalFloat(llvm::StringRef Source) {
    auto PlanResult = compileToPlan(Source);
    if (!PlanResult)
        return PlanResult.takeError();

    EmitterConfig Config;
    Config.EmitDebugInfo = false;
    Emitter E(Config);
    return E.jitExecuteFloat(*PlanResult);
}

} // anonymous namespace

// Category: Choose Expressions

// Choose on Variant Construction
static void test_CHOOSE_MATCH_SOME() {
    const char* Name = "CHOOSE-MATCH-SOME";
    auto Result = evalInt("define Option union(Some: int, None)\nchoose Option.Some(7): when v: Some: v else 0");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != 7) {
        std::string Msg = "expected 7, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}


// Choose with Binding
static void test_CHOOSE_BIND_VALUE() {
    const char* Name = "CHOOSE-BIND-VALUE";
    auto Result = evalInt("define Result union(Ok: int, Err: int)\nchoose Result.Ok(42): when x: Ok: x + 1 else 0");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != 43) {
        std::string Msg = "expected 43, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}


bool runChooseTests() {
    TestsPassed = 0;
    TestsFailed = 0;

    std::cout << "Running Choose tests..." << std::endl;

    std::cout << "  Choose Expressions" << std::endl;
    std::cout << "    Choose on Variant Construction" << std::endl;
    test_CHOOSE_MATCH_SOME();
    std::cout << "    Choose with Binding" << std::endl;
    test_CHOOSE_BIND_VALUE();

    std::cout << std::endl;
    std::cout << "Choose tests: " << TestsPassed << " passed, "
              << TestsFailed << " failed" << std::endl;

    return TestsFailed == 0;
}

} // namespace scaly
