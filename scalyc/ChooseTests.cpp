// ChooseTests.cpp - Generated from tests/Choose.sgm
// DO NOT EDIT - generated by codegen

#include "ChooseTests.h"
#include "Parser.h"
#include "Modeler.h"
#include "Planner.h"
#include "Emitter.h"
#include "llvm/Support/raw_ostream.h"
#include <iostream>
#include <cmath>

namespace scaly {

namespace {

static int TestsPassed = 0;
static int TestsFailed = 0;

static void pass(const char* Name) {
    ++TestsPassed;
    llvm::outs() << "    PASS: " << Name << "\n";
    llvm::outs().flush();
}

static void fail(const char* Name, const char* Message) {
    ++TestsFailed;
    llvm::outs() << "    FAIL: " << Name << " - " << Message << "\n";
    llvm::outs().flush();
}

// Helper to compile source to Plan
static llvm::Expected<Plan> compileToPlan(llvm::StringRef Source) {
    Parser P(Source);
    auto ParseResult = P.parseProgram();
    if (!ParseResult)
        return ParseResult.takeError();

    Modeler M("<test>");
    auto ModelResult = M.buildProgram(*ParseResult);
    if (!ModelResult)
        return ModelResult.takeError();

    Planner Pl("<test>");
    return Pl.plan(*ModelResult);
}

// Helper to evaluate int expression
static llvm::Expected<int64_t> evalInt(llvm::StringRef Source) {
    auto PlanResult = compileToPlan(Source);
    if (!PlanResult)
        return PlanResult.takeError();

    EmitterConfig Config;
    Config.EmitDebugInfo = false;
    Emitter E(Config);
    return E.jitExecuteInt(*PlanResult);
}

// Helper to evaluate bool expression
static llvm::Expected<bool> evalBool(llvm::StringRef Source) {
    auto PlanResult = compileToPlan(Source);
    if (!PlanResult)
        return PlanResult.takeError();

    EmitterConfig Config;
    Config.EmitDebugInfo = false;
    Emitter E(Config);
    return E.jitExecuteBool(*PlanResult);
}

// Helper to evaluate float expression
static llvm::Expected<double> evalFloat(llvm::StringRef Source) {
    auto PlanResult = compileToPlan(Source);
    if (!PlanResult)
        return PlanResult.takeError();

    EmitterConfig Config;
    Config.EmitDebugInfo = false;
    Emitter E(Config);
    return E.jitExecuteFloat(*PlanResult);
}

} // anonymous namespace

// Category: Choose Expressions

// Basic Choose
static void test_CHOOSE_SOME() {
    const char* Name = "CHOOSE-SOME";
    auto Result = evalInt("define Option union(Some: int, None)\nchoose Some(5): when v: Some: v + 1 else 0");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != 6) {
        std::string Msg = "expected 6, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}

static void test_CHOOSE_NONE() {
    const char* Name = "CHOOSE-NONE";
    auto Result = evalInt("define Option union(Some: int, None)\nchoose None: when v: Some: v else -1");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != -1) {
        std::string Msg = "expected -1, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}

static void test_CHOOSE_WITH_LET() {
    const char* Name = "CHOOSE-WITH-LET";
    auto Result = evalInt("define Option union(Some: int, None)\nlet x Some(10)\nchoose x: when v: Some: v * 2 else 0");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != 20) {
        std::string Msg = "expected 20, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}


// Choose with Result
static void test_CHOOSE_OK() {
    const char* Name = "CHOOSE-OK";
    auto Result = evalInt("define Result union(Ok: int, Err: String)\nchoose Ok(42): when v: Ok: v when e: Err: 0 else -1");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != 42) {
        std::string Msg = "expected 42, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}

static void test_CHOOSE_ERR() {
    const char* Name = "CHOOSE-ERR";
    auto Result = evalInt("define Result union(Ok: int, Err: String)\nchoose Err(\"error\"): when v: Ok: v when e: Err: 0 else -1");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != 0) {
        std::string Msg = "expected 0, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}


// Choose Else Branch
static void test_CHOOSE_ELSE_FALLBACK() {
    const char* Name = "CHOOSE-ELSE-FALLBACK";
    auto Result = evalInt("define Option union(Some: int, None)\nchoose None: when v: Some: v else 99");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != 99) {
        std::string Msg = "expected 99, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}


bool runChooseTests() {
    TestsPassed = 0;
    TestsFailed = 0;

    std::cout << "Running Choose tests..." << std::endl;

    std::cout << "  Choose Expressions" << std::endl;
    std::cout << "    Basic Choose" << std::endl;
    test_CHOOSE_SOME();
    test_CHOOSE_NONE();
    test_CHOOSE_WITH_LET();
    std::cout << "    Choose with Result" << std::endl;
    test_CHOOSE_OK();
    test_CHOOSE_ERR();
    std::cout << "    Choose Else Branch" << std::endl;
    test_CHOOSE_ELSE_FALLBACK();

    std::cout << std::endl;
    std::cout << "Choose tests: " << TestsPassed << " passed, "
              << TestsFailed << " failed" << std::endl;

    return TestsFailed == 0;
}

} // namespace scaly
