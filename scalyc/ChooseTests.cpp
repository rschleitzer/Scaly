// ChooseTests.cpp - Generated from tests/Choose.sgm
// DO NOT EDIT - generated by codegen

#include "ChooseTests.h"
#include "Parser.h"
#include "Modeler.h"
#include "Planner.h"
#include "Emitter.h"
#include "llvm/Support/raw_ostream.h"
#include <iostream>
#include <cmath>

namespace scaly {

namespace {

static int TestsPassed = 0;
static int TestsFailed = 0;

static void pass(const char* Name) {
    ++TestsPassed;
    llvm::outs() << "    PASS: " << Name << "\n";
    llvm::outs().flush();
}

static void fail(const char* Name, const char* Message) {
    ++TestsFailed;
    llvm::outs() << "    FAIL: " << Name << " - " << Message << "\n";
    llvm::outs().flush();
}

// Helper to compile source to Plan
static llvm::Expected<Plan> compileToPlan(llvm::StringRef Source) {
    Parser P(Source);
    auto ParseResult = P.parseProgram();
    if (!ParseResult)
        return ParseResult.takeError();

    Modeler M("<test>");
    auto ModelResult = M.buildProgram(*ParseResult);
    if (!ModelResult)
        return ModelResult.takeError();

    Planner Pl("<test>");
    return Pl.plan(*ModelResult);
}

// Helper to evaluate int expression
static llvm::Expected<int64_t> evalInt(llvm::StringRef Source) {
    auto PlanResult = compileToPlan(Source);
    if (!PlanResult)
        return PlanResult.takeError();

    EmitterConfig Config;
    Config.EmitDebugInfo = false;
    Emitter E(Config);
    return E.jitExecuteInt(*PlanResult);
}

// Helper to evaluate bool expression
static llvm::Expected<bool> evalBool(llvm::StringRef Source) {
    auto PlanResult = compileToPlan(Source);
    if (!PlanResult)
        return PlanResult.takeError();

    EmitterConfig Config;
    Config.EmitDebugInfo = false;
    Emitter E(Config);
    return E.jitExecuteBool(*PlanResult);
}

// Helper to evaluate float expression
static llvm::Expected<double> evalFloat(llvm::StringRef Source) {
    auto PlanResult = compileToPlan(Source);
    if (!PlanResult)
        return PlanResult.takeError();

    EmitterConfig Config;
    Config.EmitDebugInfo = false;
    Emitter E(Config);
    return E.jitExecuteFloat(*PlanResult);
}

} // anonymous namespace

// Category: Choose Expressions

// Choose on Variant Construction
static void test_CHOOSE_MATCH_SOME() {
    const char* Name = "CHOOSE-MATCH-SOME";
    auto Result = evalInt("define Option union(Some: int, None)\nchoose Option.Some(7): when v: Some: v else 0");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != 7) {
        std::string Msg = "expected 7, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}

static void test_CHOOSE_MATCH_NONE() {
    const char* Name = "CHOOSE-MATCH-NONE";
    auto Result = evalInt("define Option union(Some: int, None)\nchoose Option.None: when v: Some: v else 0");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != 0) {
        std::string Msg = "expected 0, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}


// Choose with Binding
static void test_CHOOSE_BIND_VALUE() {
    const char* Name = "CHOOSE-BIND-VALUE";
    auto Result = evalInt("define Result union(Ok: int, Err: int)\nchoose Result.Ok(42): when x: Ok: x + 1 else 0");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != 43) {
        std::string Msg = "expected 43, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}


// Multiple When Clauses
static void test_CHOOSE_MULTI_MATCH_FIRST() {
    const char* Name = "CHOOSE-MULTI-MATCH-FIRST";
    auto Result = evalInt("define Result union(Ok: int, Err: int)\nchoose Result.Ok(10): when x: Ok: x when e: Err: e + 100");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != 10) {
        std::string Msg = "expected 10, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}

static void test_CHOOSE_MULTI_MATCH_SECOND() {
    const char* Name = "CHOOSE-MULTI-MATCH-SECOND";
    auto Result = evalInt("define Result union(Ok: int, Err: int)\nchoose Result.Err(5): when x: Ok: x when e: Err: e + 100");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != 105) {
        std::string Msg = "expected 105, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}

// Category: Optional Types

// Is Null Check
static void test_IS_NULL_NONE() {
    const char* Name = "IS-NULL-NONE";
    auto Result = evalInt("define Option[T] union: (Some: T, None)\nfunction check(x: int?) returns int: if x is null: 0 else 1\ncheck(Option[int].None)");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != 0) {
        std::string Msg = "expected 0, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}

static void test_IS_NULL_SOME() {
    const char* Name = "IS-NULL-SOME";
    auto Result = evalInt("define Option[T] union: (Some: T, None)\nfunction check(x: int?) returns int: if x is null: 0 else 1\ncheck(Option[int].Some(42))");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != 1) {
        std::string Msg = "expected 1, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}


// Optional Type Sugar
static void test_OPTIONAL_SUGAR_UNWRAP() {
    const char* Name = "OPTIONAL-SUGAR-UNWRAP";
    auto Result = evalInt("define Option[T] union: (Some: T, None)\nfunction unwrap(x: int?) returns int: choose x: when v: Some: v else 0\nunwrap(Option[int].Some(42))");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != 42) {
        std::string Msg = "expected 42, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}


// Generic Option Types
static void test_GENERIC_OPTION_SOME() {
    const char* Name = "GENERIC-OPTION-SOME";
    auto Result = evalInt("define Option[T] union: (Some: T, None)\nchoose Option[int].Some(42): when v: Some: v else 0");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != 42) {
        std::string Msg = "expected 42, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}

static void test_GENERIC_OPTION_NONE() {
    const char* Name = "GENERIC-OPTION-NONE";
    auto Result = evalInt("define Option[T] union: (Some: T, None)\nchoose Option[int].None: when v: Some: v else -1");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != -1) {
        std::string Msg = "expected -1, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}

// Category: Variant Construction

// Construct Variants
static void test_VARIANT_OK() {
    const char* Name = "VARIANT-OK";
    auto Result = evalInt("define Result union: (Ok: int, Error: int)\nchoose Result.Ok(42): when x: Ok: x else 0");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != 42) {
        std::string Msg = "expected 42, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}

static void test_VARIANT_ERROR() {
    const char* Name = "VARIANT-ERROR";
    auto Result = evalInt("define Result union: (Ok: int, Error: int)\nchoose Result.Error(100): when e: Error: e else 0");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != 100) {
        std::string Msg = "expected 100, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}


// Variant Is Expression
static void test_VARIANT_IS_OK() {
    const char* Name = "VARIANT-IS-OK";
    auto Result = evalInt("define Result union: (Ok: int, Error: int)\nif Result.Ok(50) is Ok : 1 else 0");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != 1) {
        std::string Msg = "expected 1, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}

static void test_VARIANT_IS_NOT_MATCH() {
    const char* Name = "VARIANT-IS-NOT-MATCH";
    auto Result = evalInt("define Result union: (Ok: int, Error: int)\nif Result.Error(33) is Ok : 1 else 0");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != 0) {
        std::string Msg = "expected 0, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}


bool runChooseTests() {
    TestsPassed = 0;
    TestsFailed = 0;

    std::cout << "Running Choose tests..." << std::endl;

    std::cout << "  Choose Expressions" << std::endl;
    std::cout << "    Choose on Variant Construction" << std::endl;
    test_CHOOSE_MATCH_SOME();
    test_CHOOSE_MATCH_NONE();
    std::cout << "    Choose with Binding" << std::endl;
    test_CHOOSE_BIND_VALUE();
    std::cout << "    Multiple When Clauses" << std::endl;
    test_CHOOSE_MULTI_MATCH_FIRST();
    test_CHOOSE_MULTI_MATCH_SECOND();

    std::cout << "  Optional Types" << std::endl;
    std::cout << "    Is Null Check" << std::endl;
    test_IS_NULL_NONE();
    test_IS_NULL_SOME();
    std::cout << "    Optional Type Sugar" << std::endl;
    test_OPTIONAL_SUGAR_UNWRAP();
    std::cout << "    Generic Option Types" << std::endl;
    test_GENERIC_OPTION_SOME();
    test_GENERIC_OPTION_NONE();

    std::cout << "  Variant Construction" << std::endl;
    std::cout << "    Construct Variants" << std::endl;
    test_VARIANT_OK();
    test_VARIANT_ERROR();
    std::cout << "    Variant Is Expression" << std::endl;
    test_VARIANT_IS_OK();
    test_VARIANT_IS_NOT_MATCH();

    std::cout << std::endl;
    std::cout << "Choose tests: " << TestsPassed << " passed, "
              << TestsFailed << " failed" << std::endl;

    return TestsFailed == 0;
}

} // namespace scaly
