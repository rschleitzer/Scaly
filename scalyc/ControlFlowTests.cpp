// ControlFlowTests.cpp - Generated from tests/ControlFlow.sgm
// DO NOT EDIT - generated by codegen

#include "ControlFlowTests.h"
#include "Parser.h"
#include "Modeler.h"
#include "Planner.h"
#include "Emitter.h"
#include "llvm/Support/raw_ostream.h"
#include <iostream>
#include <cmath>

namespace scaly {

namespace {

static int TestsPassed = 0;
static int TestsFailed = 0;

static void pass(const char* Name) {
    ++TestsPassed;
    llvm::outs() << "    PASS: " << Name << "\n";
    llvm::outs().flush();
}

static void fail(const char* Name, const char* Message) {
    ++TestsFailed;
    llvm::outs() << "    FAIL: " << Name << " - " << Message << "\n";
    llvm::outs().flush();
}

// Helper to compile source to Plan
static llvm::Expected<Plan> compileToPlan(llvm::StringRef Source) {
    Parser P(Source);
    auto ParseResult = P.parseProgram();
    if (!ParseResult)
        return ParseResult.takeError();

    Modeler M("<test>");
    auto ModelResult = M.buildProgram(*ParseResult);
    if (!ModelResult)
        return ModelResult.takeError();

    Planner Pl("<test>");
    return Pl.plan(*ModelResult);
}

// Helper to evaluate int expression
static llvm::Expected<int64_t> evalInt(llvm::StringRef Source) {
    auto PlanResult = compileToPlan(Source);
    if (!PlanResult)
        return PlanResult.takeError();

    EmitterConfig Config;
    Config.EmitDebugInfo = false;
    Emitter E(Config);
    return E.jitExecuteInt(*PlanResult);
}

// Helper to evaluate bool expression
static llvm::Expected<bool> evalBool(llvm::StringRef Source) {
    auto PlanResult = compileToPlan(Source);
    if (!PlanResult)
        return PlanResult.takeError();

    EmitterConfig Config;
    Config.EmitDebugInfo = false;
    Emitter E(Config);
    return E.jitExecuteBool(*PlanResult);
}

// Helper to evaluate float expression
static llvm::Expected<double> evalFloat(llvm::StringRef Source) {
    auto PlanResult = compileToPlan(Source);
    if (!PlanResult)
        return PlanResult.takeError();

    EmitterConfig Config;
    Config.EmitDebugInfo = false;
    Emitter E(Config);
    return E.jitExecuteFloat(*PlanResult);
}

} // anonymous namespace

// Category: If Expressions

// Basic If
static void test_IF_TRUE() {
    const char* Name = "IF-TRUE";
    auto Result = evalInt("if true : 1 else 2");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != 1) {
        std::string Msg = "expected 1, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}

static void test_IF_FALSE() {
    const char* Name = "IF-FALSE";
    auto Result = evalInt("if false : 1 else 2");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != 2) {
        std::string Msg = "expected 2, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}

static void test_IF_COMPARISON() {
    const char* Name = "IF-COMPARISON";
    auto Result = evalInt("if 5 > 3 : 10 else 20");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != 10) {
        std::string Msg = "expected 10, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}


// If with Bindings
static void test_IF_WITH_LET() {
    const char* Name = "IF-WITH-LET";
    auto Result = evalInt("let x 5\nif x > 3 : x * 2 else x");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != 10) {
        std::string Msg = "expected 10, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}

static void test_IF_MAX() {
    const char* Name = "IF-MAX";
    auto Result = evalInt("let a 7\nlet b 3\nif a > b : a else b");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != 7) {
        std::string Msg = "expected 7, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}

// Category: While Loops

// Basic While
static void test_WHILE_SIMPLE() {
    const char* Name = "WHILE-SIMPLE";
    auto Result = evalInt("var x 0\nwhile x < 3 : set x : x + 1\nx");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != 3) {
        std::string Msg = "expected 3, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}

static void test_WHILE_ZERO_ITERATIONS() {
    const char* Name = "WHILE-ZERO-ITERATIONS";
    auto Result = evalInt("var x 10\nwhile x < 5 : set x : x + 1\nx");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != 10) {
        std::string Msg = "expected 10, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}


// While with Accumulation
static void test_WHILE_SUM() {
    const char* Name = "WHILE-SUM";
    auto Result = evalInt("var sum 0\nvar i 1\nwhile i <= 3 : { set sum : sum + i: set i : i + 1 }\nsum");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != 6) {
        std::string Msg = "expected 6, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}

static void test_WHILE_FACTORIAL() {
    const char* Name = "WHILE-FACTORIAL";
    auto Result = evalInt("var result 1\nvar n 5\nwhile n > 0 : { set result : result * n: set n : n - 1 }\nresult");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != 120) {
        std::string Msg = "expected 120, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}

// Category: For Loops

// Basic For
static void test_FOR_COUNT() {
    const char* Name = "FOR-COUNT";
    auto Result = evalInt("var count 0\nfor i in 3 : set count : count + 1\ncount");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != 3) {
        std::string Msg = "expected 3, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}

static void test_FOR_ZERO_ITERATIONS() {
    const char* Name = "FOR-ZERO-ITERATIONS";
    auto Result = evalInt("var x 42\nfor i in 0 : set x : 0\nx");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != 42) {
        std::string Msg = "expected 42, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}


// For with Accumulation
static void test_FOR_SUM() {
    const char* Name = "FOR-SUM";
    auto Result = evalInt("var sum 0\nfor i in 5 : set sum : sum + i\nsum");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != 10) {
        std::string Msg = "expected 10, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}

static void test_FOR_FACTORIAL() {
    const char* Name = "FOR-FACTORIAL";
    auto Result = evalInt("var prod 1\nfor i in 4 : set prod : prod * (i + 1)\nprod");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != 24) {
        std::string Msg = "expected 24, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}

// Category: Break and Continue

// Break Statements
static void test_BREAK_IN_FOR() {
    const char* Name = "BREAK-IN-FOR";
    auto Result = evalInt("var sum 0\nfor i in 10 : { if i = 3 : break else set sum : sum + i }\nsum");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != 3) {
        std::string Msg = "expected 3, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}

static void test_BREAK_IN_WHILE() {
    const char* Name = "BREAK-IN-WHILE";
    auto Result = evalInt("var x 0\nwhile x < 100 : { set x : x + 1: if x = 5 : break }\nx");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != 5) {
        std::string Msg = "expected 5, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}


// Continue Statements
static void test_CONTINUE_IN_FOR() {
    const char* Name = "CONTINUE-IN-FOR";
    auto Result = evalInt("var sum 0\nfor i in 6 : { if i % 2 = 1 : continue else set sum : sum + i }\nsum");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != 6) {
        std::string Msg = "expected 6, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}

static void test_CONTINUE_IN_WHILE() {
    const char* Name = "CONTINUE-IN-WHILE";
    auto Result = evalInt("var sum 0\nvar i 0\nwhile i < 10 : { let current i: set i : i + 1: if current % 2 = 1 : continue else set sum : sum + current }\nsum");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != 20) {
        std::string Msg = "expected 20, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}


// Nested Loops
static void test_BREAK_IN_NESTED() {
    const char* Name = "BREAK-IN-NESTED";
    auto Result = evalInt("var count 0\nfor i in 3 : { for j in 10 : { if j = 2 : break else set count : count + 1 } }\ncount");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != 6) {
        std::string Msg = "expected 6, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}

static void test_CONTINUE_IN_NESTED() {
    const char* Name = "CONTINUE-IN-NESTED";
    auto Result = evalInt("var count 0\nfor i in 3 : { for j in 5 : { if j % 2 = 1 : continue else set count : count + 1 } }\ncount");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != 9) {
        std::string Msg = "expected 9, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}

// Category: Mutable Variables

// Basic Var and Set
static void test_VAR_SIMPLE() {
    const char* Name = "VAR-SIMPLE";
    auto Result = evalInt("var x 5\nx");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != 5) {
        std::string Msg = "expected 5, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}

static void test_VAR_ASSIGN() {
    const char* Name = "VAR-ASSIGN";
    auto Result = evalInt("var x 5\nset x : 10\nx");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != 10) {
        std::string Msg = "expected 10, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}

static void test_VAR_INCREMENT() {
    const char* Name = "VAR-INCREMENT";
    auto Result = evalInt("var x 3\nset x : x + 1\nx");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != 4) {
        std::string Msg = "expected 4, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}

static void test_VAR_MULTIPLE() {
    const char* Name = "VAR-MULTIPLE";
    auto Result = evalInt("var a 2\nvar b 3\nset a : a * b\na");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != 6) {
        std::string Msg = "expected 6, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}


bool runControlFlowTests() {
    TestsPassed = 0;
    TestsFailed = 0;

    std::cout << "Running ControlFlow tests..." << std::endl;

    std::cout << "  If Expressions" << std::endl;
    std::cout << "    Basic If" << std::endl;
    test_IF_TRUE();
    test_IF_FALSE();
    test_IF_COMPARISON();
    std::cout << "    If with Bindings" << std::endl;
    test_IF_WITH_LET();
    test_IF_MAX();

    std::cout << "  While Loops" << std::endl;
    std::cout << "    Basic While" << std::endl;
    test_WHILE_SIMPLE();
    test_WHILE_ZERO_ITERATIONS();
    std::cout << "    While with Accumulation" << std::endl;
    test_WHILE_SUM();
    test_WHILE_FACTORIAL();

    std::cout << "  For Loops" << std::endl;
    std::cout << "    Basic For" << std::endl;
    test_FOR_COUNT();
    test_FOR_ZERO_ITERATIONS();
    std::cout << "    For with Accumulation" << std::endl;
    test_FOR_SUM();
    test_FOR_FACTORIAL();

    std::cout << "  Break and Continue" << std::endl;
    std::cout << "    Break Statements" << std::endl;
    test_BREAK_IN_FOR();
    test_BREAK_IN_WHILE();
    std::cout << "    Continue Statements" << std::endl;
    test_CONTINUE_IN_FOR();
    test_CONTINUE_IN_WHILE();
    std::cout << "    Nested Loops" << std::endl;
    test_BREAK_IN_NESTED();
    test_CONTINUE_IN_NESTED();

    std::cout << "  Mutable Variables" << std::endl;
    std::cout << "    Basic Var and Set" << std::endl;
    test_VAR_SIMPLE();
    test_VAR_ASSIGN();
    test_VAR_INCREMENT();
    test_VAR_MULTIPLE();

    std::cout << std::endl;
    std::cout << "ControlFlow tests: " << TestsPassed << " passed, "
              << TestsFailed << " failed" << std::endl;

    return TestsFailed == 0;
}

} // namespace scaly
