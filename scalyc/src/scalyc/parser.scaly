namespace scalyc {

class Parser(

    fileName: string,
    text: string

    ) {

    mutable lexer: Lexer new Lexer(text)

    let usingKeyword: string = new string("using")
    let namespaceKeyword: string = new string("namespace")
    let typedefKeyword: string = new string("typedef")
    let letKeyword: string = new string("let")
    let mutableKeyword: string = new string("mutable")
    let threadlocalKeyword: string = new string("threadlocal")
    let varKeyword: string = new string("var")
    let setKeyword: string = new string("set")
    let classKeyword: string = new string("class")
    let extendsKeyword: string = new string("extends")
    let initializerKeyword: string = new string("initializer")
    let allocatorKeyword: string = new string("allocator")
    let methodKeyword: string = new string("method")
    let functionKeyword: string = new string("function")
    let operatorKeyword: string = new string("operator")
    let thisKeyword: string = new string("this")
    let newKeyword: string = new string("new")
    let sizeofKeyword: string = new string("sizeof")
    let catchKeyword: string = new string("catch")
    let throwsKeyword: string = new string("throws")
    let asKeyword: string = new string("as")
    let isKeyword: string = new string("is")
    let ifKeyword: string = new string("if")
    let elseKeyword: string = new string("else")
    let switchKeyword: string = new string("switch")
    let caseKeyword: string = new string("case")
    let defaultKeyword: string = new string("default")
    let forKeyword: string = new string("for")
    let inKeyword: string = new string("in")
    let whileKeyword: string = new string("while")
    let doKeyword: string = new string("do")
    let loopKeyword: string = new string("loop")
    let breakKeyword: string = new string("break")
    let continueKeyword: string = new string("continue")
    let returnKeyword: string = new string("return")
    let throwKeyword: string = new string("throw")
    let intrinsicKeyword: string = new string("intrinsic")
    let defineKeyword: string = new string("define")
    let semicolon: string = new string(";")
    let left_curly: string = new string("{")
    let right_curly: string = new string("}")
    let left_paren: string = new string("(")
    let right_paren: string = new string(")")
    let left_bracket: string = new string("[")
    let right_bracket: string = new string("]")
    let dot: string = new string(".")
    let comma: string = new string(",")
    let colon: string = new string(":")
    let question: string = new string("?")
    let exclamation: string = new string("!")
    let at: string = new string("@")
    let hash: string = new string("#")
    let dollar: string = new string("$")
    let underscore: string = new string("_")
    let backtick: string = new string("`")

    function parseFile(): File throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()

        let intrinsics: Array[Intrinsic] = parseIntrinsicList()
        if (intrinsics <> null) {
            if (isAtEnd() = false) {
                let errorPos: Position$ = lexer.getPreviousPosition()
                throw syntax(errorPos.line, errorPos.column)
            }
        }

        let usings: Array[Using] = parseUsingList()
        if (usings <> null) {
            if (isAtEnd() = false) {
                let errorPos: Position$ = lexer.getPreviousPosition()
                throw syntax(errorPos.line, errorPos.column)
            }
        }

        let defines: Array[Define] = parseDefineList()
        if (defines <> null) {
            if (isAtEnd() = false) {
                let errorPos: Position$ = lexer.getPreviousPosition()
                throw syntax(errorPos.line, errorPos.column)
            }
        }

        let declarations: Array[Declaration] = parseDeclarationList()
        if (declarations <> null) {
            if (isAtEnd() = false) {
                let errorPos: Position$ = lexer.getPreviousPosition()
                throw syntax(errorPos.line, errorPos.column)
            }
        }

        let statements: Array[Statement] = parseStatementList()
        if (statements <> null) {
            if (isAtEnd() = false) {
                let errorPos: Position$ = lexer.getPreviousPosition()
                throw syntax(errorPos.line, errorPos.column)
            }
        }

        let end: Position$ lexer.getPosition()

        let ret: File new File(intrinsics, usings, defines, declarations, statements, new Position(start), new Position(end))
        if (intrinsics <> ()) {
            for (item: Intrinsic in intrinsics) {
                item.parent = ret }
        }
        if (usings <> ()) {
            for (item: Using in usings) {
                item.parent = ret }
        }
        if (defines <> ()) {
            for (item: Define in defines) {
                item.parent = ret }
        }
        if (declarations <> ()) {
            for (item: Declaration in declarations) {
                item.parent = ret }
        }
        if (statements <> ()) {
            for (item: Statement in statements) {
                item.parent = ret }
        }

        ret
    }

    method parseIntrinsicList(): Array[Intrinsic] {
        mutable ret: Array[Intrinsic]$ = null
        while (true) {

            let node: Intrinsic parseIntrinsic()
            if (node = ()) {
                break }

            if (ret = ()) {
                ret = new Array[Intrinsic]() }

            ret.add(node)
        }

        ret
    }

    function parseIntrinsic(): Intrinsic {
        let start: Position$ = lexer.getPreviousPosition()

        let success_intrinsic_1: bool = lexer.parseKeyword(intrinsicKeyword)
        if (success_intrinsic_1) {
            lexer.advance() }
        else {
            return () }

        let name: string = lexer.parseIdentifier()
        if ((name <> ()) && isIdentifier(name)) {
            lexer.advance() }
        else {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Intrinsic new Intrinsic(name, new Position(start), new Position(end))

        ret
    }

    method parseUsingList(): Array[Using] {
        mutable ret: Array[Using]$ = null
        while (true) {

            let node: Using parseUsing()
            if (node = ()) {
                break }

            if (ret = ()) {
                ret = new Array[Using]() }

            ret.add(node)
        }

        ret
    }

    function parseUsing(): Using {
        let start: Position$ = lexer.getPreviousPosition()

        let success_using_1: bool = lexer.parseKeyword(usingKeyword)
        if (success_using_1) {
            lexer.advance() }
        else {
            return () }

        let name: Name = parseName()
        if (name = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Using new Using(name, new Position(start), new Position(end))
        name.parent = ret

        ret
    }

    method parseDefineList(): Array[Define] {
        mutable ret: Array[Define]$ = null
        while (true) {

            let node: Define parseDefine()
            if (node = ()) {
                break }

            if (ret = ()) {
                ret = new Array[Define]() }

            ret.add(node)
        }

        ret
    }

    function parseDefine(): Define {
        let start: Position$ = lexer.getPreviousPosition()

        let success_define_1: bool = lexer.parseKeyword(defineKeyword)
        if (success_define_1) {
            lexer.advance() }
        else {
            return () }

        let name: Name = parseName()
        if (name = ()) {
            return () }

        let type_spec: Type = parseType()
        if (type_spec = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Define new Define(name, type_spec, new Position(start), new Position(end))
        name.parent = ret
        type_spec.parent = ret

        ret
    }

    function parseName(): Name {
        let start: Position$ = lexer.getPreviousPosition()

        let name: string = lexer.parseIdentifier()
        if ((name <> ()) && isIdentifier(name)) {
            lexer.advance() }
        else {
            return () }

        let extensions: Array[Extension] = parseExtensionList()

        let end: Position$ lexer.getPosition()

        let ret: Name new Name(name, extensions, new Position(start), new Position(end))
        if (extensions <> ()) {
            for (item: Extension in extensions) {
                item.parent = ret }
        }

        ret
    }

    method parseExtensionList(): Array[Extension] {
        mutable ret: Array[Extension]$ = null
        while (true) {

            let node: Extension parseExtension()
            if (node = ()) {
                break }

            if (ret = ()) {
                ret = new Array[Extension]() }

            ret.add(node)
        }

        ret
    }

    function parseExtension(): Extension {
        let start: Position$ = lexer.getPreviousPosition()

        let success_dot_1: bool = lexer.parsePunctuation(dot)
        if (success_dot_1) {
            lexer.advance() }
        else {
            return () }

        let name: string = lexer.parseIdentifier()
        if ((name <> ()) && isIdentifier(name)) {
            lexer.advance() }
        else {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Extension new Extension(name, new Position(start), new Position(end))

        ret
    }

    method parseDeclarationList(): Array[Declaration] {
        mutable ret: Array[Declaration]$ = null
        while (true) {

            let node: Declaration parseDeclaration()
            if (node = ()) {
                break }

            if (ret = ()) {
                ret = new Array[Declaration]() }

            ret.add(node)
        }

        ret
    }

    function parseDeclaration(): Declaration {
        {
            let node: Namespace = parseNamespace()
            if (node <> ()) {
                return node }
        }

        {
            let node: Function = parseFunction()
            if (node <> ()) {
                return node }
        }

        {
            let node: Class = parseClass()
            if (node <> ()) {
                return node }
        }

        {
            let node: LetDeclaration = parseLetDeclaration()
            if (node <> ()) {
                return node }
        }

        {
            let node: VarDeclaration = parseVarDeclaration()
            if (node <> ()) {
                return node }
        }

        {
            let node: MutableDeclaration = parseMutableDeclaration()
            if (node <> ()) {
                return node }
        }

        {
            let node: ThreadLocalDeclaration = parseThreadLocalDeclaration()
            if (node <> ()) {
                return node }
        }

        null
    }

    function parseNamespace(): Namespace {
        let start: Position$ = lexer.getPreviousPosition()

        let success_namespace_1: bool = lexer.parseKeyword(namespaceKeyword)
        if (success_namespace_1) {
            lexer.advance() }
        else {
            return () }

        let name: Name = parseName()
        if (name = ()) {
            return () }

        let success_left_curly_3: bool = lexer.parsePunctuation(left_curly)
        if (success_left_curly_3) {
            lexer.advance() }
        else {
            return () }

        let usings: Array[Using] = parseUsingList()

        let defines: Array[Define] = parseDefineList()

        let declarations: Array[Declaration] = parseDeclarationList()

        let success_right_curly_7: bool = lexer.parsePunctuation(right_curly)
        if (success_right_curly_7) {
            lexer.advance() }
        else {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Namespace new Namespace(name, usings, defines, declarations, new Position(start), new Position(end))
        name.parent = ret
        if (usings <> ()) {
            for (item: Using in usings) {
                item.parent = ret }
        }
        if (defines <> ()) {
            for (item: Define in defines) {
                item.parent = ret }
        }
        if (declarations <> ()) {
            for (item: Declaration in declarations) {
                item.parent = ret }
        }

        ret
    }

    function parseFunction(): Function {
        let start: Position$ = lexer.getPreviousPosition()

        let success_function_1: bool = lexer.parseKeyword(functionKeyword)
        if (success_function_1) {
            lexer.advance() }
        else {
            return () }

        let procedure: Procedure = parseProcedure()
        if (procedure = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Function new Function(procedure, new Position(start), new Position(end))
        procedure.parent = ret

        ret
    }

    function parseProcedure(): Procedure {
        let start: Position$ = lexer.getPreviousPosition()

        let name: string = lexer.parseIdentifier()
        if ((name <> ()) && isIdentifier(name)) {
            lexer.advance() }
        else {
            return () }

        let routine: Routine = parseRoutine()
        if (routine = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Procedure new Procedure(name, routine, new Position(start), new Position(end))
        routine.parent = ret

        ret
    }

    function parseRoutine(): Routine {
        let start: Position$ = lexer.getPreviousPosition()

        let input: Structure = parseStructure()

        let output: TypeAnnotation = parseTypeAnnotation()

        let throws_clause: Throws = parseThrows()

        let body: Block = parseBlock()
        if (body = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Routine new Routine(input, output, throws_clause, body, new Position(start), new Position(end))
        if (input <> ()) {
            input.parent = ret }
        if (output <> ()) {
            output.parent = ret }
        if (throws_clause <> ()) {
            throws_clause.parent = ret }
        body.parent = ret

        ret
    }

    function parseLetDeclaration(): LetDeclaration {
        let start: Position$ = lexer.getPreviousPosition()

        let declaration: Let = parseLet()
        if (declaration = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: LetDeclaration new LetDeclaration(declaration, new Position(start), new Position(end))
        declaration.parent = ret

        ret
    }

    function parseVarDeclaration(): VarDeclaration {
        let start: Position$ = lexer.getPreviousPosition()

        let declaration: Var = parseVar()
        if (declaration = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: VarDeclaration new VarDeclaration(declaration, new Position(start), new Position(end))
        declaration.parent = ret

        ret
    }

    function parseMutableDeclaration(): MutableDeclaration {
        let start: Position$ = lexer.getPreviousPosition()

        let declaration: Mutable = parseMutable()
        if (declaration = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: MutableDeclaration new MutableDeclaration(declaration, new Position(start), new Position(end))
        declaration.parent = ret

        ret
    }

    function parseThreadLocalDeclaration(): ThreadLocalDeclaration {
        let start: Position$ = lexer.getPreviousPosition()

        let declaration: ThreadLocal = parseThreadLocal()
        if (declaration = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: ThreadLocalDeclaration new ThreadLocalDeclaration(declaration, new Position(start), new Position(end))
        declaration.parent = ret

        ret
    }

    method parseStatementList(): Array[Statement] {
        mutable ret: Array[Statement]$ = null
        while (true) {

            let node: Statement parseStatement()
            if (node = ()) {
                break }

            if (ret = ()) {
                ret = new Array[Statement]() }

            ret.add(node)
        }

        ret
    }

    function parseStatement(): Statement {
        {
            let node: Let = parseLet()
            if (node <> ()) {
                return node }
        }

        {
            let node: Var = parseVar()
            if (node <> ()) {
                return node }
        }

        {
            let node: Mutable = parseMutable()
            if (node <> ()) {
                return node }
        }

        {
            let node: ThreadLocal = parseThreadLocal()
            if (node <> ()) {
                return node }
        }

        {
            let node: Set = parseSet()
            if (node <> ()) {
                return node }
        }

        {
            let node: Calculation = parseCalculation()
            if (node <> ()) {
                return node }
        }

        {
            let node: Break = parseBreak()
            if (node <> ()) {
                return node }
        }

        {
            let node: Continue = parseContinue()
            if (node <> ()) {
                return node }
        }

        {
            let node: Return = parseReturn()
            if (node <> ()) {
                return node }
        }

        {
            let node: Throw = parseThrow()
            if (node <> ()) {
                return node }
        }

        null
    }

    function parseLet(): Let {
        let start: Position$ = lexer.getPreviousPosition()

        let success_let_1: bool = lexer.parseKeyword(letKeyword)
        if (success_let_1) {
            lexer.advance() }
        else {
            return () }

        let binding: Binding = parseBinding()
        if (binding = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Let new Let(binding, new Position(start), new Position(end))
        binding.parent = ret

        ret
    }

    function parseVar(): Var {
        let start: Position$ = lexer.getPreviousPosition()

        let success_var_1: bool = lexer.parseKeyword(varKeyword)
        if (success_var_1) {
            lexer.advance() }
        else {
            return () }

        let binding: Binding = parseBinding()
        if (binding = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Var new Var(binding, new Position(start), new Position(end))
        binding.parent = ret

        ret
    }

    function parseMutable(): Mutable {
        let start: Position$ = lexer.getPreviousPosition()

        let success_mutable_1: bool = lexer.parseKeyword(mutableKeyword)
        if (success_mutable_1) {
            lexer.advance() }
        else {
            return () }

        let binding: Binding = parseBinding()
        if (binding = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Mutable new Mutable(binding, new Position(start), new Position(end))
        binding.parent = ret

        ret
    }

    function parseThreadLocal(): ThreadLocal {
        let start: Position$ = lexer.getPreviousPosition()

        let success_threadlocal_1: bool = lexer.parseKeyword(threadlocalKeyword)
        if (success_threadlocal_1) {
            lexer.advance() }
        else {
            return () }

        let binding: Binding = parseBinding()
        if (binding = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: ThreadLocal new ThreadLocal(binding, new Position(start), new Position(end))
        binding.parent = ret

        ret
    }

    function parseBinding(): Binding {
        let start: Position$ = lexer.getPreviousPosition()

        let name: string = lexer.parseIdentifier()
        if ((name <> ()) && isIdentifier(name)) {
            lexer.advance() }
        else {
            return () }

        let type_annotation: TypeAnnotation = parseTypeAnnotation()

        let calculation: Calculation = parseCalculation()
        if (calculation = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Binding new Binding(name, type_annotation, calculation, new Position(start), new Position(end))
        if (type_annotation <> ()) {
            type_annotation.parent = ret }
        calculation.parent = ret

        ret
    }

    function parseSet(): Set {
        let start: Position$ = lexer.getPreviousPosition()

        let success_set_1: bool = lexer.parseKeyword(setKeyword)
        if (success_set_1) {
            lexer.advance() }
        else {
            return () }

        let l_value: Operation = parseOperation()
        if (l_value = ()) {
            return () }

        let success_colon_3: bool = lexer.parsePunctuation(colon)
        if (success_colon_3) {
            lexer.advance() }
        else {
            return () }

        let r_value: Calculation = parseCalculation()
        if (r_value = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Set new Set(l_value, r_value, new Position(start), new Position(end))
        l_value.parent = ret
        r_value.parent = ret

        ret
    }

    function parseCalculation(): Calculation {
        let start: Position$ = lexer.getPreviousPosition()

        let operation: Operation = parseOperation()
        if (operation = ()) {
            return () }

        let success_semicolon_2: bool = lexer.parsePunctuation(semicolon)
        if (success_semicolon_2) {
            lexer.advance() }

        let end: Position$ lexer.getPosition()

        let ret: Calculation new Calculation(operation, new Position(start), new Position(end))
        operation.parent = ret

        ret
    }

    function parseOperation(): Operation {
        let start: Position$ = lexer.getPreviousPosition()

        let op: Array[Operand] = parseOperandList()

        let end: Position$ lexer.getPosition()

        let ret: Operation new Operation(op, new Position(start), new Position(end))
        if (op <> ()) {
            for (item: Operand in op) {
                item.parent = ret }
        }

        ret
    }

    method parseOperandList(): Array[Operand] {
        mutable ret: Array[Operand]$ = null
        while (true) {

            let node: Operand parseOperand()
            if (node = ()) {
                break }

            if (ret = ()) {
                ret = new Array[Operand]() }

            ret.add(node)
        }

        ret
    }

    function parseOperand(): Operand {
        let start: Position$ = lexer.getPreviousPosition()

        let primary: Expression = parseExpression()
        if (primary = ()) {
            return () }

        let postfixes: Array[Postfix] = parsePostfixList()

        let end: Position$ lexer.getPosition()

        let ret: Operand new Operand(primary, postfixes, new Position(start), new Position(end))
        primary.parent = ret
        if (postfixes <> ()) {
            for (item: Postfix in postfixes) {
                item.parent = ret }
        }

        ret
    }

    method parsePostfixList(): Array[Postfix] {
        mutable ret: Array[Postfix]$ = null
        while (true) {

            let node: Postfix parsePostfix()
            if (node = ()) {
                break }

            if (ret = ()) {
                ret = new Array[Postfix]() }

            ret.add(node)
        }

        ret
    }

    function parsePostfix(): Postfix {
        {
            let node: MemberAccess = parseMemberAccess()
            if (node <> ()) {
                return node }
        }

        {
            let node: As = parseAs()
            if (node <> ()) {
                return node }
        }

        {
            let node: Is = parseIs()
            if (node <> ()) {
                return node }
        }

        {
            let node: Unwrap = parseUnwrap()
            if (node <> ()) {
                return node }
        }

        {
            let node: Catch = parseCatch()
            if (node <> ()) {
                return node }
        }

        null
    }

    function parseMemberAccess(): MemberAccess {
        let start: Position$ = lexer.getPreviousPosition()

        let success_dot_1: bool = lexer.parsePunctuation(dot)
        if (success_dot_1) {
            lexer.advance() }
        else {
            return () }

        let member: string = lexer.parseIdentifier()
        if ((member <> ()) && isIdentifier(member)) {
            lexer.advance() }
        else {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: MemberAccess new MemberAccess(member, new Position(start), new Position(end))

        ret
    }

    function parseAs(): As {
        let start: Position$ = lexer.getPreviousPosition()

        let success_as_1: bool = lexer.parseKeyword(asKeyword)
        if (success_as_1) {
            lexer.advance() }
        else {
            return () }

        let type_spec: TypeSpec = parseTypeSpec()
        if (type_spec = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: As new As(type_spec, new Position(start), new Position(end))
        type_spec.parent = ret

        ret
    }

    function parseIs(): Is {
        let start: Position$ = lexer.getPreviousPosition()

        let success_is_1: bool = lexer.parseKeyword(isKeyword)
        if (success_is_1) {
            lexer.advance() }
        else {
            return () }

        let type_spec: TypeSpec = parseTypeSpec()
        if (type_spec = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Is new Is(type_spec, new Position(start), new Position(end))
        type_spec.parent = ret

        ret
    }

    function parseUnwrap(): Unwrap {
        let start: Position$ = lexer.getPreviousPosition()

        let success_exclamation_1: bool = lexer.parsePunctuation(exclamation)
        if (success_exclamation_1) {
            lexer.advance() }
        else {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Unwrap new Unwrap(new Position(start), new Position(end))

        ret
    }

    function parseCatch(): Catch {
        let start: Position$ = lexer.getPreviousPosition()

        let success_catch_1: bool = lexer.parseKeyword(catchKeyword)
        if (success_catch_1) {
            lexer.advance() }
        else {
            return () }

        let type_spec: CatchPattern = parseCatchPattern()
        if (type_spec = ()) {
            return () }

        let handler: Block = parseBlock()
        if (handler = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Catch new Catch(type_spec, handler, new Position(start), new Position(end))
        type_spec.parent = ret
        handler.parent = ret

        ret
    }

    function parseCatchPattern(): CatchPattern {
        {
            let node: WildCardCatchPattern = parseWildCardCatchPattern()
            if (node <> ()) {
                return node }
        }

        {
            let node: TypeCatchPattern = parseTypeCatchPattern()
            if (node <> ()) {
                return node }
        }

        null
    }

    function parseWildCardCatchPattern(): WildCardCatchPattern {
        let start: Position$ = lexer.getPreviousPosition()

        let pattern: WildcardPattern = parseWildcardPattern()
        if (pattern = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: WildCardCatchPattern new WildCardCatchPattern(pattern, new Position(start), new Position(end))
        pattern.parent = ret

        ret
    }

    function parseTypeCatchPattern(): TypeCatchPattern {
        let start: Position$ = lexer.getPreviousPosition()

        let type_spec: TypeSpec = parseTypeSpec()
        if (type_spec = ()) {
            return () }

        let error_name: string = lexer.parseIdentifier()
        if ((error_name <> ()) && isIdentifier(error_name)) {
            lexer.advance() }

        let end: Position$ lexer.getPosition()

        let ret: TypeCatchPattern new TypeCatchPattern(type_spec, error_name, new Position(start), new Position(end))
        type_spec.parent = ret

        ret
    }

    function parseExpression(): Expression {
        {
            let node: Block = parseBlock()
            if (node <> ()) {
                return node }
        }

        {
            let node: Name = parseName()
            if (node <> ()) {
                return node }
        }

        {
            let node: Constant = parseConstant()
            if (node <> ()) {
                return node }
        }

        {
            let node: If = parseIf()
            if (node <> ()) {
                return node }
        }

        {
            let node: Switch = parseSwitch()
            if (node <> ()) {
                return node }
        }

        {
            let node: For = parseFor()
            if (node <> ()) {
                return node }
        }

        {
            let node: While = parseWhile()
            if (node <> ()) {
                return node }
        }

        {
            let node: Do = parseDo()
            if (node <> ()) {
                return node }
        }

        {
            let node: This = parseThis()
            if (node <> ()) {
                return node }
        }

        {
            let node: New = parseNew()
            if (node <> ()) {
                return node }
        }

        {
            let node: Object = parseObject()
            if (node <> ()) {
                return node }
        }

        {
            let node: Array = parseArray()
            if (node <> ()) {
                return node }
        }

        {
            let node: SizeOf = parseSizeOf()
            if (node <> ()) {
                return node }
        }

        null
    }

    function parseBlock(): Block {
        let start: Position$ = lexer.getPreviousPosition()

        let success_left_curly_1: bool = lexer.parsePunctuation(left_curly)
        if (success_left_curly_1) {
            lexer.advance() }
        else {
            return () }

        let statements: Array[Statement] = parseStatementList()

        let success_right_curly_3: bool = lexer.parsePunctuation(right_curly)
        if (success_right_curly_3) {
            lexer.advance() }
        else {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Block new Block(statements, new Position(start), new Position(end))
        if (statements <> ()) {
            for (item: Statement in statements) {
                item.parent = ret }
        }

        ret
    }

    function parseConstant(): Constant {
        let start: Position$ = lexer.getPreviousPosition()

        let literal: Literal = lexer.parseLiteral()
        if (literal <> ()) {
            lexer.advance() }
        else {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Constant new Constant(literal, new Position(start), new Position(end))

        ret
    }

    function parseIf(): If {
        let start: Position$ = lexer.getPreviousPosition()

        let success_if_1: bool = lexer.parseKeyword(ifKeyword)
        if (success_if_1) {
            lexer.advance() }
        else {
            return () }

        let success_left_paren_2: bool = lexer.parsePunctuation(left_paren)
        if (success_left_paren_2) {
            lexer.advance() }
        else {
            return () }

        let condition: Operation = parseOperation()
        if (condition = ()) {
            return () }

        let success_right_paren_4: bool = lexer.parsePunctuation(right_paren)
        if (success_right_paren_4) {
            lexer.advance() }
        else {
            return () }

        let consequent: Block = parseBlock()
        if (consequent = ()) {
            return () }

        let else_clause: Else = parseElse()

        let end: Position$ lexer.getPosition()

        let ret: If new If(condition, consequent, else_clause, new Position(start), new Position(end))
        condition.parent = ret
        consequent.parent = ret
        if (else_clause <> ()) {
            else_clause.parent = ret }

        ret
    }

    function parseElse(): Else {
        let start: Position$ = lexer.getPreviousPosition()

        let success_else_1: bool = lexer.parseKeyword(elseKeyword)
        if (success_else_1) {
            lexer.advance() }
        else {
            return () }

        let alternative: Block = parseBlock()
        if (alternative = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Else new Else(alternative, new Position(start), new Position(end))
        alternative.parent = ret

        ret
    }

    function parseSwitch(): Switch {
        let start: Position$ = lexer.getPreviousPosition()

        let success_switch_1: bool = lexer.parseKeyword(switchKeyword)
        if (success_switch_1) {
            lexer.advance() }
        else {
            return () }

        let success_left_paren_2: bool = lexer.parsePunctuation(left_paren)
        if (success_left_paren_2) {
            lexer.advance() }
        else {
            return () }

        let condition: Operation = parseOperation()
        if (condition = ()) {
            return () }

        let success_right_paren_4: bool = lexer.parsePunctuation(right_paren)
        if (success_right_paren_4) {
            lexer.advance() }
        else {
            return () }

        let success_left_curly_5: bool = lexer.parsePunctuation(left_curly)
        if (success_left_curly_5) {
            lexer.advance() }
        else {
            return () }

        let cases: Array[SwitchCase] = parseSwitchCaseList()

        let success_right_curly_7: bool = lexer.parsePunctuation(right_curly)
        if (success_right_curly_7) {
            lexer.advance() }
        else {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Switch new Switch(condition, cases, new Position(start), new Position(end))
        condition.parent = ret
        if (cases <> ()) {
            for (item: SwitchCase in cases) {
                item.parent = ret }
        }

        ret
    }

    method parseSwitchCaseList(): Array[SwitchCase] {
        mutable ret: Array[SwitchCase]$ = null
        while (true) {

            let node: SwitchCase parseSwitchCase()
            if (node = ()) {
                break }

            if (ret = ()) {
                ret = new Array[SwitchCase]() }

            ret.add(node)
        }

        ret
    }

    function parseSwitchCase(): SwitchCase {
        let start: Position$ = lexer.getPreviousPosition()

        let label: CaseLabel = parseCaseLabel()
        if (label = ()) {
            return () }

        let content: Block = parseBlock()
        if (content = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: SwitchCase new SwitchCase(label, content, new Position(start), new Position(end))
        label.parent = ret
        content.parent = ret

        ret
    }

    function parseCaseLabel(): CaseLabel {
        {
            let node: ItemCaseLabel = parseItemCaseLabel()
            if (node <> ()) {
                return node }
        }

        {
            let node: DefaultCaseLabel = parseDefaultCaseLabel()
            if (node <> ()) {
                return node }
        }

        null
    }

    function parseItemCaseLabel(): ItemCaseLabel {
        let start: Position$ = lexer.getPreviousPosition()

        let success_case_1: bool = lexer.parseKeyword(caseKeyword)
        if (success_case_1) {
            lexer.advance() }
        else {
            return () }

        let items: Array[CaseItem] = parseCaseItemList()

        let end: Position$ lexer.getPosition()

        let ret: ItemCaseLabel new ItemCaseLabel(items, new Position(start), new Position(end))
        if (items <> ()) {
            for (item: CaseItem in items) {
                item.parent = ret }
        }

        ret
    }

    method parseCaseItemList(): Array[CaseItem] {
        mutable ret: Array[CaseItem]$ = null
        while (true) {

            let node: CaseItem parseCaseItem()
            if (node = ()) {
                break }

            if (ret = ()) {
                ret = new Array[CaseItem]() }

            ret.add(node)
        }

        ret
    }

    function parseCaseItem(): CaseItem {
        let start: Position$ = lexer.getPreviousPosition()

        let pattern: CasePattern = parseCasePattern()
        if (pattern = ()) {
            return () }

        let success_comma_2: bool = lexer.parsePunctuation(comma)
        if (success_comma_2) {
            lexer.advance() }

        let end: Position$ lexer.getPosition()

        let ret: CaseItem new CaseItem(pattern, new Position(start), new Position(end))
        pattern.parent = ret

        ret
    }

    function parseCasePattern(): CasePattern {
        {
            let node: ConstantPattern = parseConstantPattern()
            if (node <> ()) {
                return node }
        }

        {
            let node: WildcardPattern = parseWildcardPattern()
            if (node <> ()) {
                return node }
        }

        {
            let node: NamePattern = parseNamePattern()
            if (node <> ()) {
                return node }
        }

        null
    }

    function parseConstantPattern(): ConstantPattern {
        let start: Position$ = lexer.getPreviousPosition()

        let constant: Constant = parseConstant()
        if (constant = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: ConstantPattern new ConstantPattern(constant, new Position(start), new Position(end))
        constant.parent = ret

        ret
    }

    function parseWildcardPattern(): WildcardPattern {
        let start: Position$ = lexer.getPreviousPosition()

        let success_underscore_1: bool = lexer.parsePunctuation(underscore)
        if (success_underscore_1) {
            lexer.advance() }
        else {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: WildcardPattern new WildcardPattern(new Position(start), new Position(end))

        ret
    }

    function parseNamePattern(): NamePattern {
        let start: Position$ = lexer.getPreviousPosition()

        let name: Name = parseName()
        if (name = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: NamePattern new NamePattern(name, new Position(start), new Position(end))
        name.parent = ret

        ret
    }

    function parseDefaultCaseLabel(): DefaultCaseLabel {
        let start: Position$ = lexer.getPreviousPosition()

        let success_default_1: bool = lexer.parseKeyword(defaultKeyword)
        if (success_default_1) {
            lexer.advance() }
        else {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: DefaultCaseLabel new DefaultCaseLabel(new Position(start), new Position(end))

        ret
    }

    function parseFor(): For {
        let start: Position$ = lexer.getPreviousPosition()

        let success_for_1: bool = lexer.parseKeyword(forKeyword)
        if (success_for_1) {
            lexer.advance() }
        else {
            return () }

        let success_left_paren_2: bool = lexer.parsePunctuation(left_paren)
        if (success_left_paren_2) {
            lexer.advance() }
        else {
            return () }

        let index: string = lexer.parseIdentifier()
        if ((index <> ()) && isIdentifier(index)) {
            lexer.advance() }
        else {
            return () }

        let type_annotation: TypeAnnotation = parseTypeAnnotation()

        let success_in_5: bool = lexer.parseKeyword(inKeyword)
        if (success_in_5) {
            lexer.advance() }
        else {
            return () }

        let operation: Operation = parseOperation()
        if (operation = ()) {
            return () }

        let success_right_paren_7: bool = lexer.parsePunctuation(right_paren)
        if (success_right_paren_7) {
            lexer.advance() }
        else {
            return () }

        let iteration: Loop = parseLoop()
        if (iteration = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: For new For(index, type_annotation, operation, iteration, new Position(start), new Position(end))
        if (type_annotation <> ()) {
            type_annotation.parent = ret }
        operation.parent = ret
        iteration.parent = ret

        ret
    }

    function parseWhile(): While {
        let start: Position$ = lexer.getPreviousPosition()

        let success_while_1: bool = lexer.parseKeyword(whileKeyword)
        if (success_while_1) {
            lexer.advance() }
        else {
            return () }

        let success_left_paren_2: bool = lexer.parsePunctuation(left_paren)
        if (success_left_paren_2) {
            lexer.advance() }
        else {
            return () }

        let condition: Operation = parseOperation()
        if (condition = ()) {
            return () }

        let success_right_paren_4: bool = lexer.parsePunctuation(right_paren)
        if (success_right_paren_4) {
            lexer.advance() }
        else {
            return () }

        let iteration: Loop = parseLoop()
        if (iteration = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: While new While(condition, iteration, new Position(start), new Position(end))
        condition.parent = ret
        iteration.parent = ret

        ret
    }

    function parseDo(): Do {
        let start: Position$ = lexer.getPreviousPosition()

        let success_do_1: bool = lexer.parseKeyword(doKeyword)
        if (success_do_1) {
            lexer.advance() }
        else {
            return () }

        let iteration: Loop = parseLoop()
        if (iteration = ()) {
            return () }

        let success_while_3: bool = lexer.parseKeyword(whileKeyword)
        if (success_while_3) {
            lexer.advance() }
        else {
            return () }

        let success_left_paren_4: bool = lexer.parsePunctuation(left_paren)
        if (success_left_paren_4) {
            lexer.advance() }
        else {
            return () }

        let condition: Operation = parseOperation()
        if (condition = ()) {
            return () }

        let success_right_paren_6: bool = lexer.parsePunctuation(right_paren)
        if (success_right_paren_6) {
            lexer.advance() }
        else {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Do new Do(iteration, condition, new Position(start), new Position(end))
        iteration.parent = ret
        condition.parent = ret

        ret
    }

    function parseLoop(): Loop {
        {
            let node: SimpleLoop = parseSimpleLoop()
            if (node <> ()) {
                return node }
        }

        {
            let node: NamedLoop = parseNamedLoop()
            if (node <> ()) {
                return node }
        }

        null
    }

    function parseSimpleLoop(): SimpleLoop {
        let start: Position$ = lexer.getPreviousPosition()

        let code: Block = parseBlock()
        if (code = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: SimpleLoop new SimpleLoop(code, new Position(start), new Position(end))
        code.parent = ret

        ret
    }

    function parseNamedLoop(): NamedLoop {
        let start: Position$ = lexer.getPreviousPosition()

        let success_loop_1: bool = lexer.parseKeyword(loopKeyword)
        if (success_loop_1) {
            lexer.advance() }
        else {
            return () }

        let name: string = lexer.parseIdentifier()
        if ((name <> ()) && isIdentifier(name)) {
            lexer.advance() }
        else {
            return () }

        let code: Block = parseBlock()
        if (code = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: NamedLoop new NamedLoop(name, code, new Position(start), new Position(end))
        code.parent = ret

        ret
    }

    function parseThis(): This {
        let start: Position$ = lexer.getPreviousPosition()

        let success_this_1: bool = lexer.parseKeyword(thisKeyword)
        if (success_this_1) {
            lexer.advance() }
        else {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: This new This(new Position(start), new Position(end))

        ret
    }

    function parseNew(): New {
        let start: Position$ = lexer.getPreviousPosition()

        let success_new_1: bool = lexer.parseKeyword(newKeyword)
        if (success_new_1) {
            lexer.advance() }
        else {
            return () }

        let type_spec: Type = parseType()
        if (type_spec = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: New new New(type_spec, new Position(start), new Position(end))
        type_spec.parent = ret

        ret
    }

    function parseObject(): Object {
        let start: Position$ = lexer.getPreviousPosition()

        let success_left_paren_1: bool = lexer.parsePunctuation(left_paren)
        if (success_left_paren_1) {
            lexer.advance() }
        else {
            return () }

        let first_op: Operation = parseOperation()

        let additional_ops: Array[Item] = parseItemList()

        let success_right_paren_4: bool = lexer.parsePunctuation(right_paren)
        if (success_right_paren_4) {
            lexer.advance() }
        else {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Object new Object(first_op, additional_ops, new Position(start), new Position(end))
        if (first_op <> ()) {
            first_op.parent = ret }
        if (additional_ops <> ()) {
            for (item: Item in additional_ops) {
                item.parent = ret }
        }

        ret
    }

    function parseArray(): Array {
        let start: Position$ = lexer.getPreviousPosition()

        let success_left_bracket_1: bool = lexer.parsePunctuation(left_bracket)
        if (success_left_bracket_1) {
            lexer.advance() }
        else {
            return () }

        let first_op: Operation = parseOperation()

        let additional_ops: Array[Item] = parseItemList()

        let success_right_bracket_4: bool = lexer.parsePunctuation(right_bracket)
        if (success_right_bracket_4) {
            lexer.advance() }
        else {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Array new Array(first_op, additional_ops, new Position(start), new Position(end))
        if (first_op <> ()) {
            first_op.parent = ret }
        if (additional_ops <> ()) {
            for (item: Item in additional_ops) {
                item.parent = ret }
        }

        ret
    }

    method parseItemList(): Array[Item] {
        mutable ret: Array[Item]$ = null
        while (true) {

            let node: Item parseItem()
            if (node = ()) {
                break }

            if (ret = ()) {
                ret = new Array[Item]() }

            ret.add(node)
        }

        ret
    }

    function parseItem(): Item {
        let start: Position$ = lexer.getPreviousPosition()

        let success_comma_1: bool = lexer.parsePunctuation(comma)
        if (success_comma_1) {
            lexer.advance() }
        else {
            return () }

        let operation: Operation = parseOperation()
        if (operation = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Item new Item(operation, new Position(start), new Position(end))
        operation.parent = ret

        ret
    }

    function parseSizeOf(): SizeOf {
        let start: Position$ = lexer.getPreviousPosition()

        let success_sizeof_1: bool = lexer.parseKeyword(sizeofKeyword)
        if (success_sizeof_1) {
            lexer.advance() }
        else {
            return () }

        let type_spec: Type = parseType()
        if (type_spec = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: SizeOf new SizeOf(type_spec, new Position(start), new Position(end))
        type_spec.parent = ret

        ret
    }

    function parseBreak(): Break {
        let start: Position$ = lexer.getPreviousPosition()

        let success_break_1: bool = lexer.parseKeyword(breakKeyword)
        if (success_break_1) {
            lexer.advance() }
        else {
            return () }

        let iteration: string = lexer.parseIdentifier()
        if ((iteration <> ()) && isIdentifier(iteration)) {
            lexer.advance() }

        let success_semicolon_3: bool = lexer.parsePunctuation(semicolon)
        if (success_semicolon_3) {
            lexer.advance() }

        let end: Position$ lexer.getPosition()

        let ret: Break new Break(iteration, new Position(start), new Position(end))

        ret
    }

    function parseContinue(): Continue {
        let start: Position$ = lexer.getPreviousPosition()

        let success_continue_1: bool = lexer.parseKeyword(continueKeyword)
        if (success_continue_1) {
            lexer.advance() }
        else {
            return () }

        let iteration: string = lexer.parseIdentifier()
        if ((iteration <> ()) && isIdentifier(iteration)) {
            lexer.advance() }

        let success_semicolon_3: bool = lexer.parsePunctuation(semicolon)
        if (success_semicolon_3) {
            lexer.advance() }

        let end: Position$ lexer.getPosition()

        let ret: Continue new Continue(iteration, new Position(start), new Position(end))

        ret
    }

    function parseReturn(): Return {
        let start: Position$ = lexer.getPreviousPosition()

        let success_return_1: bool = lexer.parseKeyword(returnKeyword)
        if (success_return_1) {
            lexer.advance() }
        else {
            return () }

        let result: Calculation = parseCalculation()

        let end: Position$ lexer.getPosition()

        let ret: Return new Return(result, new Position(start), new Position(end))
        if (result <> ()) {
            result.parent = ret }

        ret
    }

    function parseThrow(): Throw {
        let start: Position$ = lexer.getPreviousPosition()

        let success_throw_1: bool = lexer.parseKeyword(throwKeyword)
        if (success_throw_1) {
            lexer.advance() }
        else {
            return () }

        let exception: Calculation = parseCalculation()
        if (exception = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Throw new Throw(exception, new Position(start), new Position(end))
        exception.parent = ret

        ret
    }

    function parseClass(): Class {
        let start: Position$ = lexer.getPreviousPosition()

        let success_class_1: bool = lexer.parseKeyword(classKeyword)
        if (success_class_1) {
            lexer.advance() }
        else {
            return () }

        let name: Name = parseName()
        if (name = ()) {
            return () }

        let generics: GenericParameters = parseGenericParameters()

        let base_class: Extends = parseExtends()

        let contents: Structure = parseStructure()

        let body: ClassBody = parseClassBody()

        let end: Position$ lexer.getPosition()

        let ret: Class new Class(name, generics, base_class, contents, body, new Position(start), new Position(end))
        name.parent = ret
        if (generics <> ()) {
            generics.parent = ret }
        if (base_class <> ()) {
            base_class.parent = ret }
        if (contents <> ()) {
            contents.parent = ret }
        if (body <> ()) {
            body.parent = ret }

        ret
    }

    function parseGenericParameters(): GenericParameters {
        let start: Position$ = lexer.getPreviousPosition()

        let success_left_bracket_1: bool = lexer.parsePunctuation(left_bracket)
        if (success_left_bracket_1) {
            lexer.advance() }
        else {
            return () }

        let name: string = lexer.parseIdentifier()
        if ((name <> ()) && isIdentifier(name)) {
            lexer.advance() }
        else {
            return () }

        let additional_generics: Array[GenericParameter] = parseGenericParameterList()

        let success_right_bracket_4: bool = lexer.parsePunctuation(right_bracket)
        if (success_right_bracket_4) {
            lexer.advance() }
        else {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: GenericParameters new GenericParameters(name, additional_generics, new Position(start), new Position(end))
        if (additional_generics <> ()) {
            for (item: GenericParameter in additional_generics) {
                item.parent = ret }
        }

        ret
    }

    method parseGenericParameterList(): Array[GenericParameter] {
        mutable ret: Array[GenericParameter]$ = null
        while (true) {

            let node: GenericParameter parseGenericParameter()
            if (node = ()) {
                break }

            if (ret = ()) {
                ret = new Array[GenericParameter]() }

            ret.add(node)
        }

        ret
    }

    function parseGenericParameter(): GenericParameter {
        let start: Position$ = lexer.getPreviousPosition()

        let success_comma_1: bool = lexer.parsePunctuation(comma)
        if (success_comma_1) {
            lexer.advance() }
        else {
            return () }

        let name: string = lexer.parseIdentifier()
        if ((name <> ()) && isIdentifier(name)) {
            lexer.advance() }
        else {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: GenericParameter new GenericParameter(name, new Position(start), new Position(end))

        ret
    }

    function parseExtends(): Extends {
        let start: Position$ = lexer.getPreviousPosition()

        let success_extends_1: bool = lexer.parseKeyword(extendsKeyword)
        if (success_extends_1) {
            lexer.advance() }
        else {
            return () }

        let name: Name = parseName()
        if (name = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Extends new Extends(name, new Position(start), new Position(end))
        name.parent = ret

        ret
    }

    function parseStructure(): Structure {
        let start: Position$ = lexer.getPreviousPosition()

        let success_left_paren_1: bool = lexer.parsePunctuation(left_paren)
        if (success_left_paren_1) {
            lexer.advance() }
        else {
            return () }

        let components: Array[Component] = parseComponentList()

        let success_right_paren_3: bool = lexer.parsePunctuation(right_paren)
        if (success_right_paren_3) {
            lexer.advance() }
        else {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Structure new Structure(components, new Position(start), new Position(end))
        if (components <> ()) {
            for (item: Component in components) {
                item.parent = ret }
        }

        ret
    }

    method parseComponentList(): Array[Component] {
        mutable ret: Array[Component]$ = null
        while (true) {

            let node: Component parseComponent()
            if (node = ()) {
                break }

            if (ret = ()) {
                ret = new Array[Component]() }

            ret.add(node)
        }

        ret
    }

    function parseComponent(): Component {
        let start: Position$ = lexer.getPreviousPosition()

        let name: string = lexer.parseIdentifier()
        if ((name <> ()) && isIdentifier(name)) {
            lexer.advance() }
        else {
            return () }

        let type_annotation: TypeAnnotation = parseTypeAnnotation()

        let success_comma_3: bool = lexer.parsePunctuation(comma)
        if (success_comma_3) {
            lexer.advance() }

        let end: Position$ lexer.getPosition()

        let ret: Component new Component(name, type_annotation, new Position(start), new Position(end))
        if (type_annotation <> ()) {
            type_annotation.parent = ret }

        ret
    }

    function parseClassBody(): ClassBody {
        let start: Position$ = lexer.getPreviousPosition()

        let success_left_curly_1: bool = lexer.parsePunctuation(left_curly)
        if (success_left_curly_1) {
            lexer.advance() }
        else {
            return () }

        let members: Array[ClassMember] = parseClassMemberList()

        let success_right_curly_3: bool = lexer.parsePunctuation(right_curly)
        if (success_right_curly_3) {
            lexer.advance() }
        else {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: ClassBody new ClassBody(members, new Position(start), new Position(end))
        if (members <> ()) {
            for (item: ClassMember in members) {
                item.parent = ret }
        }

        ret
    }

    method parseClassMemberList(): Array[ClassMember] {
        mutable ret: Array[ClassMember]$ = null
        while (true) {

            let node: ClassMember parseClassMember()
            if (node = ()) {
                break }

            if (ret = ()) {
                ret = new Array[ClassMember]() }

            ret.add(node)
        }

        ret
    }

    function parseClassMember(): ClassMember {
        {
            let node: LetMember = parseLetMember()
            if (node <> ()) {
                return node }
        }

        {
            let node: VarMember = parseVarMember()
            if (node <> ()) {
                return node }
        }

        {
            let node: MutableMember = parseMutableMember()
            if (node <> ()) {
                return node }
        }

        {
            let node: SetInitialization = parseSetInitialization()
            if (node <> ()) {
                return node }
        }

        {
            let node: Method = parseMethod()
            if (node <> ()) {
                return node }
        }

        {
            let node: StaticFunction = parseStaticFunction()
            if (node <> ()) {
                return node }
        }

        {
            let node: Operator = parseOperator()
            if (node <> ()) {
                return node }
        }

        {
            let node: Initializer = parseInitializer()
            if (node <> ()) {
                return node }
        }

        {
            let node: Allocator = parseAllocator()
            if (node <> ()) {
                return node }
        }

        null
    }

    function parseLetMember(): LetMember {
        let start: Position$ = lexer.getPreviousPosition()

        let declaration: Let = parseLet()
        if (declaration = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: LetMember new LetMember(declaration, new Position(start), new Position(end))
        declaration.parent = ret

        ret
    }

    function parseVarMember(): VarMember {
        let start: Position$ = lexer.getPreviousPosition()

        let declaration: Var = parseVar()
        if (declaration = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: VarMember new VarMember(declaration, new Position(start), new Position(end))
        declaration.parent = ret

        ret
    }

    function parseMutableMember(): MutableMember {
        let start: Position$ = lexer.getPreviousPosition()

        let declaration: Mutable = parseMutable()
        if (declaration = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: MutableMember new MutableMember(declaration, new Position(start), new Position(end))
        declaration.parent = ret

        ret
    }

    function parseSetInitialization(): SetInitialization {
        let start: Position$ = lexer.getPreviousPosition()

        let definition: Set = parseSet()
        if (definition = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: SetInitialization new SetInitialization(definition, new Position(start), new Position(end))
        definition.parent = ret

        ret
    }

    function parseMethod(): Method {
        let start: Position$ = lexer.getPreviousPosition()

        let success_method_1: bool = lexer.parseKeyword(methodKeyword)
        if (success_method_1) {
            lexer.advance() }
        else {
            return () }

        let procedure: Procedure = parseProcedure()
        if (procedure = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Method new Method(procedure, new Position(start), new Position(end))
        procedure.parent = ret

        ret
    }

    function parseStaticFunction(): StaticFunction {
        let start: Position$ = lexer.getPreviousPosition()

        let procedure: Function = parseFunction()
        if (procedure = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: StaticFunction new StaticFunction(procedure, new Position(start), new Position(end))
        procedure.parent = ret

        ret
    }

    function parseOperator(): Operator {
        let start: Position$ = lexer.getPreviousPosition()

        let success_operator_1: bool = lexer.parseKeyword(operatorKeyword)
        if (success_operator_1) {
            lexer.advance() }
        else {
            return () }

        let routine: Routine = parseRoutine()
        if (routine = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Operator new Operator(routine, new Position(start), new Position(end))
        routine.parent = ret

        ret
    }

    function parseInitializer(): Initializer {
        let start: Position$ = lexer.getPreviousPosition()

        let success_initializer_1: bool = lexer.parseKeyword(initializerKeyword)
        if (success_initializer_1) {
            lexer.advance() }
        else {
            return () }

        let input: Structure = parseStructure()

        let body: Block = parseBlock()
        if (body = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Initializer new Initializer(input, body, new Position(start), new Position(end))
        if (input <> ()) {
            input.parent = ret }
        body.parent = ret

        ret
    }

    function parseAllocator(): Allocator {
        let start: Position$ = lexer.getPreviousPosition()

        let success_allocator_1: bool = lexer.parseKeyword(allocatorKeyword)
        if (success_allocator_1) {
            lexer.advance() }
        else {
            return () }

        let input: Structure = parseStructure()

        let body: Block = parseBlock()
        if (body = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Allocator new Allocator(input, body, new Position(start), new Position(end))
        if (input <> ()) {
            input.parent = ret }
        body.parent = ret

        ret
    }

    function parseTypeAnnotation(): TypeAnnotation {
        let start: Position$ = lexer.getPreviousPosition()

        let success_colon_1: bool = lexer.parsePunctuation(colon)
        if (success_colon_1) {
            lexer.advance() }
        else {
            return () }

        let type_spec: TypeSpec = parseTypeSpec()
        if (type_spec = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: TypeAnnotation new TypeAnnotation(type_spec, new Position(start), new Position(end))
        type_spec.parent = ret

        ret
    }

    function parseTypeSpec(): TypeSpec {
        {
            let node: Type = parseType()
            if (node <> ()) {
                return node }
        }

        {
            let node: Variant = parseVariant()
            if (node <> ()) {
                return node }
        }

        null
    }

    method parseTypeList(): Array[Type] {
        mutable ret: Array[Type]$ = null
        while (true) {

            let node: Type parseType()
            if (node = ()) {
                break }

            if (ret = ()) {
                ret = new Array[Type]() }

            ret.add(node)
        }

        ret
    }

    function parseType(): Type {
        let start: Position$ = lexer.getPreviousPosition()

        let name: Name = parseName()
        if (name = ()) {
            return () }

        let generics: GenericArguments = parseGenericArguments()

        let optional: Optional = parseOptional()

        let life_time: LifeTime = parseLifeTime()

        let end: Position$ lexer.getPosition()

        let ret: Type new Type(name, generics, optional, life_time, new Position(start), new Position(end))
        name.parent = ret
        if (generics <> ()) {
            generics.parent = ret }
        if (optional <> ()) {
            optional.parent = ret }
        if (life_time <> ()) {
            life_time.parent = ret }

        ret
    }

    function parseVariant(): Variant {
        let start: Position$ = lexer.getPreviousPosition()

        let success_left_paren_1: bool = lexer.parsePunctuation(left_paren)
        if (success_left_paren_1) {
            lexer.advance() }
        else {
            return () }

        let types: Array[Type] = parseTypeList()

        let success_right_paren_3: bool = lexer.parsePunctuation(right_paren)
        if (success_right_paren_3) {
            lexer.advance() }
        else {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Variant new Variant(types, new Position(start), new Position(end))
        if (types <> ()) {
            for (item: Type in types) {
                item.parent = ret }
        }

        ret
    }

    function parseThrows(): Throws {
        let start: Position$ = lexer.getPreviousPosition()

        let success_throws_1: bool = lexer.parseKeyword(throwsKeyword)
        if (success_throws_1) {
            lexer.advance() }
        else {
            return () }

        let throws_type: TypeSpec = parseTypeSpec()
        if (throws_type = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Throws new Throws(throws_type, new Position(start), new Position(end))
        throws_type.parent = ret

        ret
    }

    function parseGenericArguments(): GenericArguments {
        let start: Position$ = lexer.getPreviousPosition()

        let success_left_bracket_1: bool = lexer.parsePunctuation(left_bracket)
        if (success_left_bracket_1) {
            lexer.advance() }
        else {
            return () }

        let generic: Type = parseType()
        if (generic = ()) {
            return () }

        let additional_generics: Array[GenericArgument] = parseGenericArgumentList()

        let success_right_bracket_4: bool = lexer.parsePunctuation(right_bracket)
        if (success_right_bracket_4) {
            lexer.advance() }
        else {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: GenericArguments new GenericArguments(generic, additional_generics, new Position(start), new Position(end))
        generic.parent = ret
        if (additional_generics <> ()) {
            for (item: GenericArgument in additional_generics) {
                item.parent = ret }
        }

        ret
    }

    method parseGenericArgumentList(): Array[GenericArgument] {
        mutable ret: Array[GenericArgument]$ = null
        while (true) {

            let node: GenericArgument parseGenericArgument()
            if (node = ()) {
                break }

            if (ret = ()) {
                ret = new Array[GenericArgument]() }

            ret.add(node)
        }

        ret
    }

    function parseGenericArgument(): GenericArgument {
        let start: Position$ = lexer.getPreviousPosition()

        let success_comma_1: bool = lexer.parsePunctuation(comma)
        if (success_comma_1) {
            lexer.advance() }
        else {
            return () }

        let type_spec: Type = parseType()
        if (type_spec = ()) {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: GenericArgument new GenericArgument(type_spec, new Position(start), new Position(end))
        type_spec.parent = ret

        ret
    }

    function parseOptional(): Optional {
        let start: Position$ = lexer.getPreviousPosition()

        let success_question_1: bool = lexer.parsePunctuation(question)
        if (success_question_1) {
            lexer.advance() }
        else {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Optional new Optional(new Position(start), new Position(end))

        ret
    }

    function parseLifeTime(): LifeTime {
        {
            let node: Root = parseRoot()
            if (node <> ()) {
                return node }
        }

        {
            let node: Local = parseLocal()
            if (node <> ()) {
                return node }
        }

        {
            let node: Reference = parseReference()
            if (node <> ()) {
                return node }
        }

        {
            let node: Thrown = parseThrown()
            if (node <> ()) {
                return node }
        }

        null
    }

    function parseRoot(): Root {
        let start: Position$ = lexer.getPreviousPosition()

        let success_dollar_1: bool = lexer.parsePunctuation(dollar)
        if (success_dollar_1) {
            lexer.advance() }
        else {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Root new Root(new Position(start), new Position(end))

        ret
    }

    function parseLocal(): Local {
        let start: Position$ = lexer.getPreviousPosition()

        let success_at_1: bool = lexer.parsePunctuation(at)
        if (success_at_1) {
            lexer.advance() }
        else {
            return () }

        let location: string = lexer.parseIdentifier()
        if ((location <> ()) && isIdentifier(location)) {
            lexer.advance() }
        else {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Local new Local(location, new Position(start), new Position(end))

        ret
    }

    function parseReference(): Reference {
        let start: Position$ = lexer.getPreviousPosition()

        let success_backtick_1: bool = lexer.parsePunctuation(backtick)
        if (success_backtick_1) {
            lexer.advance() }
        else {
            return () }

        let age: Literal = lexer.parseLiteral()
        if (age <> ()) {
            lexer.advance() }

        let end: Position$ lexer.getPosition()

        let ret: Reference new Reference(age, new Position(start), new Position(end))

        ret
    }

    function parseThrown(): Thrown {
        let start: Position$ = lexer.getPreviousPosition()

        let success_hash_1: bool = lexer.parsePunctuation(hash)
        if (success_hash_1) {
            lexer.advance() }
        else {
            return () }

        let end: Position$ lexer.getPosition()

        let ret: Thrown new Thrown(new Position(start), new Position(end))

        ret
    }

    function isAtEnd(): bool {
        lexer.isAtEnd()
    }

    function isIdentifier(id: string): bool {
        if (id.equals(usingKeyword)) {
            return false }

        if (id.equals(namespaceKeyword)) {
            return false }

        if (id.equals(typedefKeyword)) {
            return false }

        if (id.equals(letKeyword)) {
            return false }

        if (id.equals(mutableKeyword)) {
            return false }

        if (id.equals(threadlocalKeyword)) {
            return false }

        if (id.equals(varKeyword)) {
            return false }

        if (id.equals(setKeyword)) {
            return false }

        if (id.equals(classKeyword)) {
            return false }

        if (id.equals(extendsKeyword)) {
            return false }

        if (id.equals(initializerKeyword)) {
            return false }

        if (id.equals(allocatorKeyword)) {
            return false }

        if (id.equals(methodKeyword)) {
            return false }

        if (id.equals(functionKeyword)) {
            return false }

        if (id.equals(operatorKeyword)) {
            return false }

        if (id.equals(thisKeyword)) {
            return false }

        if (id.equals(newKeyword)) {
            return false }

        if (id.equals(sizeofKeyword)) {
            return false }

        if (id.equals(catchKeyword)) {
            return false }

        if (id.equals(throwsKeyword)) {
            return false }

        if (id.equals(asKeyword)) {
            return false }

        if (id.equals(isKeyword)) {
            return false }

        if (id.equals(ifKeyword)) {
            return false }

        if (id.equals(elseKeyword)) {
            return false }

        if (id.equals(switchKeyword)) {
            return false }

        if (id.equals(caseKeyword)) {
            return false }

        if (id.equals(defaultKeyword)) {
            return false }

        if (id.equals(forKeyword)) {
            return false }

        if (id.equals(inKeyword)) {
            return false }

        if (id.equals(whileKeyword)) {
            return false }

        if (id.equals(doKeyword)) {
            return false }

        if (id.equals(loopKeyword)) {
            return false }

        if (id.equals(breakKeyword)) {
            return false }

        if (id.equals(continueKeyword)) {
            return false }

        if (id.equals(returnKeyword)) {
            return false }

        if (id.equals(throwKeyword)) {
            return false }

        if (id.equals(intrinsicKeyword)) {
            return false }

        if (id.equals(defineKeyword)) {
            return false }

        true
    }
}

class Visitor {
    function open_program(programSyntax: ProgramSyntax): bool {
        true
    }

    function close_program(programSyntax: ProgramSyntax) {
    }

    function open_file(fileSyntax: FileSyntax): bool {
        true
    }

    function close_file(fileSyntax: FileSyntax) {
    }

    function visit_intrinsic(intrinsicSyntax: IntrinsicSyntax) {
    }

    function open_using(usingSyntax: UsingSyntax): bool {
        true
    }

    function close_using(usingSyntax: UsingSyntax) {
    }

    function open_define(defineSyntax: DefineSyntax): bool {
        true
    }

    function close_define(defineSyntax: DefineSyntax) {
    }

    function open_name(nameSyntax: NameSyntax): bool {
        true
    }

    function close_name(nameSyntax: NameSyntax) {
    }

    function visit_extension(extensionSyntax: ExtensionSyntax) {
    }

    function open_namespace(namespaceSyntax: NamespaceSyntax): bool {
        true
    }

    function close_namespace(namespaceSyntax: NamespaceSyntax) {
    }

    function open_function(functionSyntax: FunctionSyntax): bool {
        true
    }

    function close_function(functionSyntax: FunctionSyntax) {
    }

    function open_procedure(procedureSyntax: ProcedureSyntax): bool {
        true
    }

    function close_procedure(procedureSyntax: ProcedureSyntax) {
    }

    function open_routine(routineSyntax: RoutineSyntax): bool {
        true
    }

    function close_routine(routineSyntax: RoutineSyntax) {
    }

    function open_letdeclaration(letdeclarationSyntax: LetDeclarationSyntax): bool {
        true
    }

    function close_letdeclaration(letdeclarationSyntax: LetDeclarationSyntax) {
    }

    function open_vardeclaration(vardeclarationSyntax: VarDeclarationSyntax): bool {
        true
    }

    function close_vardeclaration(vardeclarationSyntax: VarDeclarationSyntax) {
    }

    function open_mutabledeclaration(mutabledeclarationSyntax: MutableDeclarationSyntax): bool {
        true
    }

    function close_mutabledeclaration(mutabledeclarationSyntax: MutableDeclarationSyntax) {
    }

    function open_threadlocaldeclaration(threadlocaldeclarationSyntax: ThreadLocalDeclarationSyntax): bool {
        true
    }

    function close_threadlocaldeclaration(threadlocaldeclarationSyntax: ThreadLocalDeclarationSyntax) {
    }

    function open_let(letSyntax: LetSyntax): bool {
        true
    }

    function close_let(letSyntax: LetSyntax) {
    }

    function open_var(varSyntax: VarSyntax): bool {
        true
    }

    function close_var(varSyntax: VarSyntax) {
    }

    function open_mutable(mutableSyntax: MutableSyntax): bool {
        true
    }

    function close_mutable(mutableSyntax: MutableSyntax) {
    }

    function open_threadlocal(threadlocalSyntax: ThreadLocalSyntax): bool {
        true
    }

    function close_threadlocal(threadlocalSyntax: ThreadLocalSyntax) {
    }

    function open_binding(bindingSyntax: BindingSyntax): bool {
        true
    }

    function close_binding(bindingSyntax: BindingSyntax) {
    }

    function open_set(setSyntax: SetSyntax): bool {
        true
    }

    function close_set(setSyntax: SetSyntax) {
    }

    function open_calculation(calculationSyntax: CalculationSyntax): bool {
        true
    }

    function close_calculation(calculationSyntax: CalculationSyntax) {
    }

    function open_operation(operationSyntax: OperationSyntax): bool {
        true
    }

    function close_operation(operationSyntax: OperationSyntax) {
    }

    function open_operand(operandSyntax: OperandSyntax): bool {
        true
    }

    function close_operand(operandSyntax: OperandSyntax) {
    }

    function visit_memberaccess(memberaccessSyntax: MemberAccessSyntax) {
    }

    function open_as(asSyntax: AsSyntax): bool {
        true
    }

    function close_as(asSyntax: AsSyntax) {
    }

    function open_is(isSyntax: IsSyntax): bool {
        true
    }

    function close_is(isSyntax: IsSyntax) {
    }

    function visit_unwrap(unwrapSyntax: UnwrapSyntax) {
    }

    function open_catch(catchSyntax: CatchSyntax): bool {
        true
    }

    function close_catch(catchSyntax: CatchSyntax) {
    }

    function open_wildcardcatchpattern(wildcardcatchpatternSyntax: WildCardCatchPatternSyntax): bool {
        true
    }

    function close_wildcardcatchpattern(wildcardcatchpatternSyntax: WildCardCatchPatternSyntax) {
    }

    function open_typecatchpattern(typecatchpatternSyntax: TypeCatchPatternSyntax): bool {
        true
    }

    function close_typecatchpattern(typecatchpatternSyntax: TypeCatchPatternSyntax) {
    }

    function open_block(blockSyntax: BlockSyntax): bool {
        true
    }

    function close_block(blockSyntax: BlockSyntax) {
    }

    function visit_constant(constantSyntax: ConstantSyntax) {
    }

    function open_if(ifSyntax: IfSyntax): bool {
        true
    }

    function close_if(ifSyntax: IfSyntax) {
    }

    function open_else(elseSyntax: ElseSyntax): bool {
        true
    }

    function close_else(elseSyntax: ElseSyntax) {
    }

    function open_switch(switchSyntax: SwitchSyntax): bool {
        true
    }

    function close_switch(switchSyntax: SwitchSyntax) {
    }

    function open_switchcase(switchcaseSyntax: SwitchCaseSyntax): bool {
        true
    }

    function close_switchcase(switchcaseSyntax: SwitchCaseSyntax) {
    }

    function open_itemcaselabel(itemcaselabelSyntax: ItemCaseLabelSyntax): bool {
        true
    }

    function close_itemcaselabel(itemcaselabelSyntax: ItemCaseLabelSyntax) {
    }

    function open_caseitem(caseitemSyntax: CaseItemSyntax): bool {
        true
    }

    function close_caseitem(caseitemSyntax: CaseItemSyntax) {
    }

    function open_constantpattern(constantpatternSyntax: ConstantPatternSyntax): bool {
        true
    }

    function close_constantpattern(constantpatternSyntax: ConstantPatternSyntax) {
    }

    function visit_wildcardpattern(wildcardpatternSyntax: WildcardPatternSyntax) {
    }

    function open_namepattern(namepatternSyntax: NamePatternSyntax): bool {
        true
    }

    function close_namepattern(namepatternSyntax: NamePatternSyntax) {
    }

    function visit_defaultcaselabel(defaultcaselabelSyntax: DefaultCaseLabelSyntax) {
    }

    function open_for(forSyntax: ForSyntax): bool {
        true
    }

    function close_for(forSyntax: ForSyntax) {
    }

    function open_while(whileSyntax: WhileSyntax): bool {
        true
    }

    function close_while(whileSyntax: WhileSyntax) {
    }

    function open_do(doSyntax: DoSyntax): bool {
        true
    }

    function close_do(doSyntax: DoSyntax) {
    }

    function open_simpleloop(simpleloopSyntax: SimpleLoopSyntax): bool {
        true
    }

    function close_simpleloop(simpleloopSyntax: SimpleLoopSyntax) {
    }

    function open_namedloop(namedloopSyntax: NamedLoopSyntax): bool {
        true
    }

    function close_namedloop(namedloopSyntax: NamedLoopSyntax) {
    }

    function visit_this(thisSyntax: ThisSyntax) {
    }

    function open_new(newSyntax: NewSyntax): bool {
        true
    }

    function close_new(newSyntax: NewSyntax) {
    }

    function open_object(objectSyntax: ObjectSyntax): bool {
        true
    }

    function close_object(objectSyntax: ObjectSyntax) {
    }

    function open_array(arraySyntax: ArraySyntax): bool {
        true
    }

    function close_array(arraySyntax: ArraySyntax) {
    }

    function open_item(itemSyntax: ItemSyntax): bool {
        true
    }

    function close_item(itemSyntax: ItemSyntax) {
    }

    function open_sizeof(sizeofSyntax: SizeOfSyntax): bool {
        true
    }

    function close_sizeof(sizeofSyntax: SizeOfSyntax) {
    }

    function visit_break(breakSyntax: BreakSyntax) {
    }

    function visit_continue(continueSyntax: ContinueSyntax) {
    }

    function open_return(returnSyntax: ReturnSyntax): bool {
        true
    }

    function close_return(returnSyntax: ReturnSyntax) {
    }

    function open_throw(throwSyntax: ThrowSyntax): bool {
        true
    }

    function close_throw(throwSyntax: ThrowSyntax) {
    }

    function open_class(classSyntax: ClassSyntax): bool {
        true
    }

    function close_class(classSyntax: ClassSyntax) {
    }

    function open_genericparameters(genericparametersSyntax: GenericParametersSyntax): bool {
        true
    }

    function close_genericparameters(genericparametersSyntax: GenericParametersSyntax) {
    }

    function visit_genericparameter(genericparameterSyntax: GenericParameterSyntax) {
    }

    function open_extends(extendsSyntax: ExtendsSyntax): bool {
        true
    }

    function close_extends(extendsSyntax: ExtendsSyntax) {
    }

    function open_structure(structureSyntax: StructureSyntax): bool {
        true
    }

    function close_structure(structureSyntax: StructureSyntax) {
    }

    function open_component(componentSyntax: ComponentSyntax): bool {
        true
    }

    function close_component(componentSyntax: ComponentSyntax) {
    }

    function open_classbody(classbodySyntax: ClassBodySyntax): bool {
        true
    }

    function close_classbody(classbodySyntax: ClassBodySyntax) {
    }

    function open_letmember(letmemberSyntax: LetMemberSyntax): bool {
        true
    }

    function close_letmember(letmemberSyntax: LetMemberSyntax) {
    }

    function open_varmember(varmemberSyntax: VarMemberSyntax): bool {
        true
    }

    function close_varmember(varmemberSyntax: VarMemberSyntax) {
    }

    function open_mutablemember(mutablememberSyntax: MutableMemberSyntax): bool {
        true
    }

    function close_mutablemember(mutablememberSyntax: MutableMemberSyntax) {
    }

    function open_setinitialization(setinitializationSyntax: SetInitializationSyntax): bool {
        true
    }

    function close_setinitialization(setinitializationSyntax: SetInitializationSyntax) {
    }

    function open_method(methodSyntax: MethodSyntax): bool {
        true
    }

    function close_method(methodSyntax: MethodSyntax) {
    }

    function open_staticfunction(staticfunctionSyntax: StaticFunctionSyntax): bool {
        true
    }

    function close_staticfunction(staticfunctionSyntax: StaticFunctionSyntax) {
    }

    function open_operator(operatorSyntax: OperatorSyntax): bool {
        true
    }

    function close_operator(operatorSyntax: OperatorSyntax) {
    }

    function open_initializer(initializerSyntax: InitializerSyntax): bool {
        true
    }

    function close_initializer(initializerSyntax: InitializerSyntax) {
    }

    function open_allocator(allocatorSyntax: AllocatorSyntax): bool {
        true
    }

    function close_allocator(allocatorSyntax: AllocatorSyntax) {
    }

    function open_typeannotation(typeannotationSyntax: TypeAnnotationSyntax): bool {
        true
    }

    function close_typeannotation(typeannotationSyntax: TypeAnnotationSyntax) {
    }

    function open_type(typeSyntax: TypeSyntax): bool {
        true
    }

    function close_type(typeSyntax: TypeSyntax) {
    }

    function open_variant(variantSyntax: VariantSyntax): bool {
        true
    }

    function close_variant(variantSyntax: VariantSyntax) {
    }

    function open_throws(throwsSyntax: ThrowsSyntax): bool {
        true
    }

    function close_throws(throwsSyntax: ThrowsSyntax) {
    }

    function open_genericarguments(genericargumentsSyntax: GenericArgumentsSyntax): bool {
        true
    }

    function close_genericarguments(genericargumentsSyntax: GenericArgumentsSyntax) {
    }

    function open_genericargument(genericargumentSyntax: GenericArgumentSyntax): bool {
        true
    }

    function close_genericargument(genericargumentSyntax: GenericArgumentSyntax) {
    }

    function visit_optional(optionalSyntax: OptionalSyntax) {
    }

    function visit_root(rootSyntax: RootSyntax) {
    }

    function visit_local(localSyntax: LocalSyntax) {
    }

    function visit_reference(referenceSyntax: ReferenceSyntax) {
    }

    function visit_thrown(thrownSyntax: ThrownSyntax) {
    }
}

class SyntaxNode (

    start: Position,
    end: Position

    ) {

    var parent: SyntaxNode? ()
}

class Program extends SyntaxNode (

    name: string, 
    files: Array[File]

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openProgram(this) = false) {
            return }

        if (files <> ()) {
            for (node: File in files) {
                node.accept(visitor) } }

        visitor.closeProgram(this)
    }
}

class File extends SyntaxNode (

    intrinsics: Array[Intrinsic], 
    usings: Array[Using], 
    defines: Array[Define], 
    declarations: Array[Declaration], 
    statements: Array[Statement]

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openFile(this) = false) {
            return }

        if (intrinsics <> ()) {
            for (node: Intrinsic in intrinsics) {
                node.accept(visitor) } }

        if (usings <> ()) {
            for (node: Using in usings) {
                node.accept(visitor) } }

        if (defines <> ()) {
            for (node: Define in defines) {
                node.accept(visitor) } }

        if (declarations <> ()) {
            for (node: Declaration in declarations) {
                node.accept(visitor) } }

        if (statements <> ()) {
            for (node: Statement in statements) {
                node.accept(visitor) } }

        visitor.closeFile(this)
    }
}

class Intrinsic extends SyntaxNode (

    name: string

    ) {
    function accept(visitor: Visitor) {

        visitor.visitIntrinsic(this)
    }
}

class Using extends SyntaxNode (

    name: Name

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openUsing(this) = false) {
            return }
        name.accept(visitor)

        visitor.closeUsing(this)
    }
}

class Define extends SyntaxNode (

    name: Name, 
    type_spec: Type

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openDefine(this) = false) {
            return }
        name.accept(visitor)
        type_spec.accept(visitor)

        visitor.closeDefine(this)
    }
}

class Name extends Expression (

    name: string, 
    extensions: Array[Extension]

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openName(this) = false) {
            return }

        if (extensions <> ()) {
            for (node: Extension in extensions) {
                node.accept(visitor) } }

        visitor.closeName(this)
    }
}

class Extension extends SyntaxNode (

    name: string

    ) {
    function accept(visitor: Visitor) {

        visitor.visitExtension(this)
    }
}

class Declaration extends SyntaxNode {
    function accept(visitor: Visitor) {
    }
}

class Namespace extends Declaration (

    name: Name, 
    usings: Array[Using], 
    defines: Array[Define], 
    declarations: Array[Declaration], 

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openNamespace(this) = false) {
            return }
        name.accept(visitor)

        if (usings <> ()) {
            for (node: Using in usings) {
                node.accept(visitor) } }

        if (defines <> ()) {
            for (node: Define in defines) {
                node.accept(visitor) } }

        if (declarations <> ()) {
            for (node: Declaration in declarations) {
                node.accept(visitor) } }

        visitor.closeNamespace(this)
    }
}

class Function extends Declaration (

    procedure: Procedure

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openFunction(this) = false) {
            return }
        procedure.accept(visitor)

        visitor.closeFunction(this)
    }
}

class Procedure extends SyntaxNode (

    name: string, 
    routine: Routine

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openProcedure(this) = false) {
            return }
        routine.accept(visitor)

        visitor.closeProcedure(this)
    }
}

class Routine extends SyntaxNode (

    input: Structure, 
    output: TypeAnnotation, 
    throws_clause: Throws, 
    body: Block

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openRoutine(this) = false) {
            return }

        if (input <> ()) {
            input.accept(visitor) }

        if (output <> ()) {
            output.accept(visitor) }

        if (throws_clause <> ()) {
            throws_clause.accept(visitor) }
        body.accept(visitor)

        visitor.closeRoutine(this)
    }
}

class LetDeclaration extends Declaration (

    declaration: Let

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openLetDeclaration(this) = false) {
            return }
        declaration.accept(visitor)

        visitor.closeLetDeclaration(this)
    }
}

class VarDeclaration extends Declaration (

    declaration: Var

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openVarDeclaration(this) = false) {
            return }
        declaration.accept(visitor)

        visitor.closeVarDeclaration(this)
    }
}

class MutableDeclaration extends Declaration (

    declaration: Mutable

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openMutableDeclaration(this) = false) {
            return }
        declaration.accept(visitor)

        visitor.closeMutableDeclaration(this)
    }
}

class ThreadLocalDeclaration extends Declaration (

    declaration: ThreadLocal

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openThreadLocalDeclaration(this) = false) {
            return }
        declaration.accept(visitor)

        visitor.closeThreadLocalDeclaration(this)
    }
}

class Statement extends SyntaxNode {
    function accept(visitor: Visitor) {
    }
}

class Let extends Statement (

    binding: Binding

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openLet(this) = false) {
            return }
        binding.accept(visitor)

        visitor.closeLet(this)
    }
}

class Var extends Statement (

    binding: Binding

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openVar(this) = false) {
            return }
        binding.accept(visitor)

        visitor.closeVar(this)
    }
}

class Mutable extends Statement (

    binding: Binding

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openMutable(this) = false) {
            return }
        binding.accept(visitor)

        visitor.closeMutable(this)
    }
}

class ThreadLocal extends Statement (

    binding: Binding

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openThreadLocal(this) = false) {
            return }
        binding.accept(visitor)

        visitor.closeThreadLocal(this)
    }
}

class Binding extends SyntaxNode (

    name: string, 
    type_annotation: TypeAnnotation, 
    calculation: Calculation

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openBinding(this) = false) {
            return }

        if (type_annotation <> ()) {
            type_annotation.accept(visitor) }
        calculation.accept(visitor)

        visitor.closeBinding(this)
    }
}

class Set extends Statement (

    l_value: Operation, 
    r_value: Calculation

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openSet(this) = false) {
            return }
        l_value.accept(visitor)
        r_value.accept(visitor)

        visitor.closeSet(this)
    }
}

class Calculation extends Statement (

    operation: Operation, 

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openCalculation(this) = false) {
            return }
        operation.accept(visitor)

        visitor.closeCalculation(this)
    }
}

class Operation extends SyntaxNode (

    op: Array[Operand]

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openOperation(this) = false) {
            return }

        if (op <> ()) {
            for (node: Operand in op) {
                node.accept(visitor) } }

        visitor.closeOperation(this)
    }
}

class Operand extends Statement (

    primary: Expression, 
    postfixes: Array[Postfix]

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openOperand(this) = false) {
            return }
        primary.accept(visitor)

        if (postfixes <> ()) {
            for (node: Postfix in postfixes) {
                node.accept(visitor) } }

        visitor.closeOperand(this)
    }
}

class Postfix extends SyntaxNode {
    function accept(visitor: Visitor) {
    }
}

class MemberAccess extends Postfix (

    member: string

    ) {
    function accept(visitor: Visitor) {

        visitor.visitMemberAccess(this)
    }
}

class As extends Postfix (

    type_spec: TypeSpec

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openAs(this) = false) {
            return }
        type_spec.accept(visitor)

        visitor.closeAs(this)
    }
}

class Is extends Postfix (

    type_spec: TypeSpec

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openIs(this) = false) {
            return }
        type_spec.accept(visitor)

        visitor.closeIs(this)
    }
}

class Unwrap extends Postfix (


    ) {
    function accept(visitor: Visitor) {

        visitor.visitUnwrap(this)
    }
}

class Catch extends Postfix (

    type_spec: CatchPattern, 
    handler: Block

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openCatch(this) = false) {
            return }
        type_spec.accept(visitor)
        handler.accept(visitor)

        visitor.closeCatch(this)
    }
}

class CatchPattern extends SyntaxNode {
    function accept(visitor: Visitor) {
    }
}

class WildCardCatchPattern extends CatchPattern (

    pattern: WildcardPattern

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openWildCardCatchPattern(this) = false) {
            return }
        pattern.accept(visitor)

        visitor.closeWildCardCatchPattern(this)
    }
}

class TypeCatchPattern extends CatchPattern (

    type_spec: TypeSpec, 
    error_name: string

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openTypeCatchPattern(this) = false) {
            return }
        type_spec.accept(visitor)

        visitor.closeTypeCatchPattern(this)
    }
}

class Expression extends SyntaxNode {
    function accept(visitor: Visitor) {
    }
}

class Block extends Expression (

    statements: Array[Statement], 

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openBlock(this) = false) {
            return }

        if (statements <> ()) {
            for (node: Statement in statements) {
                node.accept(visitor) } }

        visitor.closeBlock(this)
    }
}

class Constant extends Expression (

    literal: Literal

    ) {
    function accept(visitor: Visitor) {

        visitor.visitConstant(this)
    }
}

class If extends Expression (

    condition: Operation, 
    consequent: Block, 
    else_clause: Else

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openIf(this) = false) {
            return }
        condition.accept(visitor)
        consequent.accept(visitor)

        if (else_clause <> ()) {
            else_clause.accept(visitor) }

        visitor.closeIf(this)
    }
}

class Else extends SyntaxNode (

    alternative: Block

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openElse(this) = false) {
            return }
        alternative.accept(visitor)

        visitor.closeElse(this)
    }
}

class Switch extends Expression (

    condition: Operation, 
    cases: Array[SwitchCase], 

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openSwitch(this) = false) {
            return }
        condition.accept(visitor)

        if (cases <> ()) {
            for (node: SwitchCase in cases) {
                node.accept(visitor) } }

        visitor.closeSwitch(this)
    }
}

class SwitchCase extends SyntaxNode (

    label: CaseLabel, 
    content: Block

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openSwitchCase(this) = false) {
            return }
        label.accept(visitor)
        content.accept(visitor)

        visitor.closeSwitchCase(this)
    }
}

class CaseLabel extends SyntaxNode {
    function accept(visitor: Visitor) {
    }
}

class ItemCaseLabel extends CaseLabel (

    items: Array[CaseItem]

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openItemCaseLabel(this) = false) {
            return }

        if (items <> ()) {
            for (node: CaseItem in items) {
                node.accept(visitor) } }

        visitor.closeItemCaseLabel(this)
    }
}

class CaseItem extends SyntaxNode (

    pattern: CasePattern, 

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openCaseItem(this) = false) {
            return }
        pattern.accept(visitor)

        visitor.closeCaseItem(this)
    }
}

class CasePattern extends SyntaxNode {
    function accept(visitor: Visitor) {
    }
}

class ConstantPattern extends CasePattern (

    constant: Constant

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openConstantPattern(this) = false) {
            return }
        constant.accept(visitor)

        visitor.closeConstantPattern(this)
    }
}

class WildcardPattern extends CasePattern (


    ) {
    function accept(visitor: Visitor) {

        visitor.visitWildcardPattern(this)
    }
}

class NamePattern extends CasePattern (

    name: Name

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openNamePattern(this) = false) {
            return }
        name.accept(visitor)

        visitor.closeNamePattern(this)
    }
}

class DefaultCaseLabel extends CaseLabel (


    ) {
    function accept(visitor: Visitor) {

        visitor.visitDefaultCaseLabel(this)
    }
}

class For extends Expression (

    index: string, 
    type_annotation: TypeAnnotation, 
    operation: Operation, 
    iteration: Loop

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openFor(this) = false) {
            return }

        if (type_annotation <> ()) {
            type_annotation.accept(visitor) }
        operation.accept(visitor)
        iteration.accept(visitor)

        visitor.closeFor(this)
    }
}

class While extends Expression (

    condition: Operation, 
    iteration: Loop

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openWhile(this) = false) {
            return }
        condition.accept(visitor)
        iteration.accept(visitor)

        visitor.closeWhile(this)
    }
}

class Do extends Expression (

    iteration: Loop, 
    condition: Operation, 

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openDo(this) = false) {
            return }
        iteration.accept(visitor)
        condition.accept(visitor)

        visitor.closeDo(this)
    }
}

class Loop extends SyntaxNode {
    function accept(visitor: Visitor) {
    }
}

class SimpleLoop extends Loop (

    code: Block

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openSimpleLoop(this) = false) {
            return }
        code.accept(visitor)

        visitor.closeSimpleLoop(this)
    }
}

class NamedLoop extends Loop (

    name: string, 
    code: Block

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openNamedLoop(this) = false) {
            return }
        code.accept(visitor)

        visitor.closeNamedLoop(this)
    }
}

class This extends Expression (


    ) {
    function accept(visitor: Visitor) {

        visitor.visitThis(this)
    }
}

class New extends Expression (

    type_spec: Type

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openNew(this) = false) {
            return }
        type_spec.accept(visitor)

        visitor.closeNew(this)
    }
}

class Object extends Expression (

    first_op: Operation, 
    additional_ops: Array[Item], 

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openObject(this) = false) {
            return }

        if (first_op <> ()) {
            first_op.accept(visitor) }

        if (additional_ops <> ()) {
            for (node: Item in additional_ops) {
                node.accept(visitor) } }

        visitor.closeObject(this)
    }
}

class Array extends Expression (

    first_op: Operation, 
    additional_ops: Array[Item], 

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openArray(this) = false) {
            return }

        if (first_op <> ()) {
            first_op.accept(visitor) }

        if (additional_ops <> ()) {
            for (node: Item in additional_ops) {
                node.accept(visitor) } }

        visitor.closeArray(this)
    }
}

class Item extends SyntaxNode (

    operation: Operation

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openItem(this) = false) {
            return }
        operation.accept(visitor)

        visitor.closeItem(this)
    }
}

class SizeOf extends Expression (

    type_spec: Type

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openSizeOf(this) = false) {
            return }
        type_spec.accept(visitor)

        visitor.closeSizeOf(this)
    }
}

class Break extends Statement (

    iteration: string, 

    ) {
    function accept(visitor: Visitor) {

        visitor.visitBreak(this)
    }
}

class Continue extends Statement (

    iteration: string, 

    ) {
    function accept(visitor: Visitor) {

        visitor.visitContinue(this)
    }
}

class Return extends Statement (

    result: Calculation

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openReturn(this) = false) {
            return }

        if (result <> ()) {
            result.accept(visitor) }

        visitor.closeReturn(this)
    }
}

class Throw extends Statement (

    exception: Calculation

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openThrow(this) = false) {
            return }
        exception.accept(visitor)

        visitor.closeThrow(this)
    }
}

class Class extends Declaration (

    name: Name, 
    generics: GenericParameters, 
    base_class: Extends, 
    contents: Structure, 
    body: ClassBody

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openClass(this) = false) {
            return }
        name.accept(visitor)

        if (generics <> ()) {
            generics.accept(visitor) }

        if (base_class <> ()) {
            base_class.accept(visitor) }

        if (contents <> ()) {
            contents.accept(visitor) }

        if (body <> ()) {
            body.accept(visitor) }

        visitor.closeClass(this)
    }
}

class GenericParameters extends SyntaxNode (

    name: string, 
    additional_generics: Array[GenericParameter], 

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openGenericParameters(this) = false) {
            return }

        if (additional_generics <> ()) {
            for (node: GenericParameter in additional_generics) {
                node.accept(visitor) } }

        visitor.closeGenericParameters(this)
    }
}

class GenericParameter extends SyntaxNode (

    name: string

    ) {
    function accept(visitor: Visitor) {

        visitor.visitGenericParameter(this)
    }
}

class Extends extends SyntaxNode (

    name: Name

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openExtends(this) = false) {
            return }
        name.accept(visitor)

        visitor.closeExtends(this)
    }
}

class Structure extends SyntaxNode (

    components: Array[Component], 

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openStructure(this) = false) {
            return }

        if (components <> ()) {
            for (node: Component in components) {
                node.accept(visitor) } }

        visitor.closeStructure(this)
    }
}

class Component extends SyntaxNode (

    name: string, 
    type_annotation: TypeAnnotation, 

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openComponent(this) = false) {
            return }

        if (type_annotation <> ()) {
            type_annotation.accept(visitor) }

        visitor.closeComponent(this)
    }
}

class ClassBody extends SyntaxNode (

    members: Array[ClassMember], 

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openClassBody(this) = false) {
            return }

        if (members <> ()) {
            for (node: ClassMember in members) {
                node.accept(visitor) } }

        visitor.closeClassBody(this)
    }
}

class ClassMember extends SyntaxNode {
    function accept(visitor: Visitor) {
    }
}

class LetMember extends ClassMember (

    declaration: Let

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openLetMember(this) = false) {
            return }
        declaration.accept(visitor)

        visitor.closeLetMember(this)
    }
}

class VarMember extends ClassMember (

    declaration: Var

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openVarMember(this) = false) {
            return }
        declaration.accept(visitor)

        visitor.closeVarMember(this)
    }
}

class MutableMember extends ClassMember (

    declaration: Mutable

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openMutableMember(this) = false) {
            return }
        declaration.accept(visitor)

        visitor.closeMutableMember(this)
    }
}

class SetInitialization extends ClassMember (

    definition: Set

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openSetInitialization(this) = false) {
            return }
        definition.accept(visitor)

        visitor.closeSetInitialization(this)
    }
}

class Method extends ClassMember (

    procedure: Procedure

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openMethod(this) = false) {
            return }
        procedure.accept(visitor)

        visitor.closeMethod(this)
    }
}

class StaticFunction extends ClassMember (

    procedure: Function

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openStaticFunction(this) = false) {
            return }
        procedure.accept(visitor)

        visitor.closeStaticFunction(this)
    }
}

class Operator extends ClassMember (

    routine: Routine

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openOperator(this) = false) {
            return }
        routine.accept(visitor)

        visitor.closeOperator(this)
    }
}

class Initializer extends ClassMember (

    input: Structure, 
    body: Block

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openInitializer(this) = false) {
            return }

        if (input <> ()) {
            input.accept(visitor) }
        body.accept(visitor)

        visitor.closeInitializer(this)
    }
}

class Allocator extends ClassMember (

    input: Structure, 
    body: Block

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openAllocator(this) = false) {
            return }

        if (input <> ()) {
            input.accept(visitor) }
        body.accept(visitor)

        visitor.closeAllocator(this)
    }
}

class TypeAnnotation extends SyntaxNode (

    type_spec: TypeSpec

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openTypeAnnotation(this) = false) {
            return }
        type_spec.accept(visitor)

        visitor.closeTypeAnnotation(this)
    }
}

class TypeSpec extends SyntaxNode {
    function accept(visitor: Visitor) {
    }
}

class Type extends TypeSpec (

    name: Name, 
    generics: GenericArguments, 
    optional: Optional, 
    life_time: LifeTime

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openType(this) = false) {
            return }
        name.accept(visitor)

        if (generics <> ()) {
            generics.accept(visitor) }

        if (optional <> ()) {
            optional.accept(visitor) }

        if (life_time <> ()) {
            life_time.accept(visitor) }

        visitor.closeType(this)
    }
}

class Variant extends TypeSpec (

    types: Array[Type], 

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openVariant(this) = false) {
            return }

        if (types <> ()) {
            for (node: Type in types) {
                node.accept(visitor) } }

        visitor.closeVariant(this)
    }
}

class Throws extends SyntaxNode (

    throws_type: TypeSpec

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openThrows(this) = false) {
            return }
        throws_type.accept(visitor)

        visitor.closeThrows(this)
    }
}

class GenericArguments extends SyntaxNode (

    generic: Type, 
    additional_generics: Array[GenericArgument], 

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openGenericArguments(this) = false) {
            return }
        generic.accept(visitor)

        if (additional_generics <> ()) {
            for (node: GenericArgument in additional_generics) {
                node.accept(visitor) } }

        visitor.closeGenericArguments(this)
    }
}

class GenericArgument extends SyntaxNode (

    type_spec: Type

    ) {
    function accept(visitor: Visitor) {

        if (visitor.openGenericArgument(this) = false) {
            return }
        type_spec.accept(visitor)

        visitor.closeGenericArgument(this)
    }
}

class Optional extends SyntaxNode (


    ) {
    function accept(visitor: Visitor) {

        visitor.visitOptional(this)
    }
}

class LifeTime extends SyntaxNode {
    function accept(visitor: Visitor) {
    }
}

class Root extends LifeTime (


    ) {
    function accept(visitor: Visitor) {

        visitor.visitRoot(this)
    }
}

class Local extends LifeTime (

    location: string

    ) {
    function accept(visitor: Visitor) {

        visitor.visitLocal(this)
    }
}

class Reference extends LifeTime (

    age: Literal

    ) {
    function accept(visitor: Visitor) {

        visitor.visitReference(this)
    }
}

class Thrown extends LifeTime (


    ) {
    function accept(visitor: Visitor) {

        visitor.visitThrown(this)
    }
}

} // namespace scalyc
