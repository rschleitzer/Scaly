// ExpressionTests.cpp - Generated from tests/Expression.sgm
// DO NOT EDIT - generated by codegen

#include "ExpressionTests.h"
#include "Parser.h"
#include "Modeler.h"
#include "Planner.h"
#include "Emitter.h"
#include "llvm/Support/raw_ostream.h"
#include <iostream>
#include <cmath>
#include <cstring>

namespace scaly {

namespace {

static int TestsPassed = 0;
static int TestsFailed = 0;

static void pass(const char* Name) {
    ++TestsPassed;
    llvm::outs() << "    PASS: " << Name << "\n";
    llvm::outs().flush();
}

static void fail(const char* Name, const char* Message) {
    ++TestsFailed;
    llvm::outs() << "    FAIL: " << Name << " - " << Message << "\n";
    llvm::outs().flush();
}

// Helper to compile source to Plan
static llvm::Expected<Plan> compileToPlan(llvm::StringRef Source) {
    Parser P(Source);
    auto ParseResult = P.parseProgram();
    if (!ParseResult)
        return ParseResult.takeError();

    Modeler M("<test>");
    auto ModelResult = M.buildProgram(*ParseResult);
    if (!ModelResult)
        return ModelResult.takeError();

    Planner Pl("<test>");
    return Pl.plan(*ModelResult);
}

// Helper to evaluate int expression
static llvm::Expected<int64_t> evalInt(llvm::StringRef Source) {
    auto PlanResult = compileToPlan(Source);
    if (!PlanResult)
        return PlanResult.takeError();

    EmitterConfig Config;
    Config.EmitDebugInfo = false;
    Emitter E(Config);
    return E.jitExecuteInt(*PlanResult);
}

// Helper to evaluate bool expression
static llvm::Expected<bool> evalBool(llvm::StringRef Source) {
    auto PlanResult = compileToPlan(Source);
    if (!PlanResult)
        return PlanResult.takeError();

    EmitterConfig Config;
    Config.EmitDebugInfo = false;
    Emitter E(Config);
    return E.jitExecuteBool(*PlanResult);
}

// Helper to evaluate float expression
static llvm::Expected<double> evalFloat(llvm::StringRef Source) {
    auto PlanResult = compileToPlan(Source);
    if (!PlanResult)
        return PlanResult.takeError();

    EmitterConfig Config;
    Config.EmitDebugInfo = false;
    Emitter E(Config);
    return E.jitExecuteFloat(*PlanResult);
}

// Helper to evaluate string expression
static llvm::Expected<const char*> evalString(llvm::StringRef Source) {
    auto PlanResult = compileToPlan(Source);
    if (!PlanResult)
        return PlanResult.takeError();

    EmitterConfig Config;
    Config.EmitDebugInfo = false;
    Emitter E(Config);
    return E.jitExecuteString(*PlanResult);
}

} // anonymous namespace

// Category: Literals

// Boolean Literals
static void test_BOOL_TRUE() {
    const char* Name = "BOOL-TRUE";
    auto Result = evalBool("true");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != true) {
        std::string Msg = "expected true, got " + std::string(*Result ? "true" : "false");
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}

static void test_BOOL_FALSE() {
    const char* Name = "BOOL-FALSE";
    auto Result = evalBool("false");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != false) {
        std::string Msg = "expected false, got " + std::string(*Result ? "true" : "false");
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}


// Integer Literals
static void test_INT_POSITIVE() {
    const char* Name = "INT-POSITIVE";
    auto Result = evalInt("42");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != 42) {
        std::string Msg = "expected 42, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}

static void test_INT_ZERO() {
    const char* Name = "INT-ZERO";
    auto Result = evalInt("0");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != 0) {
        std::string Msg = "expected 0, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}

static void test_INT_NEGATIVE() {
    const char* Name = "INT-NEGATIVE";
    auto Result = evalInt("-7");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != -7) {
        std::string Msg = "expected -7, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}


// Hexadecimal Literals
static void test_HEX_FF() {
    const char* Name = "HEX-FF";
    auto Result = evalInt("0xFF");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != 255) {
        std::string Msg = "expected 255, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}

static void test_HEX_1A() {
    const char* Name = "HEX-1A";
    auto Result = evalInt("0x1A");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != 26) {
        std::string Msg = "expected 26, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}

static void test_HEX_ZERO() {
    const char* Name = "HEX-ZERO";
    auto Result = evalInt("0x0");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != 0) {
        std::string Msg = "expected 0, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}


// Floating-Point Literals
static void test_FLOAT_PI() {
    const char* Name = "FLOAT-PI";
    auto Result = evalFloat("3.14");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (std::fabs(*Result - 3.14) > 0.0001) {
        std::string Msg = "expected 3.14, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}

static void test_FLOAT_TWO() {
    const char* Name = "FLOAT-TWO";
    auto Result = evalFloat("2.0");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (std::fabs(*Result - 2.0) > 0.0001) {
        std::string Msg = "expected 2.0, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}

static void test_FLOAT_HALF() {
    const char* Name = "FLOAT-HALF";
    auto Result = evalFloat("0.5");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (std::fabs(*Result - 0.5) > 0.0001) {
        std::string Msg = "expected 0.5, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}


// String Literals
static void test_STRING_HELLO() {
    const char* Name = "STRING-HELLO";
    auto Result = evalString("\"hello\"");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (std::strcmp(*Result, "hello") != 0) {
        std::string Msg = "expected 'hello', got '" + std::string(*Result) + "'";
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}

static void test_STRING_EMPTY() {
    const char* Name = "STRING-EMPTY";
    auto Result = evalString("\"\"");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (std::strcmp(*Result, "") != 0) {
        std::string Msg = "expected '', got '" + std::string(*Result) + "'";
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}


// Character Literals
static void test_CHAR_A() {
    const char* Name = "CHAR-A";
    auto Result = compileToPlan("`a`");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    // TODO: Add char JIT evaluation when implemented
    pass(Name);
}

static void test_CHAR_Z() {
    const char* Name = "CHAR-Z";
    auto Result = compileToPlan("`Z`");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    // TODO: Add char JIT evaluation when implemented
    pass(Name);
}

// Category: Operations

// Prefix Functions
static void test_NEGATE_POSITIVE() {
    const char* Name = "NEGATE-POSITIVE";
    auto Result = evalInt("-7");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != -7) {
        std::string Msg = "expected -7, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}

static void test_NEGATE_NEGATIVE() {
    const char* Name = "NEGATE-NEGATIVE";
    auto Result = evalInt("-(-3)");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != 3) {
        std::string Msg = "expected 3, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}

static void test_PREFIX_ADD() {
    const char* Name = "PREFIX-ADD";
    auto Result = evalInt("+ 3");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != 3) {
        std::string Msg = "expected 3, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}


// Operator Chains
static void test_SIMPLE_ADD() {
    const char* Name = "SIMPLE-ADD";
    auto Result = evalInt("3 + 4");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != 7) {
        std::string Msg = "expected 7, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}

static void test_SIMPLE_SUBTRACT() {
    const char* Name = "SIMPLE-SUBTRACT";
    auto Result = evalInt("10 - 3");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != 7) {
        std::string Msg = "expected 7, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}

static void test_SIMPLE_MULTIPLY() {
    const char* Name = "SIMPLE-MULTIPLY";
    auto Result = evalInt("6 * 7");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != 42) {
        std::string Msg = "expected 42, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}

static void test_CHAIN_WITH_PRECEDENCE() {
    const char* Name = "CHAIN-WITH-PRECEDENCE";
    auto Result = evalInt("3 + 4 * 2");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != 11) {
        std::string Msg = "expected 11, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}

static void test_CHAIN_LEFT_TO_RIGHT() {
    const char* Name = "CHAIN-LEFT-TO-RIGHT";
    auto Result = evalInt("20 - 5 - 3");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != 12) {
        std::string Msg = "expected 12, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}


// Parentheses and Grouping
static void test_PARENS_NEGATE() {
    const char* Name = "PARENS-NEGATE";
    auto Result = evalInt("5 * (- 2)");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != -10) {
        std::string Msg = "expected -10, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}

static void test_PARENS_GROUPING() {
    const char* Name = "PARENS-GROUPING";
    auto Result = evalInt("2 * (3 + 4)");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != 14) {
        std::string Msg = "expected 14, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}

static void test_NESTED_PARENS() {
    const char* Name = "NESTED-PARENS";
    auto Result = evalInt("(2 + 3) * (4 + 1)");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != 25) {
        std::string Msg = "expected 25, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}


// Identifier Shapes
static void test_NAME_AS_OPERATOR() {
    const char* Name = "NAME-AS-OPERATOR";
    auto Result = evalInt("10 div 3");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != 3) {
        std::string Msg = "expected 3, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}

static void test_NAME_AS_FUNCTION() {
    const char* Name = "NAME-AS-FUNCTION";
    auto Result = evalInt("abs (- 5)");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != 5) {
        std::string Msg = "expected 5, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}


// Let Bindings
static void test_LET_SIMPLE() {
    const char* Name = "LET-SIMPLE";
    auto Result = evalInt("let x 5\nx");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != 5) {
        std::string Msg = "expected 5, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}

static void test_LET_USE_BINDING() {
    const char* Name = "LET-USE-BINDING";
    auto Result = evalInt("let x 5\nx + 3");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != 8) {
        std::string Msg = "expected 8, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}

static void test_LET_NESTED() {
    const char* Name = "LET-NESTED";
    auto Result = evalInt("let x 5\nlet y 3\nx + y");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != 8) {
        std::string Msg = "expected 8, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}

static void test_LET_EXPR_VALUE() {
    const char* Name = "LET-EXPR-VALUE";
    auto Result = evalInt("let x 2 + 3\nx * 2");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != 10) {
        std::string Msg = "expected 10, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}


bool runExpressionTests() {
    TestsPassed = 0;
    TestsFailed = 0;

    std::cout << "Running Expression tests..." << std::endl;

    std::cout << "  Literals" << std::endl;
    std::cout << "    Boolean Literals" << std::endl;
    test_BOOL_TRUE();
    test_BOOL_FALSE();
    std::cout << "    Integer Literals" << std::endl;
    test_INT_POSITIVE();
    test_INT_ZERO();
    test_INT_NEGATIVE();
    std::cout << "    Hexadecimal Literals" << std::endl;
    test_HEX_FF();
    test_HEX_1A();
    test_HEX_ZERO();
    std::cout << "    Floating-Point Literals" << std::endl;
    test_FLOAT_PI();
    test_FLOAT_TWO();
    test_FLOAT_HALF();
    std::cout << "    String Literals" << std::endl;
    test_STRING_HELLO();
    test_STRING_EMPTY();
    std::cout << "    Character Literals" << std::endl;
    test_CHAR_A();
    test_CHAR_Z();

    std::cout << "  Operations" << std::endl;
    std::cout << "    Prefix Functions" << std::endl;
    test_NEGATE_POSITIVE();
    test_NEGATE_NEGATIVE();
    test_PREFIX_ADD();
    std::cout << "    Operator Chains" << std::endl;
    test_SIMPLE_ADD();
    test_SIMPLE_SUBTRACT();
    test_SIMPLE_MULTIPLY();
    test_CHAIN_WITH_PRECEDENCE();
    test_CHAIN_LEFT_TO_RIGHT();
    std::cout << "    Parentheses and Grouping" << std::endl;
    test_PARENS_NEGATE();
    test_PARENS_GROUPING();
    test_NESTED_PARENS();
    std::cout << "    Identifier Shapes" << std::endl;
    test_NAME_AS_OPERATOR();
    test_NAME_AS_FUNCTION();
    std::cout << "    Let Bindings" << std::endl;
    test_LET_SIMPLE();
    test_LET_USE_BINDING();
    test_LET_NESTED();
    test_LET_EXPR_VALUE();

    std::cout << std::endl;
    std::cout << "Expression tests: " << TestsPassed << " passed, "
              << TestsFailed << " failed" << std::endl;

    return TestsFailed == 0;
}

} // namespace scaly
