// DefinitionTests.cpp - Generated from tests/Definition.sgm
// DO NOT EDIT - generated by codegen

#include "DefinitionTests.h"
#include "Parser.h"
#include "Modeler.h"
#include "Planner.h"
#include "Emitter.h"
#include "llvm/Support/raw_ostream.h"
#include <iostream>
#include <cmath>

namespace scaly {

namespace {

static int TestsPassed = 0;
static int TestsFailed = 0;

static void pass(const char* Name) {
    ++TestsPassed;
    llvm::outs() << "    PASS: " << Name << "\n";
    llvm::outs().flush();
}

static void fail(const char* Name, const char* Message) {
    ++TestsFailed;
    llvm::outs() << "    FAIL: " << Name << " - " << Message << "\n";
    llvm::outs().flush();
}

// Helper to compile source to Plan
static llvm::Expected<Plan> compileToPlan(llvm::StringRef Source) {
    Parser P(Source);
    auto ParseResult = P.parseProgram();
    if (!ParseResult)
        return ParseResult.takeError();

    Modeler M("<test>");
    auto ModelResult = M.buildProgram(*ParseResult);
    if (!ModelResult)
        return ModelResult.takeError();

    Planner Pl("<test>");
    return Pl.plan(*ModelResult);
}

// Helper to evaluate int expression
static llvm::Expected<int64_t> evalInt(llvm::StringRef Source) {
    auto PlanResult = compileToPlan(Source);
    if (!PlanResult)
        return PlanResult.takeError();

    EmitterConfig Config;
    Config.EmitDebugInfo = false;
    Emitter E(Config);
    return E.jitExecuteInt(*PlanResult);
}

// Helper to evaluate bool expression
static llvm::Expected<bool> evalBool(llvm::StringRef Source) {
    auto PlanResult = compileToPlan(Source);
    if (!PlanResult)
        return PlanResult.takeError();

    EmitterConfig Config;
    Config.EmitDebugInfo = false;
    Emitter E(Config);
    return E.jitExecuteBool(*PlanResult);
}

// Helper to evaluate float expression
static llvm::Expected<double> evalFloat(llvm::StringRef Source) {
    auto PlanResult = compileToPlan(Source);
    if (!PlanResult)
        return PlanResult.takeError();

    EmitterConfig Config;
    Config.EmitDebugInfo = false;
    Emitter E(Config);
    return E.jitExecuteFloat(*PlanResult);
}

} // anonymous namespace

// Category: Definitions

// Structure Definitions
static void test_DEFINE_POINT() {
    const char* Name = "DEFINE-POINT";
    auto Result = compileToPlan("define Point(x: int, y: int)\nPoint(3, 4)");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    pass(Name);
}

static void test_DEFINE_FIELD_ACCESS() {
    const char* Name = "DEFINE-FIELD-ACCESS";
    auto Result = evalInt("define Point(x: int, y: int)\nPoint(3, 4).x");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != 3) {
        std::string Msg = "expected 3, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}

static void test_DEFINE_WITH_LET() {
    const char* Name = "DEFINE-WITH-LET";
    auto Result = evalInt("define Point(x: int, y: int)\nlet p Point(3, 4)\np.x + p.y");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != 7) {
        std::string Msg = "expected 7, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}

static void test_DEFINE_NESTED() {
    const char* Name = "DEFINE-NESTED";
    auto Result = evalInt("define Point(x: int, y: int)\ndefine Rectangle(origin: Point, width: int, height: int)\nRectangle(Point(0, 0), 10, 5).width");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != 10) {
        std::string Msg = "expected 10, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}


// Union Definitions
static void test_OPTION_SOME() {
    const char* Name = "OPTION-SOME";
    auto Result = compileToPlan("define Option union(Some: int, None)\nSome(5)");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    pass(Name);
}

static void test_OPTION_NONE() {
    const char* Name = "OPTION-NONE";
    auto Result = compileToPlan("define Option union(Some: int, None)\nNone");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    pass(Name);
}

static void test_RESULT_OK() {
    const char* Name = "RESULT-OK";
    auto Result = compileToPlan("define Result union(Ok: int, Err: String)\nOk(42)");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    pass(Name);
}

static void test_RESULT_ERR() {
    const char* Name = "RESULT-ERR";
    auto Result = compileToPlan("define Result union(Ok: int, Err: String)\nErr(\"error\")");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    pass(Name);
}

static void test_OPTION_SOME_VALUE() {
    const char* Name = "OPTION-SOME-VALUE";
    auto Result = evalInt("define Option union(Some: int, None)\nOption.Some(5).value");
    if (!Result) {
        std::string ErrMsg;
        llvm::raw_string_ostream OS(ErrMsg);
        OS << Result.takeError();
        fail(Name, ErrMsg.c_str());
        return;
    }
    if (*Result != 5) {
        std::string Msg = "expected 5, got " + std::to_string(*Result);
        fail(Name, Msg.c_str());
        return;
    }
    pass(Name);
}


bool runDefinitionTests() {
    TestsPassed = 0;
    TestsFailed = 0;

    std::cout << "Running Definition tests..." << std::endl;

    std::cout << "  Definitions" << std::endl;
    std::cout << "    Structure Definitions" << std::endl;
    test_DEFINE_POINT();
    test_DEFINE_FIELD_ACCESS();
    test_DEFINE_WITH_LET();
    test_DEFINE_NESTED();
    std::cout << "    Union Definitions" << std::endl;
    test_OPTION_SOME();
    test_OPTION_NONE();
    test_RESULT_OK();
    test_RESULT_ERR();
    test_OPTION_SOME_VALUE();

    std::cout << std::endl;
    std::cout << "Definition tests: " << TestsPassed << " passed, "
              << TestsFailed << " failed" << std::endl;

    return TestsFailed == 0;
}

} // namespace scaly
