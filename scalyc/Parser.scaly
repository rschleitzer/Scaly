class Program
class CompilationUnit
class Statement
class Declaration
class Expression
class ConstantDeclaration
class VariableDeclaration
class MutableDeclaration
class FunctionDeclaration
class EnumDeclaration
class ClassDeclaration
class ConstructorDeclaration
class CodeBlock
class SimpleExpression
class Initializer
class BindingInitializer
class PatternInitializer
class AdditionalInitializer
class Modifier
class OverrideWord
class StaticWord
class FunctionSignature
class FunctionResult
class ParameterClause
class Parameter
class ConstParameter
class VarParameter
class ThrowsClause
class EnumMember
class EnumCase
class AdditionalCase
class ClassBody
class ClassMember
class PrefixExpression
class PostfixExpression
class BinaryOp
class BinaryOperation
class Assignment
class TypeQuery
class TypeCast
class CatchClause
class CatchPattern
class WildCardCatchPattern
class IdentifierCatchPattern
class Postfix
class OperatorPostfix
class FunctionCall
class MemberExpression
class Subscript
class ExpressionElement
class PrimaryExpression
class IdentifierExpression
class LiteralExpression
class IfExpression
class SwitchExpression
class ForExpression
class WhileExpression
class DoExpression
class ParenthesizedExpression
class ReturnExpression
class ThrowExpression
class BreakExpression
class ConstructorCall
class ThisExpression
class NullExpression
class ElseClause
class SwitchBody
class CurliedSwitchBody
class NakedSwitchBody
class SwitchCase
class CaseLabel
class ItemCaseLabel
class DefaultCaseLabel
class CaseItem
class Pattern
class WildcardPattern
class IdentifierPattern
class TuplePattern
class ExpressionPattern
class TuplePatternElement
class CaseContent
class Type
class TypeAnnotation
class Subtype
class TypePostfix
class IndexedType
class Pointer
class LifeTime
class Root
class Local
class Reference
class Thrown
class TypeInheritanceClause
class Inheritance

class Visitor {
    function openProgram(program: Program): bool {
        true
    }

    function closeProgram(program: Program) {
    }

    function openCompilationUnit(compilationUnit: CompilationUnit): bool {
        true
    }

    function closeCompilationUnit(compilationUnit: CompilationUnit) {
    }

    function openConstantDeclaration(constantDeclaration: ConstantDeclaration): bool {
        true
    }

    function closeConstantDeclaration(constantDeclaration: ConstantDeclaration) {
    }

    function openVariableDeclaration(variableDeclaration: VariableDeclaration): bool {
        true
    }

    function closeVariableDeclaration(variableDeclaration: VariableDeclaration) {
    }

    function openMutableDeclaration(mutableDeclaration: MutableDeclaration): bool {
        true
    }

    function closeMutableDeclaration(mutableDeclaration: MutableDeclaration) {
    }

    function openFunctionDeclaration(functionDeclaration: FunctionDeclaration): bool {
        true
    }

    function closeFunctionDeclaration(functionDeclaration: FunctionDeclaration) {
    }

    function openEnumDeclaration(enumDeclaration: EnumDeclaration): bool {
        true
    }

    function closeEnumDeclaration(enumDeclaration: EnumDeclaration) {
    }

    function openClassDeclaration(classDeclaration: ClassDeclaration): bool {
        true
    }

    function closeClassDeclaration(classDeclaration: ClassDeclaration) {
    }

    function openConstructorDeclaration(constructorDeclaration: ConstructorDeclaration): bool {
        true
    }

    function closeConstructorDeclaration(constructorDeclaration: ConstructorDeclaration) {
    }

    function openCodeBlock(codeBlock: CodeBlock): bool {
        true
    }

    function closeCodeBlock(codeBlock: CodeBlock) {
    }

    function openSimpleExpression(simpleExpression: SimpleExpression): bool {
        true
    }

    function closeSimpleExpression(simpleExpression: SimpleExpression) {
    }

    function openInitializer(initializer: Initializer): bool {
        true
    }

    function closeInitializer(initializer: Initializer) {
    }

    function openBindingInitializer(bindingInitializer: BindingInitializer): bool {
        true
    }

    function closeBindingInitializer(bindingInitializer: BindingInitializer) {
    }

    function openPatternInitializer(patternInitializer: PatternInitializer): bool {
        true
    }

    function closePatternInitializer(patternInitializer: PatternInitializer) {
    }

    function openAdditionalInitializer(additionalInitializer: AdditionalInitializer): bool {
        true
    }

    function closeAdditionalInitializer(additionalInitializer: AdditionalInitializer) {
    }

    function visitOverrideWord(overrideWord: OverrideWord) {
    }

    function visitStaticWord(staticWord: StaticWord) {
    }

    function openFunctionSignature(functionSignature: FunctionSignature): bool {
        true
    }

    function closeFunctionSignature(functionSignature: FunctionSignature) {
    }

    function openFunctionResult(functionResult: FunctionResult): bool {
        true
    }

    function closeFunctionResult(functionResult: FunctionResult) {
    }

    function openParameterClause(parameterClause: ParameterClause): bool {
        true
    }

    function closeParameterClause(parameterClause: ParameterClause) {
    }

    function openConstParameter(constParameter: ConstParameter): bool {
        true
    }

    function closeConstParameter(constParameter: ConstParameter) {
    }

    function openVarParameter(varParameter: VarParameter): bool {
        true
    }

    function closeVarParameter(varParameter: VarParameter) {
    }

    function openThrowsClause(throwsClause: ThrowsClause): bool {
        true
    }

    function closeThrowsClause(throwsClause: ThrowsClause) {
    }

    function openEnumMember(enumMember: EnumMember): bool {
        true
    }

    function closeEnumMember(enumMember: EnumMember) {
    }

    function visitEnumCase(enumCase: EnumCase) {
    }

    function openAdditionalCase(additionalCase: AdditionalCase): bool {
        true
    }

    function closeAdditionalCase(additionalCase: AdditionalCase) {
    }

    function openClassBody(classBody: ClassBody): bool {
        true
    }

    function closeClassBody(classBody: ClassBody) {
    }

    function openClassMember(classMember: ClassMember): bool {
        true
    }

    function closeClassMember(classMember: ClassMember) {
    }

    function openPrefixExpression(prefixExpression: PrefixExpression): bool {
        true
    }

    function closePrefixExpression(prefixExpression: PrefixExpression) {
    }

    function openPostfixExpression(postfixExpression: PostfixExpression): bool {
        true
    }

    function closePostfixExpression(postfixExpression: PostfixExpression) {
    }

    function openBinaryOperation(binaryOperation: BinaryOperation): bool {
        true
    }

    function closeBinaryOperation(binaryOperation: BinaryOperation) {
    }

    function openAssignment(assignment: Assignment): bool {
        true
    }

    function closeAssignment(assignment: Assignment) {
    }

    function openTypeQuery(typeQuery: TypeQuery): bool {
        true
    }

    function closeTypeQuery(typeQuery: TypeQuery) {
    }

    function openTypeCast(typeCast: TypeCast): bool {
        true
    }

    function closeTypeCast(typeCast: TypeCast) {
    }

    function openCatchClause(catchClause: CatchClause): bool {
        true
    }

    function closeCatchClause(catchClause: CatchClause) {
    }

    function openWildCardCatchPattern(wildCardCatchPattern: WildCardCatchPattern): bool {
        true
    }

    function closeWildCardCatchPattern(wildCardCatchPattern: WildCardCatchPattern) {
    }

    function openIdentifierCatchPattern(identifierCatchPattern: IdentifierCatchPattern): bool {
        true
    }

    function closeIdentifierCatchPattern(identifierCatchPattern: IdentifierCatchPattern) {
    }

    function visitOperatorPostfix(operatorPostfix: OperatorPostfix) {
    }

    function openFunctionCall(functionCall: FunctionCall): bool {
        true
    }

    function closeFunctionCall(functionCall: FunctionCall) {
    }

    function visitMemberExpression(memberExpression: MemberExpression) {
    }

    function openSubscript(subscript: Subscript): bool {
        true
    }

    function closeSubscript(subscript: Subscript) {
    }

    function openExpressionElement(expressionElement: ExpressionElement): bool {
        true
    }

    function closeExpressionElement(expressionElement: ExpressionElement) {
    }

    function visitIdentifierExpression(identifierExpression: IdentifierExpression) {
    }

    function visitLiteralExpression(literalExpression: LiteralExpression) {
    }

    function openIfExpression(ifExpression: IfExpression): bool {
        true
    }

    function closeIfExpression(ifExpression: IfExpression) {
    }

    function openSwitchExpression(switchExpression: SwitchExpression): bool {
        true
    }

    function closeSwitchExpression(switchExpression: SwitchExpression) {
    }

    function openForExpression(forExpression: ForExpression): bool {
        true
    }

    function closeForExpression(forExpression: ForExpression) {
    }

    function openWhileExpression(whileExpression: WhileExpression): bool {
        true
    }

    function closeWhileExpression(whileExpression: WhileExpression) {
    }

    function openDoExpression(doExpression: DoExpression): bool {
        true
    }

    function closeDoExpression(doExpression: DoExpression) {
    }

    function openParenthesizedExpression(parenthesizedExpression: ParenthesizedExpression): bool {
        true
    }

    function closeParenthesizedExpression(parenthesizedExpression: ParenthesizedExpression) {
    }

    function openReturnExpression(returnExpression: ReturnExpression): bool {
        true
    }

    function closeReturnExpression(returnExpression: ReturnExpression) {
    }

    function openThrowExpression(throwExpression: ThrowExpression): bool {
        true
    }

    function closeThrowExpression(throwExpression: ThrowExpression) {
    }

    function openBreakExpression(breakExpression: BreakExpression): bool {
        true
    }

    function closeBreakExpression(breakExpression: BreakExpression) {
    }

    function openConstructorCall(constructorCall: ConstructorCall): bool {
        true
    }

    function closeConstructorCall(constructorCall: ConstructorCall) {
    }

    function visitThisExpression(thisExpression: ThisExpression) {
    }

    function visitNullExpression(nullExpression: NullExpression) {
    }

    function openElseClause(elseClause: ElseClause): bool {
        true
    }

    function closeElseClause(elseClause: ElseClause) {
    }

    function openCurliedSwitchBody(curliedSwitchBody: CurliedSwitchBody): bool {
        true
    }

    function closeCurliedSwitchBody(curliedSwitchBody: CurliedSwitchBody) {
    }

    function openNakedSwitchBody(nakedSwitchBody: NakedSwitchBody): bool {
        true
    }

    function closeNakedSwitchBody(nakedSwitchBody: NakedSwitchBody) {
    }

    function openSwitchCase(switchCase: SwitchCase): bool {
        true
    }

    function closeSwitchCase(switchCase: SwitchCase) {
    }

    function openItemCaseLabel(itemCaseLabel: ItemCaseLabel): bool {
        true
    }

    function closeItemCaseLabel(itemCaseLabel: ItemCaseLabel) {
    }

    function visitDefaultCaseLabel(defaultCaseLabel: DefaultCaseLabel) {
    }

    function openCaseItem(caseItem: CaseItem): bool {
        true
    }

    function closeCaseItem(caseItem: CaseItem) {
    }

    function visitWildcardPattern(wildcardPattern: WildcardPattern) {
    }

    function openIdentifierPattern(identifierPattern: IdentifierPattern): bool {
        true
    }

    function closeIdentifierPattern(identifierPattern: IdentifierPattern) {
    }

    function openTuplePattern(tuplePattern: TuplePattern): bool {
        true
    }

    function closeTuplePattern(tuplePattern: TuplePattern) {
    }

    function openExpressionPattern(expressionPattern: ExpressionPattern): bool {
        true
    }

    function closeExpressionPattern(expressionPattern: ExpressionPattern) {
    }

    function openTuplePatternElement(tuplePatternElement: TuplePatternElement): bool {
        true
    }

    function closeTuplePatternElement(tuplePatternElement: TuplePatternElement) {
    }

    function openCaseContent(caseContent: CaseContent): bool {
        true
    }

    function closeCaseContent(caseContent: CaseContent) {
    }

    function openType(type: Type): bool {
        true
    }

    function closeType(type: Type) {
    }

    function openTypeAnnotation(typeAnnotation: TypeAnnotation): bool {
        true
    }

    function closeTypeAnnotation(typeAnnotation: TypeAnnotation) {
    }

    function openSubtype(subtype: Subtype): bool {
        true
    }

    function closeSubtype(subtype: Subtype) {
    }

    function openIndexedType(indexedType: IndexedType): bool {
        true
    }

    function closeIndexedType(indexedType: IndexedType) {
    }

    function visitPointer(pointer: Pointer) {
    }

    function visitRoot(root: Root) {
    }

    function visitLocal(local: Local) {
    }

    function visitReference(reference: Reference) {
    }

    function visitThrown(thrown: Thrown) {
    }

    function openTypeInheritanceClause(typeInheritanceClause: TypeInheritanceClause): bool {
        true
    }

    function closeTypeInheritanceClause(typeInheritanceClause: TypeInheritanceClause) {
    }

    function openInheritance(inheritance: Inheritance): bool {
        true
    }

    function closeInheritance(inheritance: Inheritance) {
    }
}

class SyntaxNode {
    let start: Position
    let end: Position
    var parent: SyntaxNode
}

class Program extends SyntaxNode {

    constructor(name: string, directory: string, compilationUnits: CompilationUnit[]) {
        start = new Position(0, 0)
        end = new Position(0, 0)
        this.name = name
        this.directory = directory
        this.compilationUnits = compilationUnits
        this.parent = null
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openProgram(this)
            return
        if compilationUnits != null {
            for node: CompilationUnit in compilationUnits
                node.accept(visitor)
        }
        visitor.closeProgram(this)
    }

    let name: string
    let directory: string
    let compilationUnits: CompilationUnit[]
}

class CompilationUnit extends SyntaxNode {

    constructor(statements: Statement[], start: Position, end: Position) {
        this.start = start
        this.end = end
        this.statements = statements
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openCompilationUnit(this)
            return
        if statements != null {
            for node: Statement in statements
                node.accept(visitor)
        }
        visitor.closeCompilationUnit(this)
    }

    let statements: Statement[]
    let fileName: string
}

class Statement extends SyntaxNode {

    function accept(mutable visitor: Visitor) {
    }

}

class Declaration extends Statement {

    override function accept(mutable visitor: Visitor) {
    }

}

class Expression extends Statement {

    override function accept(mutable visitor: Visitor) {
    }

}

class ConstantDeclaration extends Declaration {

    constructor(initializer: BindingInitializer, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.initializer = initializer
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openConstantDeclaration(this)
            return
        initializer.accept(visitor)
        visitor.closeConstantDeclaration(this)
    }

    let initializer: BindingInitializer
}

class VariableDeclaration extends Declaration {

    constructor(initializer: BindingInitializer, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.initializer = initializer
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openVariableDeclaration(this)
            return
        initializer.accept(visitor)
        visitor.closeVariableDeclaration(this)
    }

    let initializer: BindingInitializer
}

class MutableDeclaration extends Declaration {

    constructor(initializer: BindingInitializer, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.initializer = initializer
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openMutableDeclaration(this)
            return
        initializer.accept(visitor)
        visitor.closeMutableDeclaration(this)
    }

    let initializer: BindingInitializer
}

class FunctionDeclaration extends Declaration {

    constructor(modifiers: Modifier[], name: string, signature: FunctionSignature, body: Expression, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.modifiers = modifiers
        this.name = name
        this.signature = signature
        this.body = body
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openFunctionDeclaration(this)
            return
        if modifiers != null {
            for node: Modifier in modifiers
                node.accept(visitor)
        }
        signature.accept(visitor)
        if body != null
            body.accept(visitor)
        visitor.closeFunctionDeclaration(this)
    }

    let modifiers: Modifier[]
    let name: string
    let signature: FunctionSignature
    let body: Expression
}

class EnumDeclaration extends Declaration {

    constructor(name: string, members: EnumMember[], start: Position, end: Position) {
        this.start = start
        this.end = end
        this.name = name
        this.members = members
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openEnumDeclaration(this)
            return
        if members != null {
            for node: EnumMember in members
                node.accept(visitor)
        }
        visitor.closeEnumDeclaration(this)
    }

    let name: string
    let members: EnumMember[]
}

class ClassDeclaration extends Declaration {

    constructor(name: string, typeInheritanceClause: TypeInheritanceClause, body: ClassBody, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.name = name
        this.typeInheritanceClause = typeInheritanceClause
        this.body = body
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openClassDeclaration(this)
            return
        if typeInheritanceClause != null
            typeInheritanceClause.accept(visitor)
        if body != null
            body.accept(visitor)
        visitor.closeClassDeclaration(this)
    }

    let name: string
    let typeInheritanceClause: TypeInheritanceClause
    let body: ClassBody
}

class ConstructorDeclaration extends Declaration {

    constructor(parameterClause: ParameterClause, body: Expression, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.parameterClause = parameterClause
        this.body = body
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openConstructorDeclaration(this)
            return
        parameterClause.accept(visitor)
        body.accept(visitor)
        visitor.closeConstructorDeclaration(this)
    }

    let parameterClause: ParameterClause
    let body: Expression
}

class CodeBlock extends Expression {

    constructor(statements: Statement[], start: Position, end: Position) {
        this.start = start
        this.end = end
        this.statements = statements
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openCodeBlock(this)
            return
        if statements != null {
            for node: Statement in statements
                node.accept(visitor)
        }
        visitor.closeCodeBlock(this)
    }

    let statements: Statement[]
}

class SimpleExpression extends Expression {

    constructor(prefixExpression: PrefixExpression, binaryOps: BinaryOp[], start: Position, end: Position) {
        this.start = start
        this.end = end
        this.prefixExpression = prefixExpression
        this.binaryOps = binaryOps
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openSimpleExpression(this)
            return
        prefixExpression.accept(visitor)
        if binaryOps != null {
            for node: BinaryOp in binaryOps
                node.accept(visitor)
        }
        visitor.closeSimpleExpression(this)
    }

    let prefixExpression: PrefixExpression
    let binaryOps: BinaryOp[]
}

class Initializer extends SyntaxNode {

    constructor(expression: Expression, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.expression = expression
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openInitializer(this)
            return
        expression.accept(visitor)
        visitor.closeInitializer(this)
    }

    let expression: Expression
}

class BindingInitializer extends SyntaxNode {

    constructor(initializer: PatternInitializer, additionalInitializers: AdditionalInitializer[], start: Position, end: Position) {
        this.start = start
        this.end = end
        this.initializer = initializer
        this.additionalInitializers = additionalInitializers
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openBindingInitializer(this)
            return
        initializer.accept(visitor)
        if additionalInitializers != null {
            for node: AdditionalInitializer in additionalInitializers
                node.accept(visitor)
        }
        visitor.closeBindingInitializer(this)
    }

    let initializer: PatternInitializer
    let additionalInitializers: AdditionalInitializer[]
}

class PatternInitializer extends SyntaxNode {

    constructor(pattern: Pattern, initializer: Initializer, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.pattern = pattern
        this.initializer = initializer
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openPatternInitializer(this)
            return
        pattern.accept(visitor)
        if initializer != null
            initializer.accept(visitor)
        visitor.closePatternInitializer(this)
    }

    let pattern: Pattern
    let initializer: Initializer
}

class AdditionalInitializer extends SyntaxNode {

    constructor(pattern: PatternInitializer, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.pattern = pattern
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openAdditionalInitializer(this)
            return
        pattern.accept(visitor)
        visitor.closeAdditionalInitializer(this)
    }

    let pattern: PatternInitializer
}

class Modifier extends SyntaxNode {

    function accept(mutable visitor: Visitor) {
    }

}

class OverrideWord extends Modifier {

    constructor(start: Position, end: Position) {
        this.start = start
        this.end = end
    }

    override function accept(mutable visitor: Visitor) {
        visitor.visitOverrideWord(this)
    }

}

class StaticWord extends Modifier {

    constructor(start: Position, end: Position) {
        this.start = start
        this.end = end
    }

    override function accept(mutable visitor: Visitor) {
        visitor.visitStaticWord(this)
    }

}

class FunctionSignature extends SyntaxNode {

    constructor(parameterClause: ParameterClause, result: FunctionResult, throwsClause: ThrowsClause, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.parameterClause = parameterClause
        this.result = result
        this.throwsClause = throwsClause
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openFunctionSignature(this)
            return
        parameterClause.accept(visitor)
        if result != null
            result.accept(visitor)
        if throwsClause != null
            throwsClause.accept(visitor)
        visitor.closeFunctionSignature(this)
    }

    let parameterClause: ParameterClause
    let result: FunctionResult
    let throwsClause: ThrowsClause
}

class FunctionResult extends SyntaxNode {

    constructor(resultType: Type, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.resultType = resultType
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openFunctionResult(this)
            return
        resultType.accept(visitor)
        visitor.closeFunctionResult(this)
    }

    let resultType: Type
}

class ParameterClause extends SyntaxNode {

    constructor(parameters: Parameter[], start: Position, end: Position) {
        this.start = start
        this.end = end
        this.parameters = parameters
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openParameterClause(this)
            return
        if parameters != null {
            for node: Parameter in parameters
                node.accept(visitor)
        }
        visitor.closeParameterClause(this)
    }

    let parameters: Parameter[]
}

class Parameter extends SyntaxNode {

    function accept(mutable visitor: Visitor) {
    }

}

class ConstParameter extends Parameter {

    constructor(name: string, parameterType: Type, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.name = name
        this.parameterType = parameterType
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openConstParameter(this)
            return
        parameterType.accept(visitor)
        visitor.closeConstParameter(this)
    }

    let name: string
    let parameterType: Type
}

class VarParameter extends Parameter {

    constructor(name: string, parameterType: Type, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.name = name
        this.parameterType = parameterType
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openVarParameter(this)
            return
        parameterType.accept(visitor)
        visitor.closeVarParameter(this)
    }

    let name: string
    let parameterType: Type
}

class ThrowsClause extends SyntaxNode {

    constructor(throwsType: Type, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.throwsType = throwsType
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openThrowsClause(this)
            return
        throwsType.accept(visitor)
        visitor.closeThrowsClause(this)
    }

    let throwsType: Type
}

class EnumMember extends SyntaxNode {

    constructor(enumCase: EnumCase, additionalCases: AdditionalCase[], parameterClause: ParameterClause, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.enumCase = enumCase
        this.additionalCases = additionalCases
        this.parameterClause = parameterClause
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openEnumMember(this)
            return
        enumCase.accept(visitor)
        if additionalCases != null {
            for node: AdditionalCase in additionalCases
                node.accept(visitor)
        }
        if parameterClause != null
            parameterClause.accept(visitor)
        visitor.closeEnumMember(this)
    }

    let enumCase: EnumCase
    let additionalCases: AdditionalCase[]
    let parameterClause: ParameterClause
}

class EnumCase extends SyntaxNode {

    constructor(name: string, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.name = name
    }

    function accept(mutable visitor: Visitor) {
        visitor.visitEnumCase(this)
    }

    let name: string
}

class AdditionalCase extends SyntaxNode {

    constructor(enumCase: EnumCase, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.enumCase = enumCase
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openAdditionalCase(this)
            return
        enumCase.accept(visitor)
        visitor.closeAdditionalCase(this)
    }

    let enumCase: EnumCase
}

class ClassBody extends SyntaxNode {

    constructor(members: ClassMember[], start: Position, end: Position) {
        this.start = start
        this.end = end
        this.members = members
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openClassBody(this)
            return
        if members != null {
            for node: ClassMember in members
                node.accept(visitor)
        }
        visitor.closeClassBody(this)
    }

    let members: ClassMember[]
}

class ClassMember extends SyntaxNode {

    constructor(declaration: Declaration, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.declaration = declaration
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openClassMember(this)
            return
        declaration.accept(visitor)
        visitor.closeClassMember(this)
    }

    let declaration: Declaration
}

class PrefixExpression extends SyntaxNode {

    constructor(prefixOperator: string, expression: PostfixExpression, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.prefixOperator = prefixOperator
        this.expression = expression
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openPrefixExpression(this)
            return
        expression.accept(visitor)
        visitor.closePrefixExpression(this)
    }

    let prefixOperator: string
    let expression: PostfixExpression
}

class PostfixExpression extends SyntaxNode {

    constructor(primaryExpression: PrimaryExpression, postfixes: Postfix[], start: Position, end: Position) {
        this.start = start
        this.end = end
        this.primaryExpression = primaryExpression
        this.postfixes = postfixes
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openPostfixExpression(this)
            return
        primaryExpression.accept(visitor)
        if postfixes != null {
            for node: Postfix in postfixes
                node.accept(visitor)
        }
        visitor.closePostfixExpression(this)
    }

    let primaryExpression: PrimaryExpression
    let postfixes: Postfix[]
}

class BinaryOp extends SyntaxNode {

    function accept(mutable visitor: Visitor) {
    }

}

class BinaryOperation extends BinaryOp {

    constructor(binaryOperator: string, expression: PrefixExpression, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.binaryOperator = binaryOperator
        this.expression = expression
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openBinaryOperation(this)
            return
        expression.accept(visitor)
        visitor.closeBinaryOperation(this)
    }

    let binaryOperator: string
    let expression: PrefixExpression
}

class Assignment extends BinaryOp {

    constructor(expression: Expression, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.expression = expression
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openAssignment(this)
            return
        expression.accept(visitor)
        visitor.closeAssignment(this)
    }

    let expression: Expression
}

class TypeQuery extends BinaryOp {

    constructor(objectType: Type, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.objectType = objectType
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openTypeQuery(this)
            return
        objectType.accept(visitor)
        visitor.closeTypeQuery(this)
    }

    let objectType: Type
}

class TypeCast extends BinaryOp {

    constructor(objectType: Type, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.objectType = objectType
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openTypeCast(this)
            return
        objectType.accept(visitor)
        visitor.closeTypeCast(this)
    }

    let objectType: Type
}

class CatchClause extends SyntaxNode {

    constructor(catchPattern: CatchPattern, bindingPattern: TuplePattern, expression: Expression, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.catchPattern = catchPattern
        this.bindingPattern = bindingPattern
        this.expression = expression
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openCatchClause(this)
            return
        catchPattern.accept(visitor)
        if bindingPattern != null
            bindingPattern.accept(visitor)
        expression.accept(visitor)
        visitor.closeCatchClause(this)
    }

    let catchPattern: CatchPattern
    let bindingPattern: TuplePattern
    let expression: Expression
}

class CatchPattern extends SyntaxNode {

    function accept(mutable visitor: Visitor) {
    }

}

class WildCardCatchPattern extends CatchPattern {

    constructor(pattern: WildcardPattern, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.pattern = pattern
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openWildCardCatchPattern(this)
            return
        pattern.accept(visitor)
        visitor.closeWildCardCatchPattern(this)
    }

    let pattern: WildcardPattern
}

class IdentifierCatchPattern extends CatchPattern {

    constructor(name: string, member: MemberExpression, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.name = name
        this.member = member
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openIdentifierCatchPattern(this)
            return
        if member != null
            member.accept(visitor)
        visitor.closeIdentifierCatchPattern(this)
    }

    let name: string
    let member: MemberExpression
}

class Postfix extends SyntaxNode {

    function accept(mutable visitor: Visitor) {
    }

}

class OperatorPostfix extends Postfix {

    constructor(postfixOperator: string, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.postfixOperator = postfixOperator
    }

    override function accept(mutable visitor: Visitor) {
        visitor.visitOperatorPostfix(this)
    }

    let postfixOperator: string
}

class FunctionCall extends Postfix {

    constructor(arguments: ParenthesizedExpression, catchClauses: CatchClause[], start: Position, end: Position) {
        this.start = start
        this.end = end
        this.arguments = arguments
        this.catchClauses = catchClauses
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openFunctionCall(this)
            return
        arguments.accept(visitor)
        if catchClauses != null {
            for node: CatchClause in catchClauses
                node.accept(visitor)
        }
        visitor.closeFunctionCall(this)
    }

    let arguments: ParenthesizedExpression
    let catchClauses: CatchClause[]
}

class MemberExpression extends Postfix {

    constructor(member: string, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.member = member
    }

    override function accept(mutable visitor: Visitor) {
        visitor.visitMemberExpression(this)
    }

    let member: string
}

class Subscript extends Postfix {

    constructor(expressions: ExpressionElement[], start: Position, end: Position) {
        this.start = start
        this.end = end
        this.expressions = expressions
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openSubscript(this)
            return
        if expressions != null {
            for node: ExpressionElement in expressions
                node.accept(visitor)
        }
        visitor.closeSubscript(this)
    }

    let expressions: ExpressionElement[]
}

class ExpressionElement extends SyntaxNode {

    constructor(expression: Expression, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.expression = expression
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openExpressionElement(this)
            return
        expression.accept(visitor)
        visitor.closeExpressionElement(this)
    }

    let expression: Expression
}

class PrimaryExpression extends SyntaxNode {

    function accept(mutable visitor: Visitor) {
    }

}

class IdentifierExpression extends PrimaryExpression {

    constructor(name: string, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.name = name
    }

    override function accept(mutable visitor: Visitor) {
        visitor.visitIdentifierExpression(this)
    }

    let name: string
}

class LiteralExpression extends PrimaryExpression {

    constructor(literal: Literal, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.literal = literal
    }

    override function accept(mutable visitor: Visitor) {
        visitor.visitLiteralExpression(this)
    }

    let literal: Literal
}

class IfExpression extends PrimaryExpression {

    constructor(condition: Expression, consequent: Expression, elseClause: ElseClause, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.condition = condition
        this.consequent = consequent
        this.elseClause = elseClause
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openIfExpression(this)
            return
        condition.accept(visitor)
        consequent.accept(visitor)
        if elseClause != null
            elseClause.accept(visitor)
        visitor.closeIfExpression(this)
    }

    let condition: Expression
    let consequent: Expression
    let elseClause: ElseClause
}

class SwitchExpression extends PrimaryExpression {

    constructor(expression: Expression, body: SwitchBody, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.expression = expression
        this.body = body
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openSwitchExpression(this)
            return
        expression.accept(visitor)
        body.accept(visitor)
        visitor.closeSwitchExpression(this)
    }

    let expression: Expression
    let body: SwitchBody
}

class ForExpression extends PrimaryExpression {

    constructor(pattern: Pattern, expression: Expression, code: Expression, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.pattern = pattern
        this.expression = expression
        this.code = code
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openForExpression(this)
            return
        pattern.accept(visitor)
        expression.accept(visitor)
        code.accept(visitor)
        visitor.closeForExpression(this)
    }

    let pattern: Pattern
    let expression: Expression
    let code: Expression
}

class WhileExpression extends PrimaryExpression {

    constructor(condition: Expression, code: Expression, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.condition = condition
        this.code = code
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openWhileExpression(this)
            return
        condition.accept(visitor)
        code.accept(visitor)
        visitor.closeWhileExpression(this)
    }

    let condition: Expression
    let code: Expression
}

class DoExpression extends PrimaryExpression {

    constructor(code: Expression, condition: Expression, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.code = code
        this.condition = condition
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openDoExpression(this)
            return
        code.accept(visitor)
        condition.accept(visitor)
        visitor.closeDoExpression(this)
    }

    let code: Expression
    let condition: Expression
}

class ParenthesizedExpression extends PrimaryExpression {

    constructor(expressionElements: ExpressionElement[], start: Position, end: Position) {
        this.start = start
        this.end = end
        this.expressionElements = expressionElements
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openParenthesizedExpression(this)
            return
        if expressionElements != null {
            for node: ExpressionElement in expressionElements
                node.accept(visitor)
        }
        visitor.closeParenthesizedExpression(this)
    }

    let expressionElements: ExpressionElement[]
}

class ReturnExpression extends PrimaryExpression {

    constructor(expression: ParenthesizedExpression, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.expression = expression
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openReturnExpression(this)
            return
        if expression != null
            expression.accept(visitor)
        visitor.closeReturnExpression(this)
    }

    let expression: ParenthesizedExpression
}

class ThrowExpression extends PrimaryExpression {

    constructor(error: IdentifierExpression, arguments: ParenthesizedExpression, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.error = error
        this.arguments = arguments
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openThrowExpression(this)
            return
        error.accept(visitor)
        if arguments != null
            arguments.accept(visitor)
        visitor.closeThrowExpression(this)
    }

    let error: IdentifierExpression
    let arguments: ParenthesizedExpression
}

class BreakExpression extends PrimaryExpression {

    constructor(expression: ParenthesizedExpression, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.expression = expression
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openBreakExpression(this)
            return
        if expression != null
            expression.accept(visitor)
        visitor.closeBreakExpression(this)
    }

    let expression: ParenthesizedExpression
}

class ConstructorCall extends PrimaryExpression {

    constructor(typeToConstruct: Type, arguments: ParenthesizedExpression, catchClauses: CatchClause[], start: Position, end: Position) {
        this.start = start
        this.end = end
        this.typeToConstruct = typeToConstruct
        this.arguments = arguments
        this.catchClauses = catchClauses
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openConstructorCall(this)
            return
        typeToConstruct.accept(visitor)
        arguments.accept(visitor)
        if catchClauses != null {
            for node: CatchClause in catchClauses
                node.accept(visitor)
        }
        visitor.closeConstructorCall(this)
    }

    let typeToConstruct: Type
    let arguments: ParenthesizedExpression
    let catchClauses: CatchClause[]
}

class ThisExpression extends PrimaryExpression {

    constructor(start: Position, end: Position) {
        this.start = start
        this.end = end
    }

    override function accept(mutable visitor: Visitor) {
        visitor.visitThisExpression(this)
    }

}

class NullExpression extends PrimaryExpression {

    constructor(start: Position, end: Position) {
        this.start = start
        this.end = end
    }

    override function accept(mutable visitor: Visitor) {
        visitor.visitNullExpression(this)
    }

}

class ElseClause extends SyntaxNode {

    constructor(alternative: Expression, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.alternative = alternative
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openElseClause(this)
            return
        alternative.accept(visitor)
        visitor.closeElseClause(this)
    }

    let alternative: Expression
}

class SwitchBody extends SyntaxNode {

    function accept(mutable visitor: Visitor) {
    }

}

class CurliedSwitchBody extends SwitchBody {

    constructor(cases: SwitchCase[], start: Position, end: Position) {
        this.start = start
        this.end = end
        this.cases = cases
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openCurliedSwitchBody(this)
            return
        if cases != null {
            for node: SwitchCase in cases
                node.accept(visitor)
        }
        visitor.closeCurliedSwitchBody(this)
    }

    let cases: SwitchCase[]
}

class NakedSwitchBody extends SwitchBody {

    constructor(cases: SwitchCase[], start: Position, end: Position) {
        this.start = start
        this.end = end
        this.cases = cases
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openNakedSwitchBody(this)
            return
        if cases != null {
            for node: SwitchCase in cases
                node.accept(visitor)
        }
        visitor.closeNakedSwitchBody(this)
    }

    let cases: SwitchCase[]
}

class SwitchCase extends SyntaxNode {

    constructor(label: CaseLabel, content: CaseContent, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.label = label
        this.content = content
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openSwitchCase(this)
            return
        label.accept(visitor)
        content.accept(visitor)
        visitor.closeSwitchCase(this)
    }

    let label: CaseLabel
    let content: CaseContent
}

class CaseLabel extends SyntaxNode {

    function accept(mutable visitor: Visitor) {
    }

}

class ItemCaseLabel extends CaseLabel {

    constructor(pattern: Pattern, additionalPatterns: CaseItem[], start: Position, end: Position) {
        this.start = start
        this.end = end
        this.pattern = pattern
        this.additionalPatterns = additionalPatterns
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openItemCaseLabel(this)
            return
        pattern.accept(visitor)
        if additionalPatterns != null {
            for node: CaseItem in additionalPatterns
                node.accept(visitor)
        }
        visitor.closeItemCaseLabel(this)
    }

    let pattern: Pattern
    let additionalPatterns: CaseItem[]
}

class DefaultCaseLabel extends CaseLabel {

    constructor(start: Position, end: Position) {
        this.start = start
        this.end = end
    }

    override function accept(mutable visitor: Visitor) {
        visitor.visitDefaultCaseLabel(this)
    }

}

class CaseItem extends SyntaxNode {

    constructor(pattern: Pattern, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.pattern = pattern
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openCaseItem(this)
            return
        pattern.accept(visitor)
        visitor.closeCaseItem(this)
    }

    let pattern: Pattern
}

class Pattern extends SyntaxNode {

    function accept(mutable visitor: Visitor) {
    }

}

class WildcardPattern extends Pattern {

    constructor(start: Position, end: Position) {
        this.start = start
        this.end = end
    }

    override function accept(mutable visitor: Visitor) {
        visitor.visitWildcardPattern(this)
    }

}

class IdentifierPattern extends Pattern {

    constructor(identifier: string, annotationForType: TypeAnnotation, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.identifier = identifier
        this.annotationForType = annotationForType
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openIdentifierPattern(this)
            return
        if annotationForType != null
            annotationForType.accept(visitor)
        visitor.closeIdentifierPattern(this)
    }

    let identifier: string
    let annotationForType: TypeAnnotation
}

class TuplePattern extends Pattern {

    constructor(elements: TuplePatternElement[], start: Position, end: Position) {
        this.start = start
        this.end = end
        this.elements = elements
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openTuplePattern(this)
            return
        if elements != null {
            for node: TuplePatternElement in elements
                node.accept(visitor)
        }
        visitor.closeTuplePattern(this)
    }

    let elements: TuplePatternElement[]
}

class ExpressionPattern extends Pattern {

    constructor(expression: Expression, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.expression = expression
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openExpressionPattern(this)
            return
        expression.accept(visitor)
        visitor.closeExpressionPattern(this)
    }

    let expression: Expression
}

class TuplePatternElement extends SyntaxNode {

    constructor(pattern: Pattern, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.pattern = pattern
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openTuplePatternElement(this)
            return
        pattern.accept(visitor)
        visitor.closeTuplePatternElement(this)
    }

    let pattern: Pattern
}

class CaseContent extends SyntaxNode {

    constructor(statements: Statement[], start: Position, end: Position) {
        this.start = start
        this.end = end
        this.statements = statements
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openCaseContent(this)
            return
        if statements != null {
            for node: Statement in statements
                node.accept(visitor)
        }
        visitor.closeCaseContent(this)
    }

    let statements: Statement[]
}

class Type extends SyntaxNode {

    constructor(name: string, subType: Subtype, postfixes: TypePostfix[], lifeTime: LifeTime, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.name = name
        this.subType = subType
        this.postfixes = postfixes
        this.lifeTime = lifeTime
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openType(this)
            return
        if subType != null
            subType.accept(visitor)
        if postfixes != null {
            for node: TypePostfix in postfixes
                node.accept(visitor)
        }
        if lifeTime != null
            lifeTime.accept(visitor)
        visitor.closeType(this)
    }

    let name: string
    let subType: Subtype
    let postfixes: TypePostfix[]
    let lifeTime: LifeTime
}

class TypeAnnotation extends SyntaxNode {

    constructor(annotationForType: Type, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.annotationForType = annotationForType
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openTypeAnnotation(this)
            return
        annotationForType.accept(visitor)
        visitor.closeTypeAnnotation(this)
    }

    let annotationForType: Type
}

class Subtype extends SyntaxNode {

    constructor(type: Type, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.type = type
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openSubtype(this)
            return
        type.accept(visitor)
        visitor.closeSubtype(this)
    }

    let type: Type
}

class TypePostfix extends SyntaxNode {

    function accept(mutable visitor: Visitor) {
    }

}

class IndexedType extends TypePostfix {

    constructor(key: Type, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.key = key
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openIndexedType(this)
            return
        if key != null
            key.accept(visitor)
        visitor.closeIndexedType(this)
    }

    let key: Type
}

class Pointer extends TypePostfix {

    constructor(start: Position, end: Position) {
        this.start = start
        this.end = end
    }

    override function accept(mutable visitor: Visitor) {
        visitor.visitPointer(this)
    }

}

class LifeTime extends SyntaxNode {

    function accept(mutable visitor: Visitor) {
    }

}

class Root extends LifeTime {

    constructor(start: Position, end: Position) {
        this.start = start
        this.end = end
    }

    override function accept(mutable visitor: Visitor) {
        visitor.visitRoot(this)
    }

}

class Local extends LifeTime {

    constructor(location: string, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.location = location
    }

    override function accept(mutable visitor: Visitor) {
        visitor.visitLocal(this)
    }

    let location: string
}

class Reference extends LifeTime {

    constructor(age: Literal, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.age = age
    }

    override function accept(mutable visitor: Visitor) {
        visitor.visitReference(this)
    }

    let age: Literal
}

class Thrown extends LifeTime {

    constructor(start: Position, end: Position) {
        this.start = start
        this.end = end
    }

    override function accept(mutable visitor: Visitor) {
        visitor.visitThrown(this)
    }

}

class TypeInheritanceClause extends SyntaxNode {

    constructor(inheritances: Inheritance[], start: Position, end: Position) {
        this.start = start
        this.end = end
        this.inheritances = inheritances
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openTypeInheritanceClause(this)
            return
        if inheritances != null {
            for node: Inheritance in inheritances
                node.accept(visitor)
        }
        visitor.closeTypeInheritanceClause(this)
    }

    let inheritances: Inheritance[]
}

class Inheritance extends SyntaxNode {

    constructor(type: Type, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.type = type
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openInheritance(this)
            return
        type.accept(visitor)
        visitor.closeInheritance(this)
    }

    let type: Type
}

class Parser {
    constructor(theFileName: string, text: string) {
        lexer = new Lexer(text)
        fileName = theFileName
        classKeyword = new string("class")
        functionKeyword = new string("function")
        ifKeyword = new string("if")
        elseKeyword = new string("else")
        switchKeyword = new string("switch")
        caseKeyword = new string("case")
        defaultKeyword = new string("default")
        catchKeyword = new string("catch")
        forKeyword = new string("for")
        inKeyword = new string("in")
        whileKeyword = new string("while")
        doKeyword = new string("do")
        returnKeyword = new string("return")
        throwKeyword = new string("throw")
        breakKeyword = new string("break")
        throwsKeyword = new string("throws")
        overrideKeyword = new string("override")
        staticKeyword = new string("static")
        letKeyword = new string("let")
        varKeyword = new string("var")
        mutableKeyword = new string("mutable")
        isKeyword = new string("is")
        asKeyword = new string("as")
        constructorKeyword = new string("constructor")
        enumKeyword = new string("enum")
        thisKeyword = new string("this")
        nullKeyword = new string("null")
        newKeyword = new string("new")
        extendsKeyword = new string("extends")
        equal = new string("=")
        comma = new string(",")
        leftParen = new string("(")
        rightParen = new string(")")
        leftCurly = new string("{")
        rightCurly = new string("}")
        leftBracket = new string("[")
        rightBracket = new string("]")
        colon = new string(":")
        dot = new string(".")
        underscore = new string("_")
        circumflex = new string("^")
        dollar = new string("$")
        at = new string("@")
        hash = new string("#")
        ampersand = new string("&")
    }

    function parseCompilationUnit(): CompilationUnit {
        let start: Position$ = lexer.getPreviousPosition()

        let statements: Statement[] = parseStatementList()
        if statements != null {
            if !isAtEnd() {
                return(null)
            }
        }

        let end: Position$ = lexer.getPosition()

        var ret: CompilationUnit = new CompilationUnit(statements, new Position(start), new Position(end))
        ret.fileName = fileName
        if statements != null {
            for item: Statement in statements
                item.parent = ret
        }

        ret
    }

    function parseStatementList(): Statement[] {
        mutable ret: Statement[]$ = null
        while true {

            let node: Statement = parseStatement()
            if node == null
                break

            if ret == null
                ret = new Statement[]()

            ret.push(node)
        }

        return(ret)
    }

    function parseStatement(): Statement {
        {
            let node: Declaration = parseDeclaration()
            if node != null
                return(node)
        }

        {
            let node: Expression = parseExpression()
            if node != null
                return(node)
        }

        null
    }

    function parseDeclaration(): Declaration {
        {
            let node: ConstantDeclaration = parseConstantDeclaration()
            if node != null
                return(node)
        }

        {
            let node: VariableDeclaration = parseVariableDeclaration()
            if node != null
                return(node)
        }

        {
            let node: MutableDeclaration = parseMutableDeclaration()
            if node != null
                return(node)
        }

        {
            let node: FunctionDeclaration = parseFunctionDeclaration()
            if node != null
                return(node)
        }

        {
            let node: EnumDeclaration = parseEnumDeclaration()
            if node != null
                return(node)
        }

        {
            let node: ClassDeclaration = parseClassDeclaration()
            if node != null
                return(node)
        }

        {
            let node: ConstructorDeclaration = parseConstructorDeclaration()
            if node != null
                return(node)
        }

        null
    }

    function parseExpression(): Expression {
        {
            let node: CodeBlock = parseCodeBlock()
            if node != null
                return(node)
        }

        {
            let node: SimpleExpression = parseSimpleExpression()
            if node != null
                return(node)
        }

        null
    }

    function parseConstantDeclaration(): ConstantDeclaration {
        let start: Position$ = lexer.getPreviousPosition()

        let successLet1: bool = lexer.parseKeyword(letKeyword)
        if successLet1
            lexer.advance()
        else
            return(null)

        let initializer: BindingInitializer = parseBindingInitializer()
        if initializer == null
            return(null)

        let end: Position$ = lexer.getPosition()

        var ret: ConstantDeclaration = new ConstantDeclaration(initializer, new Position(start), new Position(end))
        initializer.parent = ret

        ret
    }

    function parseVariableDeclaration(): VariableDeclaration {
        let start: Position$ = lexer.getPreviousPosition()

        let successVar1: bool = lexer.parseKeyword(varKeyword)
        if successVar1
            lexer.advance()
        else
            return(null)

        let initializer: BindingInitializer = parseBindingInitializer()
        if initializer == null
            return(null)

        let end: Position$ = lexer.getPosition()

        var ret: VariableDeclaration = new VariableDeclaration(initializer, new Position(start), new Position(end))
        initializer.parent = ret

        ret
    }

    function parseMutableDeclaration(): MutableDeclaration {
        let start: Position$ = lexer.getPreviousPosition()

        let successMutable1: bool = lexer.parseKeyword(mutableKeyword)
        if successMutable1
            lexer.advance()
        else
            return(null)

        let initializer: BindingInitializer = parseBindingInitializer()
        if initializer == null
            return(null)

        let end: Position$ = lexer.getPosition()

        var ret: MutableDeclaration = new MutableDeclaration(initializer, new Position(start), new Position(end))
        initializer.parent = ret

        ret
    }

    function parseFunctionDeclaration(): FunctionDeclaration {
        let start: Position$ = lexer.getPreviousPosition()

        let modifiers: Modifier[] = parseModifierList()

        let successFunction2: bool = lexer.parseKeyword(functionKeyword)
        if successFunction2
            lexer.advance()
        else
            return(null)

        let name: string = lexer.parseIdentifier()
        if (name != null) && isIdentifier(name)
            lexer.advance()
        else
            return(null)

        let signature: FunctionSignature = parseFunctionSignature()
        if signature == null
            return(null)

        let body: Expression = parseExpression()

        let end: Position$ = lexer.getPosition()

        var ret: FunctionDeclaration = new FunctionDeclaration(modifiers, name, signature, body, new Position(start), new Position(end))
        if modifiers != null {
            for item: Modifier in modifiers
                item.parent = ret
        }
        signature.parent = ret
        if body != null
            body.parent = ret

        ret
    }

    function parseEnumDeclaration(): EnumDeclaration {
        let start: Position$ = lexer.getPreviousPosition()

        let successEnum1: bool = lexer.parseKeyword(enumKeyword)
        if successEnum1
            lexer.advance()
        else
            return(null)

        let name: string = lexer.parseIdentifier()
        if (name != null) && isIdentifier(name)
            lexer.advance()
        else
            return(null)

        let successLeftCurly3: bool = lexer.parsePunctuation(leftCurly)
        if successLeftCurly3
            lexer.advance()
        else
            return(null)

        let members: EnumMember[] = parseEnumMemberList()

        let successRightCurly5: bool = lexer.parsePunctuation(rightCurly)
        if successRightCurly5
            lexer.advance()
        else
            return(null)

        let end: Position$ = lexer.getPosition()

        var ret: EnumDeclaration = new EnumDeclaration(name, members, new Position(start), new Position(end))
        if members != null {
            for item: EnumMember in members
                item.parent = ret
        }

        ret
    }

    function parseClassDeclaration(): ClassDeclaration {
        let start: Position$ = lexer.getPreviousPosition()

        let successClass1: bool = lexer.parseKeyword(classKeyword)
        if successClass1
            lexer.advance()
        else
            return(null)

        let name: string = lexer.parseIdentifier()
        if (name != null) && isIdentifier(name)
            lexer.advance()
        else
            return(null)

        let typeInheritanceClause: TypeInheritanceClause = parseTypeInheritanceClause()

        let body: ClassBody = parseClassBody()

        let end: Position$ = lexer.getPosition()

        var ret: ClassDeclaration = new ClassDeclaration(name, typeInheritanceClause, body, new Position(start), new Position(end))
        if typeInheritanceClause != null
            typeInheritanceClause.parent = ret
        if body != null
            body.parent = ret

        ret
    }

    function parseConstructorDeclaration(): ConstructorDeclaration {
        let start: Position$ = lexer.getPreviousPosition()

        let successConstructor1: bool = lexer.parseKeyword(constructorKeyword)
        if successConstructor1
            lexer.advance()
        else
            return(null)

        let parameterClause: ParameterClause = parseParameterClause()
        if parameterClause == null
            return(null)

        let body: Expression = parseExpression()
        if body == null
            return(null)

        let end: Position$ = lexer.getPosition()

        var ret: ConstructorDeclaration = new ConstructorDeclaration(parameterClause, body, new Position(start), new Position(end))
        parameterClause.parent = ret
        body.parent = ret

        ret
    }

    function parseCodeBlock(): CodeBlock {
        let start: Position$ = lexer.getPreviousPosition()

        let successLeftCurly1: bool = lexer.parsePunctuation(leftCurly)
        if successLeftCurly1
            lexer.advance()
        else
            return(null)

        let statements: Statement[] = parseStatementList()

        let successRightCurly3: bool = lexer.parsePunctuation(rightCurly)
        if successRightCurly3
            lexer.advance()
        else
            return(null)

        let end: Position$ = lexer.getPosition()

        var ret: CodeBlock = new CodeBlock(statements, new Position(start), new Position(end))
        if statements != null {
            for item: Statement in statements
                item.parent = ret
        }

        ret
    }

    function parseSimpleExpression(): SimpleExpression {
        let start: Position$ = lexer.getPreviousPosition()

        let prefixExpression: PrefixExpression = parsePrefixExpression()
        if prefixExpression == null
            return(null)

        let binaryOps: BinaryOp[] = parseBinaryOpList()

        let end: Position$ = lexer.getPosition()

        var ret: SimpleExpression = new SimpleExpression(prefixExpression, binaryOps, new Position(start), new Position(end))
        prefixExpression.parent = ret
        if binaryOps != null {
            for item: BinaryOp in binaryOps
                item.parent = ret
        }

        ret
    }

    function parseInitializer(): Initializer {
        let start: Position$ = lexer.getPreviousPosition()

        let successEqual1: bool = lexer.parsePunctuation(equal)
        if successEqual1
            lexer.advance()
        else
            return(null)

        let expression: Expression = parseExpression()
        if expression == null
            return(null)

        let end: Position$ = lexer.getPosition()

        var ret: Initializer = new Initializer(expression, new Position(start), new Position(end))
        expression.parent = ret

        ret
    }

    function parseBindingInitializer(): BindingInitializer {
        let start: Position$ = lexer.getPreviousPosition()

        let initializer: PatternInitializer = parsePatternInitializer()
        if initializer == null
            return(null)

        let additionalInitializers: AdditionalInitializer[] = parseAdditionalInitializerList()

        let end: Position$ = lexer.getPosition()

        var ret: BindingInitializer = new BindingInitializer(initializer, additionalInitializers, new Position(start), new Position(end))
        initializer.parent = ret
        if additionalInitializers != null {
            for item: AdditionalInitializer in additionalInitializers
                item.parent = ret
        }

        ret
    }

    function parsePatternInitializerList(): PatternInitializer[] {
        mutable ret: PatternInitializer[]$ = null
        while true {

            let node: PatternInitializer = parsePatternInitializer()
            if node == null
                break

            if ret == null
                ret = new PatternInitializer[]()

            ret.push(node)
        }

        return(ret)
    }

    function parsePatternInitializer(): PatternInitializer {
        let start: Position$ = lexer.getPreviousPosition()

        let pattern: Pattern = parsePattern()
        if pattern == null
            return(null)

        let initializer: Initializer = parseInitializer()

        let end: Position$ = lexer.getPosition()

        var ret: PatternInitializer = new PatternInitializer(pattern, initializer, new Position(start), new Position(end))
        pattern.parent = ret
        if initializer != null
            initializer.parent = ret

        ret
    }

    function parseAdditionalInitializerList(): AdditionalInitializer[] {
        mutable ret: AdditionalInitializer[]$ = null
        while true {

            let node: AdditionalInitializer = parseAdditionalInitializer()
            if node == null
                break

            if ret == null
                ret = new AdditionalInitializer[]()

            ret.push(node)
        }

        return(ret)
    }

    function parseAdditionalInitializer(): AdditionalInitializer {
        let start: Position$ = lexer.getPreviousPosition()

        let successComma1: bool = lexer.parsePunctuation(comma)
        if successComma1
            lexer.advance()
        else
            return(null)

        let pattern: PatternInitializer = parsePatternInitializer()
        if pattern == null
            return(null)

        let end: Position$ = lexer.getPosition()

        var ret: AdditionalInitializer = new AdditionalInitializer(pattern, new Position(start), new Position(end))
        pattern.parent = ret

        ret
    }

    function parseModifierList(): Modifier[] {
        mutable ret: Modifier[]$ = null
        while true {

            let node: Modifier = parseModifier()
            if node == null
                break

            if ret == null
                ret = new Modifier[]()

            ret.push(node)
        }

        return(ret)
    }

    function parseModifier(): Modifier {
        {
            let node: OverrideWord = parseOverrideWord()
            if node != null
                return(node)
        }

        {
            let node: StaticWord = parseStaticWord()
            if node != null
                return(node)
        }

        null
    }

    function parseOverrideWord(): OverrideWord {
        let start: Position$ = lexer.getPreviousPosition()

        let successOverride1: bool = lexer.parseKeyword(overrideKeyword)
        if successOverride1
            lexer.advance()
        else
            return(null)

        let end: Position$ = lexer.getPosition()

        var ret: OverrideWord = new OverrideWord(new Position(start), new Position(end))

        ret
    }

    function parseStaticWord(): StaticWord {
        let start: Position$ = lexer.getPreviousPosition()

        let successStatic1: bool = lexer.parseKeyword(staticKeyword)
        if successStatic1
            lexer.advance()
        else
            return(null)

        let end: Position$ = lexer.getPosition()

        var ret: StaticWord = new StaticWord(new Position(start), new Position(end))

        ret
    }

    function parseFunctionSignature(): FunctionSignature {
        let start: Position$ = lexer.getPreviousPosition()

        let parameterClause: ParameterClause = parseParameterClause()
        if parameterClause == null
            return(null)

        let result: FunctionResult = parseFunctionResult()

        let throwsClause: ThrowsClause = parseThrowsClause()

        let end: Position$ = lexer.getPosition()

        var ret: FunctionSignature = new FunctionSignature(parameterClause, result, throwsClause, new Position(start), new Position(end))
        parameterClause.parent = ret
        if result != null
            result.parent = ret
        if throwsClause != null
            throwsClause.parent = ret

        ret
    }

    function parseFunctionResult(): FunctionResult {
        let start: Position$ = lexer.getPreviousPosition()

        let successColon1: bool = lexer.parsePunctuation(colon)
        if successColon1
            lexer.advance()
        else
            return(null)

        let resultType: Type = parseType()
        if resultType == null
            return(null)

        let end: Position$ = lexer.getPosition()

        var ret: FunctionResult = new FunctionResult(resultType, new Position(start), new Position(end))
        resultType.parent = ret

        ret
    }

    function parseParameterClauseList(): ParameterClause[] {
        mutable ret: ParameterClause[]$ = null
        while true {

            let node: ParameterClause = parseParameterClause()
            if node == null
                break

            if ret == null
                ret = new ParameterClause[]()

            ret.push(node)
        }

        return(ret)
    }

    function parseParameterClause(): ParameterClause {
        let start: Position$ = lexer.getPreviousPosition()

        let successLeftParen1: bool = lexer.parsePunctuation(leftParen)
        if successLeftParen1
            lexer.advance()
        else
            return(null)

        let parameters: Parameter[] = parseParameterList()

        let successRightParen3: bool = lexer.parsePunctuation(rightParen)
        if successRightParen3
            lexer.advance()
        else
            return(null)

        let end: Position$ = lexer.getPosition()

        var ret: ParameterClause = new ParameterClause(parameters, new Position(start), new Position(end))
        if parameters != null {
            for item: Parameter in parameters
                item.parent = ret
        }

        ret
    }

    function parseParameterList(): Parameter[] {
        mutable ret: Parameter[]$ = null
        while true {

            let node: Parameter = parseParameter()
            if node == null
                break

            if ret == null
                ret = new Parameter[]()

            ret.push(node)
        }

        return(ret)
    }

    function parseParameter(): Parameter {
        {
            let node: ConstParameter = parseConstParameter()
            if node != null
                return(node)
        }

        {
            let node: VarParameter = parseVarParameter()
            if node != null
                return(node)
        }

        null
    }

    function parseConstParameter(): ConstParameter {
        let start: Position$ = lexer.getPreviousPosition()

        let successLet1: bool = lexer.parseKeyword(letKeyword)
        if successLet1
            lexer.advance()

        let name: string = lexer.parseIdentifier()
        if (name != null) && isIdentifier(name)
            lexer.advance()
        else
            return(null)

        let successColon3: bool = lexer.parsePunctuation(colon)
        if successColon3
            lexer.advance()
        else
            return(null)

        let parameterType: Type = parseType()
        if parameterType == null
            return(null)

        let successComma5: bool = lexer.parsePunctuation(comma)
        if successComma5
            lexer.advance()

        let end: Position$ = lexer.getPosition()

        var ret: ConstParameter = new ConstParameter(name, parameterType, new Position(start), new Position(end))
        parameterType.parent = ret

        ret
    }

    function parseVarParameter(): VarParameter {
        let start: Position$ = lexer.getPreviousPosition()

        let successMutable1: bool = lexer.parseKeyword(mutableKeyword)
        if successMutable1
            lexer.advance()
        else
            return(null)

        let name: string = lexer.parseIdentifier()
        if (name != null) && isIdentifier(name)
            lexer.advance()
        else
            return(null)

        let successColon3: bool = lexer.parsePunctuation(colon)
        if successColon3
            lexer.advance()
        else
            return(null)

        let parameterType: Type = parseType()
        if parameterType == null
            return(null)

        let successComma5: bool = lexer.parsePunctuation(comma)
        if successComma5
            lexer.advance()

        let end: Position$ = lexer.getPosition()

        var ret: VarParameter = new VarParameter(name, parameterType, new Position(start), new Position(end))
        parameterType.parent = ret

        ret
    }

    function parseThrowsClause(): ThrowsClause {
        let start: Position$ = lexer.getPreviousPosition()

        let successThrows1: bool = lexer.parseKeyword(throwsKeyword)
        if successThrows1
            lexer.advance()
        else
            return(null)

        let throwsType: Type = parseType()
        if throwsType == null
            return(null)

        let end: Position$ = lexer.getPosition()

        var ret: ThrowsClause = new ThrowsClause(throwsType, new Position(start), new Position(end))
        throwsType.parent = ret

        ret
    }

    function parseEnumMemberList(): EnumMember[] {
        mutable ret: EnumMember[]$ = null
        while true {

            let node: EnumMember = parseEnumMember()
            if node == null
                break

            if ret == null
                ret = new EnumMember[]()

            ret.push(node)
        }

        return(ret)
    }

    function parseEnumMember(): EnumMember {
        let start: Position$ = lexer.getPreviousPosition()

        let successCase1: bool = lexer.parseKeyword(caseKeyword)
        if successCase1
            lexer.advance()
        else
            return(null)

        let enumCase: EnumCase = parseEnumCase()
        if enumCase == null
            return(null)

        let additionalCases: AdditionalCase[] = parseAdditionalCaseList()

        let parameterClause: ParameterClause = parseParameterClause()

        let end: Position$ = lexer.getPosition()

        var ret: EnumMember = new EnumMember(enumCase, additionalCases, parameterClause, new Position(start), new Position(end))
        enumCase.parent = ret
        if additionalCases != null {
            for item: AdditionalCase in additionalCases
                item.parent = ret
        }
        if parameterClause != null
            parameterClause.parent = ret

        ret
    }

    function parseEnumCase(): EnumCase {
        let start: Position$ = lexer.getPreviousPosition()

        let name: string = lexer.parseIdentifier()
        if (name != null) && isIdentifier(name)
            lexer.advance()
        else
            return(null)

        let end: Position$ = lexer.getPosition()

        var ret: EnumCase = new EnumCase(name, new Position(start), new Position(end))

        ret
    }

    function parseAdditionalCaseList(): AdditionalCase[] {
        mutable ret: AdditionalCase[]$ = null
        while true {

            let node: AdditionalCase = parseAdditionalCase()
            if node == null
                break

            if ret == null
                ret = new AdditionalCase[]()

            ret.push(node)
        }

        return(ret)
    }

    function parseAdditionalCase(): AdditionalCase {
        let start: Position$ = lexer.getPreviousPosition()

        let successComma1: bool = lexer.parsePunctuation(comma)
        if successComma1
            lexer.advance()
        else
            return(null)

        let enumCase: EnumCase = parseEnumCase()
        if enumCase == null
            return(null)

        let end: Position$ = lexer.getPosition()

        var ret: AdditionalCase = new AdditionalCase(enumCase, new Position(start), new Position(end))
        enumCase.parent = ret

        ret
    }

    function parseClassBody(): ClassBody {
        let start: Position$ = lexer.getPreviousPosition()

        let successLeftCurly1: bool = lexer.parsePunctuation(leftCurly)
        if successLeftCurly1
            lexer.advance()
        else
            return(null)

        let members: ClassMember[] = parseClassMemberList()

        let successRightCurly3: bool = lexer.parsePunctuation(rightCurly)
        if successRightCurly3
            lexer.advance()
        else
            return(null)

        let end: Position$ = lexer.getPosition()

        var ret: ClassBody = new ClassBody(members, new Position(start), new Position(end))
        if members != null {
            for item: ClassMember in members
                item.parent = ret
        }

        ret
    }

    function parseClassMemberList(): ClassMember[] {
        mutable ret: ClassMember[]$ = null
        while true {

            let node: ClassMember = parseClassMember()
            if node == null
                break

            if ret == null
                ret = new ClassMember[]()

            ret.push(node)
        }

        return(ret)
    }

    function parseClassMember(): ClassMember {
        let start: Position$ = lexer.getPreviousPosition()

        let declaration: Declaration = parseDeclaration()
        if declaration == null
            return(null)

        let end: Position$ = lexer.getPosition()

        var ret: ClassMember = new ClassMember(declaration, new Position(start), new Position(end))
        declaration.parent = ret

        ret
    }

    function parsePrefixExpression(): PrefixExpression {
        let start: Position$ = lexer.getPreviousPosition()

        let prefixOperator: string = lexer.parsePrefixOperator()
        if prefixOperator != null
            lexer.advance()

        let expression: PostfixExpression = parsePostfixExpression()
        if expression == null
            return(null)

        let end: Position$ = lexer.getPosition()

        var ret: PrefixExpression = new PrefixExpression(prefixOperator, expression, new Position(start), new Position(end))
        expression.parent = ret

        ret
    }

    function parsePostfixExpression(): PostfixExpression {
        let start: Position$ = lexer.getPreviousPosition()

        let primaryExpression: PrimaryExpression = parsePrimaryExpression()
        if primaryExpression == null
            return(null)

        let postfixes: Postfix[] = parsePostfixList()

        let end: Position$ = lexer.getPosition()

        var ret: PostfixExpression = new PostfixExpression(primaryExpression, postfixes, new Position(start), new Position(end))
        primaryExpression.parent = ret
        if postfixes != null {
            for item: Postfix in postfixes
                item.parent = ret
        }

        ret
    }

    function parseBinaryOpList(): BinaryOp[] {
        mutable ret: BinaryOp[]$ = null
        while true {

            let node: BinaryOp = parseBinaryOp()
            if node == null
                break

            if ret == null
                ret = new BinaryOp[]()

            ret.push(node)
        }

        return(ret)
    }

    function parseBinaryOp(): BinaryOp {
        {
            let node: BinaryOperation = parseBinaryOperation()
            if node != null
                return(node)
        }

        {
            let node: Assignment = parseAssignment()
            if node != null
                return(node)
        }

        {
            let node: TypeQuery = parseTypeQuery()
            if node != null
                return(node)
        }

        {
            let node: TypeCast = parseTypeCast()
            if node != null
                return(node)
        }

        null
    }

    function parseBinaryOperation(): BinaryOperation {
        let start: Position$ = lexer.getPreviousPosition()

        let binaryOperator: string = lexer.parseBinaryOperator()
        if binaryOperator != null
            lexer.advance()
        else
            return(null)

        let expression: PrefixExpression = parsePrefixExpression()
        if expression == null
            return(null)

        let end: Position$ = lexer.getPosition()

        var ret: BinaryOperation = new BinaryOperation(binaryOperator, expression, new Position(start), new Position(end))
        expression.parent = ret

        ret
    }

    function parseAssignment(): Assignment {
        let start: Position$ = lexer.getPreviousPosition()

        let successEqual1: bool = lexer.parsePunctuation(equal)
        if successEqual1
            lexer.advance()
        else
            return(null)

        let expression: Expression = parseExpression()
        if expression == null
            return(null)

        let end: Position$ = lexer.getPosition()

        var ret: Assignment = new Assignment(expression, new Position(start), new Position(end))
        expression.parent = ret

        ret
    }

    function parseTypeQuery(): TypeQuery {
        let start: Position$ = lexer.getPreviousPosition()

        let successIs1: bool = lexer.parseKeyword(isKeyword)
        if successIs1
            lexer.advance()
        else
            return(null)

        let objectType: Type = parseType()
        if objectType == null
            return(null)

        let end: Position$ = lexer.getPosition()

        var ret: TypeQuery = new TypeQuery(objectType, new Position(start), new Position(end))
        objectType.parent = ret

        ret
    }

    function parseTypeCast(): TypeCast {
        let start: Position$ = lexer.getPreviousPosition()

        let successAs1: bool = lexer.parseKeyword(asKeyword)
        if successAs1
            lexer.advance()
        else
            return(null)

        let objectType: Type = parseType()
        if objectType == null
            return(null)

        let end: Position$ = lexer.getPosition()

        var ret: TypeCast = new TypeCast(objectType, new Position(start), new Position(end))
        objectType.parent = ret

        ret
    }

    function parseCatchClauseList(): CatchClause[] {
        mutable ret: CatchClause[]$ = null
        while true {

            let node: CatchClause = parseCatchClause()
            if node == null
                break

            if ret == null
                ret = new CatchClause[]()

            ret.push(node)
        }

        return(ret)
    }

    function parseCatchClause(): CatchClause {
        let start: Position$ = lexer.getPreviousPosition()

        let successCatch1: bool = lexer.parseKeyword(catchKeyword)
        if successCatch1
            lexer.advance()
        else
            return(null)

        let catchPattern: CatchPattern = parseCatchPattern()
        if catchPattern == null
            return(null)

        let bindingPattern: TuplePattern = parseTuplePattern()

        let expression: Expression = parseExpression()
        if expression == null
            return(null)

        let end: Position$ = lexer.getPosition()

        var ret: CatchClause = new CatchClause(catchPattern, bindingPattern, expression, new Position(start), new Position(end))
        catchPattern.parent = ret
        if bindingPattern != null
            bindingPattern.parent = ret
        expression.parent = ret

        ret
    }

    function parseCatchPattern(): CatchPattern {
        {
            let node: WildCardCatchPattern = parseWildCardCatchPattern()
            if node != null
                return(node)
        }

        {
            let node: IdentifierCatchPattern = parseIdentifierCatchPattern()
            if node != null
                return(node)
        }

        null
    }

    function parseWildCardCatchPattern(): WildCardCatchPattern {
        let start: Position$ = lexer.getPreviousPosition()

        let pattern: WildcardPattern = parseWildcardPattern()
        if pattern == null
            return(null)

        let end: Position$ = lexer.getPosition()

        var ret: WildCardCatchPattern = new WildCardCatchPattern(pattern, new Position(start), new Position(end))
        pattern.parent = ret

        ret
    }

    function parseIdentifierCatchPattern(): IdentifierCatchPattern {
        let start: Position$ = lexer.getPreviousPosition()

        let name: string = lexer.parseIdentifier()
        if (name != null) && isIdentifier(name)
            lexer.advance()
        else
            return(null)

        let member: MemberExpression = parseMemberExpression()

        let end: Position$ = lexer.getPosition()

        var ret: IdentifierCatchPattern = new IdentifierCatchPattern(name, member, new Position(start), new Position(end))
        if member != null
            member.parent = ret

        ret
    }

    function parsePostfixList(): Postfix[] {
        mutable ret: Postfix[]$ = null
        while true {

            let node: Postfix = parsePostfix()
            if node == null
                break

            if ret == null
                ret = new Postfix[]()

            ret.push(node)
        }

        return(ret)
    }

    function parsePostfix(): Postfix {
        {
            let node: OperatorPostfix = parseOperatorPostfix()
            if node != null
                return(node)
        }

        {
            let node: FunctionCall = parseFunctionCall()
            if node != null
                return(node)
        }

        {
            let node: MemberExpression = parseMemberExpression()
            if node != null
                return(node)
        }

        {
            let node: Subscript = parseSubscript()
            if node != null
                return(node)
        }

        null
    }

    function parseOperatorPostfix(): OperatorPostfix {
        let start: Position$ = lexer.getPreviousPosition()

        let postfixOperator: string = lexer.parsePostfixOperator()
        if postfixOperator != null
            lexer.advance()
        else
            return(null)

        let end: Position$ = lexer.getPosition()

        var ret: OperatorPostfix = new OperatorPostfix(postfixOperator, new Position(start), new Position(end))

        ret
    }

    function parseFunctionCall(): FunctionCall {
        let start: Position$ = lexer.getPreviousPosition()

        let arguments: ParenthesizedExpression = parseParenthesizedExpression()
        if arguments == null
            return(null)

        let catchClauses: CatchClause[] = parseCatchClauseList()

        let end: Position$ = lexer.getPosition()

        var ret: FunctionCall = new FunctionCall(arguments, catchClauses, new Position(start), new Position(end))
        arguments.parent = ret
        if catchClauses != null {
            for item: CatchClause in catchClauses
                item.parent = ret
        }

        ret
    }

    function parseMemberExpression(): MemberExpression {
        let start: Position$ = lexer.getPreviousPosition()

        let successDot1: bool = lexer.parsePunctuation(dot)
        if successDot1
            lexer.advance()
        else
            return(null)

        let member: string = lexer.parseIdentifier()
        if (member != null) && isIdentifier(member)
            lexer.advance()
        else
            return(null)

        let end: Position$ = lexer.getPosition()

        var ret: MemberExpression = new MemberExpression(member, new Position(start), new Position(end))

        ret
    }

    function parseSubscript(): Subscript {
        let start: Position$ = lexer.getPreviousPosition()

        let successLeftBracket1: bool = lexer.parsePunctuation(leftBracket)
        if successLeftBracket1
            lexer.advance()
        else
            return(null)

        let expressions: ExpressionElement[] = parseExpressionElementList()

        let successRightBracket3: bool = lexer.parsePunctuation(rightBracket)
        if successRightBracket3
            lexer.advance()
        else
            return(null)

        let end: Position$ = lexer.getPosition()

        var ret: Subscript = new Subscript(expressions, new Position(start), new Position(end))
        if expressions != null {
            for item: ExpressionElement in expressions
                item.parent = ret
        }

        ret
    }

    function parseExpressionElementList(): ExpressionElement[] {
        mutable ret: ExpressionElement[]$ = null
        while true {

            let node: ExpressionElement = parseExpressionElement()
            if node == null
                break

            if ret == null
                ret = new ExpressionElement[]()

            ret.push(node)
        }

        return(ret)
    }

    function parseExpressionElement(): ExpressionElement {
        let start: Position$ = lexer.getPreviousPosition()

        let expression: Expression = parseExpression()
        if expression == null
            return(null)

        let successComma2: bool = lexer.parsePunctuation(comma)
        if successComma2
            lexer.advance()

        let end: Position$ = lexer.getPosition()

        var ret: ExpressionElement = new ExpressionElement(expression, new Position(start), new Position(end))
        expression.parent = ret

        ret
    }

    function parsePrimaryExpression(): PrimaryExpression {
        {
            let node: IdentifierExpression = parseIdentifierExpression()
            if node != null
                return(node)
        }

        {
            let node: LiteralExpression = parseLiteralExpression()
            if node != null
                return(node)
        }

        {
            let node: IfExpression = parseIfExpression()
            if node != null
                return(node)
        }

        {
            let node: SwitchExpression = parseSwitchExpression()
            if node != null
                return(node)
        }

        {
            let node: ForExpression = parseForExpression()
            if node != null
                return(node)
        }

        {
            let node: WhileExpression = parseWhileExpression()
            if node != null
                return(node)
        }

        {
            let node: DoExpression = parseDoExpression()
            if node != null
                return(node)
        }

        {
            let node: ParenthesizedExpression = parseParenthesizedExpression()
            if node != null
                return(node)
        }

        {
            let node: ReturnExpression = parseReturnExpression()
            if node != null
                return(node)
        }

        {
            let node: ThrowExpression = parseThrowExpression()
            if node != null
                return(node)
        }

        {
            let node: BreakExpression = parseBreakExpression()
            if node != null
                return(node)
        }

        {
            let node: ConstructorCall = parseConstructorCall()
            if node != null
                return(node)
        }

        {
            let node: ThisExpression = parseThisExpression()
            if node != null
                return(node)
        }

        {
            let node: NullExpression = parseNullExpression()
            if node != null
                return(node)
        }

        null
    }

    function parseIdentifierExpression(): IdentifierExpression {
        let start: Position$ = lexer.getPreviousPosition()

        let name: string = lexer.parseIdentifier()
        if (name != null) && isIdentifier(name)
            lexer.advance()
        else
            return(null)

        let end: Position$ = lexer.getPosition()

        var ret: IdentifierExpression = new IdentifierExpression(name, new Position(start), new Position(end))

        ret
    }

    function parseLiteralExpression(): LiteralExpression {
        let start: Position$ = lexer.getPreviousPosition()

        let literal: Literal = lexer.parseLiteral()
        if literal != null
            lexer.advance()
        else
            return(null)

        let end: Position$ = lexer.getPosition()

        var ret: LiteralExpression = new LiteralExpression(literal, new Position(start), new Position(end))

        ret
    }

    function parseIfExpression(): IfExpression {
        let start: Position$ = lexer.getPreviousPosition()

        let successIf1: bool = lexer.parseKeyword(ifKeyword)
        if successIf1
            lexer.advance()
        else
            return(null)

        let condition: Expression = parseExpression()
        if condition == null
            return(null)

        let consequent: Expression = parseExpression()
        if consequent == null
            return(null)

        let elseClause: ElseClause = parseElseClause()

        let end: Position$ = lexer.getPosition()

        var ret: IfExpression = new IfExpression(condition, consequent, elseClause, new Position(start), new Position(end))
        condition.parent = ret
        consequent.parent = ret
        if elseClause != null
            elseClause.parent = ret

        ret
    }

    function parseSwitchExpression(): SwitchExpression {
        let start: Position$ = lexer.getPreviousPosition()

        let successSwitch1: bool = lexer.parseKeyword(switchKeyword)
        if successSwitch1
            lexer.advance()
        else
            return(null)

        let expression: Expression = parseExpression()
        if expression == null
            return(null)

        let body: SwitchBody = parseSwitchBody()
        if body == null
            return(null)

        let end: Position$ = lexer.getPosition()

        var ret: SwitchExpression = new SwitchExpression(expression, body, new Position(start), new Position(end))
        expression.parent = ret
        body.parent = ret

        ret
    }

    function parseForExpression(): ForExpression {
        let start: Position$ = lexer.getPreviousPosition()

        let successFor1: bool = lexer.parseKeyword(forKeyword)
        if successFor1
            lexer.advance()
        else
            return(null)

        let pattern: Pattern = parsePattern()
        if pattern == null
            return(null)

        let successIn3: bool = lexer.parseKeyword(inKeyword)
        if successIn3
            lexer.advance()
        else
            return(null)

        let expression: Expression = parseExpression()
        if expression == null
            return(null)

        let code: Expression = parseExpression()
        if code == null
            return(null)

        let end: Position$ = lexer.getPosition()

        var ret: ForExpression = new ForExpression(pattern, expression, code, new Position(start), new Position(end))
        pattern.parent = ret
        expression.parent = ret
        code.parent = ret

        ret
    }

    function parseWhileExpression(): WhileExpression {
        let start: Position$ = lexer.getPreviousPosition()

        let successWhile1: bool = lexer.parseKeyword(whileKeyword)
        if successWhile1
            lexer.advance()
        else
            return(null)

        let condition: Expression = parseExpression()
        if condition == null
            return(null)

        let code: Expression = parseExpression()
        if code == null
            return(null)

        let end: Position$ = lexer.getPosition()

        var ret: WhileExpression = new WhileExpression(condition, code, new Position(start), new Position(end))
        condition.parent = ret
        code.parent = ret

        ret
    }

    function parseDoExpression(): DoExpression {
        let start: Position$ = lexer.getPreviousPosition()

        let successDo1: bool = lexer.parseKeyword(doKeyword)
        if successDo1
            lexer.advance()
        else
            return(null)

        let code: Expression = parseExpression()
        if code == null
            return(null)

        let successWhile3: bool = lexer.parseKeyword(whileKeyword)
        if successWhile3
            lexer.advance()
        else
            return(null)

        let condition: Expression = parseExpression()
        if condition == null
            return(null)

        let end: Position$ = lexer.getPosition()

        var ret: DoExpression = new DoExpression(code, condition, new Position(start), new Position(end))
        code.parent = ret
        condition.parent = ret

        ret
    }

    function parseParenthesizedExpression(): ParenthesizedExpression {
        let start: Position$ = lexer.getPreviousPosition()

        let successLeftParen1: bool = lexer.parsePunctuation(leftParen)
        if successLeftParen1
            lexer.advance()
        else
            return(null)

        let expressionElements: ExpressionElement[] = parseExpressionElementList()

        let successRightParen3: bool = lexer.parsePunctuation(rightParen)
        if successRightParen3
            lexer.advance()
        else
            return(null)

        let end: Position$ = lexer.getPosition()

        var ret: ParenthesizedExpression = new ParenthesizedExpression(expressionElements, new Position(start), new Position(end))
        if expressionElements != null {
            for item: ExpressionElement in expressionElements
                item.parent = ret
        }

        ret
    }

    function parseReturnExpression(): ReturnExpression {
        let start: Position$ = lexer.getPreviousPosition()

        let successReturn1: bool = lexer.parseKeyword(returnKeyword)
        if successReturn1
            lexer.advance()
        else
            return(null)

        let expression: ParenthesizedExpression = parseParenthesizedExpression()

        let end: Position$ = lexer.getPosition()

        var ret: ReturnExpression = new ReturnExpression(expression, new Position(start), new Position(end))
        if expression != null
            expression.parent = ret

        ret
    }

    function parseThrowExpression(): ThrowExpression {
        let start: Position$ = lexer.getPreviousPosition()

        let successThrow1: bool = lexer.parseKeyword(throwKeyword)
        if successThrow1
            lexer.advance()
        else
            return(null)

        let error: IdentifierExpression = parseIdentifierExpression()
        if error == null
            return(null)

        let arguments: ParenthesizedExpression = parseParenthesizedExpression()

        let end: Position$ = lexer.getPosition()

        var ret: ThrowExpression = new ThrowExpression(error, arguments, new Position(start), new Position(end))
        error.parent = ret
        if arguments != null
            arguments.parent = ret

        ret
    }

    function parseBreakExpression(): BreakExpression {
        let start: Position$ = lexer.getPreviousPosition()

        let successBreak1: bool = lexer.parseKeyword(breakKeyword)
        if successBreak1
            lexer.advance()
        else
            return(null)

        let expression: ParenthesizedExpression = parseParenthesizedExpression()

        let end: Position$ = lexer.getPosition()

        var ret: BreakExpression = new BreakExpression(expression, new Position(start), new Position(end))
        if expression != null
            expression.parent = ret

        ret
    }

    function parseConstructorCall(): ConstructorCall {
        let start: Position$ = lexer.getPreviousPosition()

        let successNew1: bool = lexer.parseKeyword(newKeyword)
        if successNew1
            lexer.advance()
        else
            return(null)

        let typeToConstruct: Type = parseType()
        if typeToConstruct == null
            return(null)

        let arguments: ParenthesizedExpression = parseParenthesizedExpression()
        if arguments == null
            return(null)

        let catchClauses: CatchClause[] = parseCatchClauseList()

        let end: Position$ = lexer.getPosition()

        var ret: ConstructorCall = new ConstructorCall(typeToConstruct, arguments, catchClauses, new Position(start), new Position(end))
        typeToConstruct.parent = ret
        arguments.parent = ret
        if catchClauses != null {
            for item: CatchClause in catchClauses
                item.parent = ret
        }

        ret
    }

    function parseThisExpression(): ThisExpression {
        let start: Position$ = lexer.getPreviousPosition()

        let successThis1: bool = lexer.parseKeyword(thisKeyword)
        if successThis1
            lexer.advance()
        else
            return(null)

        let end: Position$ = lexer.getPosition()

        var ret: ThisExpression = new ThisExpression(new Position(start), new Position(end))

        ret
    }

    function parseNullExpression(): NullExpression {
        let start: Position$ = lexer.getPreviousPosition()

        let successNull1: bool = lexer.parseKeyword(nullKeyword)
        if successNull1
            lexer.advance()
        else
            return(null)

        let end: Position$ = lexer.getPosition()

        var ret: NullExpression = new NullExpression(new Position(start), new Position(end))

        ret
    }

    function parseElseClause(): ElseClause {
        let start: Position$ = lexer.getPreviousPosition()

        let successElse1: bool = lexer.parseKeyword(elseKeyword)
        if successElse1
            lexer.advance()
        else
            return(null)

        let alternative: Expression = parseExpression()
        if alternative == null
            return(null)

        let end: Position$ = lexer.getPosition()

        var ret: ElseClause = new ElseClause(alternative, new Position(start), new Position(end))
        alternative.parent = ret

        ret
    }

    function parseSwitchBody(): SwitchBody {
        {
            let node: CurliedSwitchBody = parseCurliedSwitchBody()
            if node != null
                return(node)
        }

        {
            let node: NakedSwitchBody = parseNakedSwitchBody()
            if node != null
                return(node)
        }

        null
    }

    function parseCurliedSwitchBody(): CurliedSwitchBody {
        let start: Position$ = lexer.getPreviousPosition()

        let successLeftCurly1: bool = lexer.parsePunctuation(leftCurly)
        if successLeftCurly1
            lexer.advance()
        else
            return(null)

        let cases: SwitchCase[] = parseSwitchCaseList()

        let successRightCurly3: bool = lexer.parsePunctuation(rightCurly)
        if successRightCurly3
            lexer.advance()
        else
            return(null)

        let end: Position$ = lexer.getPosition()

        var ret: CurliedSwitchBody = new CurliedSwitchBody(cases, new Position(start), new Position(end))
        if cases != null {
            for item: SwitchCase in cases
                item.parent = ret
        }

        ret
    }

    function parseNakedSwitchBody(): NakedSwitchBody {
        let start: Position$ = lexer.getPreviousPosition()

        let cases: SwitchCase[] = parseSwitchCaseList()

        let end: Position$ = lexer.getPosition()

        var ret: NakedSwitchBody = new NakedSwitchBody(cases, new Position(start), new Position(end))
        if cases != null {
            for item: SwitchCase in cases
                item.parent = ret
        }

        ret
    }

    function parseSwitchCaseList(): SwitchCase[] {
        mutable ret: SwitchCase[]$ = null
        while true {

            let node: SwitchCase = parseSwitchCase()
            if node == null
                break

            if ret == null
                ret = new SwitchCase[]()

            ret.push(node)
        }

        return(ret)
    }

    function parseSwitchCase(): SwitchCase {
        let start: Position$ = lexer.getPreviousPosition()

        let label: CaseLabel = parseCaseLabel()
        if label == null
            return(null)

        let content: CaseContent = parseCaseContent()
        if content == null
            return(null)

        let end: Position$ = lexer.getPosition()

        var ret: SwitchCase = new SwitchCase(label, content, new Position(start), new Position(end))
        label.parent = ret
        content.parent = ret

        ret
    }

    function parseCaseLabel(): CaseLabel {
        {
            let node: ItemCaseLabel = parseItemCaseLabel()
            if node != null
                return(node)
        }

        {
            let node: DefaultCaseLabel = parseDefaultCaseLabel()
            if node != null
                return(node)
        }

        null
    }

    function parseItemCaseLabel(): ItemCaseLabel {
        let start: Position$ = lexer.getPreviousPosition()

        let successCase1: bool = lexer.parseKeyword(caseKeyword)
        if successCase1
            lexer.advance()
        else
            return(null)

        let pattern: Pattern = parsePattern()
        if pattern == null
            return(null)

        let additionalPatterns: CaseItem[] = parseCaseItemList()

        let successColon4: bool = lexer.parsePunctuation(colon)
        if successColon4
            lexer.advance()
        else
            return(null)

        let end: Position$ = lexer.getPosition()

        var ret: ItemCaseLabel = new ItemCaseLabel(pattern, additionalPatterns, new Position(start), new Position(end))
        pattern.parent = ret
        if additionalPatterns != null {
            for item: CaseItem in additionalPatterns
                item.parent = ret
        }

        ret
    }

    function parseDefaultCaseLabel(): DefaultCaseLabel {
        let start: Position$ = lexer.getPreviousPosition()

        let successDefault1: bool = lexer.parseKeyword(defaultKeyword)
        if successDefault1
            lexer.advance()
        else
            return(null)

        let successColon2: bool = lexer.parsePunctuation(colon)
        if successColon2
            lexer.advance()
        else
            return(null)

        let end: Position$ = lexer.getPosition()

        var ret: DefaultCaseLabel = new DefaultCaseLabel(new Position(start), new Position(end))

        ret
    }

    function parseCaseItemList(): CaseItem[] {
        mutable ret: CaseItem[]$ = null
        while true {

            let node: CaseItem = parseCaseItem()
            if node == null
                break

            if ret == null
                ret = new CaseItem[]()

            ret.push(node)
        }

        return(ret)
    }

    function parseCaseItem(): CaseItem {
        let start: Position$ = lexer.getPreviousPosition()

        let successComma1: bool = lexer.parsePunctuation(comma)
        if successComma1
            lexer.advance()
        else
            return(null)

        let pattern: Pattern = parsePattern()
        if pattern == null
            return(null)

        let end: Position$ = lexer.getPosition()

        var ret: CaseItem = new CaseItem(pattern, new Position(start), new Position(end))
        pattern.parent = ret

        ret
    }

    function parsePattern(): Pattern {
        {
            let node: WildcardPattern = parseWildcardPattern()
            if node != null
                return(node)
        }

        {
            let node: IdentifierPattern = parseIdentifierPattern()
            if node != null
                return(node)
        }

        {
            let node: TuplePattern = parseTuplePattern()
            if node != null
                return(node)
        }

        {
            let node: ExpressionPattern = parseExpressionPattern()
            if node != null
                return(node)
        }

        null
    }

    function parseWildcardPattern(): WildcardPattern {
        let start: Position$ = lexer.getPreviousPosition()

        let successUnderscore1: bool = lexer.parsePunctuation(underscore)
        if successUnderscore1
            lexer.advance()
        else
            return(null)

        let end: Position$ = lexer.getPosition()

        var ret: WildcardPattern = new WildcardPattern(new Position(start), new Position(end))

        ret
    }

    function parseIdentifierPattern(): IdentifierPattern {
        let start: Position$ = lexer.getPreviousPosition()

        let identifier: string = lexer.parseIdentifier()
        if (identifier != null) && isIdentifier(identifier)
            lexer.advance()
        else
            return(null)

        let annotationForType: TypeAnnotation = parseTypeAnnotation()

        let end: Position$ = lexer.getPosition()

        var ret: IdentifierPattern = new IdentifierPattern(identifier, annotationForType, new Position(start), new Position(end))
        if annotationForType != null
            annotationForType.parent = ret

        ret
    }

    function parseTuplePattern(): TuplePattern {
        let start: Position$ = lexer.getPreviousPosition()

        let successLeftParen1: bool = lexer.parsePunctuation(leftParen)
        if successLeftParen1
            lexer.advance()
        else
            return(null)

        let elements: TuplePatternElement[] = parseTuplePatternElementList()

        let successRightParen3: bool = lexer.parsePunctuation(rightParen)
        if successRightParen3
            lexer.advance()
        else
            return(null)

        let end: Position$ = lexer.getPosition()

        var ret: TuplePattern = new TuplePattern(elements, new Position(start), new Position(end))
        if elements != null {
            for item: TuplePatternElement in elements
                item.parent = ret
        }

        ret
    }

    function parseExpressionPattern(): ExpressionPattern {
        let start: Position$ = lexer.getPreviousPosition()

        let expression: Expression = parseExpression()
        if expression == null
            return(null)

        let end: Position$ = lexer.getPosition()

        var ret: ExpressionPattern = new ExpressionPattern(expression, new Position(start), new Position(end))
        expression.parent = ret

        ret
    }

    function parseTuplePatternElementList(): TuplePatternElement[] {
        mutable ret: TuplePatternElement[]$ = null
        while true {

            let node: TuplePatternElement = parseTuplePatternElement()
            if node == null
                break

            if ret == null
                ret = new TuplePatternElement[]()

            ret.push(node)
        }

        return(ret)
    }

    function parseTuplePatternElement(): TuplePatternElement {
        let start: Position$ = lexer.getPreviousPosition()

        let pattern: Pattern = parsePattern()
        if pattern == null
            return(null)

        let successComma2: bool = lexer.parsePunctuation(comma)
        if successComma2
            lexer.advance()

        let end: Position$ = lexer.getPosition()

        var ret: TuplePatternElement = new TuplePatternElement(pattern, new Position(start), new Position(end))
        pattern.parent = ret

        ret
    }

    function parseCaseContent(): CaseContent {
        let start: Position$ = lexer.getPreviousPosition()

        let statements: Statement[] = parseStatementList()

        let end: Position$ = lexer.getPosition()

        var ret: CaseContent = new CaseContent(statements, new Position(start), new Position(end))
        if statements != null {
            for item: Statement in statements
                item.parent = ret
        }

        ret
    }

    function parseType(): Type {
        let start: Position$ = lexer.getPreviousPosition()

        let name: string = lexer.parseIdentifier()
        if (name != null) && isIdentifier(name)
            lexer.advance()
        else
            return(null)

        let subType: Subtype = parseSubtype()

        let postfixes: TypePostfix[] = parseTypePostfixList()

        let lifeTime: LifeTime = parseLifeTime()

        let end: Position$ = lexer.getPosition()

        var ret: Type = new Type(name, subType, postfixes, lifeTime, new Position(start), new Position(end))
        if subType != null
            subType.parent = ret
        if postfixes != null {
            for item: TypePostfix in postfixes
                item.parent = ret
        }
        if lifeTime != null
            lifeTime.parent = ret

        ret
    }

    function parseTypeAnnotation(): TypeAnnotation {
        let start: Position$ = lexer.getPreviousPosition()

        let successColon1: bool = lexer.parsePunctuation(colon)
        if successColon1
            lexer.advance()
        else
            return(null)

        let annotationForType: Type = parseType()
        if annotationForType == null
            return(null)

        let end: Position$ = lexer.getPosition()

        var ret: TypeAnnotation = new TypeAnnotation(annotationForType, new Position(start), new Position(end))
        annotationForType.parent = ret

        ret
    }

    function parseSubtype(): Subtype {
        let start: Position$ = lexer.getPreviousPosition()

        let successDot1: bool = lexer.parsePunctuation(dot)
        if successDot1
            lexer.advance()
        else
            return(null)

        let type: Type = parseType()
        if type == null
            return(null)

        let end: Position$ = lexer.getPosition()

        var ret: Subtype = new Subtype(type, new Position(start), new Position(end))
        type.parent = ret

        ret
    }

    function parseTypePostfixList(): TypePostfix[] {
        mutable ret: TypePostfix[]$ = null
        while true {

            let node: TypePostfix = parseTypePostfix()
            if node == null
                break

            if ret == null
                ret = new TypePostfix[]()

            ret.push(node)
        }

        return(ret)
    }

    function parseTypePostfix(): TypePostfix {
        {
            let node: IndexedType = parseIndexedType()
            if node != null
                return(node)
        }

        {
            let node: Pointer = parsePointer()
            if node != null
                return(node)
        }

        null
    }

    function parseIndexedType(): IndexedType {
        let start: Position$ = lexer.getPreviousPosition()

        let successLeftBracket1: bool = lexer.parsePunctuation(leftBracket)
        if successLeftBracket1
            lexer.advance()
        else
            return(null)

        let key: Type = parseType()

        let successRightBracket3: bool = lexer.parsePunctuation(rightBracket)
        if successRightBracket3
            lexer.advance()
        else
            return(null)

        let end: Position$ = lexer.getPosition()

        var ret: IndexedType = new IndexedType(key, new Position(start), new Position(end))
        if key != null
            key.parent = ret

        ret
    }

    function parsePointer(): Pointer {
        let start: Position$ = lexer.getPreviousPosition()

        let successCircumflex1: bool = lexer.parsePunctuation(circumflex)
        if successCircumflex1
            lexer.advance()
        else
            return(null)

        let end: Position$ = lexer.getPosition()

        var ret: Pointer = new Pointer(new Position(start), new Position(end))

        ret
    }

    function parseLifeTime(): LifeTime {
        {
            let node: Root = parseRoot()
            if node != null
                return(node)
        }

        {
            let node: Local = parseLocal()
            if node != null
                return(node)
        }

        {
            let node: Reference = parseReference()
            if node != null
                return(node)
        }

        {
            let node: Thrown = parseThrown()
            if node != null
                return(node)
        }

        null
    }

    function parseRoot(): Root {
        let start: Position$ = lexer.getPreviousPosition()

        let successDollar1: bool = lexer.parsePunctuation(dollar)
        if successDollar1
            lexer.advance()
        else
            return(null)

        let end: Position$ = lexer.getPosition()

        var ret: Root = new Root(new Position(start), new Position(end))

        ret
    }

    function parseLocal(): Local {
        let start: Position$ = lexer.getPreviousPosition()

        let successAt1: bool = lexer.parsePunctuation(at)
        if successAt1
            lexer.advance()
        else
            return(null)

        let location: string = lexer.parseIdentifier()
        if (location != null) && isIdentifier(location)
            lexer.advance()
        else
            return(null)

        let end: Position$ = lexer.getPosition()

        var ret: Local = new Local(location, new Position(start), new Position(end))

        ret
    }

    function parseReference(): Reference {
        let start: Position$ = lexer.getPreviousPosition()

        let successAmpersand1: bool = lexer.parsePunctuation(ampersand)
        if successAmpersand1
            lexer.advance()
        else
            return(null)

        let age: Literal = lexer.parseLiteral()
        if age != null
            lexer.advance()

        let end: Position$ = lexer.getPosition()

        var ret: Reference = new Reference(age, new Position(start), new Position(end))

        ret
    }

    function parseThrown(): Thrown {
        let start: Position$ = lexer.getPreviousPosition()

        let successHash1: bool = lexer.parsePunctuation(hash)
        if successHash1
            lexer.advance()
        else
            return(null)

        let end: Position$ = lexer.getPosition()

        var ret: Thrown = new Thrown(new Position(start), new Position(end))

        ret
    }

    function parseTypeInheritanceClause(): TypeInheritanceClause {
        let start: Position$ = lexer.getPreviousPosition()

        let successExtends1: bool = lexer.parseKeyword(extendsKeyword)
        if successExtends1
            lexer.advance()
        else
            return(null)

        let inheritances: Inheritance[] = parseInheritanceList()

        let end: Position$ = lexer.getPosition()

        var ret: TypeInheritanceClause = new TypeInheritanceClause(inheritances, new Position(start), new Position(end))
        if inheritances != null {
            for item: Inheritance in inheritances
                item.parent = ret
        }

        ret
    }

    function parseInheritanceList(): Inheritance[] {
        mutable ret: Inheritance[]$ = null
        while true {

            let node: Inheritance = parseInheritance()
            if node == null
                break

            if ret == null
                ret = new Inheritance[]()

            ret.push(node)
        }

        return(ret)
    }

    function parseInheritance(): Inheritance {
        let start: Position$ = lexer.getPreviousPosition()

        let type: Type = parseType()
        if type == null
            return(null)

        let successComma2: bool = lexer.parsePunctuation(comma)
        if successComma2
            lexer.advance()

        let end: Position$ = lexer.getPosition()

        var ret: Inheritance = new Inheritance(type, new Position(start), new Position(end))
        type.parent = ret

        ret
    }

    function isAtEnd(): bool {
        lexer.isAtEnd()
    }

    function isIdentifier(id: string): bool {
        if id.equals(classKeyword)
            return(false)

        if id.equals(functionKeyword)
            return(false)

        if id.equals(ifKeyword)
            return(false)

        if id.equals(elseKeyword)
            return(false)

        if id.equals(switchKeyword)
            return(false)

        if id.equals(caseKeyword)
            return(false)

        if id.equals(defaultKeyword)
            return(false)

        if id.equals(catchKeyword)
            return(false)

        if id.equals(forKeyword)
            return(false)

        if id.equals(inKeyword)
            return(false)

        if id.equals(whileKeyword)
            return(false)

        if id.equals(doKeyword)
            return(false)

        if id.equals(returnKeyword)
            return(false)

        if id.equals(throwKeyword)
            return(false)

        if id.equals(breakKeyword)
            return(false)

        if id.equals(throwsKeyword)
            return(false)

        if id.equals(overrideKeyword)
            return(false)

        if id.equals(staticKeyword)
            return(false)

        if id.equals(letKeyword)
            return(false)

        if id.equals(varKeyword)
            return(false)

        if id.equals(mutableKeyword)
            return(false)

        if id.equals(isKeyword)
            return(false)

        if id.equals(asKeyword)
            return(false)

        if id.equals(constructorKeyword)
            return(false)

        if id.equals(enumKeyword)
            return(false)

        if id.equals(thisKeyword)
            return(false)

        if id.equals(nullKeyword)
            return(false)

        if id.equals(newKeyword)
            return(false)

        if id.equals(extendsKeyword)
            return(false)

        return(true)
    }

    mutable lexer: Lexer
    let fileName: string

    let classKeyword: string
    let functionKeyword: string
    let ifKeyword: string
    let elseKeyword: string
    let switchKeyword: string
    let caseKeyword: string
    let defaultKeyword: string
    let catchKeyword: string
    let forKeyword: string
    let inKeyword: string
    let whileKeyword: string
    let doKeyword: string
    let returnKeyword: string
    let throwKeyword: string
    let breakKeyword: string
    let throwsKeyword: string
    let overrideKeyword: string
    let staticKeyword: string
    let letKeyword: string
    let varKeyword: string
    let mutableKeyword: string
    let isKeyword: string
    let asKeyword: string
    let constructorKeyword: string
    let enumKeyword: string
    let thisKeyword: string
    let nullKeyword: string
    let newKeyword: string
    let extendsKeyword: string
    let equal: string
    let comma: string
    let leftParen: string
    let rightParen: string
    let leftCurly: string
    let rightCurly: string
    let leftBracket: string
    let rightBracket: string
    let colon: string
    let dot: string
    let underscore: string
    let circumflex: string
    let dollar: string
    let at: string
    let hash: string
    let ampersand: string
}
