// Parser.cpp - Generated from scaly.sgm
// DO NOT EDIT - generated by codegen

#include "Parser.h"

namespace scaly {

namespace {
// Error helpers
llvm::Error different() {
    return llvm::make_error<llvm::StringError>(
        "different syntax", llvm::inconvertibleErrorCode());
}

llvm::Error invalid(size_t Start, size_t End, llvm::StringRef Message) {
    return llvm::make_error<llvm::StringError>(
        Message, llvm::inconvertibleErrorCode());
}
} // anonymous namespace

Parser::Parser(llvm::StringRef Source) : Lex(Source) {
    initKeywords();
}

void Parser::initKeywords() {
    Keywords.insert("alignof");
    Keywords.insert("as");
    Keywords.insert("break");
    Keywords.insert("case");
    Keywords.insert("choose");
    Keywords.insert("continue");
    Keywords.insert("define");
    Keywords.insert("deinit");
    Keywords.insert("delegate");
    Keywords.insert("else");
    Keywords.insert("extends");
    Keywords.insert("extern");
    Keywords.insert("for");
    Keywords.insert("function");
    Keywords.insert("if");
    Keywords.insert("is");
    Keywords.insert("init");
    Keywords.insert("implement");
    Keywords.insert("in");
    Keywords.insert("instruction");
    Keywords.insert("intrinsic");
    Keywords.insert("label");
    Keywords.insert("let");
    Keywords.insert("loop");
    Keywords.insert("macro");
    Keywords.insert("match");
    Keywords.insert("module");
    Keywords.insert("mutable");
    Keywords.insert("operator");
    Keywords.insert("procedure");
    Keywords.insert("private");
    Keywords.insert("return");
    Keywords.insert("returns");
    Keywords.insert("repeat");
    Keywords.insert("set");
    Keywords.insert("sizeof");
    Keywords.insert("throw");
    Keywords.insert("throws");
    Keywords.insert("trait");
    Keywords.insert("try");
    Keywords.insert("union");
    Keywords.insert("use");
    Keywords.insert("var");
    Keywords.insert("when");
    Keywords.insert("while");
    Keywords.insert("package");
}

bool Parser::isAtEnd() const {
    return Lex.isAtEnd();
}

llvm::Expected<Literal> Parser::parseLiteralToken() {
    if (is<EmptyToken>(Lex.token()))
        Lex.advance();

    if (auto *Lit = get_if<LiteralToken>(Lex.token())) {
        Literal Result = Lit->Value;
        Lex.empty();
        return Result;
    }

    return different();
}

llvm::Expected<ProgramSyntax> Parser::parseProgram() {
    size_t Start = Lex.previousPosition();

    auto FileOrErr = parseFile();
    if (!FileOrErr)
        return FileOrErr.takeError();
    auto File = std::move(*FileOrErr);

    std::vector<StatementSyntax>* Statements = nullptr;
    {
        auto ParseResult = parseStatementList();
        if (ParseResult)
            Statements = *ParseResult;
    }

    size_t End = Lex.position();

    return ProgramSyntax{Start, End, File, Statements};

}

llvm::Expected<FileSyntax> Parser::parseFile() {
    size_t Start = Lex.previousPosition();

    std::vector<PackageSyntax>* Packages = nullptr;
    {
        auto ParseResult = parsePackageList();
        if (ParseResult)
            Packages = *ParseResult;
    }

    std::vector<UseSyntax>* Uses = nullptr;
    {
        auto ParseResult = parseUseList();
        if (ParseResult)
            Uses = *ParseResult;
    }

    std::vector<DeclarationSyntax>* Declarations = nullptr;
    {
        auto ParseResult = parseDeclarationList();
        if (ParseResult)
            Declarations = *ParseResult;
    }

    size_t End = Lex.position();

    return FileSyntax{Start, End, Packages, Uses, Declarations};

}

llvm::Expected<std::vector<DeclarationSyntax>*> Parser::parseDeclarationList() {
    auto *List = new std::vector<DeclarationSyntax>();
    while (true) {
        auto NodeOrErr = parseDeclaration();
        if (!NodeOrErr) {
            if (List->empty()) {
                delete List;
                return NodeOrErr.takeError();
            }
            llvm::consumeError(NodeOrErr.takeError());
            return List;
        }
        List->push_back(std::move(*NodeOrErr));
    }
}

llvm::Expected<DeclarationSyntax> Parser::parseDeclaration() {
    size_t Start = Lex.previousPosition();

    auto SymbolOrErr = parseSymbol();
    if (!SymbolOrErr)
        return SymbolOrErr.takeError();
    auto Symbol = std::move(*SymbolOrErr);

    Lex.parseColon();

    size_t End = Lex.position();

    return DeclarationSyntax{Start, End, Symbol};

}

llvm::Expected<SymbolSyntax> Parser::parseSymbol() {
    {
        auto Result = parsePrivate();
        if (Result)
            return SymbolSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    {
        auto Result = parseDefinition();
        if (Result)
            return SymbolSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    {
        auto Result = parseFunction();
        if (Result)
            return SymbolSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    {
        auto Result = parseOperator();
        if (Result)
            return SymbolSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    {
        auto Result = parseTrait();
        if (Result)
            return SymbolSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    {
        auto Result = parseMacro();
        if (Result)
            return SymbolSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    {
        auto Result = parseModule();
        if (Result)
            return SymbolSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    return different();

}

llvm::Expected<PrivateSyntax> Parser::parsePrivate() {
    size_t Start = Lex.previousPosition();

    if (!Lex.parseKeyword("private"))
        return different();

    auto Export_OrErr = parseExport();
    if (!Export_OrErr)
        return invalid(Start, Lex.position(), "expected Export");
    auto Export_ = std::move(*Export_OrErr);

    size_t End = Lex.position();

    return PrivateSyntax{Start, End, Export_};

}

llvm::Expected<ExportSyntax> Parser::parseExport() {
    {
        auto Result = parseDefinition();
        if (Result)
            return ExportSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    {
        auto Result = parseFunction();
        if (Result)
            return ExportSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    {
        auto Result = parseOperator();
        if (Result)
            return ExportSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    {
        auto Result = parseTrait();
        if (Result)
            return ExportSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    {
        auto Result = parseModule();
        if (Result)
            return ExportSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    return different();

}

llvm::Expected<std::vector<MemberSyntax>*> Parser::parseMemberList() {
    auto *List = new std::vector<MemberSyntax>();
    while (true) {
        auto NodeOrErr = parseMember();
        if (!NodeOrErr) {
            if (List->empty()) {
                delete List;
                return NodeOrErr.takeError();
            }
            llvm::consumeError(NodeOrErr.takeError());
            return List;
        }
        List->push_back(std::move(*NodeOrErr));
    }
}

llvm::Expected<MemberSyntax> Parser::parseMember() {
    size_t Start = Lex.previousPosition();

    auto ConstituentOrErr = parseConstituent();
    if (!ConstituentOrErr)
        return ConstituentOrErr.takeError();
    auto Constituent = std::move(*ConstituentOrErr);

    Lex.parseColon();

    size_t End = Lex.position();

    return MemberSyntax{Start, End, Constituent};

}

llvm::Expected<ConstituentSyntax> Parser::parseConstituent() {
    {
        auto Result = parseDefinition();
        if (Result)
            return ConstituentSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    {
        auto Result = parseFunction();
        if (Result)
            return ConstituentSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    {
        auto Result = parseProcedure();
        if (Result)
            return ConstituentSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    {
        auto Result = parseOperator();
        if (Result)
            return ConstituentSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    {
        auto Result = parseImplement();
        if (Result)
            return ConstituentSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    {
        auto Result = parseTrait();
        if (Result)
            return ConstituentSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    {
        auto Result = parseMacro();
        if (Result)
            return ConstituentSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    {
        auto Result = parseModule();
        if (Result)
            return ConstituentSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    return different();

}

llvm::Expected<DefinitionSyntax> Parser::parseDefinition() {
    size_t Start = Lex.previousPosition();

    if (!Lex.parseKeyword("define"))
        return different();

    llvm::StringRef Name = Lex.peekIdentifier();
    if (Name.empty() || Keywords.count(Name))
        return invalid(Start, Lex.position(), "expected identifier");
    Lex.parseIdentifier();  // Consume the identifier

    GenericParametersSyntax* Parameters = nullptr;
    {
        auto ParseResult = parseGenericParameters();
        if (ParseResult)
            Parameters = new GenericParametersSyntax(std::move(*ParseResult));
        else
            llvm::consumeError(ParseResult.takeError());
    }

    Lex.parseColon();

    std::vector<AttributeSyntax>* Attributes = nullptr;
    {
        auto ParseResult = parseAttributeList();
        if (ParseResult)
            Attributes = *ParseResult;
    }

    auto Concept_OrErr = parseConcept();
    if (!Concept_OrErr)
        return invalid(Start, Lex.position(), "expected Concept");
    auto Concept_ = std::move(*Concept_OrErr);

    size_t End = Lex.position();

    return DefinitionSyntax{Start, End, Name, Parameters, Attributes, Concept_};

}

llvm::Expected<GenericParametersSyntax> Parser::parseGenericParameters() {
    size_t Start = Lex.previousPosition();

    if (!Lex.parsePunctuation('['))
        return different();

    auto ParametersOrErr = parseGenericParameterList();
    if (!ParametersOrErr)
        return invalid(Start, Lex.position(), "expected GenericParameter");
    auto *Parameters = *ParametersOrErr;

    if (!Lex.parsePunctuation(']'))
        return invalid(Start, Lex.position(), "expected ']'");

    size_t End = Lex.position();

    return GenericParametersSyntax{Start, End, Parameters};

}

llvm::Expected<std::vector<GenericParameterSyntax>*> Parser::parseGenericParameterList() {
    auto *List = new std::vector<GenericParameterSyntax>();
    while (true) {
        auto NodeOrErr = parseGenericParameter();
        if (!NodeOrErr) {
            if (List->empty()) {
                delete List;
                return NodeOrErr.takeError();
            }
            llvm::consumeError(NodeOrErr.takeError());
            return List;
        }
        List->push_back(std::move(*NodeOrErr));
    }
}

llvm::Expected<GenericParameterSyntax> Parser::parseGenericParameter() {
    size_t Start = Lex.previousPosition();

    llvm::StringRef Name = Lex.peekIdentifier();
    if (Name.empty() || Keywords.count(Name))
        return different();
    Lex.parseIdentifier();  // Consume the identifier

    std::vector<AttributeSyntax>* Attributes = nullptr;
    {
        auto ParseResult = parseAttributeList();
        if (ParseResult)
            Attributes = *ParseResult;
    }

    Lex.parsePunctuation(',');

    size_t End = Lex.position();

    return GenericParameterSyntax{Start, End, Name, Attributes};

}

llvm::Expected<ConceptSyntax> Parser::parseConcept() {
    {
        auto Result = parseClass();
        if (Result)
            return ConceptSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    {
        auto Result = parseNamespace();
        if (Result)
            return ConceptSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    {
        auto Result = parseUnion();
        if (Result)
            return ConceptSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    {
        auto Result = parseConstant();
        if (Result)
            return ConceptSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    {
        auto Result = parseDelegate();
        if (Result)
            return ConceptSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    {
        auto Result = parseIntrinsic();
        if (Result)
            return ConceptSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    return different();

}

llvm::Expected<ClassSyntax> Parser::parseClass() {
    size_t Start = Lex.previousPosition();

    auto StructureOrErr = parseStructure();
    if (!StructureOrErr)
        return StructureOrErr.takeError();
    auto Structure = std::move(*StructureOrErr);

    Lex.parseColon();

    BodySyntax* Body = nullptr;
    {
        auto ParseResult = parseBody();
        if (ParseResult)
            Body = new BodySyntax(std::move(*ParseResult));
        else
            llvm::consumeError(ParseResult.takeError());
    }

    Lex.parseColon();

    size_t End = Lex.position();

    return ClassSyntax{Start, End, Structure, Body};

}

llvm::Expected<BodySyntax> Parser::parseBody() {
    size_t Start = Lex.previousPosition();

    if (!Lex.parsePunctuation('{'))
        return different();

    std::vector<UseSyntax>* Uses = nullptr;
    {
        auto ParseResult = parseUseList();
        if (ParseResult)
            Uses = *ParseResult;
    }

    std::vector<InitSyntax>* Inits = nullptr;
    {
        auto ParseResult = parseInitList();
        if (ParseResult)
            Inits = *ParseResult;
    }

    DeInitSyntax* DeInit = nullptr;
    {
        auto ParseResult = parseDeInit();
        if (ParseResult)
            DeInit = new DeInitSyntax(std::move(*ParseResult));
        else
            llvm::consumeError(ParseResult.takeError());
    }

    std::vector<MemberSyntax>* Members = nullptr;
    {
        auto ParseResult = parseMemberList();
        if (ParseResult)
            Members = *ParseResult;
    }

    if (!Lex.parsePunctuation('}'))
        return invalid(Start, Lex.position(), "expected '}'");

    Lex.parseColon();

    size_t End = Lex.position();

    return BodySyntax{Start, End, Uses, Inits, DeInit, Members};

}

llvm::Expected<NamespaceSyntax> Parser::parseNamespace() {
    size_t Start = Lex.previousPosition();

    if (!Lex.parsePunctuation('{'))
        return different();

    std::vector<UseSyntax>* Uses = nullptr;
    {
        auto ParseResult = parseUseList();
        if (ParseResult)
            Uses = *ParseResult;
    }

    std::vector<DeclarationSyntax>* Declarations = nullptr;
    {
        auto ParseResult = parseDeclarationList();
        if (ParseResult)
            Declarations = *ParseResult;
    }

    if (!Lex.parsePunctuation('}'))
        return invalid(Start, Lex.position(), "expected '}'");

    Lex.parseColon();

    size_t End = Lex.position();

    return NamespaceSyntax{Start, End, Uses, Declarations};

}

llvm::Expected<UnionSyntax> Parser::parseUnion() {
    size_t Start = Lex.previousPosition();

    if (!Lex.parseKeyword("union"))
        return different();

    Lex.parseColon();

    if (!Lex.parsePunctuation('('))
        return invalid(Start, Lex.position(), "expected '('");

    auto VariantsOrErr = parseVariantList();
    if (!VariantsOrErr)
        return invalid(Start, Lex.position(), "expected Variant");
    auto *Variants = *VariantsOrErr;

    if (!Lex.parsePunctuation(')'))
        return invalid(Start, Lex.position(), "expected ')'");

    Lex.parseColon();

    BodySyntax* Body = nullptr;
    {
        auto ParseResult = parseBody();
        if (ParseResult)
            Body = new BodySyntax(std::move(*ParseResult));
        else
            llvm::consumeError(ParseResult.takeError());
    }

    Lex.parseColon();

    size_t End = Lex.position();

    return UnionSyntax{Start, End, Variants, Body};

}

llvm::Expected<std::vector<VariantSyntax>*> Parser::parseVariantList() {
    auto *List = new std::vector<VariantSyntax>();
    while (true) {
        auto NodeOrErr = parseVariant();
        if (!NodeOrErr) {
            if (List->empty()) {
                delete List;
                return NodeOrErr.takeError();
            }
            llvm::consumeError(NodeOrErr.takeError());
            return List;
        }
        List->push_back(std::move(*NodeOrErr));
    }
}

llvm::Expected<VariantSyntax> Parser::parseVariant() {
    size_t Start = Lex.previousPosition();

    llvm::StringRef Name = Lex.peekIdentifier();
    if (Name.empty() || Keywords.count(Name))
        return different();
    Lex.parseIdentifier();  // Consume the identifier

    std::vector<AttributeSyntax>* Attributes = nullptr;
    {
        auto ParseResult = parseAttributeList();
        if (ParseResult)
            Attributes = *ParseResult;
    }

    TypeAnnotationSyntax* Annotation = nullptr;
    {
        auto ParseResult = parseTypeAnnotation();
        if (ParseResult)
            Annotation = new TypeAnnotationSyntax(std::move(*ParseResult));
        else
            llvm::consumeError(ParseResult.takeError());
    }

    Lex.parsePunctuation(',');

    Lex.parseColon();

    size_t End = Lex.position();

    return VariantSyntax{Start, End, Name, Attributes, Annotation};

}

llvm::Expected<ConstantSyntax> Parser::parseConstant() {
    size_t Start = Lex.previousPosition();

    auto TypeOrErr = parseType();
    if (!TypeOrErr)
        return TypeOrErr.takeError();
    auto Type = std::move(*TypeOrErr);

    std::vector<OperandSyntax>* Operation = nullptr;
    {
        auto ParseResult = parseOperandList();
        if (ParseResult)
            Operation = *ParseResult;
    }

    Lex.parseColon();

    size_t End = Lex.position();

    return ConstantSyntax{Start, End, Type, Operation};

}

llvm::Expected<DelegateSyntax> Parser::parseDelegate() {
    size_t Start = Lex.previousPosition();

    if (!Lex.parseKeyword("delegate"))
        return different();

    ParameterSetSyntax* Parameters = nullptr;
    {
        auto ParseResult = parseParameterSet();
        if (ParseResult)
            Parameters = new ParameterSetSyntax(std::move(*ParseResult));
        else
            llvm::consumeError(ParseResult.takeError());
    }

    std::vector<AttributeSyntax>* Attributes = nullptr;
    {
        auto ParseResult = parseAttributeList();
        if (ParseResult)
            Attributes = *ParseResult;
    }

    ReturnsSyntax* Result = nullptr;
    {
        auto ParseResult = parseReturns();
        if (ParseResult)
            Result = new ReturnsSyntax(std::move(*ParseResult));
        else
            llvm::consumeError(ParseResult.takeError());
    }

    ThrowsSyntax* Error = nullptr;
    {
        auto ParseResult = parseThrows();
        if (ParseResult)
            Error = new ThrowsSyntax(std::move(*ParseResult));
        else
            llvm::consumeError(ParseResult.takeError());
    }

    size_t End = Lex.position();

    return DelegateSyntax{Start, End, Parameters, Attributes, Result, Error};

}

llvm::Expected<GenericArgumentsSyntax> Parser::parseGenericArguments() {
    size_t Start = Lex.previousPosition();

    if (!Lex.parsePunctuation('['))
        return different();

    std::vector<GenericArgumentSyntax>* Generics = nullptr;
    {
        auto ParseResult = parseGenericArgumentList();
        if (ParseResult)
            Generics = *ParseResult;
    }

    if (!Lex.parsePunctuation(']'))
        return invalid(Start, Lex.position(), "expected ']'");

    size_t End = Lex.position();

    return GenericArgumentsSyntax{Start, End, Generics};

}

llvm::Expected<std::vector<GenericArgumentSyntax>*> Parser::parseGenericArgumentList() {
    auto *List = new std::vector<GenericArgumentSyntax>();
    while (true) {
        auto NodeOrErr = parseGenericArgument();
        if (!NodeOrErr) {
            if (List->empty()) {
                delete List;
                return NodeOrErr.takeError();
            }
            llvm::consumeError(NodeOrErr.takeError());
            return List;
        }
        List->push_back(std::move(*NodeOrErr));
    }
}

llvm::Expected<GenericArgumentSyntax> Parser::parseGenericArgument() {
    {
        auto Result = parseTypeArgument();
        if (Result)
            return GenericArgumentSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    {
        auto Result = parseLiteralArgument();
        if (Result)
            return GenericArgumentSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    return different();

}

llvm::Expected<TypeArgumentSyntax> Parser::parseTypeArgument() {
    size_t Start = Lex.previousPosition();

    auto TypeOrErr = parseType();
    if (!TypeOrErr)
        return TypeOrErr.takeError();
    auto Type = std::move(*TypeOrErr);

    Lex.parsePunctuation(',');

    size_t End = Lex.position();

    return TypeArgumentSyntax{Start, End, Type};

}

llvm::Expected<LiteralArgumentSyntax> Parser::parseLiteralArgument() {
    size_t Start = Lex.previousPosition();

    auto LiteralOrErr = parseLiteralToken();
    if (!LiteralOrErr)
        return LiteralOrErr.takeError();
    auto Literal = std::move(*LiteralOrErr);

    Lex.parsePunctuation(',');

    size_t End = Lex.position();

    return LiteralArgumentSyntax{Start, End, Literal};

}

llvm::Expected<OptionalSyntax> Parser::parseOptional() {
    size_t Start = Lex.previousPosition();

    if (!Lex.parsePunctuation('?'))
        return different();

    size_t End = Lex.position();

    return OptionalSyntax{Start, End};

}

llvm::Expected<ParameterSetSyntax> Parser::parseParameterSet() {
    {
        auto Result = parseParameters();
        if (Result)
            return ParameterSetSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    {
        auto Result = parseType();
        if (Result)
            return ParameterSetSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    return different();

}

llvm::Expected<ParametersSyntax> Parser::parseParameters() {
    size_t Start = Lex.previousPosition();

    if (!Lex.parsePunctuation('('))
        return different();

    std::vector<ItemSyntax>* Items = nullptr;
    {
        auto ParseResult = parseItemList();
        if (ParseResult)
            Items = *ParseResult;
    }

    if (!Lex.parsePunctuation(')'))
        return invalid(Start, Lex.position(), "expected ')'");

    size_t End = Lex.position();

    return ParametersSyntax{Start, End, Items};

}

llvm::Expected<std::vector<ItemSyntax>*> Parser::parseItemList() {
    auto *List = new std::vector<ItemSyntax>();
    while (true) {
        auto NodeOrErr = parseItem();
        if (!NodeOrErr) {
            if (List->empty()) {
                delete List;
                return NodeOrErr.takeError();
            }
            llvm::consumeError(NodeOrErr.takeError());
            return List;
        }
        List->push_back(std::move(*NodeOrErr));
    }
}

llvm::Expected<ItemSyntax> Parser::parseItem() {
    size_t Start = Lex.previousPosition();

    llvm::StringRef Name = Lex.peekIdentifier();
    if (Name.empty() || Keywords.count(Name))
        return different();
    Lex.parseIdentifier();  // Consume the identifier

    TypeAnnotationSyntax* Annotation = nullptr;
    {
        auto ParseResult = parseTypeAnnotation();
        if (ParseResult)
            Annotation = new TypeAnnotationSyntax(std::move(*ParseResult));
        else
            llvm::consumeError(ParseResult.takeError());
    }

    Lex.parsePunctuation(',');

    Lex.parseColon();

    std::vector<AttributeSyntax>* Attributes = nullptr;
    {
        auto ParseResult = parseAttributeList();
        if (ParseResult)
            Attributes = *ParseResult;
    }

    Lex.parseColon();

    size_t End = Lex.position();

    return ItemSyntax{Start, End, Name, Annotation, Attributes};

}

llvm::Expected<ReturnsSyntax> Parser::parseReturns() {
    size_t Start = Lex.previousPosition();

    if (!Lex.parseKeyword("returns"))
        return different();

    auto TypeOrErr = parseType();
    if (!TypeOrErr)
        return invalid(Start, Lex.position(), "expected Type");
    auto Type = std::move(*TypeOrErr);

    std::vector<AttributeSyntax>* Attributes = nullptr;
    {
        auto ParseResult = parseAttributeList();
        if (ParseResult)
            Attributes = *ParseResult;
    }

    size_t End = Lex.position();

    return ReturnsSyntax{Start, End, Type, Attributes};

}

llvm::Expected<ThrowsSyntax> Parser::parseThrows() {
    size_t Start = Lex.previousPosition();

    if (!Lex.parseKeyword("throws"))
        return different();

    auto TypeOrErr = parseType();
    if (!TypeOrErr)
        return invalid(Start, Lex.position(), "expected Type");
    auto Type = std::move(*TypeOrErr);

    std::vector<AttributeSyntax>* Attributes = nullptr;
    {
        auto ParseResult = parseAttributeList();
        if (ParseResult)
            Attributes = *ParseResult;
    }

    size_t End = Lex.position();

    return ThrowsSyntax{Start, End, Type, Attributes};

}

llvm::Expected<std::vector<UseSyntax>*> Parser::parseUseList() {
    auto *List = new std::vector<UseSyntax>();
    while (true) {
        auto NodeOrErr = parseUse();
        if (!NodeOrErr) {
            if (List->empty()) {
                delete List;
                return NodeOrErr.takeError();
            }
            llvm::consumeError(NodeOrErr.takeError());
            return List;
        }
        List->push_back(std::move(*NodeOrErr));
    }
}

llvm::Expected<UseSyntax> Parser::parseUse() {
    size_t Start = Lex.previousPosition();

    if (!Lex.parseKeyword("use"))
        return different();

    auto NameOrErr = parseName();
    if (!NameOrErr)
        return invalid(Start, Lex.position(), "expected Name");
    auto Name = std::move(*NameOrErr);

    Lex.parseColon();

    size_t End = Lex.position();

    return UseSyntax{Start, End, Name};

}

llvm::Expected<ImplementSyntax> Parser::parseImplement() {
    size_t Start = Lex.previousPosition();

    if (!Lex.parseKeyword("implement"))
        return different();

    auto TypeOrErr = parseType();
    if (!TypeOrErr)
        return invalid(Start, Lex.position(), "expected Type");
    auto Type = std::move(*TypeOrErr);

    std::vector<AttributeSyntax>* Attributes = nullptr;
    {
        auto ParseResult = parseAttributeList();
        if (ParseResult)
            Attributes = *ParseResult;
    }

    Lex.parseColon();

    if (!Lex.parsePunctuation('{'))
        return invalid(Start, Lex.position(), "expected '{'");

    std::vector<UseSyntax>* Uses = nullptr;
    {
        auto ParseResult = parseUseList();
        if (ParseResult)
            Uses = *ParseResult;
    }

    std::vector<MethodSyntax>* Methods = nullptr;
    {
        auto ParseResult = parseMethodList();
        if (ParseResult)
            Methods = *ParseResult;
    }

    if (!Lex.parsePunctuation('}'))
        return invalid(Start, Lex.position(), "expected '}'");

    Lex.parseColon();

    size_t End = Lex.position();

    return ImplementSyntax{Start, End, Type, Attributes, Uses, Methods};

}

llvm::Expected<TraitSyntax> Parser::parseTrait() {
    size_t Start = Lex.previousPosition();

    if (!Lex.parseKeyword("trait"))
        return different();

    auto NameOrErr = parseName();
    if (!NameOrErr)
        return invalid(Start, Lex.position(), "expected Name");
    auto Name = std::move(*NameOrErr);

    ExtendsSyntax* Extension = nullptr;
    {
        auto ParseResult = parseExtends();
        if (ParseResult)
            Extension = new ExtendsSyntax(std::move(*ParseResult));
        else
            llvm::consumeError(ParseResult.takeError());
    }

    std::vector<AttributeSyntax>* Attributes = nullptr;
    {
        auto ParseResult = parseAttributeList();
        if (ParseResult)
            Attributes = *ParseResult;
    }

    if (!Lex.parsePunctuation('{'))
        return invalid(Start, Lex.position(), "expected '{'");

    std::vector<UseSyntax>* Uses = nullptr;
    {
        auto ParseResult = parseUseList();
        if (ParseResult)
            Uses = *ParseResult;
    }

    std::vector<MethodSyntax>* Functions = nullptr;
    {
        auto ParseResult = parseMethodList();
        if (ParseResult)
            Functions = *ParseResult;
    }

    if (!Lex.parsePunctuation('}'))
        return invalid(Start, Lex.position(), "expected '}'");

    Lex.parseColon();

    size_t End = Lex.position();

    return TraitSyntax{Start, End, Name, Extension, Attributes, Uses, Functions};

}

llvm::Expected<std::vector<MethodSyntax>*> Parser::parseMethodList() {
    auto *List = new std::vector<MethodSyntax>();
    while (true) {
        auto NodeOrErr = parseMethod();
        if (!NodeOrErr) {
            if (List->empty()) {
                delete List;
                return NodeOrErr.takeError();
            }
            llvm::consumeError(NodeOrErr.takeError());
            return List;
        }
        List->push_back(std::move(*NodeOrErr));
    }
}

llvm::Expected<MethodSyntax> Parser::parseMethod() {
    {
        auto Result = parseFunction();
        if (Result)
            return MethodSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    {
        auto Result = parseProcedure();
        if (Result)
            return MethodSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    {
        auto Result = parseOperator();
        if (Result)
            return MethodSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    return different();

}

llvm::Expected<std::vector<InitSyntax>*> Parser::parseInitList() {
    auto *List = new std::vector<InitSyntax>();
    while (true) {
        auto NodeOrErr = parseInit();
        if (!NodeOrErr) {
            if (List->empty()) {
                delete List;
                return NodeOrErr.takeError();
            }
            llvm::consumeError(NodeOrErr.takeError());
            return List;
        }
        List->push_back(std::move(*NodeOrErr));
    }
}

llvm::Expected<InitSyntax> Parser::parseInit() {
    size_t Start = Lex.previousPosition();

    if (!Lex.parseKeyword("init"))
        return different();

    ParameterSetSyntax* Parameters = nullptr;
    {
        auto ParseResult = parseParameterSet();
        if (ParseResult)
            Parameters = new ParameterSetSyntax(std::move(*ParseResult));
        else
            llvm::consumeError(ParseResult.takeError());
    }

    Lex.parseColon();

    auto ActionOrErr = parseAction();
    if (!ActionOrErr)
        return invalid(Start, Lex.position(), "expected Action");
    auto Action = std::move(*ActionOrErr);

    Lex.parseColon();

    size_t End = Lex.position();

    return InitSyntax{Start, End, Parameters, Action};

}

llvm::Expected<DeInitSyntax> Parser::parseDeInit() {
    size_t Start = Lex.previousPosition();

    if (!Lex.parseKeyword("deinit"))
        return different();

    Lex.parseColon();

    auto ActionOrErr = parseAction();
    if (!ActionOrErr)
        return invalid(Start, Lex.position(), "expected Action");
    auto Action = std::move(*ActionOrErr);

    Lex.parseColon();

    size_t End = Lex.position();

    return DeInitSyntax{Start, End, Action};

}

llvm::Expected<FunctionSyntax> Parser::parseFunction() {
    size_t Start = Lex.previousPosition();

    if (!Lex.parseKeyword("function"))
        return different();

    auto TargetOrErr = parseTarget();
    if (!TargetOrErr)
        return invalid(Start, Lex.position(), "expected Target");
    auto Target = std::move(*TargetOrErr);

    size_t End = Lex.position();

    return FunctionSyntax{Start, End, Target};

}

llvm::Expected<ProcedureSyntax> Parser::parseProcedure() {
    size_t Start = Lex.previousPosition();

    if (!Lex.parseKeyword("procedure"))
        return different();

    auto TargetOrErr = parseTarget();
    if (!TargetOrErr)
        return invalid(Start, Lex.position(), "expected Target");
    auto Target = std::move(*TargetOrErr);

    size_t End = Lex.position();

    return ProcedureSyntax{Start, End, Target};

}

llvm::Expected<OperatorSyntax> Parser::parseOperator() {
    size_t Start = Lex.previousPosition();

    if (!Lex.parseKeyword("operator"))
        return different();

    auto TargetOrErr = parseTarget();
    if (!TargetOrErr)
        return invalid(Start, Lex.position(), "expected Target");
    auto Target = std::move(*TargetOrErr);

    size_t End = Lex.position();

    return OperatorSyntax{Start, End, Target};

}

llvm::Expected<TargetSyntax> Parser::parseTarget() {
    {
        auto Result = parseNamed();
        if (Result)
            return TargetSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    {
        auto Result = parseRoutine();
        if (Result)
            return TargetSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    return different();

}

llvm::Expected<NamedSyntax> Parser::parseNamed() {
    size_t Start = Lex.previousPosition();

    llvm::StringRef Name = Lex.peekIdentifier();
    if (Name.empty() || Keywords.count(Name))
        return different();
    Lex.parseIdentifier();  // Consume the identifier

    auto RoutineOrErr = parseRoutine();
    if (!RoutineOrErr)
        return invalid(Start, Lex.position(), "expected Routine");
    auto Routine = std::move(*RoutineOrErr);

    size_t End = Lex.position();

    return NamedSyntax{Start, End, Name, Routine};

}

llvm::Expected<RoutineSyntax> Parser::parseRoutine() {
    size_t Start = Lex.previousPosition();

    GenericArgumentsSyntax* Generics = nullptr;
    {
        auto ParseResult = parseGenericArguments();
        if (ParseResult)
            Generics = new GenericArgumentsSyntax(std::move(*ParseResult));
        else
            llvm::consumeError(ParseResult.takeError());
    }

    LifetimeSyntax* Lifetime = nullptr;
    {
        auto ParseResult = parseLifetime();
        if (ParseResult)
            Lifetime = new LifetimeSyntax(std::move(*ParseResult));
        else
            llvm::consumeError(ParseResult.takeError());
    }

    ParameterSetSyntax* Parameters = nullptr;
    {
        auto ParseResult = parseParameterSet();
        if (ParseResult)
            Parameters = new ParameterSetSyntax(std::move(*ParseResult));
        else
            llvm::consumeError(ParseResult.takeError());
    }

    std::vector<AttributeSyntax>* Attributes = nullptr;
    {
        auto ParseResult = parseAttributeList();
        if (ParseResult)
            Attributes = *ParseResult;
    }

    ReturnsSyntax* Returns_ = nullptr;
    {
        auto ParseResult = parseReturns();
        if (ParseResult)
            Returns_ = new ReturnsSyntax(std::move(*ParseResult));
        else
            llvm::consumeError(ParseResult.takeError());
    }

    Lex.parseColon();

    ThrowsSyntax* Throws_ = nullptr;
    {
        auto ParseResult = parseThrows();
        if (ParseResult)
            Throws_ = new ThrowsSyntax(std::move(*ParseResult));
        else
            llvm::consumeError(ParseResult.takeError());
    }

    Lex.parseColon();

    auto ImplementationOrErr = parseImplementation();
    if (!ImplementationOrErr)
        return invalid(Start, Lex.position(), "expected Implementation");
    auto Implementation = std::move(*ImplementationOrErr);

    size_t End = Lex.position();

    return RoutineSyntax{Start, End, Generics, Lifetime, Parameters, Attributes, Returns_, Throws_, Implementation};

}

llvm::Expected<ImplementationSyntax> Parser::parseImplementation() {
    {
        auto Result = parseAction();
        if (Result)
            return ImplementationSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    {
        auto Result = parseExtern();
        if (Result)
            return ImplementationSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    {
        auto Result = parseInstruction();
        if (Result)
            return ImplementationSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    {
        auto Result = parseIntrinsic();
        if (Result)
            return ImplementationSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    return different();

}

llvm::Expected<ExternSyntax> Parser::parseExtern() {
    size_t Start = Lex.previousPosition();

    if (!Lex.parseKeyword("extern"))
        return different();

    size_t End = Lex.position();

    return ExternSyntax{Start, End};

}

llvm::Expected<InstructionSyntax> Parser::parseInstruction() {
    size_t Start = Lex.previousPosition();

    if (!Lex.parseKeyword("instruction"))
        return different();

    Lex.parseColon();

    size_t End = Lex.position();

    return InstructionSyntax{Start, End};

}

llvm::Expected<IntrinsicSyntax> Parser::parseIntrinsic() {
    size_t Start = Lex.previousPosition();

    if (!Lex.parseKeyword("intrinsic"))
        return different();

    Lex.parseColon();

    size_t End = Lex.position();

    return IntrinsicSyntax{Start, End};

}

llvm::Expected<ExtendsSyntax> Parser::parseExtends() {
    size_t Start = Lex.previousPosition();

    if (!Lex.parseKeyword("extends"))
        return different();

    std::vector<ExtendSyntax>* Extensions = nullptr;
    {
        auto ParseResult = parseExtendList();
        if (ParseResult)
            Extensions = *ParseResult;
    }

    size_t End = Lex.position();

    return ExtendsSyntax{Start, End, Extensions};

}

llvm::Expected<std::vector<ExtendSyntax>*> Parser::parseExtendList() {
    auto *List = new std::vector<ExtendSyntax>();
    while (true) {
        auto NodeOrErr = parseExtend();
        if (!NodeOrErr) {
            if (List->empty()) {
                delete List;
                return NodeOrErr.takeError();
            }
            llvm::consumeError(NodeOrErr.takeError());
            return List;
        }
        List->push_back(std::move(*NodeOrErr));
    }
}

llvm::Expected<ExtendSyntax> Parser::parseExtend() {
    size_t Start = Lex.previousPosition();

    auto TypeOrErr = parseType();
    if (!TypeOrErr)
        return TypeOrErr.takeError();
    auto Type = std::move(*TypeOrErr);

    Lex.parsePunctuation(',');

    size_t End = Lex.position();

    return ExtendSyntax{Start, End, Type};

}

llvm::Expected<MacroSyntax> Parser::parseMacro() {
    size_t Start = Lex.previousPosition();

    if (!Lex.parseKeyword("macro"))
        return different();

    llvm::StringRef Name = Lex.peekIdentifier();
    if (Name.empty() || Keywords.count(Name))
        return invalid(Start, Lex.position(), "expected identifier");
    Lex.parseIdentifier();  // Consume the identifier

    auto ModelOrErr = parseModel();
    if (!ModelOrErr)
        return invalid(Start, Lex.position(), "expected Model");
    auto Model = std::move(*ModelOrErr);

    auto RuleOrErr = parseOperandList();
    if (!RuleOrErr)
        return invalid(Start, Lex.position(), "expected Operand");
    auto *Rule = *RuleOrErr;

    size_t End = Lex.position();

    return MacroSyntax{Start, End, Name, Model, Rule};

}

llvm::Expected<std::vector<AttributeSyntax>*> Parser::parseAttributeList() {
    auto *List = new std::vector<AttributeSyntax>();
    while (true) {
        auto NodeOrErr = parseAttribute();
        if (!NodeOrErr) {
            if (List->empty()) {
                delete List;
                return NodeOrErr.takeError();
            }
            llvm::consumeError(NodeOrErr.takeError());
            return List;
        }
        List->push_back(std::move(*NodeOrErr));
    }
}

llvm::Expected<AttributeSyntax> Parser::parseAttribute() {
    size_t Start = Lex.previousPosition();

    llvm::StringRef Name = Lex.parseAttribute();
    if (Name.empty())
        return different();

    auto ModelOrErr = parseModel();
    if (!ModelOrErr)
        return invalid(Start, Lex.position(), "expected Model");
    auto Model = std::move(*ModelOrErr);

    Lex.parseColon();

    size_t End = Lex.position();

    return AttributeSyntax{Start, End, Name, Model};

}

llvm::Expected<ModelSyntax> Parser::parseModel() {
    {
        auto Result = parseLiteral();
        if (Result)
            return ModelSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    {
        auto Result = parseName();
        if (Result)
            return ModelSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    {
        auto Result = parseObject();
        if (Result)
            return ModelSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    {
        auto Result = parseVector();
        if (Result)
            return ModelSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    return different();

}

llvm::Expected<ModuleSyntax> Parser::parseModule() {
    size_t Start = Lex.previousPosition();

    if (!Lex.parseKeyword("module"))
        return different();

    llvm::StringRef Name = Lex.peekIdentifier();
    if (Name.empty() || Keywords.count(Name))
        return invalid(Start, Lex.position(), "expected identifier");
    Lex.parseIdentifier();  // Consume the identifier

    Lex.parseColon();

    size_t End = Lex.position();

    return ModuleSyntax{Start, End, Name};

}

llvm::Expected<std::vector<PackageSyntax>*> Parser::parsePackageList() {
    auto *List = new std::vector<PackageSyntax>();
    while (true) {
        auto NodeOrErr = parsePackage();
        if (!NodeOrErr) {
            if (List->empty()) {
                delete List;
                return NodeOrErr.takeError();
            }
            llvm::consumeError(NodeOrErr.takeError());
            return List;
        }
        List->push_back(std::move(*NodeOrErr));
    }
}

llvm::Expected<PackageSyntax> Parser::parsePackage() {
    size_t Start = Lex.previousPosition();

    if (!Lex.parseKeyword("package"))
        return different();

    auto NameOrErr = parseName();
    if (!NameOrErr)
        return invalid(Start, Lex.position(), "expected Name");
    auto Name = std::move(*NameOrErr);

    VersionSyntax* Version = nullptr;
    {
        auto ParseResult = parseVersion();
        if (ParseResult)
            Version = new VersionSyntax(std::move(*ParseResult));
        else
            llvm::consumeError(ParseResult.takeError());
    }

    Lex.parseColon();

    size_t End = Lex.position();

    return PackageSyntax{Start, End, Name, Version};

}

llvm::Expected<VersionSyntax> Parser::parseVersion() {
    size_t Start = Lex.previousPosition();

    auto MajorMinorOrErr = parseLiteralToken();
    if (!MajorMinorOrErr)
        return MajorMinorOrErr.takeError();
    auto MajorMinor = std::move(*MajorMinorOrErr);

    if (!Lex.parsePunctuation('.'))
        return invalid(Start, Lex.position(), "expected '.'");

    auto PatchOrErr = parseLiteralToken();
    if (!PatchOrErr)
        return PatchOrErr.takeError();
    auto Patch = std::move(*PatchOrErr);

    size_t End = Lex.position();

    return VersionSyntax{Start, End, MajorMinor, Patch};

}

llvm::Expected<InitializerSyntax> Parser::parseInitializer() {
    size_t Start = Lex.previousPosition();

    if (!Lex.parsePunctuation('('))
        return different();

    auto OperandsOrErr = parseOperandList();
    if (!OperandsOrErr)
        return invalid(Start, Lex.position(), "expected Operand");
    auto *Operands = *OperandsOrErr;

    if (!Lex.parsePunctuation(')'))
        return invalid(Start, Lex.position(), "expected ')'");

    size_t End = Lex.position();

    return InitializerSyntax{Start, End, Operands};

}

llvm::Expected<std::vector<OperandSyntax>*> Parser::parseOperandList() {
    auto *List = new std::vector<OperandSyntax>();
    while (true) {
        auto NodeOrErr = parseOperand();
        if (!NodeOrErr) {
            if (List->empty()) {
                delete List;
                return NodeOrErr.takeError();
            }
            llvm::consumeError(NodeOrErr.takeError());
            return List;
        }
        List->push_back(std::move(*NodeOrErr));
    }
}

llvm::Expected<OperandSyntax> Parser::parseOperand() {
    size_t Start = Lex.previousPosition();

    auto ExpressionOrErr = parseExpression();
    if (!ExpressionOrErr)
        return ExpressionOrErr.takeError();
    auto Expression = std::move(*ExpressionOrErr);

    std::vector<MemberAccessSyntax>* Members = nullptr;
    {
        auto ParseResult = parseMemberAccessList();
        if (ParseResult)
            Members = *ParseResult;
    }

    size_t End = Lex.position();

    return OperandSyntax{Start, End, Expression, Members};

}

llvm::Expected<std::vector<MemberAccessSyntax>*> Parser::parseMemberAccessList() {
    auto *List = new std::vector<MemberAccessSyntax>();
    while (true) {
        auto NodeOrErr = parseMemberAccess();
        if (!NodeOrErr) {
            if (List->empty()) {
                delete List;
                return NodeOrErr.takeError();
            }
            llvm::consumeError(NodeOrErr.takeError());
            return List;
        }
        List->push_back(std::move(*NodeOrErr));
    }
}

llvm::Expected<MemberAccessSyntax> Parser::parseMemberAccess() {
    size_t Start = Lex.previousPosition();

    if (!Lex.parsePunctuation('.'))
        return different();

    auto NameOrErr = parseName();
    if (!NameOrErr)
        return invalid(Start, Lex.position(), "expected Name");
    auto Name = std::move(*NameOrErr);

    size_t End = Lex.position();

    return MemberAccessSyntax{Start, End, Name};

}

llvm::Expected<ExpressionSyntax> Parser::parseExpression() {
    {
        auto Result = parseLiteral();
        if (Result)
            return ExpressionSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    {
        auto Result = parseName();
        if (Result)
            return ExpressionSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    {
        auto Result = parseObject();
        if (Result)
            return ExpressionSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    {
        auto Result = parseVector();
        if (Result)
            return ExpressionSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    {
        auto Result = parseBlock();
        if (Result)
            return ExpressionSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    {
        auto Result = parseIf();
        if (Result)
            return ExpressionSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    {
        auto Result = parseMatch();
        if (Result)
            return ExpressionSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    {
        auto Result = parseLambda();
        if (Result)
            return ExpressionSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    {
        auto Result = parseFor();
        if (Result)
            return ExpressionSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    {
        auto Result = parseWhile();
        if (Result)
            return ExpressionSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    {
        auto Result = parseChoose();
        if (Result)
            return ExpressionSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    {
        auto Result = parseTry();
        if (Result)
            return ExpressionSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    {
        auto Result = parseRepeat();
        if (Result)
            return ExpressionSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    {
        auto Result = parseSizeOf();
        if (Result)
            return ExpressionSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    {
        auto Result = parseAlignOf();
        if (Result)
            return ExpressionSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    {
        auto Result = parseIs();
        if (Result)
            return ExpressionSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    {
        auto Result = parseAs();
        if (Result)
            return ExpressionSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    {
        auto Result = parseLifetime();
        if (Result)
            return ExpressionSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    return different();

}

llvm::Expected<LiteralSyntax> Parser::parseLiteral() {
    size_t Start = Lex.previousPosition();

    auto LiteralOrErr = parseLiteralToken();
    if (!LiteralOrErr)
        return LiteralOrErr.takeError();
    auto Literal = std::move(*LiteralOrErr);

    size_t End = Lex.position();

    return LiteralSyntax{Start, End, Literal};

}

llvm::Expected<ObjectSyntax> Parser::parseObject() {
    size_t Start = Lex.previousPosition();

    if (!Lex.parsePunctuation('('))
        return different();

    std::vector<ComponentSyntax>* Components = nullptr;
    {
        auto ParseResult = parseComponentList();
        if (ParseResult)
            Components = *ParseResult;
    }

    if (!Lex.parsePunctuation(')'))
        return invalid(Start, Lex.position(), "expected ')'");

    size_t End = Lex.position();

    return ObjectSyntax{Start, End, Components};

}

llvm::Expected<std::vector<ComponentSyntax>*> Parser::parseComponentList() {
    auto *List = new std::vector<ComponentSyntax>();
    while (true) {
        auto NodeOrErr = parseComponent();
        if (!NodeOrErr) {
            if (List->empty()) {
                delete List;
                return NodeOrErr.takeError();
            }
            llvm::consumeError(NodeOrErr.takeError());
            return List;
        }
        List->push_back(std::move(*NodeOrErr));
    }
}

llvm::Expected<ComponentSyntax> Parser::parseComponent() {
    size_t Start = Lex.previousPosition();

    auto OperandsOrErr = parseOperandList();
    if (!OperandsOrErr)
        return OperandsOrErr.takeError();
    auto *Operands = *OperandsOrErr;

    std::vector<AttributeSyntax>* Attributes = nullptr;
    {
        auto ParseResult = parseAttributeList();
        if (ParseResult)
            Attributes = *ParseResult;
    }

    ValueSyntax* Value = nullptr;
    {
        auto ParseResult = parseValue();
        if (ParseResult)
            Value = new ValueSyntax(std::move(*ParseResult));
        else
            llvm::consumeError(ParseResult.takeError());
    }

    Lex.parsePunctuation(',');

    size_t End = Lex.position();

    return ComponentSyntax{Start, End, Operands, Attributes, Value};

}

llvm::Expected<ValueSyntax> Parser::parseValue() {
    size_t Start = Lex.previousPosition();

    if (!Lex.parseColon())
        return different();

    auto ValueOrErr = parseOperandList();
    if (!ValueOrErr)
        return invalid(Start, Lex.position(), "expected Operand");
    auto *Value = *ValueOrErr;

    std::vector<AttributeSyntax>* Attributes = nullptr;
    {
        auto ParseResult = parseAttributeList();
        if (ParseResult)
            Attributes = *ParseResult;
    }

    size_t End = Lex.position();

    return ValueSyntax{Start, End, Value, Attributes};

}

llvm::Expected<VectorSyntax> Parser::parseVector() {
    size_t Start = Lex.previousPosition();

    if (!Lex.parsePunctuation('['))
        return different();

    auto ElementsOrErr = parseElementList();
    if (!ElementsOrErr)
        return invalid(Start, Lex.position(), "expected Element");
    auto *Elements = *ElementsOrErr;

    if (!Lex.parsePunctuation(']'))
        return invalid(Start, Lex.position(), "expected ']'");

    LifetimeSyntax* Lifetime = nullptr;
    {
        auto ParseResult = parseLifetime();
        if (ParseResult)
            Lifetime = new LifetimeSyntax(std::move(*ParseResult));
        else
            llvm::consumeError(ParseResult.takeError());
    }

    size_t End = Lex.position();

    return VectorSyntax{Start, End, Elements, Lifetime};

}

llvm::Expected<std::vector<ElementSyntax>*> Parser::parseElementList() {
    auto *List = new std::vector<ElementSyntax>();
    while (true) {
        auto NodeOrErr = parseElement();
        if (!NodeOrErr) {
            if (List->empty()) {
                delete List;
                return NodeOrErr.takeError();
            }
            llvm::consumeError(NodeOrErr.takeError());
            return List;
        }
        List->push_back(std::move(*NodeOrErr));
    }
}

llvm::Expected<ElementSyntax> Parser::parseElement() {
    size_t Start = Lex.previousPosition();

    auto OperationOrErr = parseOperandList();
    if (!OperationOrErr)
        return OperationOrErr.takeError();
    auto *Operation = *OperationOrErr;

    std::vector<AttributeSyntax>* Attributes = nullptr;
    {
        auto ParseResult = parseAttributeList();
        if (ParseResult)
            Attributes = *ParseResult;
    }

    Lex.parsePunctuation(',');

    size_t End = Lex.position();

    return ElementSyntax{Start, End, Operation, Attributes};

}

llvm::Expected<IfSyntax> Parser::parseIf() {
    size_t Start = Lex.previousPosition();

    if (!Lex.parseKeyword("if"))
        return different();

    auto ConditionOrErr = parseOperandList();
    if (!ConditionOrErr)
        return invalid(Start, Lex.position(), "expected Operand");
    auto *Condition = *ConditionOrErr;

    if (!Lex.parseColon())
        return invalid(Start, Lex.position(), "expected colon or newline");

    auto ConsequentOrErr = parseCommand();
    if (!ConsequentOrErr)
        return invalid(Start, Lex.position(), "expected Command");
    auto Consequent = std::move(*ConsequentOrErr);

    ElseSyntax* Alternative = nullptr;
    {
        auto ParseResult = parseElse();
        if (ParseResult)
            Alternative = new ElseSyntax(std::move(*ParseResult));
        else
            llvm::consumeError(ParseResult.takeError());
    }

    size_t End = Lex.position();

    return IfSyntax{Start, End, Condition, Consequent, Alternative};

}

llvm::Expected<ElseSyntax> Parser::parseElse() {
    size_t Start = Lex.previousPosition();

    if (!Lex.parseKeyword("else"))
        return different();

    Lex.parseColon();

    auto AlternativeOrErr = parseCommand();
    if (!AlternativeOrErr)
        return invalid(Start, Lex.position(), "expected Command");
    auto Alternative = std::move(*AlternativeOrErr);

    size_t End = Lex.position();

    return ElseSyntax{Start, End, Alternative};

}

llvm::Expected<MatchSyntax> Parser::parseMatch() {
    size_t Start = Lex.previousPosition();

    if (!Lex.parseKeyword("match"))
        return different();

    auto ScrutineeOrErr = parseOperandList();
    if (!ScrutineeOrErr)
        return invalid(Start, Lex.position(), "expected Operand");
    auto *Scrutinee = *ScrutineeOrErr;

    if (!Lex.parseColon())
        return invalid(Start, Lex.position(), "expected colon or newline");

    auto BranchesOrErr = parseBranchList();
    if (!BranchesOrErr)
        return invalid(Start, Lex.position(), "expected Branch");
    auto *Branches = *BranchesOrErr;

    ElseSyntax* Alternative = nullptr;
    {
        auto ParseResult = parseElse();
        if (ParseResult)
            Alternative = new ElseSyntax(std::move(*ParseResult));
        else
            llvm::consumeError(ParseResult.takeError());
    }

    size_t End = Lex.position();

    return MatchSyntax{Start, End, Scrutinee, Branches, Alternative};

}

llvm::Expected<std::vector<BranchSyntax>*> Parser::parseBranchList() {
    auto *List = new std::vector<BranchSyntax>();
    while (true) {
        auto NodeOrErr = parseBranch();
        if (!NodeOrErr) {
            if (List->empty()) {
                delete List;
                return NodeOrErr.takeError();
            }
            llvm::consumeError(NodeOrErr.takeError());
            return List;
        }
        List->push_back(std::move(*NodeOrErr));
    }
}

llvm::Expected<BranchSyntax> Parser::parseBranch() {
    size_t Start = Lex.previousPosition();

    auto CasesOrErr = parseCaseList();
    if (!CasesOrErr)
        return CasesOrErr.takeError();
    auto *Cases = *CasesOrErr;

    if (!Lex.parseColon())
        return invalid(Start, Lex.position(), "expected colon or newline");

    auto ConsequentOrErr = parseStatement();
    if (!ConsequentOrErr)
        return invalid(Start, Lex.position(), "expected Statement");
    auto Consequent = std::move(*ConsequentOrErr);

    size_t End = Lex.position();

    return BranchSyntax{Start, End, Cases, Consequent};

}

llvm::Expected<std::vector<CaseSyntax>*> Parser::parseCaseList() {
    auto *List = new std::vector<CaseSyntax>();
    while (true) {
        auto NodeOrErr = parseCase();
        if (!NodeOrErr) {
            if (List->empty()) {
                delete List;
                return NodeOrErr.takeError();
            }
            llvm::consumeError(NodeOrErr.takeError());
            return List;
        }
        List->push_back(std::move(*NodeOrErr));
    }
}

llvm::Expected<CaseSyntax> Parser::parseCase() {
    size_t Start = Lex.previousPosition();

    if (!Lex.parseKeyword("case"))
        return different();

    auto ConditionOrErr = parseOperandList();
    if (!ConditionOrErr)
        return invalid(Start, Lex.position(), "expected Operand");
    auto *Condition = *ConditionOrErr;

    size_t End = Lex.position();

    return CaseSyntax{Start, End, Condition};

}

llvm::Expected<std::vector<StatementSyntax>*> Parser::parseStatementList() {
    auto *List = new std::vector<StatementSyntax>();
    while (true) {
        auto NodeOrErr = parseStatement();
        if (!NodeOrErr) {
            if (List->empty()) {
                delete List;
                return NodeOrErr.takeError();
            }
            llvm::consumeError(NodeOrErr.takeError());
            return List;
        }
        List->push_back(std::move(*NodeOrErr));
    }
}

llvm::Expected<StatementSyntax> Parser::parseStatement() {
    size_t Start = Lex.previousPosition();

    auto CommandOrErr = parseCommand();
    if (!CommandOrErr)
        return CommandOrErr.takeError();
    auto Command = std::move(*CommandOrErr);

    Lex.parseColon();

    size_t End = Lex.position();

    return StatementSyntax{Start, End, Command};

}

llvm::Expected<WhileSyntax> Parser::parseWhile() {
    size_t Start = Lex.previousPosition();

    if (!Lex.parseKeyword("while"))
        return different();

    auto ConditionOrErr = parseCondition();
    if (!ConditionOrErr)
        return invalid(Start, Lex.position(), "expected Condition");
    auto Condition = std::move(*ConditionOrErr);

    if (!Lex.parseColon())
        return invalid(Start, Lex.position(), "expected colon or newline");

    LabelSyntax* Name = nullptr;
    {
        auto ParseResult = parseLabel();
        if (ParseResult)
            Name = new LabelSyntax(std::move(*ParseResult));
        else
            llvm::consumeError(ParseResult.takeError());
    }

    auto ActionOrErr = parseAction();
    if (!ActionOrErr)
        return invalid(Start, Lex.position(), "expected Action");
    auto Action = std::move(*ActionOrErr);

    size_t End = Lex.position();

    return WhileSyntax{Start, End, Condition, Name, Action};

}

llvm::Expected<ChooseSyntax> Parser::parseChoose() {
    size_t Start = Lex.previousPosition();

    if (!Lex.parseKeyword("choose"))
        return different();

    auto ConditionOrErr = parseOperandList();
    if (!ConditionOrErr)
        return invalid(Start, Lex.position(), "expected Operand");
    auto *Condition = *ConditionOrErr;

    if (!Lex.parseColon())
        return invalid(Start, Lex.position(), "expected colon or newline");

    std::vector<WhenSyntax>* Cases = nullptr;
    {
        auto ParseResult = parseWhenList();
        if (ParseResult)
            Cases = *ParseResult;
    }

    ElseSyntax* Alternative = nullptr;
    {
        auto ParseResult = parseElse();
        if (ParseResult)
            Alternative = new ElseSyntax(std::move(*ParseResult));
        else
            llvm::consumeError(ParseResult.takeError());
    }

    size_t End = Lex.position();

    return ChooseSyntax{Start, End, Condition, Cases, Alternative};

}

llvm::Expected<TrySyntax> Parser::parseTry() {
    size_t Start = Lex.previousPosition();

    if (!Lex.parseKeyword("try"))
        return different();

    auto ConditionOrErr = parseCondition();
    if (!ConditionOrErr)
        return invalid(Start, Lex.position(), "expected Condition");
    auto Condition = std::move(*ConditionOrErr);

    if (!Lex.parseColon())
        return invalid(Start, Lex.position(), "expected colon or newline");

    std::vector<WhenSyntax>* Cases = nullptr;
    {
        auto ParseResult = parseWhenList();
        if (ParseResult)
            Cases = *ParseResult;
    }

    ElseSyntax* Dropper = nullptr;
    {
        auto ParseResult = parseElse();
        if (ParseResult)
            Dropper = new ElseSyntax(std::move(*ParseResult));
        else
            llvm::consumeError(ParseResult.takeError());
    }

    size_t End = Lex.position();

    return TrySyntax{Start, End, Condition, Cases, Dropper};

}

llvm::Expected<ConditionSyntax> Parser::parseCondition() {
    {
        auto Result = parseOperation();
        if (Result)
            return ConditionSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    {
        auto Result = parseLet();
        if (Result)
            return ConditionSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    return different();

}

llvm::Expected<std::vector<WhenSyntax>*> Parser::parseWhenList() {
    auto *List = new std::vector<WhenSyntax>();
    while (true) {
        auto NodeOrErr = parseWhen();
        if (!NodeOrErr) {
            if (List->empty()) {
                delete List;
                return NodeOrErr.takeError();
            }
            llvm::consumeError(NodeOrErr.takeError());
            return List;
        }
        List->push_back(std::move(*NodeOrErr));
    }
}

llvm::Expected<WhenSyntax> Parser::parseWhen() {
    size_t Start = Lex.previousPosition();

    if (!Lex.parseKeyword("when"))
        return different();

    llvm::StringRef Name = Lex.peekIdentifier();
    if (Name.empty() || Keywords.count(Name))
        return invalid(Start, Lex.position(), "expected identifier");
    Lex.parseIdentifier();  // Consume the identifier

    if (!Lex.parseColon())
        return invalid(Start, Lex.position(), "expected colon or newline");

    auto VariantOrErr = parseName();
    if (!VariantOrErr)
        return invalid(Start, Lex.position(), "expected Name");
    auto Variant = std::move(*VariantOrErr);

    Lex.parseColon();

    auto CommandOrErr = parseCommand();
    if (!CommandOrErr)
        return invalid(Start, Lex.position(), "expected Command");
    auto Command = std::move(*CommandOrErr);

    Lex.parseColon();

    size_t End = Lex.position();

    return WhenSyntax{Start, End, Name, Variant, Command};

}

llvm::Expected<CommandSyntax> Parser::parseCommand() {
    {
        auto Result = parseOperation();
        if (Result)
            return CommandSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    {
        auto Result = parseLet();
        if (Result)
            return CommandSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    {
        auto Result = parseVar();
        if (Result)
            return CommandSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    {
        auto Result = parseMutable();
        if (Result)
            return CommandSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    {
        auto Result = parseSet();
        if (Result)
            return CommandSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    {
        auto Result = parseContinue();
        if (Result)
            return CommandSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    {
        auto Result = parseBreak();
        if (Result)
            return CommandSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    {
        auto Result = parseReturn();
        if (Result)
            return CommandSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    {
        auto Result = parseThrow();
        if (Result)
            return CommandSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    return different();

}

llvm::Expected<LetSyntax> Parser::parseLet() {
    size_t Start = Lex.previousPosition();

    if (!Lex.parseKeyword("let"))
        return different();

    auto BindingOrErr = parseBinding();
    if (!BindingOrErr)
        return invalid(Start, Lex.position(), "expected Binding");
    auto Binding = std::move(*BindingOrErr);

    size_t End = Lex.position();

    return LetSyntax{Start, End, Binding};

}

llvm::Expected<VarSyntax> Parser::parseVar() {
    size_t Start = Lex.previousPosition();

    if (!Lex.parseKeyword("var"))
        return different();

    auto BindingOrErr = parseBinding();
    if (!BindingOrErr)
        return invalid(Start, Lex.position(), "expected Binding");
    auto Binding = std::move(*BindingOrErr);

    size_t End = Lex.position();

    return VarSyntax{Start, End, Binding};

}

llvm::Expected<MutableSyntax> Parser::parseMutable() {
    size_t Start = Lex.previousPosition();

    if (!Lex.parseKeyword("mutable"))
        return different();

    auto BindingOrErr = parseBinding();
    if (!BindingOrErr)
        return invalid(Start, Lex.position(), "expected Binding");
    auto Binding = std::move(*BindingOrErr);

    size_t End = Lex.position();

    return MutableSyntax{Start, End, Binding};

}

llvm::Expected<BindingSyntax> Parser::parseBinding() {
    size_t Start = Lex.previousPosition();

    llvm::StringRef Name = Lex.peekIdentifier();
    if (Name.empty() || Keywords.count(Name))
        return different();
    Lex.parseIdentifier();  // Consume the identifier

    BindingAnnotationSyntax* Annotation = nullptr;
    {
        auto ParseResult = parseBindingAnnotation();
        if (ParseResult)
            Annotation = new BindingAnnotationSyntax(std::move(*ParseResult));
        else
            llvm::consumeError(ParseResult.takeError());
    }

    std::vector<OperandSyntax>* Operation = nullptr;
    {
        auto ParseResult = parseOperandList();
        if (ParseResult)
            Operation = *ParseResult;
    }

    size_t End = Lex.position();

    return BindingSyntax{Start, End, Name, Annotation, Operation};

}

llvm::Expected<BindingAnnotationSyntax> Parser::parseBindingAnnotation() {
    size_t Start = Lex.previousPosition();

    if (!Lex.parseColon())
        return different();

    auto SpecOrErr = parseBindingSpec();
    if (!SpecOrErr)
        return invalid(Start, Lex.position(), "expected BindingSpec");
    auto Spec = std::move(*SpecOrErr);

    size_t End = Lex.position();

    return BindingAnnotationSyntax{Start, End, Spec};

}

llvm::Expected<std::vector<BindingSpecSyntax>*> Parser::parseBindingSpecList() {
    auto *List = new std::vector<BindingSpecSyntax>();
    while (true) {
        auto NodeOrErr = parseBindingSpec();
        if (!NodeOrErr) {
            if (List->empty()) {
                delete List;
                return NodeOrErr.takeError();
            }
            llvm::consumeError(NodeOrErr.takeError());
            return List;
        }
        List->push_back(std::move(*NodeOrErr));
    }
}

llvm::Expected<BindingSpecSyntax> Parser::parseBindingSpec() {
    {
        auto Result = parseStructure();
        if (Result)
            return BindingSpecSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    {
        auto Result = parseType();
        if (Result)
            return BindingSpecSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    {
        auto Result = parseArray();
        if (Result)
            return BindingSpecSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    return different();

}

llvm::Expected<ArraySyntax> Parser::parseArray() {
    size_t Start = Lex.previousPosition();

    if (!Lex.parsePunctuation('['))
        return different();

    std::vector<TypeSyntax>* Members = nullptr;
    {
        auto ParseResult = parseTypeList();
        if (ParseResult)
            Members = *ParseResult;
    }

    if (!Lex.parsePunctuation(']'))
        return invalid(Start, Lex.position(), "expected ']'");

    size_t End = Lex.position();

    return ArraySyntax{Start, End, Members};

}

llvm::Expected<StructureSyntax> Parser::parseStructure() {
    size_t Start = Lex.previousPosition();

    if (!Lex.parsePunctuation('('))
        return different();

    std::vector<PartSyntax>* Parts = nullptr;
    {
        auto ParseResult = parsePartList();
        if (ParseResult)
            Parts = *ParseResult;
    }

    if (!Lex.parsePunctuation(')'))
        return invalid(Start, Lex.position(), "expected ')'");

    size_t End = Lex.position();

    return StructureSyntax{Start, End, Parts};

}

llvm::Expected<std::vector<PartSyntax>*> Parser::parsePartList() {
    auto *List = new std::vector<PartSyntax>();
    while (true) {
        auto NodeOrErr = parsePart();
        if (!NodeOrErr) {
            if (List->empty()) {
                delete List;
                return NodeOrErr.takeError();
            }
            llvm::consumeError(NodeOrErr.takeError());
            return List;
        }
        List->push_back(std::move(*NodeOrErr));
    }
}

llvm::Expected<PartSyntax> Parser::parsePart() {
    {
        auto Result = parseField();
        if (Result)
            return PartSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    {
        auto Result = parseProperty();
        if (Result)
            return PartSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    return different();

}

llvm::Expected<FieldSyntax> Parser::parseField() {
    size_t Start = Lex.previousPosition();

    if (!Lex.parseKeyword("private"))
        return different();

    auto PropertyOrErr = parseProperty();
    if (!PropertyOrErr)
        return invalid(Start, Lex.position(), "expected Property");
    auto Property = std::move(*PropertyOrErr);

    size_t End = Lex.position();

    return FieldSyntax{Start, End, Property};

}

llvm::Expected<std::vector<PropertySyntax>*> Parser::parsePropertyList() {
    auto *List = new std::vector<PropertySyntax>();
    while (true) {
        auto NodeOrErr = parseProperty();
        if (!NodeOrErr) {
            if (List->empty()) {
                delete List;
                return NodeOrErr.takeError();
            }
            llvm::consumeError(NodeOrErr.takeError());
            return List;
        }
        List->push_back(std::move(*NodeOrErr));
    }
}

llvm::Expected<PropertySyntax> Parser::parseProperty() {
    size_t Start = Lex.previousPosition();

    llvm::StringRef Name = Lex.peekIdentifier();
    if (Name.empty() || Keywords.count(Name))
        return different();
    Lex.parseIdentifier();  // Consume the identifier

    auto AnnotationOrErr = parseTypeAnnotation();
    if (!AnnotationOrErr)
        return invalid(Start, Lex.position(), "expected TypeAnnotation");
    auto Annotation = std::move(*AnnotationOrErr);

    InitializerSyntax* Initializer = nullptr;
    {
        auto ParseResult = parseInitializer();
        if (ParseResult)
            Initializer = new InitializerSyntax(std::move(*ParseResult));
        else
            llvm::consumeError(ParseResult.takeError());
    }

    Lex.parsePunctuation(',');

    Lex.parseColon();

    std::vector<AttributeSyntax>* Attributes = nullptr;
    {
        auto ParseResult = parseAttributeList();
        if (ParseResult)
            Attributes = *ParseResult;
    }

    Lex.parseColon();

    size_t End = Lex.position();

    return PropertySyntax{Start, End, Name, Annotation, Initializer, Attributes};

}

llvm::Expected<TypeAnnotationSyntax> Parser::parseTypeAnnotation() {
    size_t Start = Lex.previousPosition();

    if (!Lex.parseColon())
        return different();

    auto TypeOrErr = parseType();
    if (!TypeOrErr)
        return invalid(Start, Lex.position(), "expected Type");
    auto Type = std::move(*TypeOrErr);

    size_t End = Lex.position();

    return TypeAnnotationSyntax{Start, End, Type};

}

llvm::Expected<ContinueSyntax> Parser::parseContinue() {
    size_t Start = Lex.previousPosition();

    if (!Lex.parseKeyword("continue"))
        return different();

    LoopSyntax* Name = nullptr;
    {
        auto ParseResult = parseLoop();
        if (ParseResult)
            Name = new LoopSyntax(std::move(*ParseResult));
        else
            llvm::consumeError(ParseResult.takeError());
    }

    Lex.parseColon();

    size_t End = Lex.position();

    return ContinueSyntax{Start, End, Name};

}

llvm::Expected<BreakSyntax> Parser::parseBreak() {
    size_t Start = Lex.previousPosition();

    if (!Lex.parseKeyword("break"))
        return different();

    LoopSyntax* Name = nullptr;
    {
        auto ParseResult = parseLoop();
        if (ParseResult)
            Name = new LoopSyntax(std::move(*ParseResult));
        else
            llvm::consumeError(ParseResult.takeError());
    }

    std::vector<OperandSyntax>* Result = nullptr;
    {
        auto ParseResult = parseOperandList();
        if (ParseResult)
            Result = *ParseResult;
    }

    Lex.parseColon();

    size_t End = Lex.position();

    return BreakSyntax{Start, End, Name, Result};

}

llvm::Expected<LoopSyntax> Parser::parseLoop() {
    size_t Start = Lex.previousPosition();

    if (!Lex.parseKeyword("loop"))
        return different();

    llvm::StringRef Name = Lex.peekIdentifier();
    if (Name.empty() || Keywords.count(Name))
        return invalid(Start, Lex.position(), "expected identifier");
    Lex.parseIdentifier();  // Consume the identifier

    size_t End = Lex.position();

    return LoopSyntax{Start, End, Name};

}

llvm::Expected<ReturnSyntax> Parser::parseReturn() {
    size_t Start = Lex.previousPosition();

    if (!Lex.parseKeyword("return"))
        return different();

    std::vector<OperandSyntax>* Result = nullptr;
    {
        auto ParseResult = parseOperandList();
        if (ParseResult)
            Result = *ParseResult;
    }

    size_t End = Lex.position();

    return ReturnSyntax{Start, End, Result};

}

llvm::Expected<ThrowSyntax> Parser::parseThrow() {
    size_t Start = Lex.previousPosition();

    if (!Lex.parseKeyword("throw"))
        return different();

    std::vector<OperandSyntax>* Result = nullptr;
    {
        auto ParseResult = parseOperandList();
        if (ParseResult)
            Result = *ParseResult;
    }

    size_t End = Lex.position();

    return ThrowSyntax{Start, End, Result};

}

llvm::Expected<LambdaSyntax> Parser::parseLambda() {
    size_t Start = Lex.previousPosition();

    if (!Lex.parsePunctuation('\\'))
        return different();

    auto InputOrErr = parseOperandList();
    if (!InputOrErr)
        return invalid(Start, Lex.position(), "expected Operand");
    auto *Input = *InputOrErr;

    if (!Lex.parseColon())
        return invalid(Start, Lex.position(), "expected colon or newline");

    auto BlockOrErr = parseAction();
    if (!BlockOrErr)
        return invalid(Start, Lex.position(), "expected Action");
    auto Block = std::move(*BlockOrErr);

    size_t End = Lex.position();

    return LambdaSyntax{Start, End, Input, Block};

}

llvm::Expected<ForSyntax> Parser::parseFor() {
    size_t Start = Lex.previousPosition();

    if (!Lex.parseKeyword("for"))
        return different();

    llvm::StringRef Variable = Lex.peekIdentifier();
    if (Variable.empty() || Keywords.count(Variable))
        return invalid(Start, Lex.position(), "expected identifier");
    Lex.parseIdentifier();  // Consume the identifier

    TypeAnnotationSyntax* Annotation = nullptr;
    {
        auto ParseResult = parseTypeAnnotation();
        if (ParseResult)
            Annotation = new TypeAnnotationSyntax(std::move(*ParseResult));
        else
            llvm::consumeError(ParseResult.takeError());
    }

    if (!Lex.parseKeyword("in"))
        return invalid(Start, Lex.position(), "expected 'in'");

    auto OperationOrErr = parseOperandList();
    if (!OperationOrErr)
        return invalid(Start, Lex.position(), "expected Operand");
    auto *Operation = *OperationOrErr;

    if (!Lex.parseColon())
        return invalid(Start, Lex.position(), "expected colon or newline");

    LabelSyntax* Name = nullptr;
    {
        auto ParseResult = parseLabel();
        if (ParseResult)
            Name = new LabelSyntax(std::move(*ParseResult));
        else
            llvm::consumeError(ParseResult.takeError());
    }

    auto ActionOrErr = parseAction();
    if (!ActionOrErr)
        return invalid(Start, Lex.position(), "expected Action");
    auto Action = std::move(*ActionOrErr);

    size_t End = Lex.position();

    return ForSyntax{Start, End, Variable, Annotation, Operation, Name, Action};

}

llvm::Expected<LabelSyntax> Parser::parseLabel() {
    size_t Start = Lex.previousPosition();

    if (!Lex.parseKeyword("label"))
        return different();

    llvm::StringRef Name = Lex.peekIdentifier();
    if (Name.empty() || Keywords.count(Name))
        return invalid(Start, Lex.position(), "expected identifier");
    Lex.parseIdentifier();  // Consume the identifier

    Lex.parseColon();

    size_t End = Lex.position();

    return LabelSyntax{Start, End, Name};

}

llvm::Expected<RepeatSyntax> Parser::parseRepeat() {
    size_t Start = Lex.previousPosition();

    if (!Lex.parseKeyword("repeat"))
        return different();

    LabelSyntax* Name = nullptr;
    {
        auto ParseResult = parseLabel();
        if (ParseResult)
            Name = new LabelSyntax(std::move(*ParseResult));
        else
            llvm::consumeError(ParseResult.takeError());
    }

    auto ActionOrErr = parseAction();
    if (!ActionOrErr)
        return invalid(Start, Lex.position(), "expected Action");
    auto Action = std::move(*ActionOrErr);

    size_t End = Lex.position();

    return RepeatSyntax{Start, End, Name, Action};

}

llvm::Expected<std::vector<ActionSyntax>*> Parser::parseActionList() {
    auto *List = new std::vector<ActionSyntax>();
    while (true) {
        auto NodeOrErr = parseAction();
        if (!NodeOrErr) {
            if (List->empty()) {
                delete List;
                return NodeOrErr.takeError();
            }
            llvm::consumeError(NodeOrErr.takeError());
            return List;
        }
        List->push_back(std::move(*NodeOrErr));
    }
}

llvm::Expected<ActionSyntax> Parser::parseAction() {
    {
        auto Result = parseOperation();
        if (Result)
            return ActionSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    {
        auto Result = parseSet();
        if (Result)
            return ActionSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    {
        auto Result = parseBlock();
        if (Result)
            return ActionSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    return different();

}

llvm::Expected<OperationSyntax> Parser::parseOperation() {
    size_t Start = Lex.previousPosition();

    auto OperandsOrErr = parseOperandList();
    if (!OperandsOrErr)
        return OperandsOrErr.takeError();
    auto *Operands = *OperandsOrErr;

    size_t End = Lex.position();

    return OperationSyntax{Start, End, Operands};

}

llvm::Expected<SetSyntax> Parser::parseSet() {
    size_t Start = Lex.previousPosition();

    if (!Lex.parseKeyword("set"))
        return different();

    auto TargetOrErr = parseOperandList();
    if (!TargetOrErr)
        return invalid(Start, Lex.position(), "expected Operand");
    auto *Target = *TargetOrErr;

    if (!Lex.parseColon())
        return invalid(Start, Lex.position(), "expected colon or newline");

    auto SourceOrErr = parseOperandList();
    if (!SourceOrErr)
        return invalid(Start, Lex.position(), "expected Operand");
    auto *Source = *SourceOrErr;

    size_t End = Lex.position();

    return SetSyntax{Start, End, Target, Source};

}

llvm::Expected<BlockSyntax> Parser::parseBlock() {
    size_t Start = Lex.previousPosition();

    if (!Lex.parsePunctuation('{'))
        return different();

    std::vector<UseSyntax>* Uses = nullptr;
    {
        auto ParseResult = parseUseList();
        if (ParseResult)
            Uses = *ParseResult;
    }

    std::vector<StatementSyntax>* Statements = nullptr;
    {
        auto ParseResult = parseStatementList();
        if (ParseResult)
            Statements = *ParseResult;
    }

    if (!Lex.parsePunctuation('}'))
        return invalid(Start, Lex.position(), "expected '}'");

    size_t End = Lex.position();

    return BlockSyntax{Start, End, Uses, Statements};

}

llvm::Expected<SizeOfSyntax> Parser::parseSizeOf() {
    size_t Start = Lex.previousPosition();

    if (!Lex.parseKeyword("sizeof"))
        return different();

    auto TypeOrErr = parseType();
    if (!TypeOrErr)
        return invalid(Start, Lex.position(), "expected Type");
    auto Type = std::move(*TypeOrErr);

    size_t End = Lex.position();

    return SizeOfSyntax{Start, End, Type};

}

llvm::Expected<AlignOfSyntax> Parser::parseAlignOf() {
    size_t Start = Lex.previousPosition();

    if (!Lex.parseKeyword("alignof"))
        return different();

    auto TypeOrErr = parseType();
    if (!TypeOrErr)
        return invalid(Start, Lex.position(), "expected Type");
    auto Type = std::move(*TypeOrErr);

    size_t End = Lex.position();

    return AlignOfSyntax{Start, End, Type};

}

llvm::Expected<IsSyntax> Parser::parseIs() {
    size_t Start = Lex.previousPosition();

    if (!Lex.parseKeyword("is"))
        return different();

    auto NameOrErr = parseName();
    if (!NameOrErr)
        return invalid(Start, Lex.position(), "expected Name");
    auto Name = std::move(*NameOrErr);

    size_t End = Lex.position();

    return IsSyntax{Start, End, Name};

}

llvm::Expected<AsSyntax> Parser::parseAs() {
    size_t Start = Lex.previousPosition();

    if (!Lex.parseKeyword("as"))
        return different();

    auto TypeOrErr = parseType();
    if (!TypeOrErr)
        return invalid(Start, Lex.position(), "expected Type");
    auto Type = std::move(*TypeOrErr);

    size_t End = Lex.position();

    return AsSyntax{Start, End, Type};

}

llvm::Expected<std::vector<TypeSyntax>*> Parser::parseTypeList() {
    auto *List = new std::vector<TypeSyntax>();
    while (true) {
        auto NodeOrErr = parseType();
        if (!NodeOrErr) {
            if (List->empty()) {
                delete List;
                return NodeOrErr.takeError();
            }
            llvm::consumeError(NodeOrErr.takeError());
            return List;
        }
        List->push_back(std::move(*NodeOrErr));
    }
}

llvm::Expected<TypeSyntax> Parser::parseType() {
    size_t Start = Lex.previousPosition();

    auto NameOrErr = parseName();
    if (!NameOrErr)
        return NameOrErr.takeError();
    auto Name = std::move(*NameOrErr);

    GenericArgumentsSyntax* Generics = nullptr;
    {
        auto ParseResult = parseGenericArguments();
        if (ParseResult)
            Generics = new GenericArgumentsSyntax(std::move(*ParseResult));
        else
            llvm::consumeError(ParseResult.takeError());
    }

    OptionalSyntax* Optional = nullptr;
    {
        auto ParseResult = parseOptional();
        if (ParseResult)
            Optional = new OptionalSyntax(std::move(*ParseResult));
        else
            llvm::consumeError(ParseResult.takeError());
    }

    LifetimeSyntax* Lifetime = nullptr;
    {
        auto ParseResult = parseLifetime();
        if (ParseResult)
            Lifetime = new LifetimeSyntax(std::move(*ParseResult));
        else
            llvm::consumeError(ParseResult.takeError());
    }

    size_t End = Lex.position();

    return TypeSyntax{Start, End, Name, Generics, Optional, Lifetime};

}

llvm::Expected<NameSyntax> Parser::parseName() {
    size_t Start = Lex.previousPosition();

    llvm::StringRef Name = Lex.peekIdentifier();
    if (Name.empty() || Keywords.count(Name))
        return different();
    Lex.parseIdentifier();  // Consume the identifier

    std::vector<ExtensionSyntax>* Extensions = nullptr;
    {
        auto ParseResult = parseExtensionList();
        if (ParseResult)
            Extensions = *ParseResult;
    }

    size_t End = Lex.position();

    return NameSyntax{Start, End, Name, Extensions};

}

llvm::Expected<std::vector<ExtensionSyntax>*> Parser::parseExtensionList() {
    auto *List = new std::vector<ExtensionSyntax>();
    while (true) {
        auto NodeOrErr = parseExtension();
        if (!NodeOrErr) {
            if (List->empty()) {
                delete List;
                return NodeOrErr.takeError();
            }
            llvm::consumeError(NodeOrErr.takeError());
            return List;
        }
        List->push_back(std::move(*NodeOrErr));
    }
}

llvm::Expected<ExtensionSyntax> Parser::parseExtension() {
    size_t Start = Lex.previousPosition();

    if (!Lex.parsePunctuation('.'))
        return different();

    llvm::StringRef Name = Lex.peekIdentifier();
    if (Name.empty() || Keywords.count(Name))
        return invalid(Start, Lex.position(), "expected identifier");
    Lex.parseIdentifier();  // Consume the identifier

    size_t End = Lex.position();

    return ExtensionSyntax{Start, End, Name};

}

llvm::Expected<LifetimeSyntax> Parser::parseLifetime() {
    {
        auto Result = parseCall();
        if (Result)
            return LifetimeSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    {
        auto Result = parseLocal();
        if (Result)
            return LifetimeSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    {
        auto Result = parseReference();
        if (Result)
            return LifetimeSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    {
        auto Result = parseThrown();
        if (Result)
            return LifetimeSyntax{std::move(*Result)};
        llvm::consumeError(Result.takeError());
    }
    return different();

}

llvm::Expected<CallSyntax> Parser::parseCall() {
    size_t Start = Lex.previousPosition();

    if (!Lex.parsePunctuation('#'))
        return different();

    size_t End = Lex.position();

    return CallSyntax{Start, End};

}

llvm::Expected<LocalSyntax> Parser::parseLocal() {
    size_t Start = Lex.previousPosition();

    if (!Lex.parsePunctuation('$'))
        return different();

    size_t End = Lex.position();

    return LocalSyntax{Start, End};

}

llvm::Expected<ReferenceSyntax> Parser::parseReference() {
    size_t Start = Lex.previousPosition();

    if (!Lex.parsePunctuation('^'))
        return different();

    llvm::StringRef Location = Lex.peekIdentifier();
    if (Location.empty() || Keywords.count(Location))
        return invalid(Start, Lex.position(), "expected identifier");
    Lex.parseIdentifier();  // Consume the identifier

    size_t End = Lex.position();

    return ReferenceSyntax{Start, End, Location};

}

llvm::Expected<ThrownSyntax> Parser::parseThrown() {
    size_t Start = Lex.previousPosition();

    if (!Lex.parsePunctuation('!'))
        return different();

    size_t End = Lex.position();

    return ThrownSyntax{Start, End};

}

} // namespace scaly
