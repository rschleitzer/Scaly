class Inherits

class CppVisitor extends CommonVisitor {

    // Some rudimentary semantics cache
    mutable inherits: Inherits[]
    mutable classes: string[]

    function hasArrayPostfix(type: Type): bool {

        if type.postfixes == null
            return(false)

        let postfixes: TypePostfix[] = type.postfixes
        let typePostfix: TypePostfix = postfixes[0]

        if typePostfix is IndexedType
            return(true)

        false
    }

    function isClass(name: string): bool

    function appendCppType(mutable s: VarString, type: Type) {
        if hasArrayPostfix(type) {
            s.append("_Array<")
            appendCppTypeName(s, type)
            s.append(">*")
        }
        else {
            appendCppTypeName(s, type)
            if isClass(type.name) {
                s.append("*")
            }
        }
    }

    function appendCppTypeName(mutable s: VarString, type: Type) {
        let typeName: string = type.name
        if typeName.equals("number") {
            s.append("size_t")
            return
        }
        else {
            if typeName.equals("char") {
                s.append("char")
                return
            }
        }

        s.append(typeName)
    }

    function collectDerivedClasses(mutable derivedClasses: string[], className: string) {
        for inherit: Inherits in inherits {
            if inherit.name.equals(className)
                appendDerivedClasses(derivedClasses, inherit.inheritors)
        }
    }

    function appendDerivedClasses(mutable derivedClasses: string[], mutable inheritors: string[]) {
        for inheritor: string in inheritors {
            derivedClasses.push(inheritor)
            collectDerivedClasses(derivedClasses, inheritor)
        }
    }

    function collectInheritancesInModule(module: Module) {
        if module.statements != null {
            for statement: Statement in module.statements {
                if statement is ClassDeclaration {
                    let classDeclaration: ClassDeclaration = statement as ClassDeclaration
                    classes.push(classDeclaration.name)
                    if classDeclaration.typeInheritanceClause != null {
                        let inheritanceClause: TypeInheritanceClause  = classDeclaration.typeInheritanceClause
                        for inheritance: Inheritance in inheritanceClause.inheritances {
                            registerInheritance(classDeclaration.name, inheritance.type.name)
                        }
                    }
                }
            }
        }
    }

    function registerInheritance(className: string, baseName: string) {
        mutable inherit: Inherits@inherits = null
        for inh: Inherits in inherits {
            if inh.name.equals(baseName) {
                inherit = inh
            }
        }

        if inherit == null {
            let newInherit: Inherits@inherits = new Inherits(baseName)
            inherit = newInherit
            inherits.push(inherit)
        }

        inherit.inheritors.push(className)
    }
}

class Inherits {

    // Class to inherit from
    let name: string

    // Classes which inherit from the class
    mutable inheritors: string[]

    constructor(className: string) {
        name = new string(className)
        inheritors = new string[]()
    }
}

class HeaderVisitor extends CppVisitor {
    
    let directory: string
    mutable headerFile: VarString
    mutable mainHeaderFile: VarString

    constructor(outputDirectory: string) {
        directory = outputDirectory
        headerFile = null
        mainHeaderFile = null
        inherits = new Inherits[]()
        classes = new string[]()
    }

    function openProgram(program: Program): bool {
        mutable programDirectory: string$ = new string(directory)

        if programDirectory == null || programDirectory.equals("") {
            programDirectory = new string(".")
        }

        if !Directory.exists(programDirectory) {
            Directory.create(programDirectory)
                catch _ (error: dirError())
                    return(false)
        }

        {
            mutable outputFilePath: VarString$ = new VarString(programDirectory)
            outputFilePath.append("/")
            outputFilePath.append(program.name)

            // Build and write the main header file
            {
                buildMainHeaderFileString(program)
                {
                    mutable headerFilePath: VarString$  = new VarString(outputFilePath)
                    headerFilePath.append(".h")
                    File.writeFromString(headerFilePath, mainHeaderFile)
                        catch _ (error: fileError)
                            return(false)
                }
            }

            collectInheritances(program)
        }

        true
    }

    function openModule(module: Module): bool {

        if !(module.parent is Program)
            return(false)

        let programName: string = (module.parent as Program).name
        let fileName: string$ = getFileName(module)
        if fileName != null {
            let name: string$ = Path.getFileNameWithoutExtension(fileName)
            if !fileName.equals(programName) {
                headerFile = new VarString()
                headerFile.append("#ifndef __")
                headerFile.append(programName)
                headerFile.append("__")
                headerFile.append(name)
                headerFile.append("__\n")
                headerFile.append("#define __")
                headerFile.append(programName)
                headerFile.append("__")
                headerFile.append(name)
                headerFile.append("__\n#include \"")
                headerFile.append(programName)
                headerFile.append(".h\"\nusing namespace scaly;\nnamespace ")
                headerFile.append(programName)
                headerFile.append(" {")
            }
        }

        true
    }

    function closeModule(module: Module) {

        if !(module.parent) is Program
            return

        let programName: string = (module.parent as Program).name
        mutable outputFilePath: VarString$  = new VarString(directory)
        outputFilePath.append('/')

        let fileName: string$ = getFileName(module)
        if fileName != null {
            let name: string$ = Path.getFileNameWithoutExtension(fileName)
            outputFilePath.append(name)

            if !fileName.equals(programName) {
                headerFile.append("\n\n}\n#endif // __")
                headerFile.append(programName)
                headerFile.append("__")
                headerFile.append(name)
                headerFile.append("__\n")
                let headerFilePath: VarString$ = new VarString(outputFilePath)
                headerFilePath.append(".h")
                File.writeFromString(headerFilePath, headerFile)
                    catch _ (error: fileError)
                        return
            }
        }
    }

    function openConstantDeclaration(constantDeclaration: ConstantDeclaration): bool {

        if constantDeclaration.parent.parent.parent == null
            return(false)

        if constantDeclaration.parent.parent.parent is ClassDeclaration
            return(true)

        false
    }

    function openMutableDeclaration(mutableDeclaration: MutableDeclaration): bool {

        if mutableDeclaration.parent.parent.parent == null
            return(false)

        if mutableDeclaration.parent.parent.parent is ClassDeclaration
            return(true)

        false
    }

    function closeFunctionDeclaration(functionDeclaration: FunctionDeclaration) {

        if functionDeclaration.body == null
            headerFile.append(" = 0")
    }

    function openEnumDeclaration(enumDeclaration: EnumDeclaration): bool {
        let enumDeclarationName: string = enumDeclaration.name

        headerFile.append("\n\nclass ")
        headerFile.append(enumDeclarationName)
        headerFile.append(";\n")

        true
    }

    function closeEnumDeclaration(enumDeclaration: EnumDeclaration) {
        let enumDeclarationName: string = enumDeclaration.name

        if enumDeclaration.members != null {
            headerFile.append("enum _")
            headerFile.append(enumDeclarationName)
            headerFile.append("Code {\n")
            mutable i: int = 0
            for member: EnumMember in enumDeclaration.members {
                headerFile.append("    _")
                headerFile.append(enumDeclarationName)
                headerFile.append("Code_")
                headerFile.append(member.enumCase.name)
                if i == 0
                    headerFile.append(" = 1")
                headerFile.append(",\n")
                i++
            }
            headerFile.append("};\n\n")
        }

        headerFile.append("class ")
        headerFile.append(enumDeclarationName)
        headerFile.append(" : public Object {\npublic:\n    ")
        headerFile.append(enumDeclarationName)
        headerFile.append("(_")
        headerFile.append(enumDeclarationName)
        headerFile.append("Code errorCode)\n    : errorCode(errorCode), errorInfo(0) {}\n\n")

        if enumDeclaration.members != null {
            for member: EnumMember in enumDeclaration.members {
                if member.parameterClause {
                    headerFile.append("    ")
                    headerFile.append(enumDeclarationName)
                    headerFile.append("(_")
                    headerFile.append(enumDeclarationName)
                    headerFile.append("_")
                    headerFile.append(member.enumCase.name)
                    headerFile.append("* ")
                    headerFile.append(member.enumCase.name)
                    headerFile.append(")\n    : errorCode(_")
                    headerFile.append(enumDeclarationName)
                    headerFile.append("Code_")
                    headerFile.append(member.enumCase.name)
                    headerFile.append("), errorInfo(")
                    headerFile.append(member.enumCase.name)
                    headerFile.append(") {}\n\n")
                }
            }
        }

        headerFile.append("    long _getErrorCode();\n    void* _getErrorInfo();\n\n")

        if enumDeclaration.members != null {
            for member: EnumMember in enumDeclaration.members {
                if member.parameterClause {
                    headerFile.append("    _")
                    headerFile.append(enumDeclarationName)
                    headerFile.append("_")
                    headerFile.append(member.enumCase.name)
                    headerFile.append("* get_")
                    headerFile.append(member.enumCase.name)
                    headerFile.append("();\n")
                }
            }
        }
        headerFile.append("\nprivate:\n    _")
        headerFile.append(enumDeclarationName)
        headerFile.append("Code errorCode;\n    void* errorInfo;\n};")
    }

    function openClassDeclaration(classDeclaration: ClassDeclaration): bool {
        headerFile.append("\n\nclass ")
        headerFile.append(classDeclaration.name)
        if classDeclaration.body == null {
            headerFile.append(";")
            return(false)
        }

        headerFile.append(" : public ")
        if classDeclaration.typeInheritanceClause != null {
            mutable i: int = 0
            for inheritance: Inheritance in classDeclaration.typeInheritanceClause.inheritances {

                if i > 0
                    headerFile.append(", ")

                headerFile.append(inheritance.type.name)

                i++
            }
        }
        else {
            headerFile.append("Object")
        }
        headerFile.append(" {\n")
        headerFile.append("public:")

        true
    }

    function closeClassDeclaration(classDeclaration: ClassDeclaration) {

        headerFile.append("\n")

        if classDeclaration.typeInheritanceClause != null {
            headerFile.append("\n    virtual bool _is")
            headerFile.append(classDeclaration.name)
            headerFile.append("();")
        }

        {
            mutable derivedClasses: string[]$ = new string[]()
            collectDerivedClasses(derivedClasses, classDeclaration.name)
            for derivedClass: string in derivedClasses {
                headerFile.append("\n    virtual bool _is")
                headerFile.append(derivedClass)
                headerFile.append("();")
            }
        }

        headerFile.append("\n};")
    }

    function openConstructorDeclaration(constructorDeclaration: ConstructorDeclaration): bool {

        if !constructorDeclaration.parent.parent.parent is ClassDeclaration
            return(false)

        let classDeclarationName: string = (constructorDeclaration.parent.parent.parent as ClassDeclaration).name

        headerFile.append(classDeclarationName)
        headerFile.append("(")

        true
    }

    function openCodeBlock(codeBlock: CodeBlock): bool {
        false
    }

    function openIdentifierInitializer(identifierInitializer: IdentifierInitializer): bool {
        if identifierInitializer.parent is AdditionalInitializer
            headerFile.append("; ")

        true
    }

    function openFunctionSignature(functionSignature: FunctionSignature): bool {
        let functionDeclaration: FunctionDeclaration = functionSignature.parent as FunctionDeclaration
        if functionDeclaration.modifiers != null {
            for modifier: Modifier in functionDeclaration.modifiers {
                if modifier is StaticWord
                    headerFile.append("static ")
                else
                    headerFile.append("virtual ")
            }
        }
        else {
            headerFile.append("virtual ")
        }

        if functionSignature.result == null {
            if functionSignature.throwsClause == null {
                headerFile.append("void")
            }
            else {
                appendCppType(headerFile, functionSignature.throwsClause.throwsType)
            }
        }
        else {
            if functionSignature.throwsClause != null {
                headerFile.append("_Result<")

                if hasArrayPostfix(functionSignature.result.resultType) {
                    headerFile.append("_Array<")
                    appendCppTypeName(headerFile, functionSignature.result.resultType)
                    headerFile.append(">")
                }
                else {
                    appendCppTypeName(headerFile, functionSignature.result.resultType)
                }
                headerFile.append(", ")
                appendCppTypeName(headerFile, functionSignature.throwsClause.throwsType)
                headerFile.append(">")
            }
            else {
                if hasArrayPostfix(functionSignature.result.resultType) {
                    headerFile.append("_Array<")
                    appendCppTypeName(headerFile, functionSignature.result.resultType)
                    headerFile.append(">*")
                }
                else {
                    appendCppTypeName(headerFile, functionSignature.result.resultType)
                    if isClass(functionSignature.result.resultType.name) {
                        headerFile.append("*")
                    }
                }
            }
        }

        headerFile.append(" ")
        headerFile.append((functionSignature.parent as FunctionDeclaration).name)
        headerFile.append("(")
        if functionSignature.result != null {
            if isClass(functionSignature.result.resultType.name) {
                let lifeTime: LifeTime = functionSignature.result.resultType.lifeTime
                if (lifeTime == null) || !(lifeTime is Reference) {
                    headerFile.append("_Page* _rp")
                    if (functionSignature.parameterClause.parameters) || (functionSignature.throwsClause) {
                        headerFile.append(", ")
                    }
                }
            }
        }
        if functionSignature.throwsClause != null {
            headerFile.append("_Page* _ep")
            if functionSignature.parameterClause.parameters {
                headerFile.append(", ")
            }
        }

        true
    }

    function closeParameterClause(parameterClause: ParameterClause) {
        headerFile.append(")")
    }

    function openConstParameter(constParameter: ConstParameter): bool {
        writeParameter(constParameter.name, constParameter.parameterType)

        false
    }

    function writeParameter(name: string, parameterType: Type) {
        if parameterType.parent is Parameter {
            let parameter: Parameter = parameterType.parent as Parameter
            if parameter.parent is ParameterClause {
                let parameters: Parameter[] = (parameter.parent as ParameterClause).parameters
                if parameter != parameters[0]
                    headerFile.append(", ")
                parameterType.accept(this)
                headerFile.append(" ")
                headerFile.append(name)
            }
        }
    }

    function isClass(name: string): bool {
        if name.equals("string")
        ||  name.equals("VarString")
        ||  name.equals("File")
        ||  name.equals("Directory")
        ||  name.equals("Path")
        ||  name.equals("DirectoryError")
        ||  name.equals("FileError")
        ||  name.equals("ParserError")
        ||  name.equals("CppError")
        ||  name.equals("CompilerError")
            return(true)

        for className: string in classes {
            if className.equals(name) {
                return(true)
            }
        }

        false
    }

    function closeConstParameter(constParameter: ConstParameter) {
        headerFile.append(constParameter.name)
    }

    function openVarParameter(varParameter: VarParameter): bool {
        writeParameter(varParameter.name, varParameter.parameterType)
        false
    }

    function closeVarParameter(varParameter: VarParameter) {
        headerFile.append(varParameter.name)
    }

    function openEnumMember(enumMember: EnumMember): bool {
        if !enumMember.parent is EnumDeclaration
            return(false)

        if enumMember.parameterClause {
            headerFile.append("\nclass _")
            headerFile.append((enumMember.parent as EnumDeclaration).name)
            headerFile.append("_")
            headerFile.append(enumMember.enumCase.name)
            headerFile.append(" : public Object {\npublic:\n    _")
            headerFile.append((enumMember.parent as EnumDeclaration).name)
            headerFile.append("_")
            headerFile.append(enumMember.enumCase.name)
            headerFile.append("(")
        }

        true
    }

    function closeEnumMember(enumMember: EnumMember) {
        if enumMember.parameterClause != null {
            headerFile.append(";\n\n")

            if enumMember.parameterClause.parameters != null {
                mutable pos: number = 0
                for parameter: Parameter in enumMember.parameterClause.parameters {
                    if parameter is ConstParameter {
                        headerFile.append("    ")
                        appendCppType(headerFile, (parameter as ConstParameter).parameterType)
                        headerFile.append(" ")
                        headerFile.append((parameter as ConstParameter).name)
                        headerFile.append(";\n")
                    }
                    pos++
                }
            }

            headerFile.append("};\n")
        }
    }

    function openClassMember(classMember: ClassMember): bool {
        headerFile.append("\n    ")

        true
    }

    function closeClassMember(classMember: ClassMember) {
        headerFile.append(";")
    }

    function openIdentifierPattern(identifierPattern: IdentifierPattern): bool {

        if identifierPattern.annotationForType != null {
            identifierPattern.annotationForType.accept(this)
            headerFile.append(" ")
        }

        headerFile.append(identifierPattern.identifier)

        false
    }

    function openType(type: Type): bool {

        if (type.parent is FunctionResult)
        || (type.parent is Inheritance)
        || (type.parent is ThrowsClause)
            return(false)
            
        if hasArrayPostfix(type) {
            headerFile.append("_Array<")
        }
        appendCppTypeName(headerFile, type)
 
        true
    }

    function closeType(type: Type) {

        if hasArrayPostfix(type)
            headerFile.append(">*")

        if isClass(type.name) && !hasArrayPostfix(type) && !type.parent is ConstructorCall {
                headerFile.append("*")
        }
    }

    function buildMainHeaderFileString(program: Program) {
        mainHeaderFile = new VarString()
        mainHeaderFile.append("#ifndef __scaly__")
        mainHeaderFile.append(program.name)
        mainHeaderFile.append("__\n#define __scaly__")
        mainHeaderFile.append(program.name)
        mainHeaderFile.append("__\n\n#include \"Scaly.h\"\n")
        if program.modules != null {
            for module: Module in program.modules {
                let fileName: string$ = getFileName(module)
                if fileName != null {
                    let name: string$ = Path.getFileNameWithoutExtension(fileName)
                    mainHeaderFile.append("#include \"")
                    mainHeaderFile.append(name)
                    mainHeaderFile.append(".h\"\n")
                }
            }
        }
        mainHeaderFile.append("\nusing namespace scaly;\nnamespace ")
        mainHeaderFile.append(program.name)
        mainHeaderFile.append(" {\nFileError* _main(_Page* page, _Array<string>* arguments);\n}\n\n#endif // __scaly__")
        mainHeaderFile.append(program.name)
        mainHeaderFile.append("__\n")
    }

    function collectInheritances(program: Program) {
        for module: Module in program.modules
            collectInheritancesInModule(module)
    }
}

class SourceVisitor extends CppVisitor {

    let directory: string
    mutable sourceFile: VarString

    constructor(outputDirectory: string) {
        directory = outputDirectory
        inherits = new Inherits[]()
        classes = new string[]()
    }

    function openProgram(program: Program): bool {

        mutable projectFilePath: VarString$ = new VarString(directory)

        if projectFilePath == null || projectFilePath.equals("")
            projectFilePath = new VarString$(".")

        projectFilePath.append("/")
        projectFilePath.append(program.name)
        projectFilePath.append(".project")

        let projectFile: VarString$ = buildProjectFileString(program)

        File.writeFromString(projectFilePath , projectFile)
            catch _ (error: fileError)
                return(false)

        collectInheritances(program)

        true
    }

    function openModule(module: Module): bool {

        if !(module.parent is Program)
            return(false)

        let programName: string = (module.parent as Program).name

        // Begin cpp file
        sourceFile = new VarString(0, 4096)
        sourceFile.append("#include \"")
        sourceFile.append(programName)
        sourceFile.append(".h\"\nusing namespace scaly;\n")
        
        if module.statements != null && isTopLevelFile(module) {
            sourceFile.append("namespace scaly {\n\n")
            sourceFile.append("extern __thread _Page* __CurrentPage;\n")
            sourceFile.append("extern __thread _Task* __CurrentTask;\n\n")
            sourceFile.append("}\n\n")
            sourceFile.append("int main(int argc, char** argv) {\n")
            sourceFile.append("    // Allocate the root page for the main thread\n")
            sourceFile.append("    posix_memalign((void**)&__CurrentPage, _pageSize, _pageSize * _maxStackPages);\n")
            sourceFile.append("    if (!__CurrentPage)\n")
            sourceFile.append("        return -1;\n")
            sourceFile.append("    new (__CurrentPage) _Page();\n")
            sourceFile.append("    _Task* task = new(__CurrentPage) _Task();\n")
            sourceFile.append("    __CurrentTask = task;\n\n")
            sourceFile.append("    // Collect the arguments into a string Vector\n")
            sourceFile.append("    _Array<string>* arguments = new(__CurrentPage) _Array<string>(argc - 1);\n")
            sourceFile.append("    for (int i = 1; i < argc; i++)\n")
            sourceFile.append("        arguments->push(new(__CurrentPage) string(argv[i]));\n\n")
            sourceFile.append("    // Call Scaly's top-level code\n")
            sourceFile.append("    auto _File_error = ")
            sourceFile.append(programName)
            sourceFile.append("::_main(__CurrentPage, arguments);\n    int ret = 0;\n\n    // Convert Scaly's error enum back to OS errno values\n")
            sourceFile.append("    if (_File_error) {\n        switch(_File_error->_getErrorCode()) {\n")
            sourceFile.append("            case _FileErrorCode_noSuchFileOrDirectory:\n                ret = ENOENT;\n")
            sourceFile.append("                break;\n            default:\n                ret = -1;\n                break;\n        }\n    }\n\n")
            sourceFile.append("    // Only for monitoring, debugging and stuff\n")
            sourceFile.append("    __CurrentTask->dispose();\n\n")
            sourceFile.append("    // Give back the return code of the top-level code\n")
            sourceFile.append("    return ret;\n")
            sourceFile.append("}\n\n")
        }
        
        sourceFile.append("namespace ")
        sourceFile.append(programName)
        sourceFile.append(" {\n\n")
        
        if (module.statements != null) && isTopLevelFile(module)
            sourceFile.append("FileError* _main(_Page* _ep,  _Array<string>* arguments) {\n    _Region _rp; _Page* _p = _rp.get();\n\n")

        true
    }

    function closeModule(module: Module) {
        if !(module.parent) is Program
            return

        // Close and write cpp file

        mutable outputFilePath: VarString$  = new VarString(directory)
        outputFilePath.append('/')
        let fileName: string$ = getFileName(module)
        if fileName != null {
            let name: string$ = Path.getFileNameWithoutExtension(fileName)
            outputFilePath.append(name)
        }

        if module.statements != null && isTopLevelFile(module)
        {
            // Insert the return 0 if the last statement is not a return or a literal
            let length: number = module.statements.length()
            if length > 0 {
                let statement: Statement = module.statements[length - 1]
                if statement is SimpleExpression {
                    let simpleExpression: SimpleExpression = statement as SimpleExpression
                    let primaryExpression: PrimaryExpression = simpleExpression.prefixExpression.expression.primaryExpression
                    if (!(primaryExpression is ReturnExpression)) && (!(primaryExpression is LiteralExpression))
                        sourceFile.append("\n    return nullptr;\n")
                }
            }

            sourceFile.append("\n}\n")
        }

        sourceFile.append("\n}\n")

        mutable sourceFilePath: VarString$ = new VarString(outputFilePath)
        sourceFilePath.append(".cpp")
        File.writeFromString(sourceFilePath, sourceFile)
            catch _ (error: fileError)
                return
    }

    function openConstantDeclaration(constantDeclaration: ConstantDeclaration): bool {

        if constantDeclaration.parent.parent.parent == null
            return(true)

        if constantDeclaration.parent.parent.parent is ClassDeclaration
            return(false)
            
        true
    }

    function openMutableDeclaration(mutableDeclaration: MutableDeclaration): bool {

        if mutableDeclaration.parent.parent.parent is ClassDeclaration
            return(false)

        true
    }

    function openFunctionDeclaration(functionDeclaration: FunctionDeclaration): bool {

        if functionDeclaration.body == null
            return(false)

        true
    }

    function openEnumDeclaration(enumDeclaration: EnumDeclaration): bool {
        let enumDeclarationName: string = enumDeclaration.name

        sourceFile.append("long ")
        sourceFile.append(enumDeclarationName)
        sourceFile.append("::_getErrorCode() {\n    return (long)errorCode;\n}\n\nvoid* ")
        sourceFile.append(enumDeclarationName)
        sourceFile.append("::_getErrorInfo() {\n    return errorInfo;\n}\n\n")

        true
    }

    function closeClassDeclaration(classDeclaration: ClassDeclaration) {
        if classDeclaration.body == null
            return
        
        if classDeclaration.typeInheritanceClause != null {
            sourceFile.append("bool ")
            sourceFile.append(classDeclaration.name)
            sourceFile.append("::_is")
            sourceFile.append(classDeclaration.name)
            sourceFile.append("() { return (true); }\n\n")
        }

        mutable derivedClasses: string[]$ = new string[]()
        collectDerivedClasses(derivedClasses, classDeclaration.name)
        for derivedClass: string in derivedClasses {
            sourceFile.append("bool ")
            sourceFile.append(classDeclaration.name)
            sourceFile.append("::_is")
            sourceFile.append(derivedClass)
            sourceFile.append("() { return (false); }\n")
        }
        if derivedClasses.length() > 0
            sourceFile.append("\n")
    }

    function openConstructorDeclaration(constructorDeclaration: ConstructorDeclaration): bool {

        if !constructorDeclaration.parent.parent.parent is ClassDeclaration
            return(false)

        let classDeclarationName: string = (constructorDeclaration.parent.parent.parent as ClassDeclaration).name        
        sourceFile.append(classDeclarationName)
        sourceFile.append("::")
        sourceFile.append(classDeclarationName)
        sourceFile.append("(")
        
        true
    }

    function closeConstructorDeclaration(constructorDeclaration: ConstructorDeclaration) {
        sourceFile.append("\n")
    }

    function openCodeBlock(codeBlock: CodeBlock): bool {

        if codeBlock.parent is CodeBlock
            indent(level(codeBlock) - 1)

        if codeBlock.parent is CaseContent
            indent(level(codeBlock) - 1)
            
        sourceFile.append("{\n")

        if localAllocations(codeBlock) {
            indent(level(codeBlock))
            sourceFile.append("_Region _region; _Page* _p = _region.get();\n")
        }

        true
    }

    function localAllocations(codeBlock: CodeBlock): bool {
        if codeBlock.statements != null {
            for statement: Statement in codeBlock.statements {
                mutable bindingInitializer: BindingInitializer = null

                if statement is ConstantDeclaration
                    bindingInitializer = (statement as ConstantDeclaration).initializer

                if statement is MutableDeclaration
                    bindingInitializer = (statement as MutableDeclaration).initializer

                if isRootBinding(bindingInitializer)
                    return(true)
            }
        }
        false
    }

    function getFunctionCall(identifierInitializer: IdentifierInitializer&): FunctionCall& {
        if identifierInitializer.initializer != null {
            let expression: Expression = identifierInitializer.initializer.expression
            if expression is SimpleExpression {
                let postfixExpression: PostfixExpression = (expression as SimpleExpression).prefixExpression.expression
                if postfixExpression.primaryExpression is IdentifierExpression {
                    if postfixExpression.postfixes != null {
                        for postfix: Postfix in postfixExpression.postfixes {
                            if postfix is FunctionCall {
                                return(postfix as FunctionCall)
                            }
                        }
                    }
                }
            }
        }
        null
    }

    function isCatchingFunctionCall(identifierInitializer: IdentifierInitializer): bool {
        if catchesError(getFunctionCall(identifierInitializer))
            return(true)

        false
    }

    function closeCodeBlock(codeBlock: CodeBlock) {
        if codeBlock.parent is FunctionDeclaration {
            let functionDeclaration: FunctionDeclaration = codeBlock.parent as FunctionDeclaration
            if (functionDeclaration.signature.throwsClause != null) && (functionDeclaration.signature.result == null) {
                indent(level(codeBlock))
                sourceFile.append("return nullptr;\n")
            }
        }
 
        indent(level(codeBlock) - 1)
        sourceFile.append("}\n")
        if codeBlock.parent is FunctionDeclaration
            sourceFile.append("\n")
    }

    function openSimpleExpression(simpleExpression: SimpleExpression): bool {

        let statement: Statement = simpleExpression as Statement
        if statement.parent is CodeBlock || statement.parent is CaseContent || statement.parent is Module
            indent(level(simpleExpression))

        // Prepend a return if this expression is the only one of a function
        if statement.parent is FunctionDeclaration {
            let returnType: string$ = getReturnType(statement)
            if returnType != null
                prependReturn(simpleExpression)
        }
        
        // Prepend a return if this expression is the last one in the enclosing block if that block is the root block of a function declaration
        if statement.parent is CodeBlock {
            let block: CodeBlock = statement.parent as CodeBlock
            if block.parent is FunctionDeclaration {
                if block.statements[block.statements.length() - 1] == statement {
                    let returnType: string$ = getReturnType(statement)
                    if returnType != null
                        prependReturn(simpleExpression)
                }
            }
        }

        // Prefix type cast if any
        if simpleExpression.binaryExpressions != null {
            for binaryExpression: BinaryExpression in simpleExpression.binaryExpressions {
                if binaryExpression is TypeCast {
                    sourceFile.append("(")
                    sourceFile.append((binaryExpression as TypeCast).objectType.name)
                    sourceFile.append("*)")
                    simpleExpression.prefixExpression.accept(this)
                    return(false)
                }
            }
        }

        if simpleExpression.prefixExpression.expression.primaryExpression is IdentifierExpression {
            let binaryExpressions: BinaryExpression[] = simpleExpression.binaryExpressions

            // If we assign to a member then clear the exclusive page of that member
            if binaryExpressions != null {
                if binaryExpressions.length() == 1 {
                    let binaryExpression: BinaryExpression = binaryExpressions[0]
                    if binaryExpression is Assignment {
                        let assignment: Assignment = binaryExpression as Assignment
                        if assignment.parent is SimpleExpression {
                            let simpleExpression: SimpleExpression = (assignment.parent) as SimpleExpression
                            let leftSide: PostfixExpression = simpleExpression.prefixExpression.expression
                            if leftSide.primaryExpression is IdentifierExpression {
                                let memberExpression: IdentifierExpression = (leftSide.primaryExpression) as IdentifierExpression
                                let memberName: string = memberExpression.name
                                mutable classDeclaration: ClassDeclaration& = getClassDeclaration(assignment)
                                if classDeclaration != null {
                                    if isVariableObjectField(memberName, classDeclaration) {
                                        if (memberName != null) && (!inConstructor(assignment)) {
                                            sourceFile.append("if (")
                                            sourceFile.append(memberName)
                                            sourceFile.append(" != nullptr)\n")
                                            this.indent(level(simpleExpression))
                                            sourceFile.append("    ")
                                            sourceFile.append(memberName)
                                            sourceFile.append("->_getPage()->clear();\n")
                                            this.indent(level(simpleExpression))
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // Prefix the error result for a catching function call
            if simpleExpression.parent is CodeBlock || simpleExpression.parent is CaseContent || simpleExpression.parent is Module {
                if simpleExpression.prefixExpression.expression.postfixes != null {
                    for postfix: Postfix in simpleExpression.prefixExpression.expression.postfixes {
                        if postfix is FunctionCall {
                            if (postfix as FunctionCall).catchClauses != null {
                                let identifierExpression: IdentifierExpression = simpleExpression.prefixExpression.expression.primaryExpression as IdentifierExpression
                                sourceFile.append("auto _")
                                sourceFile.append(identifierExpression.name)
                                sourceFile.append("_error = ")
                            }
                        }
                    }
                }
            }
        }

        if simpleExpression.parent is Module {

            // Prefix the error result for a global function call which throws FileError
            if simpleExpression.prefixExpression.expression.postfixes != null {
                for postfix: Postfix in simpleExpression.prefixExpression.expression.postfixes {
                    if postfix is FunctionCall {
                        let functionCall: FunctionCall = postfix as FunctionCall
                        if functionCall.catchClauses == null {
                            if functionCall.parent is PostfixExpression {
                                let postfixExpression: PostfixExpression = (functionCall.parent) as PostfixExpression
                                if postfixExpression.primaryExpression is IdentifierExpression {
                                    let identifierExpression: IdentifierExpression = (postfixExpression.primaryExpression) as IdentifierExpression

                                    // Fix when print is recognized as external function
                                    if identifierExpression.name.equals("print") {
                                        sourceFile.append("{\n    auto _File_error = ")
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        true
    }

    function prependReturn(simpleExpression: SimpleExpression) {
        let expression: PrimaryExpression = simpleExpression.prefixExpression.expression.primaryExpression
        if (!expression is ReturnExpression) 
        && (!expression is ThrowExpression) 
        && (!expression is WhileExpression) 
        && (!expression is DoExpression)
            sourceFile.append("return ")
    }

    function closeSimpleExpression(simpleExpression: SimpleExpression) {

        let primaryExpression: PrimaryExpression = simpleExpression.prefixExpression.expression.primaryExpression

        if primaryExpression is IfExpression
        || primaryExpression is SwitchExpression
        || primaryExpression is ForExpression
        || primaryExpression is WhileExpression
            return

        if primaryExpression is IdentifierExpression {
            let postfixExpression: PostfixExpression = simpleExpression.prefixExpression.expression
            if postfixExpression.postfixes != null {
                for postfix: Postfix in postfixExpression.postfixes {
                    if postfix is FunctionCall {
                        if catchesError(postfix as FunctionCall)
                            return
                    }
                }
            }
        }

        if simpleExpression.parent is CodeBlock
        || simpleExpression.parent is CaseContent
        || simpleExpression.parent is Module
            sourceFile.append(";\n")
            
        if simpleExpression.parent is Module {

            // Check and return the error result for a global function call which throws FileError
            let postfixes: Postfix[] = simpleExpression.prefixExpression.expression.postfixes
            if postfixes != null {
                for postfix: Postfix in postfixes {
                    if postfix is FunctionCall {
                        let functionCall: FunctionCall = postfix as FunctionCall
                        if functionCall.catchClauses == null {
                            if functionCall.parent is PostfixExpression {
                                let postfixExpression: PostfixExpression = (functionCall.parent) as PostfixExpression
                                if postfixExpression.primaryExpression is IdentifierExpression {
                                    let identifierExpression: IdentifierExpression = (postfixExpression.primaryExpression) as IdentifierExpression

                                    // Fix this when print is recognized as external function
                                    if identifierExpression.name.equals("print") {
                                        sourceFile.append("    if (_File_error)\n        return _File_error;\n}\n")
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    function openInitializer(initializer: Initializer): bool {
        sourceFile.append(" = ")

        true
    }

    function openBindingInitializer(bindingInitializer: BindingInitializer): bool {

        if bindingInitializer.parent.parent is CodeBlock
        || bindingInitializer.parent.parent is CaseContent
        || bindingInitializer.parent.parent is Module
            indent(level(bindingInitializer))

        true
    }

    function closeBindingInitializer(bindingInitializer: BindingInitializer) {

        if isCatchingFunctionCall(bindingInitializer.initializer)
            return

        if bindingInitializer.parent.parent is CodeBlock
        || bindingInitializer.parent.parent is CaseContent
        || bindingInitializer.parent.parent is Module
            sourceFile.append(";\n")
    }

    function openFunctionSignature(functionSignature: FunctionSignature): bool {

        let functionName: string = (functionSignature.parent as FunctionDeclaration).name

        if functionSignature.result == null {
            if functionSignature.throwsClause == null
                sourceFile.append("void")
            else
                appendCppType(sourceFile, functionSignature.throwsClause.throwsType)
        }
        else {
            if functionSignature.throwsClause != null {

                sourceFile.append("_Result<")

                if hasArrayPostfix(functionSignature.result.resultType) {
                    sourceFile.append("_Array<")
                    appendCppTypeName(sourceFile, functionSignature.result.resultType)
                    sourceFile.append(">")
                }
                else {
                    appendCppTypeName(sourceFile, functionSignature.result.resultType)
                }
                sourceFile.append(", ")
                appendCppTypeName(sourceFile, functionSignature.throwsClause.throwsType)
                sourceFile.append(">")
            }
            else {
                if hasArrayPostfix(functionSignature.result.resultType) {
                    sourceFile.append("_Array<")
                    appendCppTypeName(sourceFile, functionSignature.result.resultType)
                    sourceFile.append(">*")
                }
                else {
                    appendCppTypeName(sourceFile, functionSignature.result.resultType)
                    if isClass(functionSignature.result.resultType.name) {
                        sourceFile.append("*")
                    }
                }
            }
        }

        sourceFile.append(" ")    
        if functionSignature.parent.parent.parent.parent is ClassDeclaration {
            sourceFile.append((functionSignature.parent.parent.parent.parent as ClassDeclaration).name)
            sourceFile.append("::")
        }
        sourceFile.append(functionName)
        sourceFile.append("(")
        if functionSignature.result != null {
            if isClass(functionSignature.result.resultType.name) {
                let lifeTime: LifeTime = functionSignature.result.resultType.lifeTime
                if (lifeTime == null) || !(lifeTime is Reference) {
                    sourceFile.append("_Page* _rp")
                    if (functionSignature.parameterClause.parameters) || (functionSignature.throwsClause) {
                        sourceFile.append(", ")
                    }
                }
            }
        }
        if functionSignature.throwsClause != null {
            sourceFile.append("_Page* _ep")
            if functionSignature.parameterClause.parameters {
                sourceFile.append(", ")
            }
        }

        true
    }

    function openFunctionResult(functionResult: FunctionResult): bool {
        false
    }

    function closeParameterClause(parameterClause: ParameterClause) {
        sourceFile.append(") ")
    }

    function openConstParameter(constParameter: ConstParameter): bool {
        writeParameter(constParameter.name, constParameter.parameterType)

        false
    }

    function writeParameter(name: string, parameterType: Type) {
        if parameterType.parent is Parameter {
            let parameter: Parameter = parameterType.parent as Parameter
            if parameter.parent is ParameterClause {
                let parameters: Parameter[] = (parameter.parent as ParameterClause).parameters
                if parameter != parameters[0]
                    sourceFile.append(", ")
                parameterType.accept(this)
                sourceFile.append(" ")
                sourceFile.append(name)
            }
        }
    }

    function isClass(name: string): bool {
        if name.equals("string")
        ||  name.equals("VarString")
        ||  name.equals("Number")
        ||  name.equals("File")
        ||  name.equals("Directory")
        ||  name.equals("Path")
        ||  name.equals("DirectoryError")
        ||  name.equals("FileError")
        ||  name.equals("ParserError")
        ||  name.equals("CppError")
        ||  name.equals("CompilerError")
        {
            return(true)
        }

        for className: string in classes {
            if className.equals(name) {
                return(true)
            }
        }

        false
    }

    function openVarParameter(varParameter: VarParameter): bool {
        writeParameter(varParameter.name, varParameter.parameterType)
        false
    }

    function openThrowsClause(throwsClause: ThrowsClause): bool {
        false
    }

    function openEnumMember(enumMember: EnumMember): bool {
        if !enumMember.parent is EnumDeclaration
            return(false)

        let enumDeclarationName: string = (enumMember.parent as EnumDeclaration).name
        if enumMember.parameterClause {
            sourceFile.append("_")
            sourceFile.append(enumDeclarationName)
            sourceFile.append("_")
            sourceFile.append(enumMember.enumCase.name)
            sourceFile.append("::_")
            sourceFile.append(enumDeclarationName)
            sourceFile.append("_")
            sourceFile.append(enumMember.enumCase.name)
            sourceFile.append("(")
        }

        true
    }

    function closeEnumMember(enumMember: EnumMember) {
        if enumMember.parameterClause != null {
            sourceFile.append("\n")

            if enumMember.parameterClause.parameters != null {
                sourceFile.append(": ")
                mutable pos: number = 0
                for parameter: Parameter in enumMember.parameterClause.parameters {
                    if parameter is ConstParameter {
                        if pos != 0
                            sourceFile.append(", ")
                        sourceFile.append((parameter as ConstParameter).name)
                        sourceFile.append("(")
                        sourceFile.append((parameter as ConstParameter).name)
                        sourceFile.append(")")
                    }
                    pos++
                }
            }

            sourceFile.append(" { }\n\n_")
            let enumDeclarationName: string = ((enumMember.parent) as EnumDeclaration).name
            sourceFile.append(enumDeclarationName)
            sourceFile.append("_")
            sourceFile.append(enumMember.enumCase.name)
            sourceFile.append("* ")
            sourceFile.append(enumDeclarationName)
            sourceFile.append("::get_")
            sourceFile.append(enumMember.enumCase.name)
            sourceFile.append("() {\n    return (_")
            sourceFile.append(enumDeclarationName)
            sourceFile.append("_")
            sourceFile.append(enumMember.enumCase.name)
            sourceFile.append("*)errorInfo;\n}\n\n")
        }
    }

    function level(syntaxNode: SyntaxNode): number {

        mutable level: number = 0
        mutable node: SyntaxNode = syntaxNode
        
        while node != null {

            if node is CodeBlock
            || node is Module
            || node is ForExpression
            || node is CatchClause
            || node is CurliedSwitchBody
            || node is CaseContent
                level++

            if node is ClassDeclaration
                level--
            
            node = node.parent
        }
        
        level
    }

    function indent(level: number) {
        mutable i: number = 0
        while i < level {
            sourceFile.append("    ")
            i++
        }
    }

    function openPrefixExpression(prefixExpression: PrefixExpression): bool {
        if prefixExpression.prefixOperator != null
            sourceFile.append(prefixExpression.prefixOperator)

        true
    }

    function openPostfixExpression(postfixExpression: PostfixExpression): bool {
        if postfixExpression.postfixes != null {
            for postfix: Postfix in postfixExpression.postfixes {
                if postfix is Subscript
                    sourceFile.append("*(*")
            }
        }
        true
    }

    function openBinaryOperation(binaryOperation: BinaryOperation): bool {
        sourceFile.append(" ")
        sourceFile.append(binaryOperation.binaryOperator)
        sourceFile.append(" ")

        true
    }

    function openAssignment(assignment: Assignment): bool {
        sourceFile.append(" = ")

        true
    }

    function inConstructor(node: SyntaxNode): bool {

        if node is ConstructorDeclaration
            return(true)

        if node.parent == null
            return(false)

        inConstructor(node.parent)
    }

    function inThrow(node: SyntaxNode): bool {

        if node is ThrowExpression
            return(true)

        if node.parent == null
            return(false)

        inThrow(node.parent)
    }

    function getClassDeclaration(node: SyntaxNode&): ClassDeclaration& {
        if node is ClassDeclaration
            return(node as ClassDeclaration)

        if node.parent != null {
            let classDeclaration: ClassDeclaration& = getClassDeclaration(node.parent)
            return(classDeclaration)
        }
        
        null
    }

    function isObjectField(memberName: string, classDeclaration: ClassDeclaration): bool {

        if classDeclaration.body == null
            return(false)

        if classDeclaration.body.members == null
            return(false)

        for member: ClassMember in classDeclaration.body.members {
            mutable bindingInitializer: BindingInitializer = null

            if member.declaration is ConstantDeclaration
                bindingInitializer = (member.declaration as ConstantDeclaration).initializer

            if member.declaration is MutableDeclaration
                bindingInitializer = (member.declaration as MutableDeclaration).initializer

            if bindingInitializer == null
                continue

            let identifierPattern: IdentifierPattern = bindingInitializer.initializer.pattern
            if identifierPattern.identifier.equals(memberName) {
                if identifierPattern.annotationForType != null {
                    if isClass(identifierPattern.annotationForType.annotationForType.name)
                        return(true)
                    else
                        return(false)
                }
            }
        }

        if classDeclaration.typeInheritanceClause != null {
            let inheritances: Inheritance[] = classDeclaration.typeInheritanceClause.inheritances
            if inheritances != null {
                for inheritance: Inheritance in inheritances {
                    let baseClassDeclarations: ClassDeclaration[]$ = findClassDeclarations(classDeclaration, inheritance.type.name)
                    for baseClassDeclaration: ClassDeclaration in baseClassDeclarations {
                        if isObjectField(memberName, baseClassDeclaration)
                            return(true)
                    }
                }
            }
        }

        false
    }

    function isVariableObjectField(memberName: string, classDeclaration: ClassDeclaration): bool {

        if classDeclaration.body == null
            return(false)

        if classDeclaration.body.members == null
            return(false)
            
        for member: ClassMember in classDeclaration.body.members {

            mutable bindingInitializer: BindingInitializer = null

            if member.declaration is MutableDeclaration
                bindingInitializer = (member.declaration as MutableDeclaration).initializer

            if bindingInitializer == null
                continue

            let identifierPattern: IdentifierPattern = bindingInitializer.initializer.pattern
            if identifierPattern.identifier.equals(memberName) {
                if identifierPattern.annotationForType != null {
                    if isClass(identifierPattern.annotationForType.annotationForType.name)
                        return(true)
                    else
                        return(false)
                }
            }
        }

        if classDeclaration.typeInheritanceClause != null {
            let inheritances: Inheritance[] = classDeclaration.typeInheritanceClause.inheritances
            if inheritances != null {
                for inheritance: Inheritance in inheritances {
                    let baseClassDeclarations: ClassDeclaration[]$ = findClassDeclarations(classDeclaration, inheritance.type.name)
                    for baseClassDeclaration: ClassDeclaration in baseClassDeclarations {
                        if isVariableObjectField(memberName, baseClassDeclaration)
                            return(true)
                    }
                }
            }
        }

        false
    }
    
    function findClassDeclarations(node: SyntaxNode, name: string): ClassDeclaration[] {
        let program: Program = null

        while node != null {
            if node is Program {
                program = node as Program
                break
            }
            node = node.parent
        }

        mutable classDeclarations: ClassDeclaration[] = new ClassDeclaration[]()
        if program.modules != null {
            for module: Module in program.modules {
                if module.statements != null {
                    for statement: Statement in module.statements {
                        if statement is ClassDeclaration {
                            let classDeclaration: ClassDeclaration = statement as ClassDeclaration
                            if classDeclaration.name.equals(name)
                                classDeclarations.push(classDeclaration)
                        }
                    }
                }
            }
        }
        
        classDeclarations
    }

    function openTypeQuery(typeQuery: TypeQuery): bool {
        sourceFile.append("->_is")

        true
    }

    function openCatchClause(catchClause: CatchClause): bool {
        if !catchClause.parent is FunctionCall
            return(false)
 
        let functionCall: FunctionCall = (catchClause.parent) as FunctionCall
        {
            mutable bindingInitializer: BindingInitializer& = getBindingInitializer(functionCall)
            if bindingInitializer != null {
                let identifierPattern: IdentifierPattern = bindingInitializer.initializer.pattern
                if functionCall.catchClauses[0] == catchClause {
                    sourceFile.append(";\n")

                    indent(level(catchClause) - 1)
                    identifierPattern.annotationForType.accept(this)
                    sourceFile.append(" ")
                    sourceFile.append(identifierPattern.identifier)
                    sourceFile.append(" = nullptr;\n")

                    indent(level(catchClause) - 1)
                    sourceFile.append("if (_")
                    sourceFile.append(identifierPattern.identifier)
                    sourceFile.append("_result.succeeded()) {\n")

                    indent(level(catchClause) - 1)
                    sourceFile.append("    ")
                    sourceFile.append(identifierPattern.identifier)
                    sourceFile.append(" = _")
                    sourceFile.append(identifierPattern.identifier)                    
                    sourceFile.append("_result.getResult();\n")
                    indent(level(catchClause) - 1)
                    sourceFile.append("}\n")
                }

                indent(level(catchClause) - 1)
                sourceFile.append("else")
                mutable errorType: string& = getErrorType(catchClause)
                if catchClause.catchPattern is IdentifierCatchPattern {
                    let identifierCatchPattern: IdentifierCatchPattern = (catchClause.catchPattern) as IdentifierCatchPattern
                    sourceFile.append(" if (_")
                    sourceFile.append(identifierPattern.identifier)
                    sourceFile.append("_result._getErrorCode() == _")
                    sourceFile.append(identifierCatchPattern.name)
                    sourceFile.append("Code_")
                    if errorType != null
                        sourceFile.append(errorType)
                    sourceFile.append(")")
                }

                sourceFile.append(" {\n")

                if catchClause.bindingPattern != null {
                    let bindingPattern: TuplePattern = catchClause.bindingPattern
                    if bindingPattern.elements != null {

                        // bind the error variable if we have one if we catch wild
                        if catchClause.catchPattern is WildCardCatchPattern {
                            if bindingPattern.elements.length() > 0 {
                                let element: TuplePatternElement = bindingPattern.elements[0]
                                if element.pattern is IdentifierPattern {
                                    let pattern: IdentifierPattern = (element.pattern) as IdentifierPattern

                                    indent(level(catchClause))
                                    sourceFile.append("auto ")
                                    sourceFile.append(pattern.identifier)                    
                                    sourceFile.append(" = _")
                                    sourceFile.append(identifierPattern.identifier)
                                    sourceFile.append("_result.getError();\n")
                                }
                            }
                        }
                        
                        // establish the bindings if we catch an error code
                        if catchClause.catchPattern is IdentifierCatchPattern {
                            for element: TuplePatternElement in bindingPattern.elements {
                                indent(level(catchClause))
                                element.accept(this)
                                sourceFile.append(" = _")
                                sourceFile.append(identifierPattern.identifier)
                                sourceFile.append("_result.getError()->get_")
                                if errorType != null
                                    sourceFile.append(errorType)
                                sourceFile.append("()->")
                                if element.pattern is IdentifierPattern {
                                    sourceFile.append((element.pattern as IdentifierPattern).identifier)
                                }
                                sourceFile.append(";")
                                sourceFile.append("\n")
                            }

                        }
                    }
                }
                                
                indent(level(catchClause))
                if catchClause.expression is SimpleExpression {
                    let simpleExpression: SimpleExpression = (catchClause.expression) as SimpleExpression
                    let primaryExpression: PrimaryExpression = simpleExpression.prefixExpression.expression.primaryExpression
                    if (!primaryExpression is ReturnExpression) && (!primaryExpression is BreakExpression) && (!primaryExpression is ThrowExpression) {
                        sourceFile.append(identifierPattern.identifier)
                        sourceFile.append(" = ")
                    }
                }
                catchClause.expression.accept(this)
                if catchClause.expression is SimpleExpression
                    sourceFile.append(";\n")
                indent(level(catchClause) - 1)
                sourceFile.append("}\n")
            }
        }
        {
            mutable identifierExpression: IdentifierExpression& = getIdentifierExpression((functionCall.parent) as PostfixExpression)
            if identifierExpression != null {
                if functionCall.catchClauses[0] == catchClause {
                    sourceFile.append(";\n")
                    indent(level(catchClause) - 1)
                    sourceFile.append("if (_")
                    sourceFile.append(identifierExpression.name)
                    sourceFile.append("_error) { switch (_")
                    sourceFile.append(identifierExpression.name)
                    sourceFile.append("_error->_getErrorCode()) {\n")
                }
                indent(level(catchClause))
                if catchClause.catchPattern is IdentifierCatchPattern {
                    sourceFile.append("case _")
                    let identifierCatchPattern: IdentifierCatchPattern = (catchClause.catchPattern) as IdentifierCatchPattern
                    sourceFile.append(identifierCatchPattern.name)
                    sourceFile.append("Code_")
                    if identifierCatchPattern.member != null {
                        sourceFile.append(identifierCatchPattern.member.member)
                        sourceFile.append(": {\n")
                        indent(level(catchClause) - 1)
                        sourceFile.append("    _")
                        sourceFile.append(identifierCatchPattern.name)
                        sourceFile.append("_")
                        sourceFile.append(identifierCatchPattern.member.member)                            
                        sourceFile.append("* ")
                        if catchClause.bindingPattern != null {
                            let bindingPattern: TuplePattern = catchClause.bindingPattern
                            if bindingPattern.elements != null {
                                if bindingPattern.elements.length() > 0 {
                                    let element: TuplePatternElement = bindingPattern.elements[0]
                                    if element.pattern is IdentifierPattern {
                                        let pattern: IdentifierPattern = (element.pattern) as IdentifierPattern
                                        sourceFile.append(pattern.identifier)                    
                                        sourceFile.append(" = _")
                                        sourceFile.append(identifierExpression.name)
                                        sourceFile.append("_error->get_")
                                        sourceFile.append(identifierCatchPattern.member.member)                            
                                        sourceFile.append("();")
                                    }
                                }
                            }
                        }
                        sourceFile.append("\n")
                    }
                }
                if catchClause.catchPattern is WildCardCatchPattern {
                    sourceFile.append("default: {\n")
                    //indent(level(catchClause))
                }
                
                indent(level(catchClause))
                catchClause.expression.accept(this)
                {
                    mutable insertBreak: bool = true
                    if catchClause.expression is SimpleExpression {
                        let simpleExpression: SimpleExpression = catchClause.expression as SimpleExpression
                        if simpleExpression.prefixExpression.expression.primaryExpression is ReturnExpression {
                            sourceFile.append(";\n")
                            insertBreak = false
                        }
                    }
                    if insertBreak {
                        indent(level(catchClause))
                        sourceFile.append("break;\n")
                    }
                }

                indent(level(catchClause))
                sourceFile.append("}\n")
                
                if functionCall.catchClauses[functionCall.catchClauses.length() - 1] == catchClause {
                    indent(level(catchClause) - 1)
                    sourceFile.append("} }\n")
                }
            }
        }

        false
    }

    function getIdentifierExpression(postfixExpression: PostfixExpression&): IdentifierExpression& {
        if postfixExpression.parent.parent.parent is CodeBlock || postfixExpression.parent.parent.parent is Module {
            if postfixExpression.parent is PrefixExpression {
                let prefixExpression: PrefixExpression = (postfixExpression.parent) as PrefixExpression
                if prefixExpression.expression.primaryExpression is IdentifierExpression {
                    return((prefixExpression.expression.primaryExpression) as IdentifierExpression)
                }
            }
        }

        null
    }

    function getErrorType(catchClause: CatchClause&): string& {
        if catchClause.catchPattern is WildCardCatchPattern {
            if catchClause.bindingPattern != null {
                if catchClause.bindingPattern.elements != null {
                    if catchClause.bindingPattern.elements.length() == 1 {
                        let element: TuplePatternElement = catchClause.bindingPattern.elements[0]
                        if element.pattern is IdentifierPattern {
                            let pattern: IdentifierPattern = (element.pattern) as IdentifierPattern
                            if pattern.annotationForType != null {
                                return(pattern.annotationForType.annotationForType.name)
                            }
                        }
                    }
                }
            }
        }

        if catchClause.catchPattern is IdentifierCatchPattern {
            let identifierCatchPattern: IdentifierCatchPattern = catchClause.catchPattern as IdentifierCatchPattern
            if identifierCatchPattern.member == null
                return(identifierCatchPattern.name)
            else
                return(identifierCatchPattern.member.member)
        }

        null
    }

    function visitOperatorPostfix(operatorPostfix: OperatorPostfix) {
        sourceFile.append(operatorPostfix.postfixOperator)
    }

    function visitMemberExpression(memberExpression: MemberExpression) {
        if memberExpression.parent is PostfixExpression {
            let postfixExpression: PostfixExpression = (memberExpression.parent) as PostfixExpression
            if postfixExpression.primaryExpression is IdentifierExpression {
                let identifierExpression: IdentifierExpression = (postfixExpression.primaryExpression) as IdentifierExpression
                if postfixExpression.postfixes.length() > 1 {
                    if (postfixExpression.postfixes[0] == explicitMemberExpression as Postfix) && ((postfixExpression.postfixes[1]) is FunctionCall) {
                        if isClass(identifierExpression.name) {
                            sourceFile.append("::")
                            sourceFile.append(memberExpression.member)
                            return
                        }
                    }
                }
            }
        }
        sourceFile.append("->")
        sourceFile.append(memberExpression.member)
    }

    function openSubscript(subscript: Subscript): bool {
        sourceFile.append(")[")

        true
    }

    function closeSubscript(subscript: Subscript) {
        sourceFile.append("]")
    }

    function closeExpressionElement(expressionElement: ExpressionElement) {
        if !isLastExpressionElement(expressionElement)
            sourceFile.append(", ")
    }

    function isLastExpressionElement(expressionElement: ExpressionElement): bool {
        if expressionElement.parent is ParenthesizedExpression {
            let parenthesizedExpression: ParenthesizedExpression = (expressionElement.parent) as ParenthesizedExpression
            let expressionElements: ExpressionElement[] = parenthesizedExpression.expressionElements
            let length: number = expressionElements.length() - 1
            let i: number = 0
            for element: ExpressionElement in expressionElements {
                if (element == expressionElement) && (i == length)
                    return(true)
                i++
            }
        }

        if expressionElement.parent is Subscript {
            let subscript: Subscript = (expressionElement.parent) as Subscript
            let expressions: ExpressionElement[] = subscript.expressions
            let length: number = expressions.length() - 1
            let i: number = 0
            for element: ExpressionElement in expressions {
                if (element == expressionElement) && (i == length)
                    return(true)
                i++
            }
        }

        false
    }

    function visitIdentifierExpression(identifierExpression: IdentifierExpression) {
        sourceFile.append(identifierExpression.name)
    }

    function inAssignment(syntaxNode: SyntaxNode): bool {
        if syntaxNode is Assignment
            return(true)

        let parentNode: SyntaxNode = syntaxNode.parent
        if parentNode == null
            return(false)

        inAssignment(parentNode)
    }

    function getAssignment(syntaxNode: SyntaxNode&): Assignment& {
        if syntaxNode is Assignment
            return(syntaxNode as Assignment)

        let parentNode: SyntaxNode = syntaxNode.parent
        if parentNode == null
            return(null)

        getAssignment(parentNode)
    }

    function getInitializer(syntaxNode: SyntaxNode&): Initializer& {
        if syntaxNode is Initializer
            return(syntaxNode as Initializer)

        let parentNode: SyntaxNode = syntaxNode.parent
        if parentNode == null
            return(null)

        getInitializer(parentNode)
    }

    function visitLiteralExpression(literalExpression: LiteralExpression) {
        let literal: Literal = literalExpression.literal
        if literal is NumericLiteral {
            let numericLiteral: NumericLiteral = literal as NumericLiteral
            sourceFile.append(numericLiteral.value)
        }
        else {
            if literal is StringLiteral {
                let stringLiteral: StringLiteral = literal as StringLiteral
                sourceFile.append("\"")
                sourceFile.append(stringLiteral.value)
                sourceFile.append("\"")
            }
            else {
                if literal is CharacterLiteral {
                    let characterLiteral: CharacterLiteral = literal as CharacterLiteral
                    sourceFile.append("\'")
                    if characterLiteral.value.getLength() > 0 {
                        if (characterLiteral.value.charAt(0) == '"') || (characterLiteral.value.charAt(0) == '\'') {
                            sourceFile.append("\\")
                            sourceFile.append(characterLiteral.value)
                        }
                        else {                        
                            switch characterLiteral.value.charAt(0) {                            
                                case '\r': sourceFile.append("\\r")
                                case '\n': sourceFile.append("\\n")
                                case '\t': sourceFile.append("\\t")
                                case '\0': sourceFile.append("\\0")
                                case '\\': sourceFile.append("\\\\")
                                default:   sourceFile.append(characterLiteral.value)                                    
                            }
                        }
                    }
                    sourceFile.append("\'")
                }
            }
        }
    }

    function openIfExpression(ifExpression: IfExpression): bool {
        sourceFile.append("if (")
        ifExpression.condition.accept(this)
        sourceFile.append(")")
        if ifExpression.consequent is SimpleExpression {
            sourceFile.append("\n    ")
            indent(level(ifExpression))
            ifExpression.consequent.accept(this)
            sourceFile.append(";\n")
        }
        else {
            sourceFile.append(" ")
            ifExpression.consequent.accept(this)
        }
        if ifExpression.elseClause != null {
            if ifExpression.elseClause.alternative is SimpleExpression {
                ifExpression.elseClause.accept(this)
                sourceFile.append(";\n")
            }
            else {
                ifExpression.elseClause.accept(this)
            }
        }

        false
    }

    function openSwitchExpression(switchExpression: SwitchExpression): bool {
        sourceFile.append("switch (")

        true
    }

    function closeSwitchExpression(switchExpression: SwitchExpression) {
    }

    function openForExpression(forExpression: ForExpression): bool {
        let pattern: Pattern = forExpression.pattern
        pattern.accept(this)    
        sourceFile.append(" = nullptr;\n")
        indent(level(forExpression) - 1)
        sourceFile.append("size_t _")
        let expression: Expression = forExpression.expression
        if expression is SimpleExpression {
            let simpleExpression: SimpleExpression = expression as SimpleExpression
            if simpleExpression.prefixExpression.expression.primaryExpression is IdentifierExpression {
                let identifierExpression: IdentifierExpression = (simpleExpression.prefixExpression.expression.primaryExpression) as IdentifierExpression
                let collectionName: string = identifierExpression.name
                sourceFile.append(collectionName)
                sourceFile.append("_length = ")
                forExpression.expression.accept(this)
                sourceFile.append("->length();\n")
                indent(level(forExpression) - 1)
                sourceFile.append("for (size_t _i = 0; _i < _")
                sourceFile.append(collectionName)
                sourceFile.append("_length; _i++) {\n")
                indent(level(forExpression))
                sourceFile.append(forExpression.pattern.identifier)
                sourceFile.append(" = *(*")
                forExpression.expression.accept(this)
                sourceFile.append(")[_i];\n")
                indent(level(forExpression))
                forExpression.code.accept(this)
                if forExpression.code is SimpleExpression
                    sourceFile.append(";\n")
                indent(level(forExpression) - 1)
                sourceFile.append("}\n")
            }
        }

        false
    }

    function openWhileExpression(whileExpression: WhileExpression): bool {
        sourceFile.append("while (")
        whileExpression.condition.accept(this)
        sourceFile.append(")")
        if whileExpression.code is SimpleExpression {
            sourceFile.append("\n")
            indent(level(whileExpression) + 1)
            whileExpression.code.accept(this)
            sourceFile.append(";\n")
        }
        else {
            sourceFile.append(" ")
            whileExpression.code.accept(this)
        }

        false
    }

    function openDoExpression(doExpression: DoExpression): bool {
        sourceFile.append("do")
        if doExpression.code is SimpleExpression {
            sourceFile.append("\n")
            indent(level(doExpression) + 1)
            doExpression.code.accept(this)
            sourceFile.append(";")
        }
        else {
            sourceFile.append(" ")
            doExpression.code.accept(this)
        }
        indent(level(doExpression))
        sourceFile.append("while (")
        doExpression.condition.accept(this)
        sourceFile.append(")")

        false
    }

    function openParenthesizedExpression(parenthesizedExpression: ParenthesizedExpression): bool {

        if !(parenthesizedExpression.parent) is ReturnExpression
            sourceFile.append("(")

        if parenthesizedExpression.parent is FunctionCall {
            let functionCall: FunctionCall = (parenthesizedExpression.parent) as FunctionCall
            let parameterInserted: bool = false

            let pageName: string$ = getPage(functionCall)
            if pageName != null {
                sourceFile.append(pageName)
                parameterInserted = true
            }
            
            if catchesError(functionCall) {
                if !inThrow(functionCall) {
                    if parameterInserted
                        sourceFile.append(", ")
                    let thrownType: string$ = getThrownType(functionCall)
                    if thrownType == null
                        sourceFile.append("_p")
                    else
                        sourceFile.append("_ep")
                    parameterInserted = true
                }
            }            
            else {
                if functionCall.parent is PostfixExpression {
                    let postfixExpression: PostfixExpression = (functionCall.parent) as PostfixExpression
                    if postfixExpression.primaryExpression is IdentifierExpression {
                        let identifierExpression: IdentifierExpression = (postfixExpression.primaryExpression) as IdentifierExpression
                        // Fix when print is recognized as external function
                        if identifierExpression.name.equals("print") {
                            sourceFile.append("_ep")
                            parameterInserted = true
                        }
                    }
                }
            }

            if parameterInserted && (parenthesizedExpression.expressionElements != null)
                sourceFile.append(", ")
        }

        true
    }

    function assignedToRootObject(functionCall: FunctionCall): bool {
        mutable bindingInitializer: BindingInitializer& = getBindingInitializer(functionCall)
        if bindingInitializer == null
            return(false)
        
        isRootBinding(bindingInitializer)
    }
    
    function getLocalPage(functionCall: FunctionCall&): string& {
        mutable bindingInitializer: BindingInitializer& = getBindingInitializer(functionCall) 
        if bindingInitializer == null
            return(null)
            
        let type: Type = bindingInitializer.initializer.pattern.annotationForType.annotationForType

        if type.lifeTime == null
            return(null)

        if type.lifeTime is Local {
            let local: Local = type.lifeTime as Local
            return (local.location)
        }
        
        null
    }
    
    function isRootBinding(bindingInitializer: BindingInitializer): bool {
 
       if bindingInitializer == null
            return(false)
            
        let type: Type = bindingInitializer.initializer.pattern.annotationForType.annotationForType

        if type.lifeTime == null
            return(false)

        if type.lifeTime is Root
            return(true)
        
        false
    }

    function assignedToReturnedObject(functionCall: FunctionCall): bool {
        mutable bindingInitializer: BindingInitializer& = getBindingInitializer(functionCall)
        if bindingInitializer == null
            return(false)

        if bindingInitializer.parent is ConstantDeclaration {
            if boundToObject(bindingInitializer)
                return(true)
        }

        false
    }

    function boundToObject(bindingInitializer: BindingInitializer): bool {
        
        if bindingInitializer == null
            return(false)

        let type: Type = bindingInitializer.initializer.pattern.annotationForType.annotationForType
        
        if type.lifeTime != null
            return(false)

        if isClass(type.name) && (getFunctionCall(bindingInitializer.initializer) != null)
            return(true)

        false
    }

    function getBindingInitializer(functionCall: FunctionCall&): BindingInitializer& {
        if functionCall.parent is PostfixExpression {
            let postfixExpression: PostfixExpression = (functionCall.parent) as PostfixExpression
            if postfixExpression.parent.parent.parent is Initializer {
                let initializer: Initializer = (postfixExpression.parent.parent.parent) as Initializer
                if initializer.parent is IdentifierInitializer {
                    let identifierInitializer: IdentifierInitializer = (initializer.parent) as IdentifierInitializer
                    if identifierInitializer.parent is BindingInitializer {
                        return((identifierInitializer.parent) as BindingInitializer)
                    }
                }
            }
        }

        null
    }

    function catchesError(functionCall: FunctionCall): bool {
        if functionCall == null
            return(false)

        if functionCall.catchClauses != null
            return(true)

        false
    }

    function closeParenthesizedExpression(parenthesizedExpression: ParenthesizedExpression) {
        if !(parenthesizedExpression.parent) is ReturnExpression
            sourceFile.append(")")
    }

    function openReturnExpression(returnExpression: ReturnExpression): bool {
        sourceFile.append("return")
        if returnExpression.expression != null {
            sourceFile.append(" ")
            let returnType: string$ = getReturnType(returnExpression)
            let thrownType: string$ = getThrownType(returnExpression)
            if thrownType != null {
                sourceFile.append("_Result<")
                if returnType != null
                    sourceFile.append(returnType)
                sourceFile.append(", ")
                sourceFile.append(thrownType)
                sourceFile.append(">(")
            }
            returnExpression.expression.accept(this)
            if returnsArray(returnExpression) {
                sourceFile.append(" ? new(_rp) ")
                sourceFile.append(returnType)
                sourceFile.append("(")
                returnExpression.expression.accept(this)
                sourceFile.append(") : nullptr")
            }
            if thrownType != null
                sourceFile.append(")")
        }
        else {
            if inTopLevelCode(returnExpression)
                sourceFile.append(" nullptr")
        }

        false
    }
    
    function inTopLevelCode(syntaxNode: SyntaxNode):bool {

        if syntaxNode == null
            return(false)

        if syntaxNode is FunctionDeclaration
            return(false)

        if syntaxNode is Module
            return(true)
            
        if syntaxNode.parent == null
            return(false)

        inTopLevelCode(syntaxNode.parent)
    }

    function closeReturnExpression(returnExpression: ReturnExpression) {
        let returnType: string$ = getReturnType(returnExpression)
        if returnType != null {
            sourceFile.append(")")
        }
    }

    function openThrowExpression(throwExpression: ThrowExpression): bool {
        let thrownType: string$ = getThrownType(throwExpression)
        if thrownType == null
            return(false)

        sourceFile.append("return ")
        let returnType: string$ = getReturnType(throwExpression)
        if returnType != null {
            sourceFile.append("_Result<")
            sourceFile.append(returnType)
            sourceFile.append(", ")
            sourceFile.append(thrownType)
            sourceFile.append(">(")
        }
        {
            let buildError: bool = true
            if throwExpression.arguments == null {
                if throwExpression.error is IdentifierExpression {
                    let errorExpression: IdentifierExpression = (throwExpression.error) as IdentifierExpression
                    let errorName: string = errorExpression.name
                    mutable catchClause: CatchClause& = getCatchClause(throwExpression)
                    if catchClause != null {
                        if catchClause.catchPattern != null {
                            if catchClause.catchPattern is WildCardCatchPattern {
                                if catchClause.bindingPattern != null {
                                    let bindingPattern: TuplePattern bindingPattern = catchClause.bindingPattern
                                    if bindingPattern.elements != null {
                                        if bindingPattern.elements.length() > 0 {
                                            let element: TuplePatternElement = bindingPattern.elements[0]
                                            if element.pattern is IdentifierPattern {
                                                let pattern: IdentifierPattern = (element.pattern) as IdentifierPattern
                                                if pattern.identifier.equals(errorName)
                                                    buildError = false
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            if buildError {
                sourceFile.append("new(_ep) ")
                sourceFile.append(thrownType)
                sourceFile.append("(")
                if throwExpression.arguments != null
                    sourceFile.append("new(_ep) ")
                sourceFile.append("_")
                sourceFile.append(thrownType)
                if throwExpression.arguments == null
                    sourceFile.append("Code")
                sourceFile.append("_")
            }
            if throwExpression.error != null
                throwExpression.error.accept(this)
            if throwExpression.arguments != null
                throwExpression.arguments.accept(this)
            if buildError
                sourceFile.append(")")
        }
        if returnType != null
            sourceFile.append(")")

        false
    }

    function inWildcardCatchClause(throwExpression: ThrowExpression): bool {
        mutable catchClause: CatchClause& = getCatchClause(throwExpression)
        if (catchClause != null) && (catchClause.catchPattern is WildCardCatchPattern)
            return(true)

        false
    }

    function getCatchClause(syntaxNode: SyntaxNode&): CatchClause& {
        if syntaxNode is CatchClause
            return(syntaxNode as CatchClause)

        if syntaxNode.parent == null
            return(null)

        getCatchClause(syntaxNode.parent)
    }

    function getReturnType(syntaxNode: SyntaxNode): string {
        mutable functionDeclaration: FunctionDeclaration& = getFunctionDeclaration(syntaxNode)
        if functionDeclaration != null {
            let functionResult: FunctionResult = functionDeclaration.signature.result
            if functionResult != null {
                let ret: VarString = new VarString()
                if hasArrayPostfix(functionResult.resultType) {
                    let type: Type = functionResult.resultType
                    ret.append("_Array<")
                    appendCppTypeName(ret, type)
                    ret.append(">")
                    return(new string(ret))
                }
                else {
                    appendCppTypeName(ret, functionResult.resultType)
                    return(new string(ret))
                }
            }
        }
        
        null
    }
    
    function getThrownType(syntaxNode: SyntaxNode): string {
        mutable functionDeclaration: FunctionDeclaration& = getFunctionDeclaration(syntaxNode)
        if functionDeclaration != null {
            let throwsClause: ThrowsClause = functionDeclaration.signature.throwsClause
            if throwsClause != null {
                let ret: VarString = new VarString()
                if hasArrayPostfix(throwsClause.throwsType) {
                    let type: Type = throwsClause.throwsType
                    ret.append("_Array<")
                    appendCppTypeName(ret, type)
                    ret.append(">")
                    return(new string(ret))
                }
                else {
                    appendCppTypeName(ret, throwsClause.throwsType)
                    return(new string(ret))
                }
            }
        }
        
        null
    }

    function returnsArray(syntaxNode: SyntaxNode): bool {
        mutable functionDeclaration: FunctionDeclaration& = getFunctionDeclaration(syntaxNode)
        if functionDeclaration != null {
            let functionResult: FunctionResult = functionDeclaration.signature.result
            if functionResult != null {
                if hasArrayPostfix(functionResult.resultType)
                    return(true)
            }
        }    

        false
    }

    function getFunctionDeclaration(syntaxNode: SyntaxNode&): FunctionDeclaration& {
        if syntaxNode is FunctionDeclaration
            return(syntaxNode as FunctionDeclaration)

        if syntaxNode.parent == null
            return(null)

        getFunctionDeclaration(syntaxNode.parent)
    }

    function openBreakExpression(breakExpression: BreakExpression): bool {
        sourceFile.append("break")

        true
    }
    
    function getPageOfVariable(name: string, codeBlock: CodeBlock): string {
        for statement: Statement in codeBlock.statements {

            mutable bindingInitializer: BindingInitializer = null
            if statement is ConstantDeclaration {
                let constantDeclaration: ConstantDeclaration = statement as ConstantDeclaration
                bindingInitializer = constantDeclaration.initializer
            }
            if statement is MutableDeclaration {
                let mutableDeclaration: MutableDeclaration = statement as MutableDeclaration
                bindingInitializer = mutableDeclaration.initializer
            }

            if bindingInitializer == null
                continue

            let identifierPattern: IdentifierPattern = bindingInitializer.initializer.pattern
            if identifierPattern.identifier.equals(name) {
                if identifierPattern.annotationForType != null {
                    if identifierPattern.annotationForType.annotationForType.lifeTime == null {
                        return(new string("_rp"))
                    }
                    else {
                        let lifeTime: LifeTime = identifierPattern.annotationForType.annotationForType.lifeTime

                        if lifeTime is Root
                            return(new string("_p"))

                        if lifeTime is Local {
                            let local: Local = lifeTime as Local
                            mutable ret: VarString = new VarString(local.location)
                            ret.append("->_getPage()")
                            return(new string(ret))
                        }
                    }
                }
            }
        }

        null
    }

    function getPage(node: SyntaxNode): string {

        while node != null {
            if node is ReturnExpression
                return(new string("_rp"))

            if node is ThrowExpression
                return(new string("_ep"))

            if node is CatchClause
                return(null)

            if node is IdentifierInitializer {
                let identifierInitializer: IdentifierInitializer = node as IdentifierInitializer
                let identifierPattern: IdentifierPattern = identifierInitializer.pattern
                if identifierPattern.annotationForType != null {

                    // simple type which needs no page for allocation
                    if !isClass(identifierPattern.annotationForType.annotationForType.name)
                        return(null)

                    // null lifeTime means the object will be returned (default)
                    if identifierPattern.annotationForType.annotationForType.lifeTime == null {
                        return(new string("_rp"))
                    }
                    else {
                        let lifeTime: LifeTime = identifierPattern.annotationForType.annotationForType.lifeTime

                        if lifeTime is Root
                            return(new string("_p"))

                        if lifeTime is Local {
                            let local: Local = lifeTime as Local
                            mutable ret: VarString = new VarString(local.location)
                            ret.append("->_getPage()")
                            return(new string(ret))
                        }
                        
                        if lifeTime is Reference
                            return(null)
                    }
                }
            }

            if node is Assignment {
                let assignment: Assignment = node as Assignment
                let simpleExpression: SimpleExpression = (assignment.parent) as SimpleExpression
                let leftSide: PostfixExpression = simpleExpression.prefixExpression.expression
                if leftSide.primaryExpression is IdentifierExpression {
                    let identifierExpression: IdentifierExpression = (leftSide.primaryExpression) as IdentifierExpression
                    let name: string = identifierExpression.name
                    
                    mutable node: SyntaxNode = assignment
                    while node != null {
                        if node is CodeBlock {
                            let codeBlock: CodeBlock = node as CodeBlock
                            let page: string = getPageOfVariable(name, codeBlock)
                            if page != null
                                return(page)
                        }
                        node = node.parent
                    }
                    
                    mutable classDeclaration: ClassDeclaration& = getClassDeclaration(assignment)
                    if classDeclaration != null {
                        let page: VarString = new VarString("")
                        if isObjectField(name, classDeclaration) {
                            if isVariableObjectField(name, classDeclaration) {
                                if !inConstructor(assignment) {
                                    page.append(name)
                                    page.append(" == nullptr ? _getPage()->allocateExclusivePage() : ")
                                    page.append(name)
                                    page.append("->")
                                }
                                page.append("_getPage()")
                                if inConstructor(assignment) {
                                    page.append("->allocateExclusivePage()")
                                }
                            }
                            else {
                                page.append("_getPage()")
                            }
                            return(new string(page))
                        }
                    }
                }
            }

            node = node.parent
        }

        null
    }

    function openConstructorCall(constructorCall: ConstructorCall): bool {
        sourceFile.append("new(")        

        let page: string$ = getPage(constructorCall.parent)
        if page != null
            sourceFile.append(page)

        sourceFile.append(") ")

        true
    }

    function visitThisExpression(thisExpression: ThisExpression) {
        sourceFile.append("this")
    }

    function visitNullExpression(nullExpression: NullExpression) {
        sourceFile.append("nullptr")
    }

    function openElseClause(elseClause: ElseClause): bool {
        indent(level(elseClause))
        sourceFile.append("else")
        if elseClause.alternative is SimpleExpression {
            sourceFile.append("\n    ")
            indent(level(elseClause))
            elseClause.alternative.accept(this)
        }
        else {
            sourceFile.append(" ")
            elseClause.alternative.accept(this)
        }
        
        false
    }

    function openCurliedSwitchBody(curliedSwitchBody: CurliedSwitchBody): bool {
        sourceFile.append(") {\n")

        true
    }

    function closeCurliedSwitchBody(curliedSwitchBody: CurliedSwitchBody) {
        indent(level(curliedSwitchBody) - 1)
        sourceFile.append("}\n")
    }

    function openSwitchCase(switchCase: SwitchCase): bool {
        indent(level(switchCase))

        true
    }

    function openItemCaseLabel(itemCaseLabel: ItemCaseLabel): bool {
        sourceFile.append("case ")

        true
    }

    function visitDefaultCaseLabel(defaultCaseLabel: DefaultCaseLabel) {
        sourceFile.append("default: ")
    }

    function openCaseItem(caseItem: CaseItem): bool {
        sourceFile.append("case ")

        true
    }

    function closeCaseItem(caseItem: CaseItem) {
        sourceFile.append(": ")
    }

    function openIdentifierPattern(identifierPattern: IdentifierPattern): bool {
        if identifierPattern.parent is IdentifierInitializer {
            let identifierInitializer: IdentifierInitializer = (identifierPattern.parent) as IdentifierInitializer
            if isCatchingIdentifierInitializer(identifierInitializer) {
                sourceFile.append("auto _")
                sourceFile.append(identifierPattern.identifier)
                sourceFile.append("_result")
                return(false)
            }
        }

        if identifierPattern.annotationForType != null {
            identifierPattern.annotationForType.accept(this)

            sourceFile.append(" ")
        }

        sourceFile.append(identifierPattern.identifier)

        false
    }

    function isCatchingIdentifierInitializer(identifierInitializer: IdentifierInitializer): bool {
        if identifierInitializer.initializer != null {
            if identifierInitializer.initializer.expression is SimpleExpression {
                let simpleExpression: SimpleExpression = (identifierInitializer.initializer.expression) as SimpleExpression
                let postfixExpression: PostfixExpression = simpleExpression.prefixExpression.expression
                if postfixExpression.postfixes != null {
                    let functionCall: FunctionCall =  null
                    if postfixExpression.postfixes.length() > 0 {
                        let postfix: Postfix = postfixExpression.postfixes[0]
                        if postfix is FunctionCall {
                            functionCall = postfix as FunctionCall
                        }
                        else {
                            if postfix is MemberExpression {
                                if postfixExpression.postfixes.length() > 1 {
                                    let postfix: Postfix = postfixExpression.postfixes[1]
                                    if postfix is FunctionCall {
                                        functionCall = postfix as FunctionCall
                                    }
                                }
                            }
                        }
                    }
                    if functionCall != null {
                        if functionCall.catchClauses != null
                            return(true)
                    }
                }
            }
        }

        false
    }

    function closeExpressionPattern(expressionPattern: ExpressionPattern) {
        if expressionPattern.parent is ItemCaseLabel
            sourceFile.append(": ")
    }

    function openCaseContent(caseContent: CaseContent): bool {
        sourceFile.append("{\n")

        true
    }

    function closeCaseContent(caseContent: CaseContent) {
        mutable additionalLineFeed: bool = true
        if caseContent.parent is SwitchCase {
            if !(caseContent.parent as SwitchCase).label is DefaultCaseLabel {
                indent(level(caseContent))
                sourceFile.append("break;\n")
            }
            else
                additionalLineFeed = false
        }

        indent(level(caseContent) - 1)
        sourceFile.append("}\n")
        if additionalLineFeed
            sourceFile.append("\n")
    }

    function openType(type: Type): bool {
        if hasArrayPostfix(type) {
            sourceFile.append("_Array<")
        }
        appendCppTypeName(sourceFile, type)
 
       true
    }

    function closeType(type: Type) {
        if hasArrayPostfix(type) {
            sourceFile.append(">")
            if !type.parent is ConstructorCall
                sourceFile.append("*")
        }

        if isClass(type.name)
        && !hasArrayPostfix(type)
        && !inTypeQuery(type)
        && !type.parent is ConstructorCall
            sourceFile.append("*")

        if inTypeQuery(type)
            sourceFile.append("()")
    }

    function inTypeQuery(type: Type): bool {
        if type.parent is TypeQuery
            return(true)

        false
    }

    function visitPointer(pointer: Pointer) {
        sourceFile.append("*")
    }

    function openInheritance(inheritance: Inheritance): bool {
        false
    }
    
    function buildProjectFileString(program: Program) : VarString {
        mutable projectFile: VarString = new VarString()
        projectFile.append("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n")
        projectFile.append("<CodeLite_Project Name=\"")
        projectFile.append(program.name)
        projectFile.append("\" InternalType=\"Console\">\n  <Plugins>\n    <Plugin Name=\"qmake\">\n")
        projectFile.append("      <![CDATA[00020001N0005Debug0000000000000001N0007Release000000000000]]>\n    </Plugin>\n")
        projectFile.append("    <Plugin Name=\"CMakePlugin\">\n      <![CDATA[[{\n")
        projectFile.append("  \"name\": \"Debug\",\n  \"enabled\": false,\n  \"buildDirectory\": \"build\",\n")
        projectFile.append("  \"sourceDirectory\": \"$(ProjectPath)\",\n  \"generator\": \"\",\n  \"buildType\": \"\",\n")
        projectFile.append("  \"arguments\": [],\n  \"parentProject\": \"\"\n")
        projectFile.append(" }, {\n")
        projectFile.append("  \"name\": \"Release\",\n")
        projectFile.append("  \"enabled\": false,\n")
        projectFile.append("  \"buildDirectory\": \"build\",\n")
        projectFile.append("  \"sourceDirectory\": \"$(ProjectPath)\",\n")
        projectFile.append("  \"generator\": \"\",\n")
        projectFile.append("  \"buildType\": \"\",\n")
        projectFile.append("  \"arguments\": [],\n")
        projectFile.append("  \"parentProject\": \"\"\n")
        projectFile.append(" }]]]>\n    </Plugin>\n  </Plugins>\n")
        projectFile.append("  <Description/>\n  <Dependencies/>\n")
        projectFile.append("  <VirtualDirectory Name=\"src\">\n")
        {
            for module: Module in program.modules {
                projectFile.append("    <File Name=\"")
                let fileName: string$ = getFileName(module)
                if fileName != null {
                    let name: string$ = Path.getFileNameWithoutExtension(fileName)
                    projectFile.append(name)
                    projectFile.append(".cpp\"/>\n")
                    projectFile.append("    <File Name=\"")
                    projectFile.append(name)
                    projectFile.append(".scaly\"/>\n")
                }
            }
        }
        projectFile.append("  </VirtualDirectory>\n  <VirtualDirectory Name=\"include\">\n")
        {
            for module: Module in program.modules {
                let fileName: string$ = getFileName(module)
                if fileName != null {
                    let name: string$ = Path.getFileNameWithoutExtension(fileName)
                    projectFile.append("    <File Name=\"")
                    projectFile.append(name)
                    projectFile.append(".h\"/>\n")
                }
            }
        }
        projectFile.append("  </VirtualDirectory>\n  <Dependencies Name=\"Debug\"/>\n  <Dependencies Name=\"Release\"/>\n")
        projectFile.append("  <Settings Type=\"Executable\">\n    <GlobalSettings>\n")
        projectFile.append("      <Compiler Options=\"\" C_Options=\"\" Assembler=\"\">\n")
        projectFile.append("        <IncludePath Value=\".\"/>\n      </Compiler>\n      <Linker Options=\"\">\n")
        projectFile.append("        <LibraryPath Value=\".\"/>\n      </Linker>\n      <ResourceCompiler Options=\"\"/>\n")
        projectFile.append("    </GlobalSettings>\n")
        projectFile.append("    <Configuration Name=\"Debug\" CompilerType=\"GCC\" DebuggerType=\"GNU gdb debugger\"")
        projectFile.append(" Type=\"Executable\" BuildCmpWithGlobalSettings=\"append\" BuildLnkWithGlobalSettings=\"append\"")
        projectFile.append(" BuildResWithGlobalSettings=\"append\">\n")
        projectFile.append("      <Compiler Options=\"-g;-O0;-std=c++11;-Wall\" C_Options=\"-g;-O0;-Wall\" Assembler=\"\"")
        projectFile.append(" Required=\"yes\" PreCompiledHeader=\"\" PCHInCommandLine=\"no\" PCHFlags=\"\" PCHFlagsPolicy=\"0\">\n")
        projectFile.append("        <IncludePath Value=\".\"/>\n        <IncludePath Value=\"../scaly\"/>\n      </Compiler>\n")
        projectFile.append("      <Linker Options=\"\" Required=\"yes\">\n        <LibraryPath Value=\"../Debug\"/>\n")
        projectFile.append("        <Library Value=\"libscaly\"/>\n      </Linker>\n      <ResourceCompiler Options=\"\" Required=\"no\"/>\n")
        projectFile.append("      <General OutputFile=\"$(IntermediateDirectory)/$(ProjectName)\" IntermediateDirectory=\"../Debug\" ")
        projectFile.append("Command=\"./$(ProjectName)\" CommandArguments=\"-o ")
        projectFile.append(program.name)
        projectFile.append(" -d ../")
        projectFile.append(program.name)
        {
            for module: Module in program.modules {
                let fileName: string$ = getFileName(module)
                if fileName != null {
                    let name: string$ = Path.getFileNameWithoutExtension(fileName)
                    projectFile.append(" ../")
                    projectFile.append(program.name)
                    projectFile.append("/")
                    projectFile.append(name)
                    projectFile.append(".scaly")
                }
            }
        }
        projectFile.append("\" UseSeparateDebugArgs=\"no\" DebugArguments=\"\" WorkingDirectory=\"$(IntermediateDirectory)\"")
        projectFile.append(" PauseExecWhenProcTerminates=\"yes\" IsGUIProgram=\"no\" IsEnabled=\"yes\"/>\n")
        projectFile.append("      <Environment EnvVarSetName=\"&lt;Use Defaults&gt;\" DbgSetName=\"&lt;Use Defaults&gt;\">\n")
        projectFile.append("        <![CDATA[]]>\n      </Environment>\n")
        projectFile.append("      <Debugger IsRemote=\"no\" RemoteHostName=\"\" RemoteHostPort=\"\" DebuggerPath=\"\" IsExtended=\"yes\">\n")
        projectFile.append("        <DebuggerSearchPaths/>\n        <PostConnectCommands/>\n        <StartupCommands/>\n      </Debugger>\n")
        projectFile.append("      <PreBuild/>\n      <PostBuild/>\n      <CustomBuild Enabled=\"no\">\n        <RebuildCommand/>\n")
        projectFile.append("        <CleanCommand/>\n        <BuildCommand/>\n        <PreprocessFileCommand/>\n        <SingleFileCommand/>\n")
        projectFile.append("        <MakefileGenerationCommand/>\n        <ThirdPartyToolName>None</ThirdPartyToolName>\n")
        projectFile.append("        <WorkingDirectory/>\n      </CustomBuild>\n      <AdditionalRules>\n")
        projectFile.append("        <CustomPostBuild/>\n        <CustomPreBuild/>\n      </AdditionalRules>\n")
        projectFile.append("      <Completion EnableCpp11=\"no\" EnableCpp14=\"no\">\n        <ClangCmpFlagsC/>\n        <ClangCmpFlags/>\n")
        projectFile.append("        <ClangPP/>\n        <SearchPaths/>\n      </Completion>\n")
        projectFile.append("    </Configuration>\n")
        projectFile.append("    <Configuration Name=\"Release\" CompilerType=\"GCC\" DebuggerType=\"GNU gdb debugger\" Type=\"Executable\"")
        projectFile.append(" BuildCmpWithGlobalSettings=\"append\" BuildLnkWithGlobalSettings=\"append\" BuildResWithGlobalSettings=\"append\">\n")
        projectFile.append("      <Compiler Options=\"-O2;-Wall\" C_Options=\"-O2;-Wall\" Assembler=\"\" Required=\"yes\" PreCompiledHeader=\"\"")
        projectFile.append(" PCHInCommandLine=\"no\" PCHFlags=\"\" PCHFlagsPolicy=\"0\">\n")
        projectFile.append("        <IncludePath Value=\".\"/>\n        <Preprocessor Value=\"NDEBUG\"/>\n")
        projectFile.append("      </Compiler>\n      <Linker Options=\"\" Required=\"yes\">\n")
        projectFile.append("        <LibraryPath Value=\"../Release\"/>\n        <Library Value=\"libscaly\"/>\n      </Linker>\n")
        projectFile.append("      <ResourceCompiler Options=\"\" Required=\"no\"/>\n")
        projectFile.append("      <General OutputFile=\"$(IntermediateDirectory)/$(ProjectName)\" IntermediateDirectory=\"../Release\"")
        projectFile.append(" Command=\"./$(ProjectName)\" CommandArguments=\"\" UseSeparateDebugArgs=\"no\" DebugArguments=\"\"")
        projectFile.append(" WorkingDirectory=\"$(IntermediateDirectory)\" PauseExecWhenProcTerminates=\"yes\" IsGUIProgram=\"no\" IsEnabled=\"yes\"/>\n")
        projectFile.append("      <Environment EnvVarSetName=\"&lt;Use Defaults&gt;\" DbgSetName=\"&lt;Use Defaults&gt;\">\n")
        projectFile.append("        <![CDATA[]]>\n      </Environment>\n")
        projectFile.append("      <Debugger IsRemote=\"no\" RemoteHostName=\"\" RemoteHostPort=\"\" DebuggerPath=\"\" IsExtended=\"yes\">\n")
        projectFile.append("        <DebuggerSearchPaths/>\n        <PostConnectCommands/>\n        <StartupCommands/>\n")
        projectFile.append("      </Debugger>\n      <PreBuild/>\n      <PostBuild/>\n      <CustomBuild Enabled=\"no\">\n")
        projectFile.append("        <RebuildCommand/>\n        <CleanCommand/>\n        <BuildCommand/>\n        <PreprocessFileCommand/>\n")
        projectFile.append("        <SingleFileCommand/>\n        <MakefileGenerationCommand/>\n")
        projectFile.append("        <ThirdPartyToolName>None</ThirdPartyToolName>\n        <WorkingDirectory/>\n")
        projectFile.append("      </CustomBuild>\n      <AdditionalRules>\n        <CustomPostBuild/>\n")
        projectFile.append("        <CustomPreBuild/>\n      </AdditionalRules>\n      <Completion EnableCpp11=\"no\" EnableCpp14=\"no\">\n")
        projectFile.append("        <ClangCmpFlagsC/>\n        <ClangCmpFlags/>\n        <ClangPP/>\n")
        projectFile.append("        <SearchPaths/>\n      </Completion>\n    </Configuration>\n  </Settings>\n")
        projectFile.append("  <Dependencies Name=\"Debug\"/>\n  <Dependencies Name=\"Release\"/>\n</CodeLite_Project>\n")
        
        projectFile
    }

    function collectInheritances(program: Program) {
        for module: Module in program.modules
            collectInheritancesInModule(module)
    }
}
