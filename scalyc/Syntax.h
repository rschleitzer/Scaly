// Syntax.h - Generated from scaly.sgm
// DO NOT EDIT - generated by codegen

#pragma once

#include "Lexer.h"
#include "llvm/ADT/StringRef.h"
#include <cstddef>
#include <variant>
#include <vector>

namespace scaly {

// Forward declarations for all syntax types
struct ProgramSyntax;
struct FileSyntax;
struct DeclarationSyntax;
struct SymbolSyntax;
struct PrivateSyntax;
struct ExportSyntax;
struct MemberSyntax;
struct ConstituentSyntax;
struct DefinitionSyntax;
struct GenericParametersSyntax;
struct GenericParameterSyntax;
struct ConceptSyntax;
struct ClassSyntax;
struct BodySyntax;
struct NamespaceSyntax;
struct UnionSyntax;
struct VariantSyntax;
struct ConstantSyntax;
struct DelegateSyntax;
struct GenericArgumentsSyntax;
struct GenericArgumentSyntax;
struct OptionalSyntax;
struct ParameterSetSyntax;
struct ParametersSyntax;
struct ItemSyntax;
struct ReturnsSyntax;
struct ThrowsSyntax;
struct UseSyntax;
struct ImplementSyntax;
struct TraitSyntax;
struct MethodSyntax;
struct InitSyntax;
struct DeInitSyntax;
struct FunctionSyntax;
struct ProcedureSyntax;
struct OperatorSyntax;
struct TargetSyntax;
struct NamedSyntax;
struct RoutineSyntax;
struct ImplementationSyntax;
struct ExternSyntax;
struct InstructionSyntax;
struct IntrinsicSyntax;
struct ExtendsSyntax;
struct ExtendSyntax;
struct MacroSyntax;
struct AttributeSyntax;
struct ModelSyntax;
struct ModuleSyntax;
struct PackageSyntax;
struct VersionSyntax;
struct InitializerSyntax;
struct OperandSyntax;
struct MemberAccessSyntax;
struct ExpressionSyntax;
struct LiteralSyntax;
struct ObjectSyntax;
struct ComponentSyntax;
struct ValueSyntax;
struct VectorSyntax;
struct ElementSyntax;
struct BlockSyntax;
struct IfSyntax;
struct ElseSyntax;
struct MatchSyntax;
struct BranchSyntax;
struct CaseSyntax;
struct StatementSyntax;
struct WhileSyntax;
struct ChooseSyntax;
struct TrySyntax;
struct ConditionSyntax;
struct WhenSyntax;
struct CommandSyntax;
struct LetSyntax;
struct VarSyntax;
struct MutableSyntax;
struct BindingSyntax;
struct BindingAnnotationSyntax;
struct BindingSpecSyntax;
struct ArraySyntax;
struct StructureSyntax;
struct PartSyntax;
struct FieldSyntax;
struct PropertySyntax;
struct TypeAnnotationSyntax;
struct ContinueSyntax;
struct BreakSyntax;
struct LoopSyntax;
struct ReturnSyntax;
struct ThrowSyntax;
struct LambdaSyntax;
struct ForSyntax;
struct LabelSyntax;
struct RepeatSyntax;
struct ActionSyntax;
struct OperationSyntax;
struct SetSyntax;
struct SizeOfSyntax;
struct IsSyntax;
struct TypeSyntax;
struct NameSyntax;
struct ExtensionSyntax;
struct LifetimeSyntax;
struct CallSyntax;
struct LocalSyntax;
struct ReferenceSyntax;
struct ThrownSyntax;

// Parser error types
struct DifferentSyntax {};
struct InvalidSyntax {
    size_t Start;
    size_t End;
    llvm::StringRef Message;
};

using ParserError = std::variant<DifferentSyntax, InvalidSyntax>;

// Syntax node definitions

struct ThrownSyntax {
    size_t Start;
    size_t End;
};

struct ReferenceSyntax {
    size_t Start;
    size_t End;
    llvm::StringRef location;
};

struct LocalSyntax {
    size_t Start;
    size_t End;
};

struct CallSyntax {
    size_t Start;
    size_t End;
};

struct LifetimeSyntax {
    std::variant<CallSyntax, LocalSyntax, ReferenceSyntax, ThrownSyntax> Value;
};

struct ExtensionSyntax {
    size_t Start;
    size_t End;
    llvm::StringRef name;
};

struct NameSyntax {
    size_t Start;
    size_t End;
    llvm::StringRef name;
    std::vector<ExtensionSyntax>* extensions;
};

struct TypeSyntax {
    size_t Start;
    size_t End;
    NameSyntax name;
    GenericArgumentsSyntax* generics;
    OptionalSyntax* optional;
    LifetimeSyntax* lifetime;
};

struct IsSyntax {
    size_t Start;
    size_t End;
    NameSyntax name;
};

struct SizeOfSyntax {
    size_t Start;
    size_t End;
    TypeSyntax type;
};

struct SetSyntax {
    size_t Start;
    size_t End;
    std::vector<OperandSyntax>* target;
    std::vector<OperandSyntax>* source;
};

struct OperationSyntax {
    size_t Start;
    size_t End;
    std::vector<OperandSyntax>* operands;
};

struct ActionSyntax {
    std::variant<OperationSyntax, SetSyntax> Value;
};

struct RepeatSyntax {
    size_t Start;
    size_t End;
    LabelSyntax* name;
    ActionSyntax action;
};

struct LabelSyntax {
    size_t Start;
    size_t End;
    llvm::StringRef name;
};

struct ForSyntax {
    size_t Start;
    size_t End;
    llvm::StringRef variable;
    TypeAnnotationSyntax* annotation;
    std::vector<OperandSyntax>* operation;
    LabelSyntax* name;
    ActionSyntax action;
};

struct LambdaSyntax {
    size_t Start;
    size_t End;
    std::vector<OperandSyntax>* input;
    ActionSyntax block;
};

struct ThrowSyntax {
    size_t Start;
    size_t End;
    std::vector<OperandSyntax>* result;
};

struct ReturnSyntax {
    size_t Start;
    size_t End;
    std::vector<OperandSyntax>* result;
};

struct LoopSyntax {
    size_t Start;
    size_t End;
    llvm::StringRef name;
};

struct BreakSyntax {
    size_t Start;
    size_t End;
    LoopSyntax* name;
    std::vector<OperandSyntax>* result;
};

struct ContinueSyntax {
    size_t Start;
    size_t End;
    LoopSyntax* name;
};

struct TypeAnnotationSyntax {
    size_t Start;
    size_t End;
    TypeSyntax type;
};

struct PropertySyntax {
    size_t Start;
    size_t End;
    llvm::StringRef name;
    TypeAnnotationSyntax annotation;
    InitializerSyntax* initializer;
    std::vector<AttributeSyntax>* attributes;
};

struct FieldSyntax {
    size_t Start;
    size_t End;
    PropertySyntax property;
};

struct PartSyntax {
    std::variant<FieldSyntax, PropertySyntax> Value;
};

struct StructureSyntax {
    size_t Start;
    size_t End;
    std::vector<PartSyntax>* parts;
};

struct ArraySyntax {
    size_t Start;
    size_t End;
    std::vector<TypeSyntax>* members;
};

struct BindingSpecSyntax {
    std::variant<StructureSyntax, TypeSyntax, ArraySyntax> Value;
};

struct BindingAnnotationSyntax {
    size_t Start;
    size_t End;
    BindingSpecSyntax spec;
};

struct BindingSyntax {
    size_t Start;
    size_t End;
    llvm::StringRef name;
    BindingAnnotationSyntax* annotation;
    std::vector<OperandSyntax>* operation;
};

struct MutableSyntax {
    size_t Start;
    size_t End;
    BindingSyntax binding;
};

struct VarSyntax {
    size_t Start;
    size_t End;
    BindingSyntax binding;
};

struct LetSyntax {
    size_t Start;
    size_t End;
    BindingSyntax binding;
};

struct CommandSyntax {
    std::variant<LetSyntax, VarSyntax, MutableSyntax, SetSyntax, ContinueSyntax, BreakSyntax, ReturnSyntax, ThrowSyntax, OperationSyntax> Value;
};

struct WhenSyntax {
    size_t Start;
    size_t End;
    llvm::StringRef name;
    NameSyntax variant;
    CommandSyntax command;
};

struct ConditionSyntax {
    std::variant<OperationSyntax, LetSyntax> Value;
};

struct TrySyntax {
    size_t Start;
    size_t End;
    ConditionSyntax condition;
    std::vector<WhenSyntax>* cases;
    ElseSyntax* dropper;
};

struct ChooseSyntax {
    size_t Start;
    size_t End;
    std::vector<OperandSyntax>* condition;
    std::vector<WhenSyntax>* cases;
    ElseSyntax* alternative;
};

struct WhileSyntax {
    size_t Start;
    size_t End;
    ConditionSyntax condition;
    LabelSyntax* name;
    ActionSyntax action;
};

struct StatementSyntax {
    size_t Start;
    size_t End;
    CommandSyntax command;
};

struct CaseSyntax {
    size_t Start;
    size_t End;
    std::vector<OperandSyntax>* condition;
};

struct BranchSyntax {
    size_t Start;
    size_t End;
    std::vector<CaseSyntax>* cases;
    StatementSyntax consequent;
};

struct MatchSyntax {
    size_t Start;
    size_t End;
    std::vector<OperandSyntax>* scrutinee;
    std::vector<BranchSyntax>* branches;
    ElseSyntax* alternative;
};

struct ElseSyntax {
    size_t Start;
    size_t End;
    CommandSyntax alternative;
};

struct IfSyntax {
    size_t Start;
    size_t End;
    std::vector<OperandSyntax>* condition;
    CommandSyntax consequent;
    ElseSyntax* alternative;
};

struct BlockSyntax {
    size_t Start;
    size_t End;
    std::vector<UseSyntax>* uses;
    std::vector<StatementSyntax>* statements;
};

struct ElementSyntax {
    size_t Start;
    size_t End;
    std::vector<OperandSyntax>* operation;
    std::vector<AttributeSyntax>* attributes;
};

struct VectorSyntax {
    size_t Start;
    size_t End;
    std::vector<ElementSyntax>* elements;
    LifetimeSyntax* lifetime;
};

struct ValueSyntax {
    size_t Start;
    size_t End;
    std::vector<OperandSyntax>* value;
    std::vector<AttributeSyntax>* attributes;
};

struct ComponentSyntax {
    size_t Start;
    size_t End;
    std::vector<OperandSyntax>* operands;
    std::vector<AttributeSyntax>* attributes;
    ValueSyntax* value;
};

struct ObjectSyntax {
    size_t Start;
    size_t End;
    std::vector<ComponentSyntax>* components;
};

struct LiteralSyntax {
    size_t Start;
    size_t End;
    Literal literal;
};

struct ExpressionSyntax {
    std::variant<LiteralSyntax, TypeSyntax, ObjectSyntax, VectorSyntax, BlockSyntax, IfSyntax, MatchSyntax, LambdaSyntax, ForSyntax, WhileSyntax, ChooseSyntax, TrySyntax, RepeatSyntax, SizeOfSyntax, IsSyntax> Value;
};

struct MemberAccessSyntax {
    size_t Start;
    size_t End;
    NameSyntax name;
};

struct OperandSyntax {
    size_t Start;
    size_t End;
    ExpressionSyntax expression;
    std::vector<MemberAccessSyntax>* members;
};

struct InitializerSyntax {
    size_t Start;
    size_t End;
    std::vector<OperandSyntax>* operands;
};

struct VersionSyntax {
    size_t Start;
    size_t End;
    Literal majorMinor;
    Literal patch;
};

struct PackageSyntax {
    size_t Start;
    size_t End;
    NameSyntax name;
    VersionSyntax* version;
};

struct ModuleSyntax {
    size_t Start;
    size_t End;
    llvm::StringRef name;
};

struct ModelSyntax {
    std::variant<LiteralSyntax, NameSyntax, ObjectSyntax, VectorSyntax> Value;
};

struct AttributeSyntax {
    size_t Start;
    size_t End;
    llvm::StringRef name;
    ModelSyntax model;
};

struct MacroSyntax {
    size_t Start;
    size_t End;
    llvm::StringRef name;
    ModelSyntax model;
    std::vector<OperandSyntax>* rule;
};

struct ExtendSyntax {
    size_t Start;
    size_t End;
    TypeSyntax type;
};

struct ExtendsSyntax {
    size_t Start;
    size_t End;
    std::vector<ExtendSyntax>* extensions;
};

struct IntrinsicSyntax {
    size_t Start;
    size_t End;
};

struct InstructionSyntax {
    size_t Start;
    size_t End;
};

struct ExternSyntax {
    size_t Start;
    size_t End;
};

struct ImplementationSyntax {
    std::variant<ActionSyntax, ExternSyntax, InstructionSyntax, IntrinsicSyntax> Value;
};

struct RoutineSyntax {
    size_t Start;
    size_t End;
    GenericArgumentsSyntax* generics;
    LifetimeSyntax* lifetime;
    ParameterSetSyntax* parameters;
    std::vector<AttributeSyntax>* attributes;
    ReturnsSyntax* returns_;
    ThrowsSyntax* throws_;
    ImplementationSyntax implementation;
};

struct NamedSyntax {
    size_t Start;
    size_t End;
    llvm::StringRef name;
    RoutineSyntax routine;
};

struct TargetSyntax {
    std::variant<NamedSyntax, RoutineSyntax> Value;
};

struct OperatorSyntax {
    size_t Start;
    size_t End;
    TargetSyntax target;
};

struct ProcedureSyntax {
    size_t Start;
    size_t End;
    TargetSyntax target;
};

struct FunctionSyntax {
    size_t Start;
    size_t End;
    TargetSyntax target;
};

struct DeInitSyntax {
    size_t Start;
    size_t End;
    ActionSyntax action;
};

struct InitSyntax {
    size_t Start;
    size_t End;
    ParameterSetSyntax* parameters;
    ActionSyntax action;
};

struct MethodSyntax {
    std::variant<FunctionSyntax, ProcedureSyntax, OperatorSyntax> Value;
};

struct TraitSyntax {
    size_t Start;
    size_t End;
    NameSyntax name;
    ExtendsSyntax* extension;
    std::vector<AttributeSyntax>* attributes;
    std::vector<UseSyntax>* uses;
    std::vector<MethodSyntax>* functions;
};

struct ImplementSyntax {
    size_t Start;
    size_t End;
    TypeSyntax type;
    std::vector<AttributeSyntax>* attributes;
    std::vector<UseSyntax>* uses;
    std::vector<MethodSyntax>* methods;
};

struct UseSyntax {
    size_t Start;
    size_t End;
    NameSyntax name;
};

struct ThrowsSyntax {
    size_t Start;
    size_t End;
    TypeSyntax type;
    std::vector<AttributeSyntax>* attributes;
};

struct ReturnsSyntax {
    size_t Start;
    size_t End;
    TypeSyntax type;
    std::vector<AttributeSyntax>* attributes;
};

struct ItemSyntax {
    size_t Start;
    size_t End;
    llvm::StringRef name;
    TypeAnnotationSyntax* annotation;
    std::vector<AttributeSyntax>* attributes;
};

struct ParametersSyntax {
    size_t Start;
    size_t End;
    std::vector<ItemSyntax>* items;
};

struct ParameterSetSyntax {
    std::variant<ParametersSyntax, TypeSyntax> Value;
};

struct OptionalSyntax {
    size_t Start;
    size_t End;
};

struct GenericArgumentSyntax {
    size_t Start;
    size_t End;
    TypeSyntax type;
};

struct GenericArgumentsSyntax {
    size_t Start;
    size_t End;
    std::vector<GenericArgumentSyntax>* generics;
};

struct DelegateSyntax {
    size_t Start;
    size_t End;
    ParameterSetSyntax* parameters;
    std::vector<AttributeSyntax>* attributes;
    ReturnsSyntax* result;
    ThrowsSyntax* error;
};

struct ConstantSyntax {
    size_t Start;
    size_t End;
    TypeSyntax type;
    std::vector<OperandSyntax>* operation;
};

struct VariantSyntax {
    size_t Start;
    size_t End;
    llvm::StringRef name;
    std::vector<AttributeSyntax>* attributes;
    TypeAnnotationSyntax* annotation;
};

struct UnionSyntax {
    size_t Start;
    size_t End;
    std::vector<VariantSyntax>* variants;
    BodySyntax* body;
};

struct NamespaceSyntax {
    size_t Start;
    size_t End;
    std::vector<UseSyntax>* uses;
    std::vector<DeclarationSyntax>* declarations;
};

struct BodySyntax {
    size_t Start;
    size_t End;
    std::vector<UseSyntax>* uses;
    std::vector<InitSyntax>* inits;
    DeInitSyntax* deInit;
    std::vector<MemberSyntax>* members;
};

struct ClassSyntax {
    size_t Start;
    size_t End;
    StructureSyntax structure;
    BodySyntax* body;
};

struct ConceptSyntax {
    std::variant<ClassSyntax, NamespaceSyntax, UnionSyntax, ConstantSyntax, DelegateSyntax, IntrinsicSyntax> Value;
};

struct GenericParameterSyntax {
    size_t Start;
    size_t End;
    llvm::StringRef name;
    std::vector<AttributeSyntax>* attributes;
};

struct GenericParametersSyntax {
    size_t Start;
    size_t End;
    std::vector<GenericParameterSyntax>* parameters;
};

struct DefinitionSyntax {
    size_t Start;
    size_t End;
    llvm::StringRef name;
    GenericParametersSyntax* parameters;
    std::vector<AttributeSyntax>* attributes;
    ConceptSyntax concept_;
};

struct ConstituentSyntax {
    std::variant<DefinitionSyntax, FunctionSyntax, ProcedureSyntax, OperatorSyntax, ImplementSyntax, TraitSyntax, MacroSyntax, ModuleSyntax> Value;
};

struct MemberSyntax {
    size_t Start;
    size_t End;
    ConstituentSyntax constituent;
};

struct ExportSyntax {
    std::variant<DefinitionSyntax, FunctionSyntax, OperatorSyntax, TraitSyntax, ModuleSyntax> Value;
};

struct PrivateSyntax {
    size_t Start;
    size_t End;
    ExportSyntax export_;
};

struct SymbolSyntax {
    std::variant<PrivateSyntax, DefinitionSyntax, FunctionSyntax, OperatorSyntax, TraitSyntax, MacroSyntax, ModuleSyntax> Value;
};

struct DeclarationSyntax {
    size_t Start;
    size_t End;
    SymbolSyntax symbol;
};

struct FileSyntax {
    size_t Start;
    size_t End;
    std::vector<PackageSyntax>* packages;
    std::vector<UseSyntax>* uses;
    std::vector<DeclarationSyntax>* declarations;
};

struct ProgramSyntax {
    size_t Start;
    size_t End;
    FileSyntax file;
    std::vector<StatementSyntax>* statements;
};

} // namespace scaly
