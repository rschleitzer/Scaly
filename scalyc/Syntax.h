// Syntax.h - Generated from scaly.sgm
// DO NOT EDIT - generated by codegen

#pragma once

#include "Lexer.h"
#include "llvm/ADT/StringRef.h"
#include <cstddef>
#include <variant>
#include <vector>

namespace scaly {

// Forward declarations for all syntax types
struct ProgramSyntax;
struct FileSyntax;
struct DeclarationSyntax;
struct SymbolSyntax;
struct PrivateSyntax;
struct ExportSyntax;
struct MemberSyntax;
struct ConstituentSyntax;
struct DefinitionSyntax;
struct GenericParametersSyntax;
struct GenericParameterSyntax;
struct ConceptSyntax;
struct ClassSyntax;
struct BodySyntax;
struct NamespaceSyntax;
struct UnionSyntax;
struct VariantSyntax;
struct ConstantSyntax;
struct DelegateSyntax;
struct GenericArgumentsSyntax;
struct GenericArgumentSyntax;
struct OptionalSyntax;
struct ParameterSetSyntax;
struct ParametersSyntax;
struct ItemSyntax;
struct ReturnsSyntax;
struct ThrowsSyntax;
struct UseSyntax;
struct ImplementSyntax;
struct TraitSyntax;
struct MethodSyntax;
struct InitSyntax;
struct DeInitSyntax;
struct FunctionSyntax;
struct ProcedureSyntax;
struct OperatorSyntax;
struct TargetSyntax;
struct NamedSyntax;
struct RoutineSyntax;
struct ImplementationSyntax;
struct ExternSyntax;
struct InstructionSyntax;
struct IntrinsicSyntax;
struct ExtendsSyntax;
struct ExtendSyntax;
struct MacroSyntax;
struct AttributeSyntax;
struct ModelSyntax;
struct ModuleSyntax;
struct PackageSyntax;
struct InitializerSyntax;
struct OperandSyntax;
struct MemberAccessSyntax;
struct ExpressionSyntax;
struct LiteralSyntax;
struct ObjectSyntax;
struct ComponentSyntax;
struct ValueSyntax;
struct VectorSyntax;
struct ElementSyntax;
struct BlockSyntax;
struct IfSyntax;
struct ElseSyntax;
struct MatchSyntax;
struct BranchSyntax;
struct CaseSyntax;
struct StatementSyntax;
struct WhileSyntax;
struct ChooseSyntax;
struct TrySyntax;
struct ConditionSyntax;
struct WhenSyntax;
struct CommandSyntax;
struct LetSyntax;
struct VarSyntax;
struct MutableSyntax;
struct BindingSyntax;
struct BindingAnnotationSyntax;
struct BindingSpecSyntax;
struct ArraySyntax;
struct StructureSyntax;
struct PartSyntax;
struct FieldSyntax;
struct PropertySyntax;
struct TypeAnnotationSyntax;
struct ContinueSyntax;
struct BreakSyntax;
struct LoopSyntax;
struct ReturnSyntax;
struct ThrowSyntax;
struct LambdaSyntax;
struct ForSyntax;
struct LabelSyntax;
struct RepeatSyntax;
struct ActionSyntax;
struct OperationSyntax;
struct SetSyntax;
struct SizeOfSyntax;
struct IsSyntax;
struct TypeSyntax;
struct NameSyntax;
struct ExtensionSyntax;
struct LifetimeSyntax;
struct CallSyntax;
struct LocalSyntax;
struct ReferenceSyntax;
struct ThrownSyntax;

// Parser error types
struct DifferentSyntax {};
struct InvalidSyntax {
    size_t Start;
    size_t End;
    llvm::StringRef Message;
};

using ParserError = std::variant<DifferentSyntax, InvalidSyntax>;

// Syntax node definitions

struct ThrownSyntax {
    size_t Start;
    size_t End;
};

struct ReferenceSyntax {
    size_t Start;
    size_t End;
    llvm::StringRef Location;
};

struct LocalSyntax {
    size_t Start;
    size_t End;
};

struct CallSyntax {
    size_t Start;
    size_t End;
};

struct LifetimeSyntax {
    std::variant<CallSyntax, LocalSyntax, ReferenceSyntax, ThrownSyntax> Value;
};

struct ExtensionSyntax {
    size_t Start;
    size_t End;
    llvm::StringRef Name;
};

struct NameSyntax {
    size_t Start;
    size_t End;
    llvm::StringRef Name;
    std::vector<ExtensionSyntax>* Extensions;
};

struct TypeSyntax {
    size_t Start;
    size_t End;
    NameSyntax Name;
    GenericArgumentsSyntax* Generics;
    OptionalSyntax* Optional;
    LifetimeSyntax* Lifetime;
};

struct IsSyntax {
    size_t Start;
    size_t End;
    NameSyntax Name;
};

struct SizeOfSyntax {
    size_t Start;
    size_t End;
    TypeSyntax Type;
};

struct SetSyntax {
    size_t Start;
    size_t End;
    std::vector<OperandSyntax>* Target;
    std::vector<OperandSyntax>* Source;
};

struct OperationSyntax {
    size_t Start;
    size_t End;
    std::vector<OperandSyntax>* Operands;
};

struct ActionSyntax {
    std::variant<OperationSyntax, SetSyntax> Value;
};

struct RepeatSyntax {
    size_t Start;
    size_t End;
    LabelSyntax* Name;
    ActionSyntax Action;
};

struct LabelSyntax {
    size_t Start;
    size_t End;
    llvm::StringRef Name;
};

struct ForSyntax {
    size_t Start;
    size_t End;
    llvm::StringRef Variable;
    TypeAnnotationSyntax* Annotation;
    std::vector<OperandSyntax>* Operation;
    LabelSyntax* Name;
    ActionSyntax Action;
};

struct LambdaSyntax {
    size_t Start;
    size_t End;
    std::vector<OperandSyntax>* Input;
    ActionSyntax Block;
};

struct ThrowSyntax {
    size_t Start;
    size_t End;
    std::vector<OperandSyntax>* Result;
};

struct ReturnSyntax {
    size_t Start;
    size_t End;
    std::vector<OperandSyntax>* Result;
};

struct LoopSyntax {
    size_t Start;
    size_t End;
    llvm::StringRef Name;
};

struct BreakSyntax {
    size_t Start;
    size_t End;
    LoopSyntax* Name;
    std::vector<OperandSyntax>* Result;
};

struct ContinueSyntax {
    size_t Start;
    size_t End;
    LoopSyntax* Name;
};

struct TypeAnnotationSyntax {
    size_t Start;
    size_t End;
    TypeSyntax Type;
};

struct PropertySyntax {
    size_t Start;
    size_t End;
    llvm::StringRef Name;
    TypeAnnotationSyntax Annotation;
    InitializerSyntax* Initializer;
    std::vector<AttributeSyntax>* Attributes;
};

struct FieldSyntax {
    size_t Start;
    size_t End;
    PropertySyntax Property;
};

struct PartSyntax {
    std::variant<FieldSyntax, PropertySyntax> Value;
};

struct StructureSyntax {
    size_t Start;
    size_t End;
    std::vector<PartSyntax>* Parts;
};

struct ArraySyntax {
    size_t Start;
    size_t End;
    std::vector<TypeSyntax>* Members;
};

struct BindingSpecSyntax {
    std::variant<StructureSyntax, TypeSyntax, ArraySyntax> Value;
};

struct BindingAnnotationSyntax {
    size_t Start;
    size_t End;
    BindingSpecSyntax Spec;
};

struct BindingSyntax {
    size_t Start;
    size_t End;
    llvm::StringRef Name;
    BindingAnnotationSyntax* Annotation;
    std::vector<OperandSyntax>* Operation;
};

struct MutableSyntax {
    size_t Start;
    size_t End;
    BindingSyntax Binding;
};

struct VarSyntax {
    size_t Start;
    size_t End;
    BindingSyntax Binding;
};

struct LetSyntax {
    size_t Start;
    size_t End;
    BindingSyntax Binding;
};

struct CommandSyntax {
    std::variant<OperationSyntax, LetSyntax, VarSyntax, MutableSyntax, SetSyntax, ContinueSyntax, BreakSyntax, ReturnSyntax, ThrowSyntax> Value;
};

struct WhenSyntax {
    size_t Start;
    size_t End;
    llvm::StringRef Name;
    NameSyntax Variant;
    CommandSyntax Command;
};

struct ConditionSyntax {
    std::variant<OperationSyntax, LetSyntax> Value;
};

struct TrySyntax {
    size_t Start;
    size_t End;
    ConditionSyntax Condition;
    std::vector<WhenSyntax>* Cases;
    ElseSyntax* Dropper;
};

struct ChooseSyntax {
    size_t Start;
    size_t End;
    std::vector<OperandSyntax>* Condition;
    std::vector<WhenSyntax>* Cases;
    ElseSyntax* Alternative;
};

struct WhileSyntax {
    size_t Start;
    size_t End;
    ConditionSyntax Condition;
    LabelSyntax* Name;
    ActionSyntax Action;
};

struct StatementSyntax {
    size_t Start;
    size_t End;
    CommandSyntax Command;
};

struct CaseSyntax {
    size_t Start;
    size_t End;
    std::vector<OperandSyntax>* Condition;
};

struct BranchSyntax {
    size_t Start;
    size_t End;
    std::vector<CaseSyntax>* Cases;
    StatementSyntax Consequent;
};

struct MatchSyntax {
    size_t Start;
    size_t End;
    std::vector<OperandSyntax>* Scrutinee;
    std::vector<BranchSyntax>* Branches;
    ElseSyntax* Alternative;
};

struct ElseSyntax {
    size_t Start;
    size_t End;
    CommandSyntax Alternative;
};

struct IfSyntax {
    size_t Start;
    size_t End;
    std::vector<OperandSyntax>* Condition;
    CommandSyntax Consequent;
    ElseSyntax* Alternative;
};

struct BlockSyntax {
    size_t Start;
    size_t End;
    std::vector<UseSyntax>* Uses;
    std::vector<StatementSyntax>* Statements;
};

struct ElementSyntax {
    size_t Start;
    size_t End;
    std::vector<OperandSyntax>* Operation;
    std::vector<AttributeSyntax>* Attributes;
};

struct VectorSyntax {
    size_t Start;
    size_t End;
    std::vector<ElementSyntax>* Elements;
    LifetimeSyntax* Lifetime;
};

struct ValueSyntax {
    size_t Start;
    size_t End;
    std::vector<OperandSyntax>* Value;
    std::vector<AttributeSyntax>* Attributes;
};

struct ComponentSyntax {
    size_t Start;
    size_t End;
    std::vector<OperandSyntax>* Operands;
    std::vector<AttributeSyntax>* Attributes;
    ValueSyntax* Value;
};

struct ObjectSyntax {
    size_t Start;
    size_t End;
    std::vector<ComponentSyntax>* Components;
};

struct LiteralSyntax {
    size_t Start;
    size_t End;
    Literal Literal;
};

struct ExpressionSyntax {
    std::variant<LiteralSyntax, TypeSyntax, ObjectSyntax, VectorSyntax, BlockSyntax, IfSyntax, MatchSyntax, LambdaSyntax, ForSyntax, WhileSyntax, ChooseSyntax, TrySyntax, RepeatSyntax, SizeOfSyntax, IsSyntax> Value;
};

struct MemberAccessSyntax {
    size_t Start;
    size_t End;
    NameSyntax Name;
};

struct OperandSyntax {
    size_t Start;
    size_t End;
    ExpressionSyntax Expression;
    std::vector<MemberAccessSyntax>* Members;
};

struct InitializerSyntax {
    size_t Start;
    size_t End;
    std::vector<OperandSyntax>* Operands;
};

struct PackageSyntax {
    size_t Start;
    size_t End;
    NameSyntax Name;
};

struct ModuleSyntax {
    size_t Start;
    size_t End;
    llvm::StringRef Name;
};

struct ModelSyntax {
    std::variant<LiteralSyntax, NameSyntax, ObjectSyntax, VectorSyntax> Value;
};

struct AttributeSyntax {
    size_t Start;
    size_t End;
    llvm::StringRef Name;
    ModelSyntax Model;
};

struct MacroSyntax {
    size_t Start;
    size_t End;
    llvm::StringRef Name;
    ModelSyntax Model;
    std::vector<OperandSyntax>* Rule;
};

struct ExtendSyntax {
    size_t Start;
    size_t End;
    TypeSyntax Type;
};

struct ExtendsSyntax {
    size_t Start;
    size_t End;
    std::vector<ExtendSyntax>* Extensions;
};

struct IntrinsicSyntax {
    size_t Start;
    size_t End;
};

struct InstructionSyntax {
    size_t Start;
    size_t End;
};

struct ExternSyntax {
    size_t Start;
    size_t End;
};

struct ImplementationSyntax {
    std::variant<ActionSyntax, ExternSyntax, InstructionSyntax, IntrinsicSyntax> Value;
};

struct RoutineSyntax {
    size_t Start;
    size_t End;
    GenericArgumentsSyntax* Generics;
    LifetimeSyntax* Lifetime;
    ParameterSetSyntax* Parameters;
    std::vector<AttributeSyntax>* Attributes;
    ReturnsSyntax* Returns_;
    ThrowsSyntax* Throws_;
    ImplementationSyntax Implementation;
};

struct NamedSyntax {
    size_t Start;
    size_t End;
    llvm::StringRef Name;
    RoutineSyntax Routine;
};

struct TargetSyntax {
    std::variant<NamedSyntax, RoutineSyntax> Value;
};

struct OperatorSyntax {
    size_t Start;
    size_t End;
    TargetSyntax Target;
};

struct ProcedureSyntax {
    size_t Start;
    size_t End;
    TargetSyntax Target;
};

struct FunctionSyntax {
    size_t Start;
    size_t End;
    TargetSyntax Target;
};

struct DeInitSyntax {
    size_t Start;
    size_t End;
    ActionSyntax Action;
};

struct InitSyntax {
    size_t Start;
    size_t End;
    ParameterSetSyntax* Parameters;
    ActionSyntax Action;
};

struct MethodSyntax {
    std::variant<FunctionSyntax, ProcedureSyntax, OperatorSyntax> Value;
};

struct TraitSyntax {
    size_t Start;
    size_t End;
    NameSyntax Name;
    ExtendsSyntax* Extension;
    std::vector<AttributeSyntax>* Attributes;
    std::vector<UseSyntax>* Uses;
    std::vector<MethodSyntax>* Functions;
};

struct ImplementSyntax {
    size_t Start;
    size_t End;
    TypeSyntax Type;
    std::vector<AttributeSyntax>* Attributes;
    std::vector<UseSyntax>* Uses;
    std::vector<MethodSyntax>* Methods;
};

struct UseSyntax {
    size_t Start;
    size_t End;
    NameSyntax Name;
};

struct ThrowsSyntax {
    size_t Start;
    size_t End;
    TypeSyntax Type;
    std::vector<AttributeSyntax>* Attributes;
};

struct ReturnsSyntax {
    size_t Start;
    size_t End;
    TypeSyntax Type;
    std::vector<AttributeSyntax>* Attributes;
};

struct ItemSyntax {
    size_t Start;
    size_t End;
    llvm::StringRef Name;
    TypeAnnotationSyntax* Annotation;
    std::vector<AttributeSyntax>* Attributes;
};

struct ParametersSyntax {
    size_t Start;
    size_t End;
    std::vector<ItemSyntax>* Items;
};

struct ParameterSetSyntax {
    std::variant<ParametersSyntax, TypeSyntax> Value;
};

struct OptionalSyntax {
    size_t Start;
    size_t End;
};

struct GenericArgumentSyntax {
    size_t Start;
    size_t End;
    TypeSyntax Type;
};

struct GenericArgumentsSyntax {
    size_t Start;
    size_t End;
    std::vector<GenericArgumentSyntax>* Generics;
};

struct DelegateSyntax {
    size_t Start;
    size_t End;
    ParameterSetSyntax* Parameters;
    std::vector<AttributeSyntax>* Attributes;
    ReturnsSyntax* Result;
    ThrowsSyntax* Error;
};

struct ConstantSyntax {
    size_t Start;
    size_t End;
    TypeSyntax Type;
    std::vector<OperandSyntax>* Operation;
};

struct VariantSyntax {
    size_t Start;
    size_t End;
    llvm::StringRef Name;
    std::vector<AttributeSyntax>* Attributes;
    TypeAnnotationSyntax* Annotation;
};

struct UnionSyntax {
    size_t Start;
    size_t End;
    std::vector<VariantSyntax>* Variants;
    BodySyntax* Body;
};

struct NamespaceSyntax {
    size_t Start;
    size_t End;
    std::vector<UseSyntax>* Uses;
    std::vector<DeclarationSyntax>* Declarations;
};

struct BodySyntax {
    size_t Start;
    size_t End;
    std::vector<UseSyntax>* Uses;
    std::vector<InitSyntax>* Inits;
    DeInitSyntax* DeInit;
    std::vector<MemberSyntax>* Members;
};

struct ClassSyntax {
    size_t Start;
    size_t End;
    StructureSyntax Structure;
    BodySyntax* Body;
};

struct ConceptSyntax {
    std::variant<ClassSyntax, NamespaceSyntax, UnionSyntax, ConstantSyntax, DelegateSyntax, IntrinsicSyntax> Value;
};

struct GenericParameterSyntax {
    size_t Start;
    size_t End;
    llvm::StringRef Name;
    std::vector<AttributeSyntax>* Attributes;
};

struct GenericParametersSyntax {
    size_t Start;
    size_t End;
    std::vector<GenericParameterSyntax>* Parameters;
};

struct DefinitionSyntax {
    size_t Start;
    size_t End;
    llvm::StringRef Name;
    GenericParametersSyntax* Parameters;
    std::vector<AttributeSyntax>* Attributes;
    ConceptSyntax Concept_;
};

struct ConstituentSyntax {
    std::variant<DefinitionSyntax, FunctionSyntax, ProcedureSyntax, OperatorSyntax, ImplementSyntax, TraitSyntax, MacroSyntax, ModuleSyntax> Value;
};

struct MemberSyntax {
    size_t Start;
    size_t End;
    ConstituentSyntax Constituent;
};

struct ExportSyntax {
    std::variant<DefinitionSyntax, FunctionSyntax, OperatorSyntax, TraitSyntax, ModuleSyntax> Value;
};

struct PrivateSyntax {
    size_t Start;
    size_t End;
    ExportSyntax Export_;
};

struct SymbolSyntax {
    std::variant<PrivateSyntax, DefinitionSyntax, FunctionSyntax, OperatorSyntax, TraitSyntax, MacroSyntax, ModuleSyntax> Value;
};

struct DeclarationSyntax {
    size_t Start;
    size_t End;
    SymbolSyntax Symbol;
};

struct FileSyntax {
    size_t Start;
    size_t End;
    std::vector<PackageSyntax>* Packages;
    std::vector<UseSyntax>* Uses;
    std::vector<DeclarationSyntax>* Declarations;
};

struct ProgramSyntax {
    size_t Start;
    size_t End;
    FileSyntax File;
    std::vector<StatementSyntax>* Statements;
};

} // namespace scaly
