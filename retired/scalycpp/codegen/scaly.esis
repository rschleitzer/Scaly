?IS10744 ArcBase DSSSL
(STYLE-SHEET
AID IMPLIED
AUSE IMPLIED
(STYLE-SPECIFICATION
ACONTENT IMPLIED
(STYLE-SPECIFICATION-BODY
-(define (syntax) ($\n\n"\nclass SyntaxNode {\n    let start: Position\n    let end: Position\n    mutable parent: SyntaxNode&\n}\n"\n    (apply-to-selected-children "syntax" (lambda (syntax-node) ($\n"\nclass "(id syntax-node)" extends "(if (base syntax-node) (base syntax-node) "SyntaxNode")" {\n"       (if (abstract? syntax-node) "" ($\n"\n    constructor("(scaly-syntax-constructor-parameters syntax-node)") {\n"     (if (program? syntax-node)\n"        start = new Position(0, 0)\n        end = new Position(0, 0)\n        this.name = name\n        this.modules = modules\n        this.parent = null\n"\n            (constructor-initializers syntax-node)\n        )\n"    }\n"       ))\n"\n    function accept(mutable visitor: Visitor) {\n"       (if (abstract? syntax-node) "" ($\n            (if (has-syntax-children? syntax-node)\n                ($\n"        if !visitor.open"(id syntax-node)"(this)\n            return\n"\n                    (apply-to-children-of syntax-node (lambda (content)\n                        (case (type content)\n                            (("syntax") ($\n                                (if (abstract? syntax-node) "" ($\n                                    (if (and (optional? content) (not (multiple? content))) ($\n"        if "(property content)" != null\n"\n                                    )"")\n                                    (if (multiple? content)\n                                        ($\n"        if "(property content)" != null {\n            for node: "(link content)" in "(property content)"\n                node.accept(visitor)\n        }\n"\n                                        )\n                                        ($\n(if (optional? content) "    " "")"        "(property content)".accept(visitor)\n"\n                                        )\n                                    )\n                                ))\n                            ))\n                            (else "")\n                        )\n                    ))\n"        visitor.close"(id syntax-node)"(this)\n"\n                )\n                ($\n"        visitor.visit"(id syntax-node)"(this)\n"\n                )\n            )\n       ))\n"    }\n\n"\n        (apply-to-children-of syntax-node (lambda (content) ($\n            (if (property content) ($\n"    let "(property content)": "\n                (case (type content)\n                    (("syntax") ($ (link content)(if (multiple? content)"[]" "")))\n                    (("identifier" "operator" "prefixoperator" "binaryoperator" "postfixoperator") "string")\n                    (("literal") "Literal")\n                    (("keyword" "punctuation") "bool")\n                )\n                "\n"\n          )"")\n        )))\n"}\n"   )))\n))\n\n(define (scaly-syntax-constructor-parameters syntax-node)\n    ($\n        (apply-to-property-children-of syntax-node (lambda (content) ($\n            (scaly-property-declaration content)(if (properties-remaining? content syntax-node) ", " "")\n        )))\n        (if (program? syntax-node) "" ($ (if (node-list-empty? (properties syntax-node)) "" ", ") "start: Position, end: Position"))))\n\n(define (scaly-property-declaration content)\n    (case (type content)\n        (("syntax") ($ (property content)": "(link content)(if (multiple? content)"[]" "")))\n        (("identifier" "operator" "prefixoperator" "binaryoperator" "postfixoperator") ($ (property content)": string"))\n        (("literal") ($ (property content)": Literal"))\n        (("keyword" "punctuation") ($ (property content)": bool"))))\n\n(define (inheritors node)\n    (if (abstract? node) (node-list-union\n        (children node)\n        (apply node-list-union\n            (map inheritors\n                (node-list->list\n                    (node-list-map\n                        (lambda (content-node)\n                            (element-with-id (link content-node))\n                        )\n                        (children node)))))\n    )(empty-node-list))\n)\n\n(define (constructor-initializers syntax-node)\n    ($\n"        this.start = start\n        this.end = end\n"       (apply-to-property-children-of syntax-node (lambda (content) ($\n"        this."(property content)" = "(property content)"\n"\n)))))\n\n(define (visitor) ($\n"\nclass Visitor {"\n    (apply-to-selected-children "syntax" (lambda (syntax) (if (abstract? syntax) "" ($\n        (if (has-syntax-children? syntax)\n            ($ "\n    function open"(id syntax)"("(string-firstchar-downcase (id syntax))": "(id syntax)"): bool {\n        true\n    }\n\n    function close"(id syntax)"("(string-firstchar-downcase (id syntax))": "(id syntax)") {\n    }\n"            )\n            ($ "\n    function visit"(id syntax)"("(string-firstchar-downcase (id syntax))": "(id syntax)") {\n    }\n"            )\n        )\n    ))))\n"}\n"\n))\n\n(define (parser) ($\n        (apply-to-selected-children "syntax" (lambda (syntax-node) ($\n"class "(id syntax-node)"\n"\n        )))\n"\nclass Parser {\n    constructor(theFileName: string, text: string) {\n        lexer = new Lexer(text)\n        fileName = theFileName\n"   (apply-to-selected-children "keyword" (lambda (keyword) ($\n"        "(name keyword)" = new string(\\""(id keyword)"\\")\n"   )))\n    (apply-to-selected-children "punctuation" (lambda (punctuation) ($\n"        "(id punctuation)" = new string(\\""(value punctuation)"\\")\n"   )))\n"    }\n"\n    (apply-to-selected-children "syntax" (lambda (syntax) (if (program? syntax) "" ($\n        (if (multiple? syntax) ($\n"\n    function parse"(id syntax)"List(): "(id syntax)"[] {\n        mutable ret: "(id syntax)"[]$ = null\n        while true {\n\n            let node: "(id syntax)" = parse"(id syntax)"()\n            if node == null\n                break\n\n            if ret == null\n                ret = new "(id syntax)"[]()\n\n            ret.push(node)\n        }\n\n        return(ret)\n    }\n"       )"")\n"\n    function parse"(id syntax)"(): "(id syntax)(if (top? syntax) " throws ParserError" "")" {"\n        (if (abstract? syntax)\n            ($\n                (apply-to-children-of syntax (lambda (content) ($\n"\n        {\n            let node: "(link content)" = parse"(link content)"()\n            if node != null\n                return(node)\n        }\n"\n                )))\n"\n        null\n"\n            )\n            ($ ; non-abstract syntax\n"\n        let start: Position$ = lexer.getPreviousPosition()\n"                (apply-to-children-of syntax (lambda (content) ($\n                   (if (string=? "syntax" (type content))\n                        ($ ; non-terminals\n"\n        let "(property content)": "(link content)(if (multiple? content) "[]" "")" = parse"(link content)(if (multiple? content) "List" "")"()\n"\n                    (if (or (optional? content) (multiple? content)) "" ($\n"        if "(property content)" == null\n            return(null)\n"\n                    ))\n                           (if (top? syntax) ($\n"        if "(property content)" != null {\n            if !isAtEnd() {\n                let errorPos: Position$ = lexer.getPreviousPosition()\n                throw syntax(errorPos.line, errorPos.column)\n            }\n        }\n"                           )"")\n                        )\n                        ($ ; terminals\n"\n        let "(case (type content) (("keyword" "punctuation") ($ "success"(if (property content) (string-firstchar-upcase (property content)) ($ (string-firstchar-upcase (link content))(number->string (child-number content))))": bool"))(("literal") ($ (property content)": Literal"))(else ($ (property content)": string")))\n            " = lexer.parse"\n            (case (type content)(("prefixoperator") "PrefixOperator")(("binaryoperator") "BinaryOperator")(("postfixoperator") "PostfixOperator")(("identifier") "Identifier")(("literal") "Literal")(("keyword") "Keyword")(("punctuation") "Punctuation"))\n            "("(case (type content)(("keyword") (name-of-link content)) (("punctuation") (link content)) (else ""))")\n        if "(case (type content) (("keyword" "punctuation") ($ "success"(if (property content) (string-firstchar-upcase (property content)) ($ (string-firstchar-upcase (link content))(number->string (child-number content))))))(("identifier") ($ "("(property content)" != null) && isIdentifier("(property content)")")) (else ($ (property content)" != null")))"\n            lexer.advance()\n"                           (if (optional? content) "" ($\n"        else\n            return(null)\n"\n                           ))\n                        )\n                    ) ; syntax or terminal\n                ))) ; apply to children of syntax\n"\n        let end: Position$ = lexer.getPosition()\n\n        let ret: "(id syntax)" = new "(id syntax)"("\n                (apply-to-property-children-of syntax (lambda (content) ($\n                    (property content)(if (properties-remaining? content syntax) ", " "")\n                )))\n                (if (node-list-empty? (properties syntax)) "" ", ")\n                "new Position(start), new Position(end))\n"                (apply-to-property-children-of syntax (lambda (content)\n                    (if (multiple? content)\n                        ($\n"        if "(property content)" != null {\n            for item: "(link content)" in "(property content)"\n                item.parent = ret\n        }\n"                       )\n                        (if (string=? "syntax" (type content)) ($\n                            (if (optional? content) ($\n"        if "(property content)" != null\n    "                       )"")\n"        "(property content)".parent = ret\n"                       )"")\n                    )\n                ))\n"\n        ret\n"\n            ) ; $\n        ) ; abstract or not\n"    }\n"   ))))\n"\n    function isAtEnd(): bool {\n        lexer.isAtEnd()\n    }\n\n    function isIdentifier(id: string): bool {"\n   (apply-to-selected-children "keyword" (lambda (keyword) ($\n"\n        if id.equals("(name keyword)")\n            return(false)\n"   )))\n"\n        return(true)\n    }\n\n    mutable lexer: Lexer\n    let fileName: string\n\n"   (apply-to-selected-children "keyword" (lambda (keyword) ($\n"    let "(name keyword)": string\n"   )))\n    (apply-to-selected-children "punctuation" (lambda (punctuation) ($\n"    let "(id punctuation)": string\n"   )))\n"}\n"\n\n))\n\n(element language\n    (create-file ($ "Parser.scaly")\n        (output ($ (parser)(visitor)(syntax)))))\n\n(define (string-firstchar-upcase s)\n    (string-firstchar-case s char-upcase-ascii))\n\n(define (string-firstchar-downcase s)\n    (string-firstchar-case s char-downcase-ascii))\n\n(define (string-firstchar-case s func)\n    (list->string\n        (let ((charlist (string->list s)))\n            (cons\n                (func (car charlist))\n                (cdr charlist)))))\n\n(define (char-upcase-ascii c)\n    (case c\n        ((#\\A #\\a) #\\A) ((#\\B #\\b) #\\B)\n        ((#\\C #\\c) #\\C) ((#\\D #\\d) #\\D)\n        ((#\\E #\\e) #\\E) ((#\\F #\\f) #\\F)\n        ((#\\G #\\g) #\\G) ((#\\H #\\h) #\\H)\n        ((#\\I #\\i) #\\I) ((#\\J #\\j) #\\J)\n        ((#\\K #\\k) #\\K) ((#\\L #\\l) #\\L)\n        ((#\\M #\\m) #\\M) ((#\\N #\\n) #\\N)\n        ((#\\O #\\o) #\\O) ((#\\P #\\p) #\\P)\n        ((#\\Q #\\q) #\\Q) ((#\\R #\\r) #\\R)\n        ((#\\S #\\s) #\\S) ((#\\T #\\t) #\\T)\n        ((#\\U #\\u) #\\U) ((#\\V #\\v) #\\V)\n        ((#\\W #\\w) #\\W) ((#\\X #\\x) #\\X)\n        ((#\\Y #\\y) #\\Y) ((#\\Z #\\z) #\\Z)\n        (else c)\n    )\n)\n\n(define (char-downcase-ascii c)\n    (case c\n        ((#\\A #\\a) #\\a) ((#\\B #\\b) #\\b)\n        ((#\\C #\\c) #\\c) ((#\\D #\\d) #\\d)\n        ((#\\E #\\e) #\\e) ((#\\F #\\f) #\\f)\n        ((#\\G #\\g) #\\g) ((#\\H #\\h) #\\h)\n        ((#\\I #\\i) #\\i) ((#\\J #\\j) #\\j)\n        ((#\\K #\\k) #\\k) ((#\\L #\\l) #\\l)\n        ((#\\M #\\m) #\\m) ((#\\N #\\n) #\\n)\n        ((#\\O #\\o) #\\o) ((#\\P #\\p) #\\p)\n        ((#\\Q #\\q) #\\q) ((#\\R #\\r) #\\r)\n        ((#\\S #\\s) #\\s) ((#\\T #\\t) #\\t)\n        ((#\\U #\\u) #\\u) ((#\\V #\\v) #\\v)\n        ((#\\W #\\w) #\\w) ((#\\X #\\x) #\\x)\n        ((#\\Y #\\y) #\\y) ((#\\Z #\\z) #\\z)\n        (else c)\n    )\n)\n\n(define (create-file filename content)\n    (make entity system-id: filename content))\n\n(define (output content)\n    (make formatting-instruction data: content))\n\n(define (apply-to-nodelist nl func)\n    (apply $ (map func (node-list->list nl))))\n\n(define (apply-to-children-of node func)\n    (apply-to-nodelist (children node) func))\n\n(define (apply-to-children func)\n    (apply-to-children-of (current-node) func))\n\n(define (apply-to-selected-children-of node element func)\n    (apply-to-nodelist (select-elements (children node) element ) func))\n\n(define (apply-to-selected-children element func)\n    (apply-to-selected-children-of (current-node) element func))\n\n(define (apply-to-descendants-of node func)\n    (apply-to-nodelist (descendants node) func))\n\n(define (apply-to-descendants func)\n    (apply-to-descendants-of (current-node) func))\n\n(define (apply-to-selected-descendants-of node element func)\n    (apply-to-nodelist (select-elements (descendants node) element) func))\n\n(define (apply-to-selected-descendants element func)\n    (apply-to-selected-descendants-of (current-node) element func))\n\n(define (apply-to-property-children-of node func)\n    (apply-to-nodelist (properties node) func))\n\n(define (properties node)\n    (node-list-filter property (children node)))\n\n(define (properties-remaining? node syntax)\n    (not (node-list=? (node-list-last (properties syntax)) node)))\n\n(define $ string-append)\n\n(define (link node)\n    (attribute-string "link" node))\n\n(define (value node)\n    (attribute-string "value" node))\n\n(define (abstract? node)\n    (string=? "abstract" (attribute-string "abstract" node)))\n\n(define (multiple? node)\n    (string=? "multiple" (attribute-string "multiple" node)))\n\n(define (optional? node)\n    (string=? "optional" (attribute-string "optional" node)))\n\n(define (syntax? node)\n    (string=? "syntax" (type node)))\n\n(define (identifier? node)\n    (string=? "identifier" (type node)))\n\n(define (top? node)\n    (string=? "top" (attribute-string "top" node)))\n\n(define (program? node)\n    (string=? "program" (attribute-string "program" node)))\n\n(define (property node)\n    (attribute-string "property" node))\n\n(define (base node)\n    (attribute-string "base" node))\n\n(define (name node)\n    (if (string=? "keyword" (gi node))\n        ($ (id node) "Keyword")\n        (attribute-string "name" node)))\n\n(define (name-of-link node)\n    (name (element-with-id (attribute-string "link" node))))\n\n(define (type node)\n    (if (attribute-string "link" node)\n        (gi (element-with-id (attribute-string "link" node)))\n        (attribute-string "type" node)))\n\n(define (has-syntax-children? node)\n    (not (node-list-empty?\n        (node-list-filter (lambda (snl) (and (syntax? snl) (string=? "syntax" (gi (element-with-id (attribute-string "link" snl))))))\n            (children node)))))\n(declare-flow-object-class element\n  "UNREGISTERED::James Clark//Flow Object Class::element")\n\n(declare-flow-object-class empty-element\n  "UNREGISTERED::James Clark//Flow Object Class::empty-element")\n\n(declare-flow-object-class document-type\n  "UNREGISTERED::James Clark//Flow Object Class::document-type")\n\n(declare-flow-object-class processing-instruction\n  "UNREGISTERED::James Clark//Flow Object Class::processing-instruction")\n\n(declare-flow-object-class entity\n  "UNREGISTERED::James Clark//Flow Object Class::entity")\n\n(declare-flow-object-class entity-ref\n  "UNREGISTERED::James Clark//Flow Object Class::entity-ref")\n\n(declare-flow-object-class formatting-instruction\n  "UNREGISTERED::James Clark//Flow Object Class::formatting-instruction")\n\n(declare-characteristic preserve-sdata?\n  "UNREGISTERED::James Clark//Characteristic::preserve-sdata?"\n  #f)\n\n(define debug\n    (external-procedure "UNREGISTERED::James Clark//Procedure::debug"))\n
)STYLE-SPECIFICATION-BODY
)STYLE-SPECIFICATION
)STYLE-SHEET
C
