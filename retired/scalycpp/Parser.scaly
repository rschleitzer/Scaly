class Program
class Module
class Statement
class Declaration
class ConstantDeclaration
class MutableDeclaration
class BindingInitializer
class IdentifierInitializer
class Initializer
class AdditionalInitializer
class Pattern
class IdentifierPattern
class TypeAnnotation
class Type
class TypePostfix
class IndexedType
class Pointer
class LifeTime
class Root
class Local
class Reference
class Thrown
class FunctionDeclaration
class Modifier
class StaticWord
class FunctionSignature
class ParameterClause
class Parameter
class ConstParameter
class VarParameter
class FunctionResult
class ThrowsClause
class EnumDeclaration
class EnumMember
class EnumCase
class AdditionalCase
class ClassDeclaration
class TypeInheritanceClause
class Inheritance
class ClassBody
class ClassMember
class ConstructorDeclaration
class Expression
class CodeBlock
class SimpleExpression
class PrefixExpression
class PostfixExpression
class PrimaryExpression
class IdentifierExpression
class LiteralExpression
class IfExpression
class ElseClause
class SwitchExpression
class SwitchBody
class CurliedSwitchBody
class NakedSwitchBody
class SwitchCase
class CaseLabel
class ItemCaseLabel
class DefaultCaseLabel
class CaseItem
class CaseContent
class ForExpression
class WhileExpression
class DoExpression
class ParenthesizedExpression
class ExpressionElement
class ReturnExpression
class ThrowExpression
class BreakExpression
class ConstructorCall
class ThisExpression
class NullExpression
class Postfix
class OperatorPostfix
class FunctionCall
class CatchClause
class CatchPattern
class WildCardCatchPattern
class IdentifierCatchPattern
class WildcardPattern
class TuplePattern
class TuplePatternElement
class ExpressionPattern
class MemberExpression
class Subscript
class BinaryExpression
class BinaryOperation
class Assignment
class TypeQuery
class TypeCast

class Parser {
    constructor(theFileName: string, text: string) {
        lexer = new Lexer(text)
        fileName = theFileName
        classKeyword = new string("class")
        functionKeyword = new string("function")
        ifKeyword = new string("if")
        elseKeyword = new string("else")
        switchKeyword = new string("switch")
        caseKeyword = new string("case")
        defaultKeyword = new string("default")
        catchKeyword = new string("catch")
        forKeyword = new string("for")
        inKeyword = new string("in")
        whileKeyword = new string("while")
        doKeyword = new string("do")
        returnKeyword = new string("return")
        throwKeyword = new string("throw")
        breakKeyword = new string("break")
        throwsKeyword = new string("throws")
        staticKeyword = new string("static")
        letKeyword = new string("let")
        mutableKeyword = new string("mutable")
        isKeyword = new string("is")
        asKeyword = new string("as")
        constructorKeyword = new string("constructor")
        enumKeyword = new string("enum")
        thisKeyword = new string("this")
        nullKeyword = new string("null")
        newKeyword = new string("new")
        extendsKeyword = new string("extends")
        equal = new string("=")
        comma = new string(",")
        leftParen = new string("(")
        rightParen = new string(")")
        leftCurly = new string("{")
        rightCurly = new string("}")
        leftBracket = new string("[")
        rightBracket = new string("]")
        colon = new string(":")
        dot = new string(".")
        underscore = new string("_")
        circumflex = new string("^")
        dollar = new string("$")
        at = new string("@")
        hash = new string("#")
        ampersand = new string("&")
    }

    function parseModule(): Module throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()

        let statements: Statement[] = parseStatementList()
        if statements != null {
            if !isAtEnd() {
                let errorPos: Position$ = lexer.getPreviousPosition()
                throw syntax(errorPos.line, errorPos.column)
            }
        }

        let end: Position$ = lexer.getPosition()

        let ret: Module = new Module(statements, new Position(start), new Position(end))
        if statements != null {
            for item: Statement in statements
                item.parent = ret
        }

        ret
    }

    function parseStatementList(): Statement[] {
        mutable ret: Statement[]$ = null
        while true {

            let node: Statement = parseStatement()
            if node == null
                break

            if ret == null
                ret = new Statement[]()

            ret.push(node)
        }

        return(ret)
    }

    function parseStatement(): Statement {
        {
            let node: Declaration = parseDeclaration()
            if node != null
                return(node)
        }

        {
            let node: Expression = parseExpression()
            if node != null
                return(node)
        }

        null
    }

    function parseDeclaration(): Declaration {
        {
            let node: ConstantDeclaration = parseConstantDeclaration()
            if node != null
                return(node)
        }

        {
            let node: MutableDeclaration = parseMutableDeclaration()
            if node != null
                return(node)
        }

        {
            let node: FunctionDeclaration = parseFunctionDeclaration()
            if node != null
                return(node)
        }

        {
            let node: EnumDeclaration = parseEnumDeclaration()
            if node != null
                return(node)
        }

        {
            let node: ClassDeclaration = parseClassDeclaration()
            if node != null
                return(node)
        }

        {
            let node: ConstructorDeclaration = parseConstructorDeclaration()
            if node != null
                return(node)
        }

        null
    }

    function parseConstantDeclaration(): ConstantDeclaration {
        let start: Position$ = lexer.getPreviousPosition()

        let successLet1: bool = lexer.parseKeyword(letKeyword)
        if successLet1
            lexer.advance()
        else
            return(null)

        let initializer: BindingInitializer = parseBindingInitializer()
        if initializer == null
            return(null)

        let end: Position$ = lexer.getPosition()

        let ret: ConstantDeclaration = new ConstantDeclaration(initializer, new Position(start), new Position(end))
        initializer.parent = ret

        ret
    }

    function parseMutableDeclaration(): MutableDeclaration {
        let start: Position$ = lexer.getPreviousPosition()

        let successMutable1: bool = lexer.parseKeyword(mutableKeyword)
        if successMutable1
            lexer.advance()
        else
            return(null)

        let initializer: BindingInitializer = parseBindingInitializer()
        if initializer == null
            return(null)

        let end: Position$ = lexer.getPosition()

        let ret: MutableDeclaration = new MutableDeclaration(initializer, new Position(start), new Position(end))
        initializer.parent = ret

        ret
    }

    function parseBindingInitializer(): BindingInitializer {
        let start: Position$ = lexer.getPreviousPosition()

        let initializer: IdentifierInitializer = parseIdentifierInitializer()
        if initializer == null
            return(null)

        let additionalInitializers: AdditionalInitializer[] = parseAdditionalInitializerList()

        let end: Position$ = lexer.getPosition()

        let ret: BindingInitializer = new BindingInitializer(initializer, additionalInitializers, new Position(start), new Position(end))
        initializer.parent = ret
        if additionalInitializers != null {
            for item: AdditionalInitializer in additionalInitializers
                item.parent = ret
        }

        ret
    }

    function parseIdentifierInitializerList(): IdentifierInitializer[] {
        mutable ret: IdentifierInitializer[]$ = null
        while true {

            let node: IdentifierInitializer = parseIdentifierInitializer()
            if node == null
                break

            if ret == null
                ret = new IdentifierInitializer[]()

            ret.push(node)
        }

        return(ret)
    }

    function parseIdentifierInitializer(): IdentifierInitializer {
        let start: Position$ = lexer.getPreviousPosition()

        let pattern: IdentifierPattern = parseIdentifierPattern()
        if pattern == null
            return(null)

        let initializer: Initializer = parseInitializer()

        let end: Position$ = lexer.getPosition()

        let ret: IdentifierInitializer = new IdentifierInitializer(pattern, initializer, new Position(start), new Position(end))
        pattern.parent = ret
        if initializer != null
            initializer.parent = ret

        ret
    }

    function parseInitializer(): Initializer {
        let start: Position$ = lexer.getPreviousPosition()

        let successEqual1: bool = lexer.parsePunctuation(equal)
        if successEqual1
            lexer.advance()
        else
            return(null)

        let expression: Expression = parseExpression()
        if expression == null
            return(null)

        let end: Position$ = lexer.getPosition()

        let ret: Initializer = new Initializer(expression, new Position(start), new Position(end))
        expression.parent = ret

        ret
    }

    function parseAdditionalInitializerList(): AdditionalInitializer[] {
        mutable ret: AdditionalInitializer[]$ = null
        while true {

            let node: AdditionalInitializer = parseAdditionalInitializer()
            if node == null
                break

            if ret == null
                ret = new AdditionalInitializer[]()

            ret.push(node)
        }

        return(ret)
    }

    function parseAdditionalInitializer(): AdditionalInitializer {
        let start: Position$ = lexer.getPreviousPosition()

        let successComma1: bool = lexer.parsePunctuation(comma)
        if successComma1
            lexer.advance()
        else
            return(null)

        let pattern: IdentifierInitializer = parseIdentifierInitializer()
        if pattern == null
            return(null)

        let end: Position$ = lexer.getPosition()

        let ret: AdditionalInitializer = new AdditionalInitializer(pattern, new Position(start), new Position(end))
        pattern.parent = ret

        ret
    }

    function parsePattern(): Pattern {
        {
            let node: WildcardPattern = parseWildcardPattern()
            if node != null
                return(node)
        }

        {
            let node: IdentifierPattern = parseIdentifierPattern()
            if node != null
                return(node)
        }

        {
            let node: TuplePattern = parseTuplePattern()
            if node != null
                return(node)
        }

        {
            let node: ExpressionPattern = parseExpressionPattern()
            if node != null
                return(node)
        }

        null
    }

    function parseIdentifierPattern(): IdentifierPattern {
        let start: Position$ = lexer.getPreviousPosition()

        let identifier: string = lexer.parseIdentifier()
        if (identifier != null) && isIdentifier(identifier)
            lexer.advance()
        else
            return(null)

        let annotationForType: TypeAnnotation = parseTypeAnnotation()

        let end: Position$ = lexer.getPosition()

        let ret: IdentifierPattern = new IdentifierPattern(identifier, annotationForType, new Position(start), new Position(end))
        if annotationForType != null
            annotationForType.parent = ret

        ret
    }

    function parseTypeAnnotation(): TypeAnnotation {
        let start: Position$ = lexer.getPreviousPosition()

        let successColon1: bool = lexer.parsePunctuation(colon)
        if successColon1
            lexer.advance()
        else
            return(null)

        let annotationForType: Type = parseType()
        if annotationForType == null
            return(null)

        let end: Position$ = lexer.getPosition()

        let ret: TypeAnnotation = new TypeAnnotation(annotationForType, new Position(start), new Position(end))
        annotationForType.parent = ret

        ret
    }

    function parseType(): Type {
        let start: Position$ = lexer.getPreviousPosition()

        let name: string = lexer.parseIdentifier()
        if (name != null) && isIdentifier(name)
            lexer.advance()
        else
            return(null)

        let postfixes: TypePostfix[] = parseTypePostfixList()

        let lifeTime: LifeTime = parseLifeTime()

        let end: Position$ = lexer.getPosition()

        let ret: Type = new Type(name, postfixes, lifeTime, new Position(start), new Position(end))
        if postfixes != null {
            for item: TypePostfix in postfixes
                item.parent = ret
        }
        if lifeTime != null
            lifeTime.parent = ret

        ret
    }

    function parseTypePostfixList(): TypePostfix[] {
        mutable ret: TypePostfix[]$ = null
        while true {

            let node: TypePostfix = parseTypePostfix()
            if node == null
                break

            if ret == null
                ret = new TypePostfix[]()

            ret.push(node)
        }

        return(ret)
    }

    function parseTypePostfix(): TypePostfix {
        {
            let node: IndexedType = parseIndexedType()
            if node != null
                return(node)
        }

        {
            let node: Pointer = parsePointer()
            if node != null
                return(node)
        }

        null
    }

    function parseIndexedType(): IndexedType {
        let start: Position$ = lexer.getPreviousPosition()

        let successLeftBracket1: bool = lexer.parsePunctuation(leftBracket)
        if successLeftBracket1
            lexer.advance()
        else
            return(null)

        let key: Type = parseType()

        let successRightBracket3: bool = lexer.parsePunctuation(rightBracket)
        if successRightBracket3
            lexer.advance()
        else
            return(null)

        let end: Position$ = lexer.getPosition()

        let ret: IndexedType = new IndexedType(key, new Position(start), new Position(end))
        if key != null
            key.parent = ret

        ret
    }

    function parsePointer(): Pointer {
        let start: Position$ = lexer.getPreviousPosition()

        let successCircumflex1: bool = lexer.parsePunctuation(circumflex)
        if successCircumflex1
            lexer.advance()
        else
            return(null)

        let end: Position$ = lexer.getPosition()

        let ret: Pointer = new Pointer(new Position(start), new Position(end))

        ret
    }

    function parseLifeTime(): LifeTime {
        {
            let node: Root = parseRoot()
            if node != null
                return(node)
        }

        {
            let node: Local = parseLocal()
            if node != null
                return(node)
        }

        {
            let node: Reference = parseReference()
            if node != null
                return(node)
        }

        {
            let node: Thrown = parseThrown()
            if node != null
                return(node)
        }

        null
    }

    function parseRoot(): Root {
        let start: Position$ = lexer.getPreviousPosition()

        let successDollar1: bool = lexer.parsePunctuation(dollar)
        if successDollar1
            lexer.advance()
        else
            return(null)

        let end: Position$ = lexer.getPosition()

        let ret: Root = new Root(new Position(start), new Position(end))

        ret
    }

    function parseLocal(): Local {
        let start: Position$ = lexer.getPreviousPosition()

        let successAt1: bool = lexer.parsePunctuation(at)
        if successAt1
            lexer.advance()
        else
            return(null)

        let location: string = lexer.parseIdentifier()
        if (location != null) && isIdentifier(location)
            lexer.advance()
        else
            return(null)

        let end: Position$ = lexer.getPosition()

        let ret: Local = new Local(location, new Position(start), new Position(end))

        ret
    }

    function parseReference(): Reference {
        let start: Position$ = lexer.getPreviousPosition()

        let successAmpersand1: bool = lexer.parsePunctuation(ampersand)
        if successAmpersand1
            lexer.advance()
        else
            return(null)

        let age: Literal = lexer.parseLiteral()
        if age != null
            lexer.advance()

        let end: Position$ = lexer.getPosition()

        let ret: Reference = new Reference(age, new Position(start), new Position(end))

        ret
    }

    function parseThrown(): Thrown {
        let start: Position$ = lexer.getPreviousPosition()

        let successHash1: bool = lexer.parsePunctuation(hash)
        if successHash1
            lexer.advance()
        else
            return(null)

        let end: Position$ = lexer.getPosition()

        let ret: Thrown = new Thrown(new Position(start), new Position(end))

        ret
    }

    function parseFunctionDeclaration(): FunctionDeclaration {
        let start: Position$ = lexer.getPreviousPosition()

        let modifiers: Modifier[] = parseModifierList()

        let successFunction2: bool = lexer.parseKeyword(functionKeyword)
        if successFunction2
            lexer.advance()
        else
            return(null)

        let name: string = lexer.parseIdentifier()
        if (name != null) && isIdentifier(name)
            lexer.advance()
        else
            return(null)

        let signature: FunctionSignature = parseFunctionSignature()
        if signature == null
            return(null)

        let body: Expression = parseExpression()

        let end: Position$ = lexer.getPosition()

        let ret: FunctionDeclaration = new FunctionDeclaration(modifiers, name, signature, body, new Position(start), new Position(end))
        if modifiers != null {
            for item: Modifier in modifiers
                item.parent = ret
        }
        signature.parent = ret
        if body != null
            body.parent = ret

        ret
    }

    function parseModifierList(): Modifier[] {
        mutable ret: Modifier[]$ = null
        while true {

            let node: Modifier = parseModifier()
            if node == null
                break

            if ret == null
                ret = new Modifier[]()

            ret.push(node)
        }

        return(ret)
    }

    function parseModifier(): Modifier {
        {
            let node: StaticWord = parseStaticWord()
            if node != null
                return(node)
        }

        null
    }

    function parseStaticWord(): StaticWord {
        let start: Position$ = lexer.getPreviousPosition()

        let successStatic1: bool = lexer.parseKeyword(staticKeyword)
        if successStatic1
            lexer.advance()
        else
            return(null)

        let end: Position$ = lexer.getPosition()

        let ret: StaticWord = new StaticWord(new Position(start), new Position(end))

        ret
    }

    function parseFunctionSignature(): FunctionSignature {
        let start: Position$ = lexer.getPreviousPosition()

        let parameterClause: ParameterClause = parseParameterClause()
        if parameterClause == null
            return(null)

        let result: FunctionResult = parseFunctionResult()

        let throwsClause: ThrowsClause = parseThrowsClause()

        let end: Position$ = lexer.getPosition()

        let ret: FunctionSignature = new FunctionSignature(parameterClause, result, throwsClause, new Position(start), new Position(end))
        parameterClause.parent = ret
        if result != null
            result.parent = ret
        if throwsClause != null
            throwsClause.parent = ret

        ret
    }

    function parseParameterClauseList(): ParameterClause[] {
        mutable ret: ParameterClause[]$ = null
        while true {

            let node: ParameterClause = parseParameterClause()
            if node == null
                break

            if ret == null
                ret = new ParameterClause[]()

            ret.push(node)
        }

        return(ret)
    }

    function parseParameterClause(): ParameterClause {
        let start: Position$ = lexer.getPreviousPosition()

        let successLeftParen1: bool = lexer.parsePunctuation(leftParen)
        if successLeftParen1
            lexer.advance()
        else
            return(null)

        let parameters: Parameter[] = parseParameterList()

        let successRightParen3: bool = lexer.parsePunctuation(rightParen)
        if successRightParen3
            lexer.advance()
        else
            return(null)

        let end: Position$ = lexer.getPosition()

        let ret: ParameterClause = new ParameterClause(parameters, new Position(start), new Position(end))
        if parameters != null {
            for item: Parameter in parameters
                item.parent = ret
        }

        ret
    }

    function parseParameterList(): Parameter[] {
        mutable ret: Parameter[]$ = null
        while true {

            let node: Parameter = parseParameter()
            if node == null
                break

            if ret == null
                ret = new Parameter[]()

            ret.push(node)
        }

        return(ret)
    }

    function parseParameter(): Parameter {
        {
            let node: ConstParameter = parseConstParameter()
            if node != null
                return(node)
        }

        {
            let node: VarParameter = parseVarParameter()
            if node != null
                return(node)
        }

        null
    }

    function parseConstParameter(): ConstParameter {
        let start: Position$ = lexer.getPreviousPosition()

        let successLet1: bool = lexer.parseKeyword(letKeyword)
        if successLet1
            lexer.advance()

        let name: string = lexer.parseIdentifier()
        if (name != null) && isIdentifier(name)
            lexer.advance()
        else
            return(null)

        let successColon3: bool = lexer.parsePunctuation(colon)
        if successColon3
            lexer.advance()
        else
            return(null)

        let parameterType: Type = parseType()
        if parameterType == null
            return(null)

        let successComma5: bool = lexer.parsePunctuation(comma)
        if successComma5
            lexer.advance()

        let end: Position$ = lexer.getPosition()

        let ret: ConstParameter = new ConstParameter(name, parameterType, new Position(start), new Position(end))
        parameterType.parent = ret

        ret
    }

    function parseVarParameter(): VarParameter {
        let start: Position$ = lexer.getPreviousPosition()

        let successMutable1: bool = lexer.parseKeyword(mutableKeyword)
        if successMutable1
            lexer.advance()
        else
            return(null)

        let name: string = lexer.parseIdentifier()
        if (name != null) && isIdentifier(name)
            lexer.advance()
        else
            return(null)

        let successColon3: bool = lexer.parsePunctuation(colon)
        if successColon3
            lexer.advance()
        else
            return(null)

        let parameterType: Type = parseType()
        if parameterType == null
            return(null)

        let successComma5: bool = lexer.parsePunctuation(comma)
        if successComma5
            lexer.advance()

        let end: Position$ = lexer.getPosition()

        let ret: VarParameter = new VarParameter(name, parameterType, new Position(start), new Position(end))
        parameterType.parent = ret

        ret
    }

    function parseFunctionResult(): FunctionResult {
        let start: Position$ = lexer.getPreviousPosition()

        let successColon1: bool = lexer.parsePunctuation(colon)
        if successColon1
            lexer.advance()
        else
            return(null)

        let resultType: Type = parseType()
        if resultType == null
            return(null)

        let end: Position$ = lexer.getPosition()

        let ret: FunctionResult = new FunctionResult(resultType, new Position(start), new Position(end))
        resultType.parent = ret

        ret
    }

    function parseThrowsClause(): ThrowsClause {
        let start: Position$ = lexer.getPreviousPosition()

        let successThrows1: bool = lexer.parseKeyword(throwsKeyword)
        if successThrows1
            lexer.advance()
        else
            return(null)

        let throwsType: Type = parseType()
        if throwsType == null
            return(null)

        let end: Position$ = lexer.getPosition()

        let ret: ThrowsClause = new ThrowsClause(throwsType, new Position(start), new Position(end))
        throwsType.parent = ret

        ret
    }

    function parseEnumDeclaration(): EnumDeclaration {
        let start: Position$ = lexer.getPreviousPosition()

        let successEnum1: bool = lexer.parseKeyword(enumKeyword)
        if successEnum1
            lexer.advance()
        else
            return(null)

        let name: string = lexer.parseIdentifier()
        if (name != null) && isIdentifier(name)
            lexer.advance()
        else
            return(null)

        let successLeftCurly3: bool = lexer.parsePunctuation(leftCurly)
        if successLeftCurly3
            lexer.advance()
        else
            return(null)

        let members: EnumMember[] = parseEnumMemberList()

        let successRightCurly5: bool = lexer.parsePunctuation(rightCurly)
        if successRightCurly5
            lexer.advance()
        else
            return(null)

        let end: Position$ = lexer.getPosition()

        let ret: EnumDeclaration = new EnumDeclaration(name, members, new Position(start), new Position(end))
        if members != null {
            for item: EnumMember in members
                item.parent = ret
        }

        ret
    }

    function parseEnumMemberList(): EnumMember[] {
        mutable ret: EnumMember[]$ = null
        while true {

            let node: EnumMember = parseEnumMember()
            if node == null
                break

            if ret == null
                ret = new EnumMember[]()

            ret.push(node)
        }

        return(ret)
    }

    function parseEnumMember(): EnumMember {
        let start: Position$ = lexer.getPreviousPosition()

        let successCase1: bool = lexer.parseKeyword(caseKeyword)
        if successCase1
            lexer.advance()
        else
            return(null)

        let enumCase: EnumCase = parseEnumCase()
        if enumCase == null
            return(null)

        let additionalCases: AdditionalCase[] = parseAdditionalCaseList()

        let parameterClause: ParameterClause = parseParameterClause()

        let end: Position$ = lexer.getPosition()

        let ret: EnumMember = new EnumMember(enumCase, additionalCases, parameterClause, new Position(start), new Position(end))
        enumCase.parent = ret
        if additionalCases != null {
            for item: AdditionalCase in additionalCases
                item.parent = ret
        }
        if parameterClause != null
            parameterClause.parent = ret

        ret
    }

    function parseEnumCase(): EnumCase {
        let start: Position$ = lexer.getPreviousPosition()

        let name: string = lexer.parseIdentifier()
        if (name != null) && isIdentifier(name)
            lexer.advance()
        else
            return(null)

        let end: Position$ = lexer.getPosition()

        let ret: EnumCase = new EnumCase(name, new Position(start), new Position(end))

        ret
    }

    function parseAdditionalCaseList(): AdditionalCase[] {
        mutable ret: AdditionalCase[]$ = null
        while true {

            let node: AdditionalCase = parseAdditionalCase()
            if node == null
                break

            if ret == null
                ret = new AdditionalCase[]()

            ret.push(node)
        }

        return(ret)
    }

    function parseAdditionalCase(): AdditionalCase {
        let start: Position$ = lexer.getPreviousPosition()

        let successComma1: bool = lexer.parsePunctuation(comma)
        if successComma1
            lexer.advance()
        else
            return(null)

        let enumCase: EnumCase = parseEnumCase()
        if enumCase == null
            return(null)

        let end: Position$ = lexer.getPosition()

        let ret: AdditionalCase = new AdditionalCase(enumCase, new Position(start), new Position(end))
        enumCase.parent = ret

        ret
    }

    function parseClassDeclaration(): ClassDeclaration {
        let start: Position$ = lexer.getPreviousPosition()

        let successClass1: bool = lexer.parseKeyword(classKeyword)
        if successClass1
            lexer.advance()
        else
            return(null)

        let name: string = lexer.parseIdentifier()
        if (name != null) && isIdentifier(name)
            lexer.advance()
        else
            return(null)

        let typeInheritanceClause: TypeInheritanceClause = parseTypeInheritanceClause()

        let body: ClassBody = parseClassBody()

        let end: Position$ = lexer.getPosition()

        let ret: ClassDeclaration = new ClassDeclaration(name, typeInheritanceClause, body, new Position(start), new Position(end))
        if typeInheritanceClause != null
            typeInheritanceClause.parent = ret
        if body != null
            body.parent = ret

        ret
    }

    function parseTypeInheritanceClause(): TypeInheritanceClause {
        let start: Position$ = lexer.getPreviousPosition()

        let successExtends1: bool = lexer.parseKeyword(extendsKeyword)
        if successExtends1
            lexer.advance()
        else
            return(null)

        let inheritances: Inheritance[] = parseInheritanceList()

        let end: Position$ = lexer.getPosition()

        let ret: TypeInheritanceClause = new TypeInheritanceClause(inheritances, new Position(start), new Position(end))
        if inheritances != null {
            for item: Inheritance in inheritances
                item.parent = ret
        }

        ret
    }

    function parseInheritanceList(): Inheritance[] {
        mutable ret: Inheritance[]$ = null
        while true {

            let node: Inheritance = parseInheritance()
            if node == null
                break

            if ret == null
                ret = new Inheritance[]()

            ret.push(node)
        }

        return(ret)
    }

    function parseInheritance(): Inheritance {
        let start: Position$ = lexer.getPreviousPosition()

        let type: Type = parseType()
        if type == null
            return(null)

        let successComma2: bool = lexer.parsePunctuation(comma)
        if successComma2
            lexer.advance()

        let end: Position$ = lexer.getPosition()

        let ret: Inheritance = new Inheritance(type, new Position(start), new Position(end))
        type.parent = ret

        ret
    }

    function parseClassBody(): ClassBody {
        let start: Position$ = lexer.getPreviousPosition()

        let successLeftCurly1: bool = lexer.parsePunctuation(leftCurly)
        if successLeftCurly1
            lexer.advance()
        else
            return(null)

        let members: ClassMember[] = parseClassMemberList()

        let successRightCurly3: bool = lexer.parsePunctuation(rightCurly)
        if successRightCurly3
            lexer.advance()
        else
            return(null)

        let end: Position$ = lexer.getPosition()

        let ret: ClassBody = new ClassBody(members, new Position(start), new Position(end))
        if members != null {
            for item: ClassMember in members
                item.parent = ret
        }

        ret
    }

    function parseClassMemberList(): ClassMember[] {
        mutable ret: ClassMember[]$ = null
        while true {

            let node: ClassMember = parseClassMember()
            if node == null
                break

            if ret == null
                ret = new ClassMember[]()

            ret.push(node)
        }

        return(ret)
    }

    function parseClassMember(): ClassMember {
        let start: Position$ = lexer.getPreviousPosition()

        let declaration: Declaration = parseDeclaration()
        if declaration == null
            return(null)

        let end: Position$ = lexer.getPosition()

        let ret: ClassMember = new ClassMember(declaration, new Position(start), new Position(end))
        declaration.parent = ret

        ret
    }

    function parseConstructorDeclaration(): ConstructorDeclaration {
        let start: Position$ = lexer.getPreviousPosition()

        let successConstructor1: bool = lexer.parseKeyword(constructorKeyword)
        if successConstructor1
            lexer.advance()
        else
            return(null)

        let parameterClause: ParameterClause = parseParameterClause()
        if parameterClause == null
            return(null)

        let body: Expression = parseExpression()
        if body == null
            return(null)

        let end: Position$ = lexer.getPosition()

        let ret: ConstructorDeclaration = new ConstructorDeclaration(parameterClause, body, new Position(start), new Position(end))
        parameterClause.parent = ret
        body.parent = ret

        ret
    }

    function parseExpression(): Expression {
        {
            let node: CodeBlock = parseCodeBlock()
            if node != null
                return(node)
        }

        {
            let node: SimpleExpression = parseSimpleExpression()
            if node != null
                return(node)
        }

        null
    }

    function parseCodeBlock(): CodeBlock {
        let start: Position$ = lexer.getPreviousPosition()

        let successLeftCurly1: bool = lexer.parsePunctuation(leftCurly)
        if successLeftCurly1
            lexer.advance()
        else
            return(null)

        let statements: Statement[] = parseStatementList()

        let successRightCurly3: bool = lexer.parsePunctuation(rightCurly)
        if successRightCurly3
            lexer.advance()
        else
            return(null)

        let end: Position$ = lexer.getPosition()

        let ret: CodeBlock = new CodeBlock(statements, new Position(start), new Position(end))
        if statements != null {
            for item: Statement in statements
                item.parent = ret
        }

        ret
    }

    function parseSimpleExpression(): SimpleExpression {
        let start: Position$ = lexer.getPreviousPosition()

        let prefixExpression: PrefixExpression = parsePrefixExpression()
        if prefixExpression == null
            return(null)

        let binaryExpressions: BinaryExpression[] = parseBinaryExpressionList()

        let end: Position$ = lexer.getPosition()

        let ret: SimpleExpression = new SimpleExpression(prefixExpression, binaryExpressions, new Position(start), new Position(end))
        prefixExpression.parent = ret
        if binaryExpressions != null {
            for item: BinaryExpression in binaryExpressions
                item.parent = ret
        }

        ret
    }

    function parsePrefixExpression(): PrefixExpression {
        let start: Position$ = lexer.getPreviousPosition()

        let prefixOperator: string = lexer.parsePrefixOperator()
        if prefixOperator != null
            lexer.advance()

        let expression: PostfixExpression = parsePostfixExpression()
        if expression == null
            return(null)

        let end: Position$ = lexer.getPosition()

        let ret: PrefixExpression = new PrefixExpression(prefixOperator, expression, new Position(start), new Position(end))
        expression.parent = ret

        ret
    }

    function parsePostfixExpression(): PostfixExpression {
        let start: Position$ = lexer.getPreviousPosition()

        let primaryExpression: PrimaryExpression = parsePrimaryExpression()
        if primaryExpression == null
            return(null)

        let postfixes: Postfix[] = parsePostfixList()

        let end: Position$ = lexer.getPosition()

        let ret: PostfixExpression = new PostfixExpression(primaryExpression, postfixes, new Position(start), new Position(end))
        primaryExpression.parent = ret
        if postfixes != null {
            for item: Postfix in postfixes
                item.parent = ret
        }

        ret
    }

    function parsePrimaryExpression(): PrimaryExpression {
        {
            let node: IdentifierExpression = parseIdentifierExpression()
            if node != null
                return(node)
        }

        {
            let node: LiteralExpression = parseLiteralExpression()
            if node != null
                return(node)
        }

        {
            let node: IfExpression = parseIfExpression()
            if node != null
                return(node)
        }

        {
            let node: SwitchExpression = parseSwitchExpression()
            if node != null
                return(node)
        }

        {
            let node: ForExpression = parseForExpression()
            if node != null
                return(node)
        }

        {
            let node: WhileExpression = parseWhileExpression()
            if node != null
                return(node)
        }

        {
            let node: DoExpression = parseDoExpression()
            if node != null
                return(node)
        }

        {
            let node: ParenthesizedExpression = parseParenthesizedExpression()
            if node != null
                return(node)
        }

        {
            let node: ReturnExpression = parseReturnExpression()
            if node != null
                return(node)
        }

        {
            let node: ThrowExpression = parseThrowExpression()
            if node != null
                return(node)
        }

        {
            let node: BreakExpression = parseBreakExpression()
            if node != null
                return(node)
        }

        {
            let node: ConstructorCall = parseConstructorCall()
            if node != null
                return(node)
        }

        {
            let node: ThisExpression = parseThisExpression()
            if node != null
                return(node)
        }

        {
            let node: NullExpression = parseNullExpression()
            if node != null
                return(node)
        }

        null
    }

    function parseIdentifierExpression(): IdentifierExpression {
        let start: Position$ = lexer.getPreviousPosition()

        let name: string = lexer.parseIdentifier()
        if (name != null) && isIdentifier(name)
            lexer.advance()
        else
            return(null)

        let end: Position$ = lexer.getPosition()

        let ret: IdentifierExpression = new IdentifierExpression(name, new Position(start), new Position(end))

        ret
    }

    function parseLiteralExpression(): LiteralExpression {
        let start: Position$ = lexer.getPreviousPosition()

        let literal: Literal = lexer.parseLiteral()
        if literal != null
            lexer.advance()
        else
            return(null)

        let end: Position$ = lexer.getPosition()

        let ret: LiteralExpression = new LiteralExpression(literal, new Position(start), new Position(end))

        ret
    }

    function parseIfExpression(): IfExpression {
        let start: Position$ = lexer.getPreviousPosition()

        let successIf1: bool = lexer.parseKeyword(ifKeyword)
        if successIf1
            lexer.advance()
        else
            return(null)

        let condition: Expression = parseExpression()
        if condition == null
            return(null)

        let consequent: Expression = parseExpression()
        if consequent == null
            return(null)

        let elseClause: ElseClause = parseElseClause()

        let end: Position$ = lexer.getPosition()

        let ret: IfExpression = new IfExpression(condition, consequent, elseClause, new Position(start), new Position(end))
        condition.parent = ret
        consequent.parent = ret
        if elseClause != null
            elseClause.parent = ret

        ret
    }

    function parseElseClause(): ElseClause {
        let start: Position$ = lexer.getPreviousPosition()

        let successElse1: bool = lexer.parseKeyword(elseKeyword)
        if successElse1
            lexer.advance()
        else
            return(null)

        let alternative: Expression = parseExpression()
        if alternative == null
            return(null)

        let end: Position$ = lexer.getPosition()

        let ret: ElseClause = new ElseClause(alternative, new Position(start), new Position(end))
        alternative.parent = ret

        ret
    }

    function parseSwitchExpression(): SwitchExpression {
        let start: Position$ = lexer.getPreviousPosition()

        let successSwitch1: bool = lexer.parseKeyword(switchKeyword)
        if successSwitch1
            lexer.advance()
        else
            return(null)

        let expression: Expression = parseExpression()
        if expression == null
            return(null)

        let body: SwitchBody = parseSwitchBody()
        if body == null
            return(null)

        let end: Position$ = lexer.getPosition()

        let ret: SwitchExpression = new SwitchExpression(expression, body, new Position(start), new Position(end))
        expression.parent = ret
        body.parent = ret

        ret
    }

    function parseSwitchBody(): SwitchBody {
        {
            let node: CurliedSwitchBody = parseCurliedSwitchBody()
            if node != null
                return(node)
        }

        {
            let node: NakedSwitchBody = parseNakedSwitchBody()
            if node != null
                return(node)
        }

        null
    }

    function parseCurliedSwitchBody(): CurliedSwitchBody {
        let start: Position$ = lexer.getPreviousPosition()

        let successLeftCurly1: bool = lexer.parsePunctuation(leftCurly)
        if successLeftCurly1
            lexer.advance()
        else
            return(null)

        let cases: SwitchCase[] = parseSwitchCaseList()

        let successRightCurly3: bool = lexer.parsePunctuation(rightCurly)
        if successRightCurly3
            lexer.advance()
        else
            return(null)

        let end: Position$ = lexer.getPosition()

        let ret: CurliedSwitchBody = new CurliedSwitchBody(cases, new Position(start), new Position(end))
        if cases != null {
            for item: SwitchCase in cases
                item.parent = ret
        }

        ret
    }

    function parseNakedSwitchBody(): NakedSwitchBody {
        let start: Position$ = lexer.getPreviousPosition()

        let cases: SwitchCase[] = parseSwitchCaseList()

        let end: Position$ = lexer.getPosition()

        let ret: NakedSwitchBody = new NakedSwitchBody(cases, new Position(start), new Position(end))
        if cases != null {
            for item: SwitchCase in cases
                item.parent = ret
        }

        ret
    }

    function parseSwitchCaseList(): SwitchCase[] {
        mutable ret: SwitchCase[]$ = null
        while true {

            let node: SwitchCase = parseSwitchCase()
            if node == null
                break

            if ret == null
                ret = new SwitchCase[]()

            ret.push(node)
        }

        return(ret)
    }

    function parseSwitchCase(): SwitchCase {
        let start: Position$ = lexer.getPreviousPosition()

        let label: CaseLabel = parseCaseLabel()
        if label == null
            return(null)

        let content: CaseContent = parseCaseContent()
        if content == null
            return(null)

        let end: Position$ = lexer.getPosition()

        let ret: SwitchCase = new SwitchCase(label, content, new Position(start), new Position(end))
        label.parent = ret
        content.parent = ret

        ret
    }

    function parseCaseLabel(): CaseLabel {
        {
            let node: ItemCaseLabel = parseItemCaseLabel()
            if node != null
                return(node)
        }

        {
            let node: DefaultCaseLabel = parseDefaultCaseLabel()
            if node != null
                return(node)
        }

        null
    }

    function parseItemCaseLabel(): ItemCaseLabel {
        let start: Position$ = lexer.getPreviousPosition()

        let successCase1: bool = lexer.parseKeyword(caseKeyword)
        if successCase1
            lexer.advance()
        else
            return(null)

        let pattern: Pattern = parsePattern()
        if pattern == null
            return(null)

        let additionalPatterns: CaseItem[] = parseCaseItemList()

        let successColon4: bool = lexer.parsePunctuation(colon)
        if successColon4
            lexer.advance()
        else
            return(null)

        let end: Position$ = lexer.getPosition()

        let ret: ItemCaseLabel = new ItemCaseLabel(pattern, additionalPatterns, new Position(start), new Position(end))
        pattern.parent = ret
        if additionalPatterns != null {
            for item: CaseItem in additionalPatterns
                item.parent = ret
        }

        ret
    }

    function parseDefaultCaseLabel(): DefaultCaseLabel {
        let start: Position$ = lexer.getPreviousPosition()

        let successDefault1: bool = lexer.parseKeyword(defaultKeyword)
        if successDefault1
            lexer.advance()
        else
            return(null)

        let successColon2: bool = lexer.parsePunctuation(colon)
        if successColon2
            lexer.advance()
        else
            return(null)

        let end: Position$ = lexer.getPosition()

        let ret: DefaultCaseLabel = new DefaultCaseLabel(new Position(start), new Position(end))

        ret
    }

    function parseCaseItemList(): CaseItem[] {
        mutable ret: CaseItem[]$ = null
        while true {

            let node: CaseItem = parseCaseItem()
            if node == null
                break

            if ret == null
                ret = new CaseItem[]()

            ret.push(node)
        }

        return(ret)
    }

    function parseCaseItem(): CaseItem {
        let start: Position$ = lexer.getPreviousPosition()

        let successComma1: bool = lexer.parsePunctuation(comma)
        if successComma1
            lexer.advance()
        else
            return(null)

        let pattern: Pattern = parsePattern()
        if pattern == null
            return(null)

        let end: Position$ = lexer.getPosition()

        let ret: CaseItem = new CaseItem(pattern, new Position(start), new Position(end))
        pattern.parent = ret

        ret
    }

    function parseCaseContent(): CaseContent {
        let start: Position$ = lexer.getPreviousPosition()

        let statements: Statement[] = parseStatementList()

        let end: Position$ = lexer.getPosition()

        let ret: CaseContent = new CaseContent(statements, new Position(start), new Position(end))
        if statements != null {
            for item: Statement in statements
                item.parent = ret
        }

        ret
    }

    function parseForExpression(): ForExpression {
        let start: Position$ = lexer.getPreviousPosition()

        let successFor1: bool = lexer.parseKeyword(forKeyword)
        if successFor1
            lexer.advance()
        else
            return(null)

        let pattern: IdentifierPattern = parseIdentifierPattern()
        if pattern == null
            return(null)

        let successIn3: bool = lexer.parseKeyword(inKeyword)
        if successIn3
            lexer.advance()
        else
            return(null)

        let expression: Expression = parseExpression()
        if expression == null
            return(null)

        let code: Expression = parseExpression()
        if code == null
            return(null)

        let end: Position$ = lexer.getPosition()

        let ret: ForExpression = new ForExpression(pattern, expression, code, new Position(start), new Position(end))
        pattern.parent = ret
        expression.parent = ret
        code.parent = ret

        ret
    }

    function parseWhileExpression(): WhileExpression {
        let start: Position$ = lexer.getPreviousPosition()

        let successWhile1: bool = lexer.parseKeyword(whileKeyword)
        if successWhile1
            lexer.advance()
        else
            return(null)

        let condition: Expression = parseExpression()
        if condition == null
            return(null)

        let code: Expression = parseExpression()
        if code == null
            return(null)

        let end: Position$ = lexer.getPosition()

        let ret: WhileExpression = new WhileExpression(condition, code, new Position(start), new Position(end))
        condition.parent = ret
        code.parent = ret

        ret
    }

    function parseDoExpression(): DoExpression {
        let start: Position$ = lexer.getPreviousPosition()

        let successDo1: bool = lexer.parseKeyword(doKeyword)
        if successDo1
            lexer.advance()
        else
            return(null)

        let code: Expression = parseExpression()
        if code == null
            return(null)

        let successWhile3: bool = lexer.parseKeyword(whileKeyword)
        if successWhile3
            lexer.advance()
        else
            return(null)

        let condition: Expression = parseExpression()
        if condition == null
            return(null)

        let end: Position$ = lexer.getPosition()

        let ret: DoExpression = new DoExpression(code, condition, new Position(start), new Position(end))
        code.parent = ret
        condition.parent = ret

        ret
    }

    function parseParenthesizedExpression(): ParenthesizedExpression {
        let start: Position$ = lexer.getPreviousPosition()

        let successLeftParen1: bool = lexer.parsePunctuation(leftParen)
        if successLeftParen1
            lexer.advance()
        else
            return(null)

        let expressionElements: ExpressionElement[] = parseExpressionElementList()

        let successRightParen3: bool = lexer.parsePunctuation(rightParen)
        if successRightParen3
            lexer.advance()
        else
            return(null)

        let end: Position$ = lexer.getPosition()

        let ret: ParenthesizedExpression = new ParenthesizedExpression(expressionElements, new Position(start), new Position(end))
        if expressionElements != null {
            for item: ExpressionElement in expressionElements
                item.parent = ret
        }

        ret
    }

    function parseExpressionElementList(): ExpressionElement[] {
        mutable ret: ExpressionElement[]$ = null
        while true {

            let node: ExpressionElement = parseExpressionElement()
            if node == null
                break

            if ret == null
                ret = new ExpressionElement[]()

            ret.push(node)
        }

        return(ret)
    }

    function parseExpressionElement(): ExpressionElement {
        let start: Position$ = lexer.getPreviousPosition()

        let expression: Expression = parseExpression()
        if expression == null
            return(null)

        let successComma2: bool = lexer.parsePunctuation(comma)
        if successComma2
            lexer.advance()

        let end: Position$ = lexer.getPosition()

        let ret: ExpressionElement = new ExpressionElement(expression, new Position(start), new Position(end))
        expression.parent = ret

        ret
    }

    function parseReturnExpression(): ReturnExpression {
        let start: Position$ = lexer.getPreviousPosition()

        let successReturn1: bool = lexer.parseKeyword(returnKeyword)
        if successReturn1
            lexer.advance()
        else
            return(null)

        let expression: ParenthesizedExpression = parseParenthesizedExpression()

        let end: Position$ = lexer.getPosition()

        let ret: ReturnExpression = new ReturnExpression(expression, new Position(start), new Position(end))
        if expression != null
            expression.parent = ret

        ret
    }

    function parseThrowExpression(): ThrowExpression {
        let start: Position$ = lexer.getPreviousPosition()

        let successThrow1: bool = lexer.parseKeyword(throwKeyword)
        if successThrow1
            lexer.advance()
        else
            return(null)

        let error: IdentifierExpression = parseIdentifierExpression()
        if error == null
            return(null)

        let arguments: ParenthesizedExpression = parseParenthesizedExpression()

        let end: Position$ = lexer.getPosition()

        let ret: ThrowExpression = new ThrowExpression(error, arguments, new Position(start), new Position(end))
        error.parent = ret
        if arguments != null
            arguments.parent = ret

        ret
    }

    function parseBreakExpression(): BreakExpression {
        let start: Position$ = lexer.getPreviousPosition()

        let successBreak1: bool = lexer.parseKeyword(breakKeyword)
        if successBreak1
            lexer.advance()
        else
            return(null)

        let expression: ParenthesizedExpression = parseParenthesizedExpression()

        let end: Position$ = lexer.getPosition()

        let ret: BreakExpression = new BreakExpression(expression, new Position(start), new Position(end))
        if expression != null
            expression.parent = ret

        ret
    }

    function parseConstructorCall(): ConstructorCall {
        let start: Position$ = lexer.getPreviousPosition()

        let successNew1: bool = lexer.parseKeyword(newKeyword)
        if successNew1
            lexer.advance()
        else
            return(null)

        let typeToConstruct: Type = parseType()
        if typeToConstruct == null
            return(null)

        let arguments: ParenthesizedExpression = parseParenthesizedExpression()
        if arguments == null
            return(null)

        let catchClauses: CatchClause[] = parseCatchClauseList()

        let end: Position$ = lexer.getPosition()

        let ret: ConstructorCall = new ConstructorCall(typeToConstruct, arguments, catchClauses, new Position(start), new Position(end))
        typeToConstruct.parent = ret
        arguments.parent = ret
        if catchClauses != null {
            for item: CatchClause in catchClauses
                item.parent = ret
        }

        ret
    }

    function parseThisExpression(): ThisExpression {
        let start: Position$ = lexer.getPreviousPosition()

        let successThis1: bool = lexer.parseKeyword(thisKeyword)
        if successThis1
            lexer.advance()
        else
            return(null)

        let end: Position$ = lexer.getPosition()

        let ret: ThisExpression = new ThisExpression(new Position(start), new Position(end))

        ret
    }

    function parseNullExpression(): NullExpression {
        let start: Position$ = lexer.getPreviousPosition()

        let successNull1: bool = lexer.parseKeyword(nullKeyword)
        if successNull1
            lexer.advance()
        else
            return(null)

        let end: Position$ = lexer.getPosition()

        let ret: NullExpression = new NullExpression(new Position(start), new Position(end))

        ret
    }

    function parsePostfixList(): Postfix[] {
        mutable ret: Postfix[]$ = null
        while true {

            let node: Postfix = parsePostfix()
            if node == null
                break

            if ret == null
                ret = new Postfix[]()

            ret.push(node)
        }

        return(ret)
    }

    function parsePostfix(): Postfix {
        {
            let node: OperatorPostfix = parseOperatorPostfix()
            if node != null
                return(node)
        }

        {
            let node: FunctionCall = parseFunctionCall()
            if node != null
                return(node)
        }

        {
            let node: MemberExpression = parseMemberExpression()
            if node != null
                return(node)
        }

        {
            let node: Subscript = parseSubscript()
            if node != null
                return(node)
        }

        null
    }

    function parseOperatorPostfix(): OperatorPostfix {
        let start: Position$ = lexer.getPreviousPosition()

        let postfixOperator: string = lexer.parsePostfixOperator()
        if postfixOperator != null
            lexer.advance()
        else
            return(null)

        let end: Position$ = lexer.getPosition()

        let ret: OperatorPostfix = new OperatorPostfix(postfixOperator, new Position(start), new Position(end))

        ret
    }

    function parseFunctionCall(): FunctionCall {
        let start: Position$ = lexer.getPreviousPosition()

        let arguments: ParenthesizedExpression = parseParenthesizedExpression()
        if arguments == null
            return(null)

        let catchClauses: CatchClause[] = parseCatchClauseList()

        let end: Position$ = lexer.getPosition()

        let ret: FunctionCall = new FunctionCall(arguments, catchClauses, new Position(start), new Position(end))
        arguments.parent = ret
        if catchClauses != null {
            for item: CatchClause in catchClauses
                item.parent = ret
        }

        ret
    }

    function parseCatchClauseList(): CatchClause[] {
        mutable ret: CatchClause[]$ = null
        while true {

            let node: CatchClause = parseCatchClause()
            if node == null
                break

            if ret == null
                ret = new CatchClause[]()

            ret.push(node)
        }

        return(ret)
    }

    function parseCatchClause(): CatchClause {
        let start: Position$ = lexer.getPreviousPosition()

        let successCatch1: bool = lexer.parseKeyword(catchKeyword)
        if successCatch1
            lexer.advance()
        else
            return(null)

        let catchPattern: CatchPattern = parseCatchPattern()
        if catchPattern == null
            return(null)

        let bindingPattern: TuplePattern = parseTuplePattern()

        let expression: Expression = parseExpression()
        if expression == null
            return(null)

        let end: Position$ = lexer.getPosition()

        let ret: CatchClause = new CatchClause(catchPattern, bindingPattern, expression, new Position(start), new Position(end))
        catchPattern.parent = ret
        if bindingPattern != null
            bindingPattern.parent = ret
        expression.parent = ret

        ret
    }

    function parseCatchPattern(): CatchPattern {
        {
            let node: WildCardCatchPattern = parseWildCardCatchPattern()
            if node != null
                return(node)
        }

        {
            let node: IdentifierCatchPattern = parseIdentifierCatchPattern()
            if node != null
                return(node)
        }

        null
    }

    function parseWildCardCatchPattern(): WildCardCatchPattern {
        let start: Position$ = lexer.getPreviousPosition()

        let pattern: WildcardPattern = parseWildcardPattern()
        if pattern == null
            return(null)

        let end: Position$ = lexer.getPosition()

        let ret: WildCardCatchPattern = new WildCardCatchPattern(pattern, new Position(start), new Position(end))
        pattern.parent = ret

        ret
    }

    function parseIdentifierCatchPattern(): IdentifierCatchPattern {
        let start: Position$ = lexer.getPreviousPosition()

        let name: string = lexer.parseIdentifier()
        if (name != null) && isIdentifier(name)
            lexer.advance()
        else
            return(null)

        let member: MemberExpression = parseMemberExpression()

        let end: Position$ = lexer.getPosition()

        let ret: IdentifierCatchPattern = new IdentifierCatchPattern(name, member, new Position(start), new Position(end))
        if member != null
            member.parent = ret

        ret
    }

    function parseWildcardPattern(): WildcardPattern {
        let start: Position$ = lexer.getPreviousPosition()

        let successUnderscore1: bool = lexer.parsePunctuation(underscore)
        if successUnderscore1
            lexer.advance()
        else
            return(null)

        let end: Position$ = lexer.getPosition()

        let ret: WildcardPattern = new WildcardPattern(new Position(start), new Position(end))

        ret
    }

    function parseTuplePattern(): TuplePattern {
        let start: Position$ = lexer.getPreviousPosition()

        let successLeftParen1: bool = lexer.parsePunctuation(leftParen)
        if successLeftParen1
            lexer.advance()
        else
            return(null)

        let elements: TuplePatternElement[] = parseTuplePatternElementList()

        let successRightParen3: bool = lexer.parsePunctuation(rightParen)
        if successRightParen3
            lexer.advance()
        else
            return(null)

        let end: Position$ = lexer.getPosition()

        let ret: TuplePattern = new TuplePattern(elements, new Position(start), new Position(end))
        if elements != null {
            for item: TuplePatternElement in elements
                item.parent = ret
        }

        ret
    }

    function parseTuplePatternElementList(): TuplePatternElement[] {
        mutable ret: TuplePatternElement[]$ = null
        while true {

            let node: TuplePatternElement = parseTuplePatternElement()
            if node == null
                break

            if ret == null
                ret = new TuplePatternElement[]()

            ret.push(node)
        }

        return(ret)
    }

    function parseTuplePatternElement(): TuplePatternElement {
        let start: Position$ = lexer.getPreviousPosition()

        let pattern: Pattern = parsePattern()
        if pattern == null
            return(null)

        let successComma2: bool = lexer.parsePunctuation(comma)
        if successComma2
            lexer.advance()

        let end: Position$ = lexer.getPosition()

        let ret: TuplePatternElement = new TuplePatternElement(pattern, new Position(start), new Position(end))
        pattern.parent = ret

        ret
    }

    function parseExpressionPattern(): ExpressionPattern {
        let start: Position$ = lexer.getPreviousPosition()

        let expression: Expression = parseExpression()
        if expression == null
            return(null)

        let end: Position$ = lexer.getPosition()

        let ret: ExpressionPattern = new ExpressionPattern(expression, new Position(start), new Position(end))
        expression.parent = ret

        ret
    }

    function parseMemberExpression(): MemberExpression {
        let start: Position$ = lexer.getPreviousPosition()

        let successDot1: bool = lexer.parsePunctuation(dot)
        if successDot1
            lexer.advance()
        else
            return(null)

        let member: string = lexer.parseIdentifier()
        if (member != null) && isIdentifier(member)
            lexer.advance()
        else
            return(null)

        let end: Position$ = lexer.getPosition()

        let ret: MemberExpression = new MemberExpression(member, new Position(start), new Position(end))

        ret
    }

    function parseSubscript(): Subscript {
        let start: Position$ = lexer.getPreviousPosition()

        let successLeftBracket1: bool = lexer.parsePunctuation(leftBracket)
        if successLeftBracket1
            lexer.advance()
        else
            return(null)

        let expressions: ExpressionElement[] = parseExpressionElementList()

        let successRightBracket3: bool = lexer.parsePunctuation(rightBracket)
        if successRightBracket3
            lexer.advance()
        else
            return(null)

        let end: Position$ = lexer.getPosition()

        let ret: Subscript = new Subscript(expressions, new Position(start), new Position(end))
        if expressions != null {
            for item: ExpressionElement in expressions
                item.parent = ret
        }

        ret
    }

    function parseBinaryExpressionList(): BinaryExpression[] {
        mutable ret: BinaryExpression[]$ = null
        while true {

            let node: BinaryExpression = parseBinaryExpression()
            if node == null
                break

            if ret == null
                ret = new BinaryExpression[]()

            ret.push(node)
        }

        return(ret)
    }

    function parseBinaryExpression(): BinaryExpression {
        {
            let node: BinaryOperation = parseBinaryOperation()
            if node != null
                return(node)
        }

        {
            let node: Assignment = parseAssignment()
            if node != null
                return(node)
        }

        {
            let node: TypeQuery = parseTypeQuery()
            if node != null
                return(node)
        }

        {
            let node: TypeCast = parseTypeCast()
            if node != null
                return(node)
        }

        null
    }

    function parseBinaryOperation(): BinaryOperation {
        let start: Position$ = lexer.getPreviousPosition()

        let binaryOperator: string = lexer.parseBinaryOperator()
        if binaryOperator != null
            lexer.advance()
        else
            return(null)

        let expression: PrefixExpression = parsePrefixExpression()
        if expression == null
            return(null)

        let end: Position$ = lexer.getPosition()

        let ret: BinaryOperation = new BinaryOperation(binaryOperator, expression, new Position(start), new Position(end))
        expression.parent = ret

        ret
    }

    function parseAssignment(): Assignment {
        let start: Position$ = lexer.getPreviousPosition()

        let successEqual1: bool = lexer.parsePunctuation(equal)
        if successEqual1
            lexer.advance()
        else
            return(null)

        let expression: Expression = parseExpression()
        if expression == null
            return(null)

        let end: Position$ = lexer.getPosition()

        let ret: Assignment = new Assignment(expression, new Position(start), new Position(end))
        expression.parent = ret

        ret
    }

    function parseTypeQuery(): TypeQuery {
        let start: Position$ = lexer.getPreviousPosition()

        let successIs1: bool = lexer.parseKeyword(isKeyword)
        if successIs1
            lexer.advance()
        else
            return(null)

        let objectType: Type = parseType()
        if objectType == null
            return(null)

        let end: Position$ = lexer.getPosition()

        let ret: TypeQuery = new TypeQuery(objectType, new Position(start), new Position(end))
        objectType.parent = ret

        ret
    }

    function parseTypeCast(): TypeCast {
        let start: Position$ = lexer.getPreviousPosition()

        let successAs1: bool = lexer.parseKeyword(asKeyword)
        if successAs1
            lexer.advance()
        else
            return(null)

        let objectType: Type = parseType()
        if objectType == null
            return(null)

        let end: Position$ = lexer.getPosition()

        let ret: TypeCast = new TypeCast(objectType, new Position(start), new Position(end))
        objectType.parent = ret

        ret
    }

    function isAtEnd(): bool {
        lexer.isAtEnd()
    }

    function isIdentifier(id: string): bool {
        if id.equals(classKeyword)
            return(false)

        if id.equals(functionKeyword)
            return(false)

        if id.equals(ifKeyword)
            return(false)

        if id.equals(elseKeyword)
            return(false)

        if id.equals(switchKeyword)
            return(false)

        if id.equals(caseKeyword)
            return(false)

        if id.equals(defaultKeyword)
            return(false)

        if id.equals(catchKeyword)
            return(false)

        if id.equals(forKeyword)
            return(false)

        if id.equals(inKeyword)
            return(false)

        if id.equals(whileKeyword)
            return(false)

        if id.equals(doKeyword)
            return(false)

        if id.equals(returnKeyword)
            return(false)

        if id.equals(throwKeyword)
            return(false)

        if id.equals(breakKeyword)
            return(false)

        if id.equals(throwsKeyword)
            return(false)

        if id.equals(staticKeyword)
            return(false)

        if id.equals(letKeyword)
            return(false)

        if id.equals(mutableKeyword)
            return(false)

        if id.equals(isKeyword)
            return(false)

        if id.equals(asKeyword)
            return(false)

        if id.equals(constructorKeyword)
            return(false)

        if id.equals(enumKeyword)
            return(false)

        if id.equals(thisKeyword)
            return(false)

        if id.equals(nullKeyword)
            return(false)

        if id.equals(newKeyword)
            return(false)

        if id.equals(extendsKeyword)
            return(false)

        return(true)
    }

    mutable lexer: Lexer
    let fileName: string

    let classKeyword: string
    let functionKeyword: string
    let ifKeyword: string
    let elseKeyword: string
    let switchKeyword: string
    let caseKeyword: string
    let defaultKeyword: string
    let catchKeyword: string
    let forKeyword: string
    let inKeyword: string
    let whileKeyword: string
    let doKeyword: string
    let returnKeyword: string
    let throwKeyword: string
    let breakKeyword: string
    let throwsKeyword: string
    let staticKeyword: string
    let letKeyword: string
    let mutableKeyword: string
    let isKeyword: string
    let asKeyword: string
    let constructorKeyword: string
    let enumKeyword: string
    let thisKeyword: string
    let nullKeyword: string
    let newKeyword: string
    let extendsKeyword: string
    let equal: string
    let comma: string
    let leftParen: string
    let rightParen: string
    let leftCurly: string
    let rightCurly: string
    let leftBracket: string
    let rightBracket: string
    let colon: string
    let dot: string
    let underscore: string
    let circumflex: string
    let dollar: string
    let at: string
    let hash: string
    let ampersand: string
}

class Visitor {
    function openProgram(program: Program): bool {
        true
    }

    function closeProgram(program: Program) {
    }

    function openModule(module: Module): bool {
        true
    }

    function closeModule(module: Module) {
    }

    function openConstantDeclaration(constantDeclaration: ConstantDeclaration): bool {
        true
    }

    function closeConstantDeclaration(constantDeclaration: ConstantDeclaration) {
    }

    function openMutableDeclaration(mutableDeclaration: MutableDeclaration): bool {
        true
    }

    function closeMutableDeclaration(mutableDeclaration: MutableDeclaration) {
    }

    function openBindingInitializer(bindingInitializer: BindingInitializer): bool {
        true
    }

    function closeBindingInitializer(bindingInitializer: BindingInitializer) {
    }

    function openIdentifierInitializer(identifierInitializer: IdentifierInitializer): bool {
        true
    }

    function closeIdentifierInitializer(identifierInitializer: IdentifierInitializer) {
    }

    function openInitializer(initializer: Initializer): bool {
        true
    }

    function closeInitializer(initializer: Initializer) {
    }

    function openAdditionalInitializer(additionalInitializer: AdditionalInitializer): bool {
        true
    }

    function closeAdditionalInitializer(additionalInitializer: AdditionalInitializer) {
    }

    function openIdentifierPattern(identifierPattern: IdentifierPattern): bool {
        true
    }

    function closeIdentifierPattern(identifierPattern: IdentifierPattern) {
    }

    function openTypeAnnotation(typeAnnotation: TypeAnnotation): bool {
        true
    }

    function closeTypeAnnotation(typeAnnotation: TypeAnnotation) {
    }

    function openType(type: Type): bool {
        true
    }

    function closeType(type: Type) {
    }

    function openIndexedType(indexedType: IndexedType): bool {
        true
    }

    function closeIndexedType(indexedType: IndexedType) {
    }

    function visitPointer(pointer: Pointer) {
    }

    function visitRoot(root: Root) {
    }

    function visitLocal(local: Local) {
    }

    function visitReference(reference: Reference) {
    }

    function visitThrown(thrown: Thrown) {
    }

    function openFunctionDeclaration(functionDeclaration: FunctionDeclaration): bool {
        true
    }

    function closeFunctionDeclaration(functionDeclaration: FunctionDeclaration) {
    }

    function visitStaticWord(staticWord: StaticWord) {
    }

    function openFunctionSignature(functionSignature: FunctionSignature): bool {
        true
    }

    function closeFunctionSignature(functionSignature: FunctionSignature) {
    }

    function openParameterClause(parameterClause: ParameterClause): bool {
        true
    }

    function closeParameterClause(parameterClause: ParameterClause) {
    }

    function openConstParameter(constParameter: ConstParameter): bool {
        true
    }

    function closeConstParameter(constParameter: ConstParameter) {
    }

    function openVarParameter(varParameter: VarParameter): bool {
        true
    }

    function closeVarParameter(varParameter: VarParameter) {
    }

    function openFunctionResult(functionResult: FunctionResult): bool {
        true
    }

    function closeFunctionResult(functionResult: FunctionResult) {
    }

    function openThrowsClause(throwsClause: ThrowsClause): bool {
        true
    }

    function closeThrowsClause(throwsClause: ThrowsClause) {
    }

    function openEnumDeclaration(enumDeclaration: EnumDeclaration): bool {
        true
    }

    function closeEnumDeclaration(enumDeclaration: EnumDeclaration) {
    }

    function openEnumMember(enumMember: EnumMember): bool {
        true
    }

    function closeEnumMember(enumMember: EnumMember) {
    }

    function visitEnumCase(enumCase: EnumCase) {
    }

    function openAdditionalCase(additionalCase: AdditionalCase): bool {
        true
    }

    function closeAdditionalCase(additionalCase: AdditionalCase) {
    }

    function openClassDeclaration(classDeclaration: ClassDeclaration): bool {
        true
    }

    function closeClassDeclaration(classDeclaration: ClassDeclaration) {
    }

    function openTypeInheritanceClause(typeInheritanceClause: TypeInheritanceClause): bool {
        true
    }

    function closeTypeInheritanceClause(typeInheritanceClause: TypeInheritanceClause) {
    }

    function openInheritance(inheritance: Inheritance): bool {
        true
    }

    function closeInheritance(inheritance: Inheritance) {
    }

    function openClassBody(classBody: ClassBody): bool {
        true
    }

    function closeClassBody(classBody: ClassBody) {
    }

    function openClassMember(classMember: ClassMember): bool {
        true
    }

    function closeClassMember(classMember: ClassMember) {
    }

    function openConstructorDeclaration(constructorDeclaration: ConstructorDeclaration): bool {
        true
    }

    function closeConstructorDeclaration(constructorDeclaration: ConstructorDeclaration) {
    }

    function openCodeBlock(codeBlock: CodeBlock): bool {
        true
    }

    function closeCodeBlock(codeBlock: CodeBlock) {
    }

    function openSimpleExpression(simpleExpression: SimpleExpression): bool {
        true
    }

    function closeSimpleExpression(simpleExpression: SimpleExpression) {
    }

    function openPrefixExpression(prefixExpression: PrefixExpression): bool {
        true
    }

    function closePrefixExpression(prefixExpression: PrefixExpression) {
    }

    function openPostfixExpression(postfixExpression: PostfixExpression): bool {
        true
    }

    function closePostfixExpression(postfixExpression: PostfixExpression) {
    }

    function visitIdentifierExpression(identifierExpression: IdentifierExpression) {
    }

    function visitLiteralExpression(literalExpression: LiteralExpression) {
    }

    function openIfExpression(ifExpression: IfExpression): bool {
        true
    }

    function closeIfExpression(ifExpression: IfExpression) {
    }

    function openElseClause(elseClause: ElseClause): bool {
        true
    }

    function closeElseClause(elseClause: ElseClause) {
    }

    function openSwitchExpression(switchExpression: SwitchExpression): bool {
        true
    }

    function closeSwitchExpression(switchExpression: SwitchExpression) {
    }

    function openCurliedSwitchBody(curliedSwitchBody: CurliedSwitchBody): bool {
        true
    }

    function closeCurliedSwitchBody(curliedSwitchBody: CurliedSwitchBody) {
    }

    function openNakedSwitchBody(nakedSwitchBody: NakedSwitchBody): bool {
        true
    }

    function closeNakedSwitchBody(nakedSwitchBody: NakedSwitchBody) {
    }

    function openSwitchCase(switchCase: SwitchCase): bool {
        true
    }

    function closeSwitchCase(switchCase: SwitchCase) {
    }

    function openItemCaseLabel(itemCaseLabel: ItemCaseLabel): bool {
        true
    }

    function closeItemCaseLabel(itemCaseLabel: ItemCaseLabel) {
    }

    function visitDefaultCaseLabel(defaultCaseLabel: DefaultCaseLabel) {
    }

    function openCaseItem(caseItem: CaseItem): bool {
        true
    }

    function closeCaseItem(caseItem: CaseItem) {
    }

    function openCaseContent(caseContent: CaseContent): bool {
        true
    }

    function closeCaseContent(caseContent: CaseContent) {
    }

    function openForExpression(forExpression: ForExpression): bool {
        true
    }

    function closeForExpression(forExpression: ForExpression) {
    }

    function openWhileExpression(whileExpression: WhileExpression): bool {
        true
    }

    function closeWhileExpression(whileExpression: WhileExpression) {
    }

    function openDoExpression(doExpression: DoExpression): bool {
        true
    }

    function closeDoExpression(doExpression: DoExpression) {
    }

    function openParenthesizedExpression(parenthesizedExpression: ParenthesizedExpression): bool {
        true
    }

    function closeParenthesizedExpression(parenthesizedExpression: ParenthesizedExpression) {
    }

    function openExpressionElement(expressionElement: ExpressionElement): bool {
        true
    }

    function closeExpressionElement(expressionElement: ExpressionElement) {
    }

    function openReturnExpression(returnExpression: ReturnExpression): bool {
        true
    }

    function closeReturnExpression(returnExpression: ReturnExpression) {
    }

    function openThrowExpression(throwExpression: ThrowExpression): bool {
        true
    }

    function closeThrowExpression(throwExpression: ThrowExpression) {
    }

    function openBreakExpression(breakExpression: BreakExpression): bool {
        true
    }

    function closeBreakExpression(breakExpression: BreakExpression) {
    }

    function openConstructorCall(constructorCall: ConstructorCall): bool {
        true
    }

    function closeConstructorCall(constructorCall: ConstructorCall) {
    }

    function visitThisExpression(thisExpression: ThisExpression) {
    }

    function visitNullExpression(nullExpression: NullExpression) {
    }

    function visitOperatorPostfix(operatorPostfix: OperatorPostfix) {
    }

    function openFunctionCall(functionCall: FunctionCall): bool {
        true
    }

    function closeFunctionCall(functionCall: FunctionCall) {
    }

    function openCatchClause(catchClause: CatchClause): bool {
        true
    }

    function closeCatchClause(catchClause: CatchClause) {
    }

    function openWildCardCatchPattern(wildCardCatchPattern: WildCardCatchPattern): bool {
        true
    }

    function closeWildCardCatchPattern(wildCardCatchPattern: WildCardCatchPattern) {
    }

    function openIdentifierCatchPattern(identifierCatchPattern: IdentifierCatchPattern): bool {
        true
    }

    function closeIdentifierCatchPattern(identifierCatchPattern: IdentifierCatchPattern) {
    }

    function visitWildcardPattern(wildcardPattern: WildcardPattern) {
    }

    function openTuplePattern(tuplePattern: TuplePattern): bool {
        true
    }

    function closeTuplePattern(tuplePattern: TuplePattern) {
    }

    function openTuplePatternElement(tuplePatternElement: TuplePatternElement): bool {
        true
    }

    function closeTuplePatternElement(tuplePatternElement: TuplePatternElement) {
    }

    function openExpressionPattern(expressionPattern: ExpressionPattern): bool {
        true
    }

    function closeExpressionPattern(expressionPattern: ExpressionPattern) {
    }

    function visitMemberExpression(memberExpression: MemberExpression) {
    }

    function openSubscript(subscript: Subscript): bool {
        true
    }

    function closeSubscript(subscript: Subscript) {
    }

    function openBinaryOperation(binaryOperation: BinaryOperation): bool {
        true
    }

    function closeBinaryOperation(binaryOperation: BinaryOperation) {
    }

    function openAssignment(assignment: Assignment): bool {
        true
    }

    function closeAssignment(assignment: Assignment) {
    }

    function openTypeQuery(typeQuery: TypeQuery): bool {
        true
    }

    function closeTypeQuery(typeQuery: TypeQuery) {
    }

    function openTypeCast(typeCast: TypeCast): bool {
        true
    }

    function closeTypeCast(typeCast: TypeCast) {
    }
}

class SyntaxNode {
    let start: Position
    let end: Position
    mutable parent: SyntaxNode&
}

class Program extends SyntaxNode {

    constructor(name: string, modules: Module[]) {
        start = new Position(0, 0)
        end = new Position(0, 0)
        this.name = name
        this.modules = modules
        this.parent = null
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openProgram(this)
            return
        if modules != null {
            for node: Module in modules
                node.accept(visitor)
        }
        visitor.closeProgram(this)
    }

    let name: string
    let modules: Module[]
}

class Module extends SyntaxNode {

    constructor(statements: Statement[], start: Position, end: Position) {
        this.start = start
        this.end = end
        this.statements = statements
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openModule(this)
            return
        if statements != null {
            for node: Statement in statements
                node.accept(visitor)
        }
        visitor.closeModule(this)
    }

    let statements: Statement[]
}

class Statement extends SyntaxNode {

    function accept(mutable visitor: Visitor) {
    }

}

class Declaration extends Statement {

    function accept(mutable visitor: Visitor) {
    }

}

class ConstantDeclaration extends Declaration {

    constructor(initializer: BindingInitializer, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.initializer = initializer
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openConstantDeclaration(this)
            return
        initializer.accept(visitor)
        visitor.closeConstantDeclaration(this)
    }

    let initializer: BindingInitializer
}

class MutableDeclaration extends Declaration {

    constructor(initializer: BindingInitializer, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.initializer = initializer
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openMutableDeclaration(this)
            return
        initializer.accept(visitor)
        visitor.closeMutableDeclaration(this)
    }

    let initializer: BindingInitializer
}

class BindingInitializer extends SyntaxNode {

    constructor(initializer: IdentifierInitializer, additionalInitializers: AdditionalInitializer[], start: Position, end: Position) {
        this.start = start
        this.end = end
        this.initializer = initializer
        this.additionalInitializers = additionalInitializers
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openBindingInitializer(this)
            return
        initializer.accept(visitor)
        if additionalInitializers != null {
            for node: AdditionalInitializer in additionalInitializers
                node.accept(visitor)
        }
        visitor.closeBindingInitializer(this)
    }

    let initializer: IdentifierInitializer
    let additionalInitializers: AdditionalInitializer[]
}

class IdentifierInitializer extends SyntaxNode {

    constructor(pattern: IdentifierPattern, initializer: Initializer, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.pattern = pattern
        this.initializer = initializer
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openIdentifierInitializer(this)
            return
        pattern.accept(visitor)
        if initializer != null
            initializer.accept(visitor)
        visitor.closeIdentifierInitializer(this)
    }

    let pattern: IdentifierPattern
    let initializer: Initializer
}

class Initializer extends SyntaxNode {

    constructor(expression: Expression, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.expression = expression
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openInitializer(this)
            return
        expression.accept(visitor)
        visitor.closeInitializer(this)
    }

    let expression: Expression
}

class AdditionalInitializer extends SyntaxNode {

    constructor(pattern: IdentifierInitializer, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.pattern = pattern
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openAdditionalInitializer(this)
            return
        pattern.accept(visitor)
        visitor.closeAdditionalInitializer(this)
    }

    let pattern: IdentifierInitializer
}

class Pattern extends SyntaxNode {

    function accept(mutable visitor: Visitor) {
    }

}

class IdentifierPattern extends Pattern {

    constructor(identifier: string, annotationForType: TypeAnnotation, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.identifier = identifier
        this.annotationForType = annotationForType
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openIdentifierPattern(this)
            return
        if annotationForType != null
            annotationForType.accept(visitor)
        visitor.closeIdentifierPattern(this)
    }

    let identifier: string
    let annotationForType: TypeAnnotation
}

class TypeAnnotation extends SyntaxNode {

    constructor(annotationForType: Type, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.annotationForType = annotationForType
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openTypeAnnotation(this)
            return
        annotationForType.accept(visitor)
        visitor.closeTypeAnnotation(this)
    }

    let annotationForType: Type
}

class Type extends SyntaxNode {

    constructor(name: string, postfixes: TypePostfix[], lifeTime: LifeTime, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.name = name
        this.postfixes = postfixes
        this.lifeTime = lifeTime
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openType(this)
            return
        if postfixes != null {
            for node: TypePostfix in postfixes
                node.accept(visitor)
        }
        if lifeTime != null
            lifeTime.accept(visitor)
        visitor.closeType(this)
    }

    let name: string
    let postfixes: TypePostfix[]
    let lifeTime: LifeTime
}

class TypePostfix extends SyntaxNode {

    function accept(mutable visitor: Visitor) {
    }

}

class IndexedType extends TypePostfix {

    constructor(key: Type, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.key = key
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openIndexedType(this)
            return
        if key != null
            key.accept(visitor)
        visitor.closeIndexedType(this)
    }

    let key: Type
}

class Pointer extends TypePostfix {

    constructor(start: Position, end: Position) {
        this.start = start
        this.end = end
    }

    function accept(mutable visitor: Visitor) {
        visitor.visitPointer(this)
    }

}

class LifeTime extends SyntaxNode {

    function accept(mutable visitor: Visitor) {
    }

}

class Root extends LifeTime {

    constructor(start: Position, end: Position) {
        this.start = start
        this.end = end
    }

    function accept(mutable visitor: Visitor) {
        visitor.visitRoot(this)
    }

}

class Local extends LifeTime {

    constructor(location: string, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.location = location
    }

    function accept(mutable visitor: Visitor) {
        visitor.visitLocal(this)
    }

    let location: string
}

class Reference extends LifeTime {

    constructor(age: Literal, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.age = age
    }

    function accept(mutable visitor: Visitor) {
        visitor.visitReference(this)
    }

    let age: Literal
}

class Thrown extends LifeTime {

    constructor(start: Position, end: Position) {
        this.start = start
        this.end = end
    }

    function accept(mutable visitor: Visitor) {
        visitor.visitThrown(this)
    }

}

class FunctionDeclaration extends Declaration {

    constructor(modifiers: Modifier[], name: string, signature: FunctionSignature, body: Expression, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.modifiers = modifiers
        this.name = name
        this.signature = signature
        this.body = body
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openFunctionDeclaration(this)
            return
        if modifiers != null {
            for node: Modifier in modifiers
                node.accept(visitor)
        }
        signature.accept(visitor)
        if body != null
            body.accept(visitor)
        visitor.closeFunctionDeclaration(this)
    }

    let modifiers: Modifier[]
    let name: string
    let signature: FunctionSignature
    let body: Expression
}

class Modifier extends SyntaxNode {

    function accept(mutable visitor: Visitor) {
    }

}

class StaticWord extends Modifier {

    constructor(start: Position, end: Position) {
        this.start = start
        this.end = end
    }

    function accept(mutable visitor: Visitor) {
        visitor.visitStaticWord(this)
    }

}

class FunctionSignature extends SyntaxNode {

    constructor(parameterClause: ParameterClause, result: FunctionResult, throwsClause: ThrowsClause, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.parameterClause = parameterClause
        this.result = result
        this.throwsClause = throwsClause
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openFunctionSignature(this)
            return
        parameterClause.accept(visitor)
        if result != null
            result.accept(visitor)
        if throwsClause != null
            throwsClause.accept(visitor)
        visitor.closeFunctionSignature(this)
    }

    let parameterClause: ParameterClause
    let result: FunctionResult
    let throwsClause: ThrowsClause
}

class ParameterClause extends SyntaxNode {

    constructor(parameters: Parameter[], start: Position, end: Position) {
        this.start = start
        this.end = end
        this.parameters = parameters
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openParameterClause(this)
            return
        if parameters != null {
            for node: Parameter in parameters
                node.accept(visitor)
        }
        visitor.closeParameterClause(this)
    }

    let parameters: Parameter[]
}

class Parameter extends SyntaxNode {

    function accept(mutable visitor: Visitor) {
    }

}

class ConstParameter extends Parameter {

    constructor(name: string, parameterType: Type, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.name = name
        this.parameterType = parameterType
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openConstParameter(this)
            return
        parameterType.accept(visitor)
        visitor.closeConstParameter(this)
    }

    let name: string
    let parameterType: Type
}

class VarParameter extends Parameter {

    constructor(name: string, parameterType: Type, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.name = name
        this.parameterType = parameterType
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openVarParameter(this)
            return
        parameterType.accept(visitor)
        visitor.closeVarParameter(this)
    }

    let name: string
    let parameterType: Type
}

class FunctionResult extends SyntaxNode {

    constructor(resultType: Type, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.resultType = resultType
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openFunctionResult(this)
            return
        resultType.accept(visitor)
        visitor.closeFunctionResult(this)
    }

    let resultType: Type
}

class ThrowsClause extends SyntaxNode {

    constructor(throwsType: Type, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.throwsType = throwsType
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openThrowsClause(this)
            return
        throwsType.accept(visitor)
        visitor.closeThrowsClause(this)
    }

    let throwsType: Type
}

class EnumDeclaration extends Declaration {

    constructor(name: string, members: EnumMember[], start: Position, end: Position) {
        this.start = start
        this.end = end
        this.name = name
        this.members = members
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openEnumDeclaration(this)
            return
        if members != null {
            for node: EnumMember in members
                node.accept(visitor)
        }
        visitor.closeEnumDeclaration(this)
    }

    let name: string
    let members: EnumMember[]
}

class EnumMember extends SyntaxNode {

    constructor(enumCase: EnumCase, additionalCases: AdditionalCase[], parameterClause: ParameterClause, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.enumCase = enumCase
        this.additionalCases = additionalCases
        this.parameterClause = parameterClause
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openEnumMember(this)
            return
        enumCase.accept(visitor)
        if additionalCases != null {
            for node: AdditionalCase in additionalCases
                node.accept(visitor)
        }
        if parameterClause != null
            parameterClause.accept(visitor)
        visitor.closeEnumMember(this)
    }

    let enumCase: EnumCase
    let additionalCases: AdditionalCase[]
    let parameterClause: ParameterClause
}

class EnumCase extends SyntaxNode {

    constructor(name: string, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.name = name
    }

    function accept(mutable visitor: Visitor) {
        visitor.visitEnumCase(this)
    }

    let name: string
}

class AdditionalCase extends SyntaxNode {

    constructor(enumCase: EnumCase, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.enumCase = enumCase
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openAdditionalCase(this)
            return
        enumCase.accept(visitor)
        visitor.closeAdditionalCase(this)
    }

    let enumCase: EnumCase
}

class ClassDeclaration extends Declaration {

    constructor(name: string, typeInheritanceClause: TypeInheritanceClause, body: ClassBody, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.name = name
        this.typeInheritanceClause = typeInheritanceClause
        this.body = body
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openClassDeclaration(this)
            return
        if typeInheritanceClause != null
            typeInheritanceClause.accept(visitor)
        if body != null
            body.accept(visitor)
        visitor.closeClassDeclaration(this)
    }

    let name: string
    let typeInheritanceClause: TypeInheritanceClause
    let body: ClassBody
}

class TypeInheritanceClause extends SyntaxNode {

    constructor(inheritances: Inheritance[], start: Position, end: Position) {
        this.start = start
        this.end = end
        this.inheritances = inheritances
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openTypeInheritanceClause(this)
            return
        if inheritances != null {
            for node: Inheritance in inheritances
                node.accept(visitor)
        }
        visitor.closeTypeInheritanceClause(this)
    }

    let inheritances: Inheritance[]
}

class Inheritance extends SyntaxNode {

    constructor(type: Type, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.type = type
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openInheritance(this)
            return
        type.accept(visitor)
        visitor.closeInheritance(this)
    }

    let type: Type
}

class ClassBody extends SyntaxNode {

    constructor(members: ClassMember[], start: Position, end: Position) {
        this.start = start
        this.end = end
        this.members = members
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openClassBody(this)
            return
        if members != null {
            for node: ClassMember in members
                node.accept(visitor)
        }
        visitor.closeClassBody(this)
    }

    let members: ClassMember[]
}

class ClassMember extends SyntaxNode {

    constructor(declaration: Declaration, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.declaration = declaration
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openClassMember(this)
            return
        declaration.accept(visitor)
        visitor.closeClassMember(this)
    }

    let declaration: Declaration
}

class ConstructorDeclaration extends Declaration {

    constructor(parameterClause: ParameterClause, body: Expression, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.parameterClause = parameterClause
        this.body = body
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openConstructorDeclaration(this)
            return
        parameterClause.accept(visitor)
        body.accept(visitor)
        visitor.closeConstructorDeclaration(this)
    }

    let parameterClause: ParameterClause
    let body: Expression
}

class Expression extends Statement {

    function accept(mutable visitor: Visitor) {
    }

}

class CodeBlock extends Expression {

    constructor(statements: Statement[], start: Position, end: Position) {
        this.start = start
        this.end = end
        this.statements = statements
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openCodeBlock(this)
            return
        if statements != null {
            for node: Statement in statements
                node.accept(visitor)
        }
        visitor.closeCodeBlock(this)
    }

    let statements: Statement[]
}

class SimpleExpression extends Expression {

    constructor(prefixExpression: PrefixExpression, binaryExpressions: BinaryExpression[], start: Position, end: Position) {
        this.start = start
        this.end = end
        this.prefixExpression = prefixExpression
        this.binaryExpressions = binaryExpressions
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openSimpleExpression(this)
            return
        prefixExpression.accept(visitor)
        if binaryExpressions != null {
            for node: BinaryExpression in binaryExpressions
                node.accept(visitor)
        }
        visitor.closeSimpleExpression(this)
    }

    let prefixExpression: PrefixExpression
    let binaryExpressions: BinaryExpression[]
}

class PrefixExpression extends SyntaxNode {

    constructor(prefixOperator: string, expression: PostfixExpression, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.prefixOperator = prefixOperator
        this.expression = expression
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openPrefixExpression(this)
            return
        expression.accept(visitor)
        visitor.closePrefixExpression(this)
    }

    let prefixOperator: string
    let expression: PostfixExpression
}

class PostfixExpression extends SyntaxNode {

    constructor(primaryExpression: PrimaryExpression, postfixes: Postfix[], start: Position, end: Position) {
        this.start = start
        this.end = end
        this.primaryExpression = primaryExpression
        this.postfixes = postfixes
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openPostfixExpression(this)
            return
        primaryExpression.accept(visitor)
        if postfixes != null {
            for node: Postfix in postfixes
                node.accept(visitor)
        }
        visitor.closePostfixExpression(this)
    }

    let primaryExpression: PrimaryExpression
    let postfixes: Postfix[]
}

class PrimaryExpression extends SyntaxNode {

    function accept(mutable visitor: Visitor) {
    }

}

class IdentifierExpression extends PrimaryExpression {

    constructor(name: string, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.name = name
    }

    function accept(mutable visitor: Visitor) {
        visitor.visitIdentifierExpression(this)
    }

    let name: string
}

class LiteralExpression extends PrimaryExpression {

    constructor(literal: Literal, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.literal = literal
    }

    function accept(mutable visitor: Visitor) {
        visitor.visitLiteralExpression(this)
    }

    let literal: Literal
}

class IfExpression extends PrimaryExpression {

    constructor(condition: Expression, consequent: Expression, elseClause: ElseClause, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.condition = condition
        this.consequent = consequent
        this.elseClause = elseClause
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openIfExpression(this)
            return
        condition.accept(visitor)
        consequent.accept(visitor)
        if elseClause != null
            elseClause.accept(visitor)
        visitor.closeIfExpression(this)
    }

    let condition: Expression
    let consequent: Expression
    let elseClause: ElseClause
}

class ElseClause extends SyntaxNode {

    constructor(alternative: Expression, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.alternative = alternative
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openElseClause(this)
            return
        alternative.accept(visitor)
        visitor.closeElseClause(this)
    }

    let alternative: Expression
}

class SwitchExpression extends PrimaryExpression {

    constructor(expression: Expression, body: SwitchBody, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.expression = expression
        this.body = body
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openSwitchExpression(this)
            return
        expression.accept(visitor)
        body.accept(visitor)
        visitor.closeSwitchExpression(this)
    }

    let expression: Expression
    let body: SwitchBody
}

class SwitchBody extends SyntaxNode {

    function accept(mutable visitor: Visitor) {
    }

}

class CurliedSwitchBody extends SwitchBody {

    constructor(cases: SwitchCase[], start: Position, end: Position) {
        this.start = start
        this.end = end
        this.cases = cases
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openCurliedSwitchBody(this)
            return
        if cases != null {
            for node: SwitchCase in cases
                node.accept(visitor)
        }
        visitor.closeCurliedSwitchBody(this)
    }

    let cases: SwitchCase[]
}

class NakedSwitchBody extends SwitchBody {

    constructor(cases: SwitchCase[], start: Position, end: Position) {
        this.start = start
        this.end = end
        this.cases = cases
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openNakedSwitchBody(this)
            return
        if cases != null {
            for node: SwitchCase in cases
                node.accept(visitor)
        }
        visitor.closeNakedSwitchBody(this)
    }

    let cases: SwitchCase[]
}

class SwitchCase extends SyntaxNode {

    constructor(label: CaseLabel, content: CaseContent, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.label = label
        this.content = content
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openSwitchCase(this)
            return
        label.accept(visitor)
        content.accept(visitor)
        visitor.closeSwitchCase(this)
    }

    let label: CaseLabel
    let content: CaseContent
}

class CaseLabel extends SyntaxNode {

    function accept(mutable visitor: Visitor) {
    }

}

class ItemCaseLabel extends CaseLabel {

    constructor(pattern: Pattern, additionalPatterns: CaseItem[], start: Position, end: Position) {
        this.start = start
        this.end = end
        this.pattern = pattern
        this.additionalPatterns = additionalPatterns
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openItemCaseLabel(this)
            return
        pattern.accept(visitor)
        if additionalPatterns != null {
            for node: CaseItem in additionalPatterns
                node.accept(visitor)
        }
        visitor.closeItemCaseLabel(this)
    }

    let pattern: Pattern
    let additionalPatterns: CaseItem[]
}

class DefaultCaseLabel extends CaseLabel {

    constructor(start: Position, end: Position) {
        this.start = start
        this.end = end
    }

    function accept(mutable visitor: Visitor) {
        visitor.visitDefaultCaseLabel(this)
    }

}

class CaseItem extends SyntaxNode {

    constructor(pattern: Pattern, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.pattern = pattern
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openCaseItem(this)
            return
        pattern.accept(visitor)
        visitor.closeCaseItem(this)
    }

    let pattern: Pattern
}

class CaseContent extends SyntaxNode {

    constructor(statements: Statement[], start: Position, end: Position) {
        this.start = start
        this.end = end
        this.statements = statements
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openCaseContent(this)
            return
        if statements != null {
            for node: Statement in statements
                node.accept(visitor)
        }
        visitor.closeCaseContent(this)
    }

    let statements: Statement[]
}

class ForExpression extends PrimaryExpression {

    constructor(pattern: IdentifierPattern, expression: Expression, code: Expression, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.pattern = pattern
        this.expression = expression
        this.code = code
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openForExpression(this)
            return
        pattern.accept(visitor)
        expression.accept(visitor)
        code.accept(visitor)
        visitor.closeForExpression(this)
    }

    let pattern: IdentifierPattern
    let expression: Expression
    let code: Expression
}

class WhileExpression extends PrimaryExpression {

    constructor(condition: Expression, code: Expression, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.condition = condition
        this.code = code
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openWhileExpression(this)
            return
        condition.accept(visitor)
        code.accept(visitor)
        visitor.closeWhileExpression(this)
    }

    let condition: Expression
    let code: Expression
}

class DoExpression extends PrimaryExpression {

    constructor(code: Expression, condition: Expression, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.code = code
        this.condition = condition
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openDoExpression(this)
            return
        code.accept(visitor)
        condition.accept(visitor)
        visitor.closeDoExpression(this)
    }

    let code: Expression
    let condition: Expression
}

class ParenthesizedExpression extends PrimaryExpression {

    constructor(expressionElements: ExpressionElement[], start: Position, end: Position) {
        this.start = start
        this.end = end
        this.expressionElements = expressionElements
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openParenthesizedExpression(this)
            return
        if expressionElements != null {
            for node: ExpressionElement in expressionElements
                node.accept(visitor)
        }
        visitor.closeParenthesizedExpression(this)
    }

    let expressionElements: ExpressionElement[]
}

class ExpressionElement extends SyntaxNode {

    constructor(expression: Expression, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.expression = expression
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openExpressionElement(this)
            return
        expression.accept(visitor)
        visitor.closeExpressionElement(this)
    }

    let expression: Expression
}

class ReturnExpression extends PrimaryExpression {

    constructor(expression: ParenthesizedExpression, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.expression = expression
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openReturnExpression(this)
            return
        if expression != null
            expression.accept(visitor)
        visitor.closeReturnExpression(this)
    }

    let expression: ParenthesizedExpression
}

class ThrowExpression extends PrimaryExpression {

    constructor(error: IdentifierExpression, arguments: ParenthesizedExpression, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.error = error
        this.arguments = arguments
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openThrowExpression(this)
            return
        error.accept(visitor)
        if arguments != null
            arguments.accept(visitor)
        visitor.closeThrowExpression(this)
    }

    let error: IdentifierExpression
    let arguments: ParenthesizedExpression
}

class BreakExpression extends PrimaryExpression {

    constructor(expression: ParenthesizedExpression, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.expression = expression
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openBreakExpression(this)
            return
        if expression != null
            expression.accept(visitor)
        visitor.closeBreakExpression(this)
    }

    let expression: ParenthesizedExpression
}

class ConstructorCall extends PrimaryExpression {

    constructor(typeToConstruct: Type, arguments: ParenthesizedExpression, catchClauses: CatchClause[], start: Position, end: Position) {
        this.start = start
        this.end = end
        this.typeToConstruct = typeToConstruct
        this.arguments = arguments
        this.catchClauses = catchClauses
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openConstructorCall(this)
            return
        typeToConstruct.accept(visitor)
        arguments.accept(visitor)
        if catchClauses != null {
            for node: CatchClause in catchClauses
                node.accept(visitor)
        }
        visitor.closeConstructorCall(this)
    }

    let typeToConstruct: Type
    let arguments: ParenthesizedExpression
    let catchClauses: CatchClause[]
}

class ThisExpression extends PrimaryExpression {

    constructor(start: Position, end: Position) {
        this.start = start
        this.end = end
    }

    function accept(mutable visitor: Visitor) {
        visitor.visitThisExpression(this)
    }

}

class NullExpression extends PrimaryExpression {

    constructor(start: Position, end: Position) {
        this.start = start
        this.end = end
    }

    function accept(mutable visitor: Visitor) {
        visitor.visitNullExpression(this)
    }

}

class Postfix extends SyntaxNode {

    function accept(mutable visitor: Visitor) {
    }

}

class OperatorPostfix extends Postfix {

    constructor(postfixOperator: string, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.postfixOperator = postfixOperator
    }

    function accept(mutable visitor: Visitor) {
        visitor.visitOperatorPostfix(this)
    }

    let postfixOperator: string
}

class FunctionCall extends Postfix {

    constructor(arguments: ParenthesizedExpression, catchClauses: CatchClause[], start: Position, end: Position) {
        this.start = start
        this.end = end
        this.arguments = arguments
        this.catchClauses = catchClauses
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openFunctionCall(this)
            return
        arguments.accept(visitor)
        if catchClauses != null {
            for node: CatchClause in catchClauses
                node.accept(visitor)
        }
        visitor.closeFunctionCall(this)
    }

    let arguments: ParenthesizedExpression
    let catchClauses: CatchClause[]
}

class CatchClause extends SyntaxNode {

    constructor(catchPattern: CatchPattern, bindingPattern: TuplePattern, expression: Expression, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.catchPattern = catchPattern
        this.bindingPattern = bindingPattern
        this.expression = expression
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openCatchClause(this)
            return
        catchPattern.accept(visitor)
        if bindingPattern != null
            bindingPattern.accept(visitor)
        expression.accept(visitor)
        visitor.closeCatchClause(this)
    }

    let catchPattern: CatchPattern
    let bindingPattern: TuplePattern
    let expression: Expression
}

class CatchPattern extends SyntaxNode {

    function accept(mutable visitor: Visitor) {
    }

}

class WildCardCatchPattern extends CatchPattern {

    constructor(pattern: WildcardPattern, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.pattern = pattern
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openWildCardCatchPattern(this)
            return
        pattern.accept(visitor)
        visitor.closeWildCardCatchPattern(this)
    }

    let pattern: WildcardPattern
}

class IdentifierCatchPattern extends CatchPattern {

    constructor(name: string, member: MemberExpression, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.name = name
        this.member = member
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openIdentifierCatchPattern(this)
            return
        if member != null
            member.accept(visitor)
        visitor.closeIdentifierCatchPattern(this)
    }

    let name: string
    let member: MemberExpression
}

class WildcardPattern extends Pattern {

    constructor(start: Position, end: Position) {
        this.start = start
        this.end = end
    }

    function accept(mutable visitor: Visitor) {
        visitor.visitWildcardPattern(this)
    }

}

class TuplePattern extends Pattern {

    constructor(elements: TuplePatternElement[], start: Position, end: Position) {
        this.start = start
        this.end = end
        this.elements = elements
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openTuplePattern(this)
            return
        if elements != null {
            for node: TuplePatternElement in elements
                node.accept(visitor)
        }
        visitor.closeTuplePattern(this)
    }

    let elements: TuplePatternElement[]
}

class TuplePatternElement extends SyntaxNode {

    constructor(pattern: Pattern, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.pattern = pattern
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openTuplePatternElement(this)
            return
        pattern.accept(visitor)
        visitor.closeTuplePatternElement(this)
    }

    let pattern: Pattern
}

class ExpressionPattern extends Pattern {

    constructor(expression: Expression, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.expression = expression
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openExpressionPattern(this)
            return
        expression.accept(visitor)
        visitor.closeExpressionPattern(this)
    }

    let expression: Expression
}

class MemberExpression extends Postfix {

    constructor(member: string, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.member = member
    }

    function accept(mutable visitor: Visitor) {
        visitor.visitMemberExpression(this)
    }

    let member: string
}

class Subscript extends Postfix {

    constructor(expressions: ExpressionElement[], start: Position, end: Position) {
        this.start = start
        this.end = end
        this.expressions = expressions
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openSubscript(this)
            return
        if expressions != null {
            for node: ExpressionElement in expressions
                node.accept(visitor)
        }
        visitor.closeSubscript(this)
    }

    let expressions: ExpressionElement[]
}

class BinaryExpression extends SyntaxNode {

    function accept(mutable visitor: Visitor) {
    }

}

class BinaryOperation extends BinaryExpression {

    constructor(binaryOperator: string, expression: PrefixExpression, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.binaryOperator = binaryOperator
        this.expression = expression
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openBinaryOperation(this)
            return
        expression.accept(visitor)
        visitor.closeBinaryOperation(this)
    }

    let binaryOperator: string
    let expression: PrefixExpression
}

class Assignment extends BinaryExpression {

    constructor(expression: Expression, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.expression = expression
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openAssignment(this)
            return
        expression.accept(visitor)
        visitor.closeAssignment(this)
    }

    let expression: Expression
}

class TypeQuery extends BinaryExpression {

    constructor(objectType: Type, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.objectType = objectType
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openTypeQuery(this)
            return
        objectType.accept(visitor)
        visitor.closeTypeQuery(this)
    }

    let objectType: Type
}

class TypeCast extends BinaryExpression {

    constructor(objectType: Type, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.objectType = objectType
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openTypeCast(this)
            return
        objectType.accept(visitor)
        visitor.closeTypeCast(this)
    }

    let objectType: Type
}
