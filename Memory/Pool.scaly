use Memory.Bucket
use Memory.Bucket.'bucket pages'
use Memory.Bucket.Heap
use Memory.Page
use Memory.Page.'page size'
use Memory.Allocation.allocate
use Memory.Allocation.free
use Memory.Allocation.'size of'

define Pool
(
    map: 'size type',
    private heap: pointer[Heap]
)
{
    function create(heap: pointer[Heap]) returns pointer[Pool]
    {
        var pool: pointer[Pool] null
        let 'pointer address' pool &.'cast to'[pointer[pointer[void]]]()
        let 'pool alignment' 'page size' * 'bucket pages'
        let 'pool size' 'pool alignment' * 'bucket pages'
        allocate('pointer address', 'pool size', 'pool alignment')
        ; println!("Pool memory: {:X}.", pool as usize)
        ;if pool = null
        ;    panic("Unable to create pool: Out of memory.")

        for i in from 0 to 'bucket pages'
        {
            let 'bucket page' pool.'cast to'['size type'] + 'pool alignment' * i.'cast to'[pointer[Page]]()
            ; println!("Bucket page: {}, {:X}.", i, bucket_page as usize)
            'bucket page'*.reset()
            let bucket = 'bucket page'*.allocate(Bucket.Heap(pool: null, map: 'size type'.'maximum value'))
            ; println!("Bucket initialized: {:X}.", bucket as usize)
            if i = 0
            {
                pool = 'bucket page'.allocate(Pool(map: 'size type'.'maximum value', heap: heap))
                ; println!("Pool object: {:X}.", pool as usize);
                ; println!("Pool map after creation: {:X}.", (*pool).map);
            }
            set bucket*.'cast to'[Bucket.Heap]().pool: pool
        }
        pool
    }
;*
    pub fn allocate_page(&mut self) -> *mut Page {
        // println!("Pool map before allocation: {:X}.", self.map);
        if self.map == 0 {
            unsafe {
                (*self.heap).mark_as_full(self);
                return (*self.heap).allocate_page();
            };
        }
        let pool_page_address = Page::get(self as *const Pool as usize) as usize;
        // println!("Pool page address: {:X}.", pool_page_address);
        let bucket_page_address = {
            let position = Bucket::find_least_position(self.map);
            // println!("Pool least position: {}.", position);
            pool_page_address + PAGE_SIZE * BUCKET_PAGES * (position - 1)
        };
        // println!("Bucket page address: {:X}.", bucket_page_address);
        let bucket = (bucket_page_address + size_of::<Page>()) as *mut Bucket;
        // println!("Bucket address: {:X}.", bucket as usize);
        unsafe { (*bucket).allocate_page() }
    }

    fn get_allocation_bit(&self, page: usize) -> usize {
        let first_bucket_address = Page::get(self as *const Pool as usize) as usize;
        let distance = page - first_bucket_address;
        let position = distance / PAGE_SIZE / BUCKET_PAGES;
        1 << (BUCKET_PAGES - 1 - position)
    }

    pub fn mark_as_full(&mut self, page: usize) {
        let bit = self.get_allocation_bit(page);
        // println!("Pool bit to be marked as full: {:X}", bit);
        self.map = self.map & !bit;
    }

    pub fn mark_as_free(&mut self, page: usize) {
        let bit = self.get_allocation_bit(page);
        // println!("Pool bit to be marked as free: {:X}", bit);
        let old_map = self.map;
        self.map = self.map | bit;
        if old_map == 0 {
            unsafe {
                (*self.heap).mark_as_free(self);
            }
        }
    }

    pub fn deallocate(&mut self) {
        if self.map != MAX {
            panic!("Pool is not empty!")
        }
        unsafe {
            // println!(
            //     "Pool: dealloc {:X}",
            //     Page::get(self as *const Pool as usize) as usize
            // );
            dealloc(
                Page::get(self as *const Pool as usize) as *mut u8,
                Layout::from_size_align(
                    PAGE_SIZE * BUCKET_PAGES * BUCKET_PAGES,
                    PAGE_SIZE * BUCKET_PAGES,
                )
                .unwrap(),
            );
        }
    }
*;
}
