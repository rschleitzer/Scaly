use scaly.memory.Page
use scaly.memory.runtime

define VectorIterator[T]
(
    vector: pointer[Vector[T]]
    position: size_t
)
{
    init (v: pointer[Vector[T]])
    {
        set vector: v
        set position: 0
    }

    function next(this: VectorIterator[T]) returns pointer[T]
    {
        if vector = null
            return null

        if position = vector.length
            return null

        set position: position + 1
        return vector.get(position - 1)
    }
}

define Vector[T]
(
    length: size_t
    data: pointer[T]
)
{
    init ()
    {
        set length: 0
        set data: null
    }

    init (d: pointer[T], len: size_t)
    {
        set length: len
        set data: d
    }

    init#(rp, len: size_t)
    {
        set length: len
        if len > 0
        {
            set data: rp.allocate(len * sizeof T, alignof T) as pointer[T]
            memset(data, 0, len * sizeof T)
        }
        else
            set data: null
    }

    init#(rp, arr: pointer[T], len: size_t)
    {
        set length: len
        if len > 0
        {
            set data: rp.allocate(len * sizeof T, alignof T) as pointer[T]
            memcpy(data, arr, len * sizeof T)
        }
        else
            set data: null
    }

    init#(rp, other: Vector[T])
    {
        set length: other.length
        if length > 0
        {
            set data: rp.allocate(length * sizeof T, alignof T) as pointer[T]
            memcpy(data, other.data, length * sizeof T)
        }
        else
            set data: null
    }

    init#(rp, array: Array[T])
    {
        set length: array.length
        if length > 0
        {
            set data: rp.allocate(length * sizeof T, alignof T) as pointer[T]
            let arr_vector array.vector
            memcpy(data, arr_vector.data, length * sizeof T)
        }
        else
            set data: null
    }

    init#(rp, list: List[T])
    {
        set length: list.count()
        if length > 0
        {
            set data: rp.allocate(length * sizeof T, alignof T) as pointer[T]
            var list_iterator list.get_iterator()
            var i: size_t length
            while let item list_iterator.next()
            {
                set i: i - 1
                set *(data + i): *item
            }
        }
        else
            set data: null
    }

    function get(this: Vector[T], i: size_t) returns pointer[T]
    {
        if i >= length
            return null
        data + i
    }

    function put(this: Vector[T], i: size_t, item: T) returns bool
    {
        if i >= length
            return false
        set *(data + i): item
        true
    }

    operator [](i: size_t) returns pointer[T]
    {
        if i >= length
            return null
        data + i
    }

    function get_iterator(this: Vector[T]) returns VectorIterator[T]
        VectorIterator[T](this)

    function as_slice(this: Vector[T]) returns Slice[T]
        Slice[T](data, length)
}
