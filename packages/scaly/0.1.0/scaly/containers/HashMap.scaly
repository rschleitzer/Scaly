define HashMapIterator[K, V]
(
    slot_iterator: VectorIterator[Vector[KeyValuePair[K, V]]]
    element_iterator: VectorIterator[KeyValuePair[K, V]]
)
{
    init (hash_map: HashMap[K, V])
    {
        set slot_iterator: VectorIterator[Vector[KeyValuePair[K, V]]](hash_map.slots)
        let first_slot slot_iterator.next()
        if first_slot <> null
            set element_iterator: VectorIterator[KeyValuePair[K, V]](first_slot)
    }

    function next(this: HashMapIterator[K, V]) returns pointer[V]
    {
        while true
        {
            let ret element_iterator.next()
            if ret <> null
                return &ret.value

            let next_slot slot_iterator.next()
            if next_slot = null
                return null

            set element_iterator: VectorIterator[KeyValuePair[K, V]](next_slot)
        }
    }
}

define HashMap[K, V]
(
    slots: pointer[Vector[Vector[KeyValuePair[K, V]]]] (null)
)
{
    init# (rp, hash_map_builder: HashMapBuilder[K, V])
    {
        if hash_map_builder.length = 0
        {
            set slots: null
            return
        }

        set slots: Vector[Vector[KeyValuePair[K, V]]]^rp(hash_map_builder.slots.length)
        let length hash_map_builder.slots.length
        var i: size_t 0
        while i < length
        {
            var array Array[KeyValuePair[K, V]]$()
            let slot_ptr hash_map_builder.slots.get_ptr(i)
            if slot_ptr <> null
            {
                var list_iterator ListIterator[Slot[KeyValuePair[K, V]]](slot_ptr.head)
                while let item list_iterator.next()
                    array.add(item.value)
            }
            if array.length > 0
                slots.put(i, Vector[KeyValuePair[K, V]]^rp(*array))

            set i: i + 1
        }
    }

    function contains(this: HashMap[K, V], key: K) returns bool
    {
        if slots = null
            return false

        let hash key.hash()
        let slot_number hash % slots.length
        let slot_ref slots.get_ptr(slot_number)
        if slot_ref = null
            return false
        let slot *slot_ref
        let length slot.length
        var i: size_t 0
        while i < length
        {
            let item slot.get_ptr(i)
            if item <> null
            {
                if key.equals(item.key)
                    return true
            }

            set i: i + 1
        }

        return false
    }

    operator [](key: K) returns ref[V]?
    {
        return get(key)
    }

    function get(this: HashMap[K, V], key: K) returns ref[V]?
    {
        if slots = null
            return null

        let hash key.hash()
        let slot_number hash % slots.length
        let slot_ref slots.get_ptr(slot_number)
        if slot_ref = null
            return null
        let slot *slot_ref
        let length slot.length
        var i: size_t 0
        while i < length
        {
            let item slot.get_ptr(i)
            if item <> null
            {
                if key.equals(item.key)
                    return &item.value
            }

            set i: i + 1
        }

        return null
    }
}
