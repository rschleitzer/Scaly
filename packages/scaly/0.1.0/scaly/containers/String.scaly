use scaly.memory.Page
use scaly.memory.runtime

define PACKED_SIZE: int 9

define String (data: pointer[u8](null))
{
    ; Empty string - no page needed
    init()
    {
        set data: null
    }

    init#(page, length: size_t)
    {
        var length_array: u8[PACKED_SIZE]
        var rest length

        var counter: size_t 0
        while rest >= (0x80 as size_t)
        {
            set *(length_array + counter): (rest as u8) | (0x80 as u8)
            set rest: rest >> (7 as size_t)
            set counter: counter + (1 as size_t)
        }

        set *(length_array + counter): rest as u8
        let overall_length counter + (1 as size_t) + length
        set data: page.allocate(overall_length, 1) as pointer[u8]
        memcpy(data, length_array, counter + (1 as size_t))
    }

    init#(page, other: pointer[const_char], length: size_t)
    {
        if length = (0 as size_t)
        {
            set data: null
            return
        }

        var length_array: u8[PACKED_SIZE]
        var rest length

        var counter: size_t 0
        while rest >= (0x80 as size_t)
        {
            set *(length_array + counter): (rest as u8) | (0x80 as u8)
            set rest: rest >> (7 as size_t)
            set counter: counter + (1 as size_t)
        }

        set *(length_array + counter): rest as u8
        let overall_length counter + (1 as size_t) + length
        set data: page.allocate(overall_length, 1) as pointer[u8]
        memcpy(data, length_array, counter + (1 as size_t))
        memcpy((data + counter + (1 as size_t)) as pointer[void], other, length)
    }

    init#(page, other: Vector[char])
    {
        ; Delegate to String(page, pointer, length)
        var length_array: u8[PACKED_SIZE]
        var rest other.length

        var counter: size_t 0
        while rest >= (0x80 as size_t)
        {
            set *(length_array + counter): (rest as u8) | (0x80 as u8)
            set rest: rest >> (7 as size_t)
            set counter: counter + (1 as size_t)
        }

        set *(length_array + counter): rest as u8
        let overall_length counter + (1 as size_t) + other.length
        set data: page.allocate(overall_length, 1) as pointer[u8]
        memcpy(data, length_array, counter + (1 as size_t))
        if other.length > 0
            memcpy((data + counter + (1 as size_t)) as pointer[void], other.data, other.length)
    }

    init#(page, c_string: pointer[const_char])
    {
        let length strlen(c_string)
        if length = (0 as size_t)
        {
            set data: null
            return
        }

        var length_array: u8[PACKED_SIZE]
        var rest length

        var counter: size_t 0
        while rest >= (0x80 as size_t)
        {
            set *(length_array + counter): (rest as u8) | (0x80 as u8)
            set rest: rest >> (7 as size_t)
            set counter: counter + (1 as size_t)
        }

        set *(length_array + counter): rest as u8
        let overall_length counter + (1 as size_t) + length
        set data: page.allocate(overall_length, 1) as pointer[u8]
        memcpy(data, length_array, counter + (1 as size_t))
        memcpy((data + counter + (1 as size_t)) as pointer[void], c_string, length)
    }

    init#(page, other: String)
    {
        if other.data = null
        {
            set data: null
            return
        }

        var length: size_t 0
        var bit_count: size_t 0
        var index 0
        while true
        {
            if bit_count = (PACKED_SIZE * 7) as size_t
                ; Bad string length
                exit(12)

            let byte *(other.data + index)
            set length: length | ((byte & (0x7F as u8)) as size_t) << bit_count
            if (byte & (0x80 as u8)) = (0 as u8)
                break;

            set bit_count: bit_count + (7 as size_t)
            set index: index + (1 as size_t)
        }
        var overall_length index + (1 as size_t) + length
        set data: page.allocate(overall_length, 1) as pointer[u8]
        memcpy(data, other.data, overall_length)
    }

    init#(page, character: u8)
    {
        set data: page.allocate(2, 1) as pointer[u8]
        set *data: 1
        set *(data + 1): character
    }

    function get_buffer(this: String) returns pointer[u8]
    {
        if data = null
            return null

        var length: size_t 0
        var bit_count: size_t 0
        var index: size_t 0
        while true
        {
            if bit_count = (PACKED_SIZE * 7) as size_t
                exit(11)

            var byte: u8 *(data + index)
            set length: length | ((byte & (0x7F as u8)) as size_t) << bit_count
            if (byte & (0x80 as u8)) = (0 as u8)
                break
            set bit_count: bit_count + (7 as size_t)
            set index: index + (1 as size_t)
        }

        data + index + (1 as size_t)
    }

    ; Returns raw buffer pointer for C interop (cast of get_buffer)
    function c_data(this: String) returns pointer[const_char]
        get_buffer() as pointer[const_char]

    function to_c_string#(page, this: String) returns pointer[const_char]
    {
        var length: size_t 0
        var bit_count: size_t 0
        var index: size_t 0
        if data <> null
        {
            while true
            {
                if bit_count = (PACKED_SIZE * 7) as size_t
                    exit(11)

                var byte: u8 *(data + index)
                set length: length | ((byte & (0x7F as u8)) as size_t) << bit_count
                if (byte & (0x80 as u8)) = (0 as u8)
                    break
                set bit_count: bit_count + (7 as size_t)
                set index: index + (1 as size_t)
            }
        }

        var dest page.allocate(length + (1 as size_t), (1 as size_t))
        if data <> null
            memcpy(dest, data + index + (1 as size_t), length)
        set *(dest as pointer[u8] + index + length): (0 as u8)

        dest as pointer[const_char]
    }

    function get_length(this: String) returns size_t
    {
        if data = null
            return 0

        var result: size_t 0
        var bit_count: size_t 0
        var index: size_t 0
        while true
        {
            if bit_count = (PACKED_SIZE * 7) as size_t
                exit(11)

            var byte: u8 *(data + index)
            set result: result | (((byte & (0x7F as u8)) as size_t)) << bit_count
            if (byte & (0x80 as u8)) = (0 as u8)
                break
            set bit_count: bit_count + (7 as size_t)
            set index: index + (1 as size_t)
        }
        result
    }

    function get(this: String, index: size_t) returns u8
    {
        let buffer get_buffer()
        *(buffer + index)
    }

    function length(this: String) returns size_t
        get_length()

    function substring(this: String, page: pointer[Page], start: size_t, len: size_t) returns String
        String^page(get_buffer() + start, len)

    function equals(this: String, other: String) returns bool
    {
        var length: size_t 0
        var index: size_t 0
        if data <> null
        {
            var bit_count: size_t 0
            while true
            {
                if bit_count = (PACKED_SIZE * 7) as size_t
                    exit(11)

                var byte: u8 *(data + index)
                set length: length | (((byte & (0x7F as u8)) as size_t)) << bit_count
                if (byte & (0x80 as u8)) = (0 as u8)
                    break
                set bit_count: bit_count + (7 as size_t)
                set index: index + (1 as size_t)
            }
        }

        if length <> other.get_length()
            return false

        if data = null
            return true

        memcmp(data + index + (1 as size_t), other.data + index + (1 as size_t), length) = 0
    }

    function equals(this: String, other: pointer[const_char]) returns bool
    {
        var length: size_t 0
        var index: size_t 0
        if data <> null
        {
            var bit_count: size_t 0
            while true
            {
                if bit_count = (PACKED_SIZE * 7) as size_t
                    exit(13)

                var byte: u8 *(data + index)
                set length: length | (((byte & (0x7F as u8)) as size_t)) << bit_count
                if (byte & (0x80 as u8)) = (0 as u8)
                    break
                set bit_count: bit_count + (7 as size_t)
                set index: index + (1 as size_t)
            }
        }

        if length <> strlen(other)
            return false

        if data = null
            return true

        memcmp(data + index + (1 as size_t), other, length) = 0
    }

    function equals (this: String, other: Vector[char]) returns bool
    {
        var length: size_t 0
        var bit_count: size_t 0
        var index: size_t 0
        while true
        {
            if bit_count = (PACKED_SIZE * 7) as size_t
                exit(11)

            var byte: u8 *(data + index)
            set length: length | (((byte & (0x7F as u8)) as size_t)) << bit_count
            if (byte & (0x80 as u8)) = (0 as u8)
                break
            set bit_count: bit_count + (7 as size_t)
            set index: index + (1 as size_t)
        }

        if length <> other.length
            return false

        memcmp(data + index + (1 as size_t), other.data, length) = 0
    }

    function hash(this: String) returns size_t
    {
        var length: size_t 0
        var bit_count: size_t 0
        var index: size_t 0
        while true
        {
            if bit_count = (PACKED_SIZE * 7) as size_t
                exit(11)

            var byte: u8 *(data + index)
            set length: length | (((byte & (0x7F as u8)) as size_t)) << bit_count
            if (byte & (0x80 as u8)) = (0 as u8)
                break
            set bit_count: bit_count + (7 as size_t)
            set index: index + (1 as size_t)
        }

        hashing.hash(data + index + (1 as size_t), length)
    }

    function get_iterator(this: String) returns StringIterator
        StringIterator(this)

    ; Get a non-owning slice view of the string data
    function as_slice(this: String) returns Slice[u8]
    {
        if data = null
            return Slice[u8]()

        ; Decode length and find where actual chars start
        var string_length: size_t 0
        var bit_count: size_t 0
        var index: size_t 0
        while true
        {
            if bit_count = (PACKED_SIZE * 7) as size_t
                exit(11)

            var byte: u8 *(data + index)
            set string_length: string_length | (((byte & (0x7F as u8)) as size_t)) << bit_count
            if (byte & (0x80 as u8)) = (0 as u8)
                break
            set bit_count: bit_count + (7 as size_t)
            set index: index + (1 as size_t)
        }

        Slice[u8](data + index + (1 as size_t), string_length)
    }

    ; Check if string contains a character
    function contains(this: String, c: u8) returns bool
    {
        let buf get_buffer()
        if buf = null
            return false
        let len get_length()
        var i: size_t 0
        while i < len
        {
            if *(buf + i) = c
                return true
            set i: i + 1
        }
        false
    }

    ; Check if string contains a substring
    function contains(this: String, other: String) returns bool
    {
        let this_len get_length()
        let other_len other.get_length()
        if other_len = 0
            return true
        if other_len > this_len
            return false

        let buf get_buffer()
        let other_buf other.get_buffer()
        var i: size_t 0
        while i <= this_len - other_len
        {
            if memcmp(buf + i, other_buf, other_len) = 0
                return true
            set i: i + 1
        }
        false
    }

    ; Check if string starts with prefix
    function starts_with(this: String, prefix: String) returns bool
    {
        let this_len get_length()
        let prefix_len prefix.get_length()
        if prefix_len > this_len
            return false
        if prefix_len = 0
            return true

        let buf get_buffer()
        let prefix_buf prefix.get_buffer()
        memcmp(buf, prefix_buf, prefix_len) = 0
    }

    ; Check if string starts with C string prefix
    function starts_with(this: String, prefix: pointer[const_char]) returns bool
    {
        let this_len get_length()
        let prefix_len strlen(prefix)
        if prefix_len > this_len
            return false
        if prefix_len = 0
            return true

        let buf get_buffer()
        memcmp(buf, prefix, prefix_len) = 0
    }

    ; Check if string ends with suffix
    function ends_with(this: String, suffix: String) returns bool
    {
        let this_len get_length()
        let suffix_len suffix.get_length()
        if suffix_len > this_len
            return false
        if suffix_len = 0
            return true

        let buf get_buffer()
        let suffix_buf suffix.get_buffer()
        memcmp(buf + this_len - suffix_len, suffix_buf, suffix_len) = 0
    }

    ; Check if string ends with C string suffix
    function ends_with(this: String, suffix: pointer[const_char]) returns bool
    {
        let this_len get_length()
        let suffix_len strlen(suffix)
        if suffix_len > this_len
            return false
        if suffix_len = 0
            return true

        let buf get_buffer()
        memcmp(buf + this_len - suffix_len, suffix, suffix_len) = 0
    }

    ; Find first occurrence of character, returns -1 if not found
    function index_of(this: String, c: u8) returns int
    {
        let buf get_buffer()
        if buf = null
            return -1
        let len get_length()
        var i: size_t 0
        while i < len
        {
            if *(buf + i) = c
                return i as int
            set i: i + 1
        }
        -1
    }

    ; Find first occurrence of character starting at offset, returns -1 if not found
    function index_of(this: String, c: u8, start: size_t) returns int
    {
        let buf get_buffer()
        if buf = null
            return -1
        let len get_length()
        if start >= len
            return -1
        var i start
        while i < len
        {
            if *(buf + i) = c
                return i as int
            set i: i + 1
        }
        -1
    }

    ; Find last occurrence of character, returns -1 if not found
    function last_index_of(this: String, c: u8) returns int
    {
        let buf get_buffer()
        if buf = null
            return -1
        let len get_length()
        if len = 0
            return -1
        var i len - 1
        while i >= 0
        {
            if *(buf + i) = c
                return i as int
            if i = 0
                break
            set i: i - 1
        }
        -1
    }
}
