use scaly.memory.Page

define PACKED_SIZE: int 9

define String (data: pointer[char](null))
{
    ; Empty string - no page needed
    init()
    {
        set data: null
    }

    init#(page, length: size_t)
    {
        var length_array: char[PACKED_SIZE]
        var rest length

        var counter: size_t 0
        while rest >= 0x80
        {
            set *(length_array + counter): (rest as char) | 0x80
            set rest: rest >> 7
            set counter: counter + 1
        }

        set *(length_array + counter): rest as char
        let overall_length counter + 1 + length
        set data: page.allocate(overall_length, 1) as pointer[char]
        memcpy(data, length_array, counter + 1)
    }

    init#(page, other: pointer[const_char], length: size_t)
    {
        if length = 0
        {
            set data: null
            return
        }

        var length_array: char[PACKED_SIZE]
        var rest length

        var counter: size_t 0
        while rest >= 0x80
        {
            set *(length_array + counter): (rest as char) | 0x80
            set rest: rest >> 7
            set counter: counter + 1
        }

        set *(length_array + counter): rest as char
        let overall_length counter + 1 + length
        set data: page.allocate(overall_length, 1) as pointer[char]
        memcpy(data, length_array, counter + 1)
        memcpy((data + counter + 1) as pointer[void], other, length)
    }

    init#(page, other: Vector[char])
    {
        ; Delegate to String(page, pointer, length)
        var length_array: char[PACKED_SIZE]
        var rest other.length

        var counter: size_t 0
        while rest >= 0x80
        {
            set *(length_array + counter): (rest as char) | 0x80
            set rest: rest >> 7
            set counter: counter + 1
        }

        set *(length_array + counter): rest as char
        let overall_length counter + 1 + other.length
        set data: page.allocate(overall_length, 1) as pointer[char]
        memcpy(data, length_array, counter + 1)
        if other.length > 0
            memcpy((data + counter + 1) as pointer[void], other.data, other.length)
    }

    init#(page, c_string: pointer[const_char])
    {
        let length strlen(c_string)
        if length = 0
        {
            set data: null
            return
        }

        var length_array: char[PACKED_SIZE]
        var rest length

        var counter: size_t 0
        while rest >= 0x80
        {
            set *(length_array + counter): (rest as char) | 0x80
            set rest: rest >> 7
            set counter: counter + 1
        }

        set *(length_array + counter): rest as char
        let overall_length counter + 1 + length
        set data: page.allocate(overall_length, 1) as pointer[char]
        memcpy(data, length_array, counter + 1)
        memcpy((data + counter + 1) as pointer[void], c_string, length)
    }

    init#(page, other: String)
    {
        if other.data = null
        {
            set data: null
            return
        }

        var length: size_t 0
        var bit_count 0
        var index 0
        while true
        {
            if bit_count = PACKED_SIZE * 7
                ; Bad string length
                exit(12)

            let byte *(other.data + index)
            set length: length | ((byte & 0x7F) as size_t) << bit_count
            if (byte & 0x80) = 0
                break;

            set bit_count: bit_count + 7
            set index: index + 1
        }
        var overall_length index + 1 + length
        set data: page.allocate(overall_length, 1) as pointer[char]
        memcpy(data, other.data, overall_length)
    }

    init#(page, character: char)
    {
        set data: page.allocate(2, 1) as pointer[char]
        set *data: 1
        set *(data + 1): character
    }

    function get_buffer(this: String) returns pointer[char]
    {
        if data = null
            return null

        var length: size_t 0
        var bit_count 0
        var index: size_t 0
        while true
        {
            if bit_count = PACKED_SIZE * 7
                exit(11)

            var byte: char *(data + index)
            set length: length | ((byte & 0x7F) as size_t) << bit_count
            if (byte & 0x80) == 0
                break
            set bit_count: bit_count + 7
            set index: index + 1
        }

        data + index + 1
    }

    function to_c_string#(page, this: String) returns pointer[const_char]
    {
        var length: size_t 0
        var bit_count 0
        var index: size_t 0
        if data <> null
        {
            while true
            {
                if bit_count = PACKED_SIZE * 7
                    exit(11)

                var byte: char *(data + index)
                set length: length | ((byte & 0x7F) as size_t) << bit_count
                if (byte & 0x80) == 0
                    break
                set bit_count: bit_count + 7
                set index: index + 1
            }
        }

        var dest page.allocate(length + 1, 1)
        if data <> null
            memcpy(dest, data + index + 1, length)
        set *(dest as pointer[char] + index + length): 0

        dest as pointer[const_char]
    }

    function get_length(this: String) returns size_t
    {
        if data = null
            return 0

        var result: size_t 0
        var bit_count 0
        var index: size_t 0
        while true
        {
            if bit_count = PACKED_SIZE * 7
                exit(11)

            var byte: char *(data + index)
            set result: result | (((byte & 0x7F) as size_t)) << bit_count
            if (byte & 0x80) == 0
                break
            set bit_count: bit_count + 7
            set index: index + 1
        }
        result
    }

    function get(this: String, index: size_t) returns char
    {
        let buffer get_buffer()
        *(buffer + index)
    }

    function length(this: String) returns size_t
        get_length()

    function substring(this: String, page: pointer[Page], start: size_t, len: size_t) returns String
        String^page(get_buffer() + start, len)

    function equals(this: String, other: String) returns bool
    {
        var length: size_t 0
        var index: size_t 0
        if data <> null
        {
            var bit_count 0
            while true
            {
                if bit_count = PACKED_SIZE * 7
                    exit(11)

                var byte: char *(data + index)
                set length: length | (((byte & 0x7F) as size_t)) << bit_count
                if (byte & 0x80) == 0
                    break
                set bit_count: bit_count + 7
                set index: index + 1
            }
        }

        if length <> other.get_length()
            return false

        if data = null
            return true

        memcmp(data + index + 1, other.data + index + 1, length) = 0
    }

    function equals(this: String, other: pointer[const_char]) returns bool
    {
        var length: size_t 0
        var index: size_t 0
        if data <> null
        {
            var bit_count 0
            while true
            {
                if bit_count = PACKED_SIZE * 7
                    exit(13)

                var byte: char *(data + index)
                set length: length | (((byte & 0x7F) as size_t)) << bit_count
                if (byte & 0x80) == 0
                    break
                set bit_count: bit_count + 7
                set index: index + 1
            }
        }

        if length <> strlen(other)
            return false

        if data = null
            return true

        memcmp(data + index + 1, other, length) = 0
    }

    function equals (this: String, other: Vector[char]) returns bool
    {
        var length: size_t 0
        var bit_count 0
        var index: size_t 0
        while true
        {
            if bit_count = PACKED_SIZE * 7
                exit(11)

            var byte: char *(data + index)
            set length: length | (((byte & 0x7F) as size_t)) << bit_count
            if (byte & 0x80) == 0
                break
            set bit_count: bit_count + 7
            set index: index + 1
        }

        if length <> other.length
            return false

        memcmp(data + index + 1, other.data, length) = 0
    }

    function hash(this: String) returns size_t
    {
        var length: size_t 0
        var bit_count 0
        var index: size_t 0
        while true
        {
            if bit_count = PACKED_SIZE * 7
                exit(11)

            var byte: char *(data + index)
            set length: length | (((byte & 0x7F) as size_t)) << bit_count
            if (byte & 0x80) == 0
                break
            set bit_count: bit_count + 7
            set index: index + 1
        }

        hashing.hash(data + index + 1, length)
    }

    function get_iterator(this: String) returns StringIterator
        StringIterator(this)

    ; Get a non-owning slice view of the string data
    function as_slice(this: String) returns Slice[char]
    {
        if data = null
            return Slice[char]()

        ; Decode length and find where actual chars start
        var string_length: size_t 0
        var bit_count 0
        var index: size_t 0
        while true
        {
            if bit_count = PACKED_SIZE * 7
                exit(11)

            var byte: char *(data + index)
            set string_length: string_length | (((byte & 0x7F) as size_t)) << bit_count
            if (byte & 0x80) == 0
                break
            set bit_count: bit_count + 7
            set index: index + 1
        }

        Slice[char](data + index + 1, string_length)
    }
}
