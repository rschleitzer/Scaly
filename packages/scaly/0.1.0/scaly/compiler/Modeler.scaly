; Modeler.scaly - Syntax to semantic model transformation
; Ported from C++ Modeler.cpp

use scaly.containers.String
use scaly.containers.Vector
use scaly.compiler.Model
use scaly.compiler.Syntax

; ============================================================================
; Modeler state
; ============================================================================

define Modeler
(
    file: String
    package_search_paths: pointer[Vector[String]]
)
{
    init(file_name: String)
    {
        set file: file_name
        set package_search_paths: null
    }

    procedure add_package_search_path(this: Modeler, path: String)
    {
        ; TODO: implement when Vector mutation is supported
    }
}

; ============================================================================
; Lifetime handling
; ============================================================================

function handle_lifetime(syntax: pointer[LifetimeSyntax]) returns Lifetime
{
    if syntax = null
        return Lifetime.Unspecified(UnspecifiedLifetime())

    let lifetime_syntax (*syntax)
    choose lifetime_syntax
        when call: Call
            Lifetime.Call(CallLifetime(Span(call.start, call.end)))
        when local: Local
            Lifetime.Local(LocalLifetime(Span(local.start, local.end)))
        when ref: Reference
            Lifetime.Reference(ReferenceLifetime(Span(ref.start, ref.end), ref.location))
        when thrown: Thrown
            Lifetime.Thrown(ThrownLifetime(Span(thrown.start, thrown.end)))
        else
            Lifetime.Unspecified(UnspecifiedLifetime())
}

; ============================================================================
; Test function
; ============================================================================

function test() returns int
{
    ; Basic smoke test - just return success
    0
}
