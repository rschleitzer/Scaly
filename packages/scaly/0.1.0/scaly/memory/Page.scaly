define PAGE_SIZE size_t 0x1000

define Page
(
    next_object: pointer[void]
    current_page: pointer[Page]
    next_page: pointer[Page]
    exclusive_pages: PageList
)
{
    function allocate_page() returns pointer[Page]
    {
        var page aligned_alloc(PAGE_SIZE, PAGE_SIZE) as pointer[Page]
        page.reset()
        return page
    }

    function reset(this: Page)
    {
        set current_page: null
        set next_page: null
        set next_object: this + (1 as size_t)
        set exclusive_pages: PageList()
    }

    function allocate(this: Page, size: size_t, align: size_t) returns pointer[void]
    {
        let location next_object as size_t
        let aligned_location (location + align - (1 as size_t)) & (~(align - (1 as size_t)))
        let location_after_page this as size_t + PAGE_SIZE
        let capacity location_after_page - aligned_location

        if capacity < size
        {
            ; We need to reserve the space for the page object
            let gross_size size + sizeof Page
            if gross_size > PAGE_SIZE
                return allocate_oversized(gross_size)

            if current_page <> null
            {
                let object current_page.allocate(size, align)
                let page_of_allocated_object get(object)
                if page_of_allocated_object <> current_page
                    set current_page: page_of_allocated_object
                return object
            }

            var page allocate_page()
            set current_page: page
            set next_page: page
            return page.allocate(size, align)
        }

        ; Allocate from ourselves
        let next_location aligned_location + size
        set next_object: next_location as pointer[void]
        return aligned_location as pointer[void]
    }

    function allocate_oversized(this: Page, size: size_t) returns pointer[void]
    {
        ; We allocate oversized objects directly.
        let address aligned_alloc(PAGE_SIZE,  (size + PAGE_SIZE - (1 as size_t)) & (~(PAGE_SIZE - (1 as size_t))))
        if address = null
            exit(1)
        var page address as pointer[Page]

        ; Oversized pages have no next_object
        set page.next_object: null

        ; An oversized page is always exclusive
        exclusive_pages.add(page)

        ; The page offset by the null pointer for next_object
        return (page + 1) as pointer[void]
    }

    function get(address: pointer[void]) returns pointer[Page]
    {
        let mask ~((PAGE_SIZE - (1 as size_t)) as size_t)
        let page (address as size_t & mask) as pointer[Page]
        page
    }

    function get_capacity(this: Page, align: size_t) returns size_t
    {
        var location next_object as size_t
        let aligned_location (location + align - (1 as size_t)) & (~(align - (1 as size_t)))
        var location_after_page this as size_t + PAGE_SIZE
        var capacity location_after_page - aligned_location
        capacity
    }

    function allocate_exclusive_page(this: Page) returns pointer[Page]
    {
        let page allocate_page()
        exclusive_pages.add(page)
        page
    }

    procedure deallocate_extensions(this: Page)
    {
        ; Oversized pages cannot have extensions
        if next_object = null
            return

        for exclusive_page_ptr in exclusive_pages
        {
            let exclusive_page (*exclusive_page_ptr)
            exclusive_page.deallocate_extensions()
            free(exclusive_page as pointer[void])
        }

        var page next_page
        while page <> null
        {
            let next_page page.next_page
            free(page as pointer[void])
            set page: next_page
        }
    }

    function deallocate_exclusive_page(this: Page, page: pointer[Page])
    {
        page.deallocate_extensions()
        free(page as pointer[void])
        if exclusive_pages.remove(page) = false
            exit (2)
    }

    function save_watermark(this: Page) returns BlockWatermark
    {
        if current_page <> null
            return BlockWatermark(current_page, current_page.next_object, next_page, exclusive_pages.head)
        let this_page Page.get(next_object)
        BlockWatermark(this_page, next_object, next_page, exclusive_pages.head)
    }

    procedure restore_watermark(this: Page, mark: BlockWatermark)
    {
        ; Deallocate exclusive pages added after watermark (prepended, so at front)
        while exclusive_pages.head <> mark.exclusive_head
        {
            let node exclusive_pages.head
            let page node.page
            page.deallocate_extensions()
            free(page as pointer[void])
            set exclusive_pages.head: node.next
        }

        ; Deallocate extensions added after mark.extension_tail
        deallocate_extensions_after(mark.extension_tail)

        ; Restore allocation state
        set current_page: mark.page
        if mark.page <> null
            set (*mark.page).next_object: mark.next_object
        else
            set next_object: mark.next_object
    }

    procedure deallocate_extensions_after(this: Page, stop_at: pointer[Page])
    {
        ; Walk next_page chain and free until we hit stop_at
        while next_page <> null & next_page <> stop_at
        {
            let page_to_free next_page
            set next_page: page_to_free.next_page
            free(page_to_free as pointer[void])
        }
    }
}
