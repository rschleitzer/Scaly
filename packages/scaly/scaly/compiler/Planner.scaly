use scaly.containers
use scaly.io

define Planner
(
    program: ref[Program]
    intrinsics_builder: HashSetBuilder[String]
    types_list: List[Plan.Type]
    types_builder: HashMapBuilder[String, Plan.Type]
    functions_list: List[Plan.Function]
    functions_builder: HashMapBuilder[String, Plan.Function]
)
{

init(program: ref[Program]) (program(program)) (intrinsics_builder(new_ HashSetBuilder[String]())) (types_builder(new_ HashMapBuilder[String, Plan.Type]())) (functions_builder(new_ HashMapBuilder[String, Plan.Function]())) {}

function plan_program(this: Planner) returns Plan.Module throws PlannerError {
    var r Region()

    let file program.module_.file
    var path Path->get_directory_name(r.get_page(), file)
    if path.get_length() > 0
    {
        try let exists Directory->exists(ep, path)
            else throw

        if exists = false
        {
            try Directory->create(ep, path)
                else throw
        }
    }

    try plan_module(ep, program.module_)
    else throw

    for module_ in program.module_.modules
    {
        try plan_module(ep, module_)
            else throw
    }

    if program.statements.length > 0
    {
        try plan_main_function(ep, program)
            else throw
    }

    return Plan->Module(path, program.module_.name, 
        new_ Vector[Plan.Type](rp, types_list),
        new_ HashMap[String, Plan.Type](rp, types_builder),
        new_ Vector[Plan.Function](rp, functions_list),
        new_ HashMap[String, Plan.Function](rp, functions_builder))
}

function plan_main_function(this: Planner, program: ref[Program]) throws PlannerError {
    var r Region()
    let main_name String(get_page(), "main")
    if functions_builder.contains(main_name)
        throw DuplicateFunction(String(ep, main_name))

    var input_list: ref[List[Plan.Argument]] *new_ List[Plan.Argument]$()
    input_list.add(Plan->Argument(String(get_page(), "argc"), String(get_page(), "int32")))
    input_list.add(Plan->Argument(String(get_page(), "argv"), String(get_page(), "ptr")))

    var blocks: ref[List[Plan.Block]] *new_ List[Plan.Block]$()
    var instructions: ref[List[Plan.Instruction]] *new_ List[Plan.Instruction]$()
    var values: ref[List[String]] *List[String]$()
    for statement in program.statements
    {
        try let new_instructions plan_statement(get_page(), ep, program.module_.symbols, null, statement, blocks, &instructions)
            else throw
        set instructions: *new_instructions
    }

    if (*(instructions.get_head())).result
    {
        var ret_list: ref[List[String]] *List[String]$()
        ret_list.add(*(*(instructions.get_head())).result)
        instructions.add(Plan->Instruction(null, String(get_page(), "ret"), Vector[String](get_page(), ret_list)))
    } else {
        instructions.add(Plan->Instruction(null, String(get_page(), "ret"), Vector[String]()))
    }

    var block new_ Plan.Block(String(get_page(), "entry"), new_ Vector[Plan.Instruction](get_page(), instructions))
    blocks.add(block)

    let int_name String(get_page(), "int32")
    var plan_function: Plan.Function Plan->Function(main_name, new_ Vector[Plan.Argument](get_page(), input_list), int_name, new_ Vector[Plan.Block](get_page(), blocks))
    functions_builder.add(main_name, plan_function)
    functions_list.add(plan_function)
    return Void()
}

function plan_module(this: Planner, module_: ref[Module]) throws PlannerError {
    var r Region()

    try plan_symbols(ep, module_.file, module_.symbols, module_.members)
        else throw

    return Void()
}

function plan_symbols(this: Planner, file: String, symbols: ref[HashMap[String, Nameable]], members: Vector[Member]) throws PlannerError {
    var r Region()

    for member in members
    {
        choose member
            when func: Member.Function
                try plan_function(ep, file, symbols, func)
                    else throw
            when concept: Member.Concept
                try plan_concept(ep, symbols, concept)
                    else throw
            when op: Member.Operator
                throw FeatureNotImplemented(String(ep, "operator symbol"))
            when p: Member.Package
                throw FeatureNotImplemented(String(ep, "package"))
    }

    return Void()
}

function plan_concept(this: Planner, symbols: ref[HashMap[String, Nameable]], concept: ref[Concept]) throws PlannerError { 
    choose concept.definition
        when ns: Definition.Namespace
            throw FeatureNotImplemented(String(ep, "namespace"))
        when structure: Definition.Structure
            throw FeatureNotImplemented(String(ep, "structure"))
        when i: Definition.Intrinsic
            return plan_intrinsic(ep, concept.name)
        when g: Definition.Global
            throw FeatureNotImplemented(String(ep, "global"))
        when u: Definition.Union
            throw FeatureNotImplemented(String(ep, "union"))
}

function plan_intrinsic(this: Planner, name: String) throws PlannerError {
    var r Region()

    if intrinsics_builder.contains(name)
        throw DuplicateIntrinsic(String(ep, name))
    
    intrinsics_builder.add(name)

    return Void()
}

function resolve_type(this: Planner, file: String, type: Type) returns String throws PlannerError {
    let name *type.name.get(0)
    if intrinsics_builder.contains(name)
        return name

    throw UndefinedType(file, String(ep, name), type.span)
}

function plan_tuple(this: Planner, symbols: ref[HashMap[String, Nameable]], tuple: ref[Tuple], blocks: ref[List[Plan.Block]], instructions: pointer[List[Plan.Instruction]], values: ref[List[String]]) returns pointer[List[Plan.Instruction]] throws PlannerError {
    for component in tuple.components
    {
        if component.name
            throw TupleComponentNamesNotSupported()
        plan_operation(get_page(), ep, symbols, component.value, blocks, instructions, values)
        let last_instruction (*instructions).get_head()
        if last_instruction
            values.add(*(*last_instruction).result)
    }
    return instructions
}

function allocate_value_name(this: Planner, blocks: ref[List[Plan.Block]], instructions: ref[List[Plan.Instruction]]) returns String {
    var r Region()
    var value_name_builder: ref[StringBuilder] *StringBuilder$()
    value_name_builder.append('v')
    value_name_builder.append(to_string(r.get_page(), blocks.count()))
    value_name_builder.append('_')
    value_name_builder.append(to_string(r.get_page(), instructions.count()))
    return String(value_name_builder.to_string(rp))
}

function plan_instruction_call(this: Planner, symbols: ref[HashMap[String, Nameable]], operation: pointer[VectorIterator[Operand]], name: String, tuple: ref[Tuple], blocks: ref[List[Plan.Block]], instructions: pointer[List[Plan.Instruction]]) returns pointer[List[Plan.Instruction]] throws PlannerError {
    var r Region()
    var values_list: ref[List[String]] *List[String]$()
    plan_tuple(get_page(), ep, symbols, tuple, blocks, instructions, values_list)    
    var values Vector[String](get_page(), values_list)
    var page get_page()
    let value allocate_value_name(get_page(), blocks, *instructions)
    (*instructions).add(Plan->Instruction(new_ String^page(get_page(), value), name, values))
    return instructions
}

function plan_type(this: Planner, symbols: ref[HashMap[String, Nameable]], operation: pointer[VectorIterator[Operand]], type: ref[Type], blocks: ref[List[Plan.Block]], instructions: pointer[List[Plan.Instruction]], values: ref[List[String]]) returns pointer[List[Plan.Instruction]] throws PlannerError {
    if type.name.length > 1
        throw FeatureNotImplemented(String(ep, "Qualified type name"))
    if type.generics
        throw FeatureNotImplemented(String(ep, "Generic type"))

    choose type.lifetime
        when unspecified: Lifetime.Unspecified {}
        when call: Lifetime.Call
            throw FeatureNotImplemented(String(ep, "Call lifetime"))
        when local: Lifetime.Local
            throw FeatureNotImplemented(String(ep, "Local lifetime"))
        when reference: Lifetime.Reference
            throw FeatureNotImplemented(String(ep, "Reference lifetime"))
        when thrown: Lifetime.Thrown
            throw FeatureNotImplemented(String(ep, "Thrown lifetime"))
    
    let name *type.name.get(0)
    if symbols.contains(name)
    {
        choose *symbols.get(name)
            when modules: Nameable.Package
                throw FeatureNotImplemented(String(ep, "Package reference"))
            when concept: Nameable.Concept
                throw FeatureNotImplemented(String(ep, "Concept reference"))
            when operator_: Nameable.Operator
                throw FeatureNotImplemented(String(ep, "Operator reference"))
            when functions: Nameable.Functions {
                if functions.length > 1
                    throw FeatureNotImplemented(String(ep, "Overloaded functions"))
                let function_ *functions.get(0)
                choose function_.implementation
                    when action: Implementation.Action
                        throw FeatureNotImplemented(String(ep, "Internal Function call"))
                    when extern_: Implementation.Extern
                        throw FeatureNotImplemented(String(ep, "External Function call"))
                    when instruction_: Implementation.Instruction {
                        if operation = null
                            throw InstructionWithoutArguments(String(ep, name))
                        var next_operand (*operation).next()
                        if next_operand = null
                            throw InstructionWithoutArguments(String(ep, name))
                        choose (*next_operand).expression
                            when tuple: Expression.Tuple {
                                return plan_instruction_call(get_page(), ep, symbols, operation, name, tuple, blocks, instructions)
                            }
                            else throw InstructionWithoutArguments(String(ep, name))

                    }
                    when intrinsic_: Implementation.Intrinsic
                        throw FeatureNotImplemented(String(ep, "Intrinsic call"))
            }
            when property: Nameable.Property
                throw FeatureNotImplemented(String(ep, "Property reference"))
            when variant: Nameable.Variant
                throw FeatureNotImplemented(String(ep, "Variant reference"))
    } else {
        values.add(name)
    }

    return instructions
}

function plan_statement(this: Planner, symbols: ref[HashMap[String, Nameable]], operation: pointer[VectorIterator[Operand]], statement: ref[Statement], blocks: ref[List[Plan.Block]], instructions: pointer[List[Plan.Instruction]]) returns pointer[List[Plan.Instruction]] throws PlannerError {
    choose statement
        when action: Statement.Action
        {
            var r Region()
            var values: ref[List[String]] *List[String]$()
            return plan_action(get_page(), ep, symbols, operation, action, blocks, instructions, values)
        }
        when binding: Statement.Binding
            throw FeatureNotImplemented(String(ep, "Binding statement"))
        when break_: Statement.Break
            throw FeatureNotImplemented(String(ep, "Break statement"))
        when continue_: Statement.Continue
            throw FeatureNotImplemented(String(ep, "Continue statement"))
        when return_: Statement.Return
            throw FeatureNotImplemented(String(ep, "Return statement"))
        when throw_: Statement.Throw
            throw FeatureNotImplemented(String(ep, "Throw statement"))

    return instructions
}

function plan_block(this: Planner, symbols: ref[HashMap[String, Nameable]], operation: pointer[VectorIterator[Operand]], block: ref[Block], blocks: ref[List[Plan.Block]], instructions: pointer[List[Plan.Instruction]]) returns pointer[List[Plan.Instruction]] throws PlannerError {
    for statement in block.statements
    {
        try let new_instructions plan_statement(get_page(), ep, symbols, operation, statement, blocks, instructions)
            else throw
        set instructions: new_instructions
    }
    return instructions
}

function plan_operand(this: Planner, symbols: ref[HashMap[String, Nameable]], operation: pointer[VectorIterator[Operand]], operand: ref[Operand], blocks: ref[List[Plan.Block]], instructions: pointer[List[Plan.Instruction]], values: ref[List[String]]) returns pointer[List[Plan.Instruction]] throws PlannerError {
    var r Region()
    if operand.member_access
        throw FeatureNotImplemented(String(ep, "member access"))

    choose operand.expression
        when constant: Expression.Constant
            throw FeatureNotImplemented(String(ep, "Constant expression"))
        when type: Expression.Type
            return plan_type(get_page(), ep, symbols, operation, type, blocks, instructions, values)
        when tuple: Expression.Tuple
            throw FeatureNotImplemented(String(ep, "Tuple expression"))
        when matrix: Expression.Matrix
            throw FeatureNotImplemented(String(ep, "Matrix expression"))
        when block: Expression.Block
            return plan_block(get_page(), ep, symbols, operation, block, blocks, instructions)
        when if_: Expression.If
            throw FeatureNotImplemented(String(ep, "If expression"))
        when match_: Expression.Match
            throw FeatureNotImplemented(String(ep, "Match expression"))
        when choose_: Expression.Choose
            throw FeatureNotImplemented(String(ep, "Choose expression"))
        when for_: Expression.For
            throw FeatureNotImplemented(String(ep, "For expression"))
        when while_: Expression.While
            throw FeatureNotImplemented(String(ep, "While expression"))
        when try_: Expression.Try
            throw FeatureNotImplemented(String(ep, "Try expression"))
        when sizeof_: Expression.SizeOf
            throw FeatureNotImplemented(String(ep, "SizeOf expression"))
        when is_: Expression.Is
            throw FeatureNotImplemented(String(ep, "Is expression"))
        when new__: Expression.New
            throw FeatureNotImplemented(String(ep, "New expression"))
}

function plan_operation(this: Planner, symbols: ref[HashMap[String, Nameable]], operation: ref[Vector[Operand]], blocks: ref[List[Plan.Block]], instructions: pointer[List[Plan.Instruction]], values: ref[List[String]]) returns pointer[List[Plan.Instruction]] throws PlannerError {
    var r Region()

    var operand_iterator operation.get_iterator()
    while let operand operand_iterator.next()
    {
        try let new_instructions plan_operand(get_page(), ep, symbols, &operand_iterator, *operand, blocks, instructions, values)
            else throw
    }

    return instructions
}

function plan_action(this: Planner, symbols: ref[HashMap[String, Nameable]], operation: pointer[VectorIterator[Operand]], action: ref[Action], blocks: ref[List[Plan.Block]], instructions: pointer[List[Plan.Instruction]], values: ref[List[String]]) returns pointer[List[Plan.Instruction]] throws PlannerError {
    var r Region()
    if action.target.length > 0
        throw FeatureNotImplemented(String(ep, "set"))

    try let new_instructions plan_operation(get_page(), ep, symbols, action.source, blocks, instructions, values)
        else throw

    return instructions
}

function plan_function(this: Planner, file: String, symbols: ref[HashMap[String, Nameable]], func: ref[Function]) throws PlannerError {
    var r Region()

    if functions_builder.contains(func.name)
        throw DuplicateFunction(String(ep, func.name))

    try let returnType resolve_type(get_page(), ep, file, *func.returns_)
        else throw

    var input_list: ref[List[Plan.Argument]] *new_ List[Plan.Argument]$()
    for item in func.input
    {
        try let type resolve_type(get_page(), ep, file, *item.type)
            else throw

        input_list.add(Plan->Argument(*item.name, type))
    }

    var blocks: ref[List[Plan.Block]] *new_ List[Plan.Block]$()
    var instructions: ref[List[Plan.Instruction]] *new_ List[Plan.Instruction]$()
    choose func.implementation
        when action: Implementation.Action
        {
            var values: ref[List[String]] *List[String]$()
            try let new_instructions plan_action(get_page(), ep, symbols, null, action, blocks, &instructions, values)
                else throw
            set instructions: *new_instructions
            if func.returns_
            {
                var ret_list: ref[List[String]] *List[String]$()
                ret_list.add(*(*(instructions.get_head())).result)
                instructions.add(Plan->Instruction(null, String(get_page(), "ret"), Vector[String](get_page(), ret_list)))
            } else {
                instructions.add(Plan->Instruction(null, String(get_page(), "ret"), Vector[String]()))
            }

            var block new_ Plan.Block(String(get_page(), "entry"), new_ Vector[Plan.Instruction](get_page(), instructions))
            blocks.add(block)
        }
        when e: Implementation.Extern {}
        when i: Implementation.Instruction
            return Void()
        when i: Implementation.Intrinsic
            return Void()

    var plan_function: Plan.Function Plan->Function(func.name, new_ Vector[Plan.Argument](get_page(), input_list), returnType, new_ Vector[Plan.Block](get_page(), blocks))
    functions_builder.add(func.name, plan_function)
    functions_list.add(plan_function)
    return Void()
}

}