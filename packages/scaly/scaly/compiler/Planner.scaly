use scaly.containers
use scaly.io
use scaly.compiler.Plan

define Planner
(
    program: ref[Program]
    intrinsics_builder: HashSetBuilder[String]
    types_builder: HashMapBuilder[String, Plan.PlanType]
    functions_builder: HashMapBuilder[String, Plan.PlanFunction]
    module_list: List[Plan.Source]
)
{

init(program: ref[Program]) (program(program)) (intrinsics_builder(new_ HashSetBuilder[String]())) (types_builder(new_ HashMapBuilder[String, Plan.PlanType]())) (functions_builder(new_ HashMapBuilder[String, Plan.PlanFunction]())) {}

function plan_program(this: Planner) returns Plan.PlanProgram throws PlannerError {
    var r Region()

    let file program.module_.file
    var path Path->get_directory_name(r.get_page(), file)
    if path.get_length() > 0
    {
        try let exists Directory->exists(ep, path)
            else throw

        if exists = false
        {
            try Directory->create(ep, path)
                else throw
        }
    }

    try let source plan_module(rp, ep, program.module_)
        else throw

    for module_ in program.module_.modules
    {
        try let source plan_module(rp, ep, module_)
            else throw
    }

    if program.statements.length > 0
    {
        try plan_main_function(ep, source, program)
            else throw
    }

    return Plan->PlanProgram(
        source,
        Plan->PlanModule(String(), String(), String(), String(), new_ HashMap[String, String](rp, HashMapBuilder[String, String]()), null, new_ HashMap[String, Vector[Metadata]](rp, HashMapBuilder[String, Vector[Metadata]]())),
        new_ HashMap[String, PlanType](rp, types_builder),
        new_ HashMap[String, LLVMType](rp, HashMapBuilder[String, LLVMType]()),
        new_ HashMap[String, PlanFunction](rp, functions_builder),
        new_ HashMap[String, GlobalVariable](rp, HashMapBuilder[String, GlobalVariable]()),
        new_ HashMap[String, Metadata](rp, HashMapBuilder[String, Metadata]()),
        Vector[DebugInfo](rp, List[DebugInfo]()))
}

function plan_main_function(this: Planner, source: pointer[Plan.Source], program: ref[Program]) throws PlannerError {
    var r Region()
    let main_name String(get_page(), "main")
    if functions_builder.contains(main_name)
        throw DuplicateFunction(String(ep, main_name))

    var input_list: ref[List[PlanArgument]] *new_ List[PlanArgument]$()
    input_list.add(Plan->PlanArgument(String(get_page(), "argc"), String(get_page(), "int32"), Vector[String](get_page(), List[String]()), null))
    input_list.add(Plan->PlanArgument(String(get_page(), "argv"), String(get_page(), "ptr"), Vector[String](get_page(), List[String]()), null))

    var blocks: ref[List[BasicBlock]] *new_ List[BasicBlock]$()
    var instructions: ref[List[PlanInstruction]] *new_ List[PlanInstruction]$()
    var values: ref[List[String]] *List[String]$()
    var statement_iterator program.statements.get_iterator()
    var next_statement statement_iterator.next()
    var required_type: pointer[String] null
    var input_environment_builder: ref[HashMapBuilder[String, String]] *new_ HashMapBuilder[String, String]$()
    input_environment_builder.add(String(get_page(), "argc"), String(get_page(), "int32"))
    input_environment_builder.add(String(get_page(), "argv"), String(get_page(), "ptr"))
    var page get_page()
    var environment: ref[List[HashMap[String, String]]] *new_ List[HashMap[String, String]]^page()
    environment.add(HashMap[String, String](page, input_environment_builder))
    while true
    {
        var statement *next_statement
        set next_statement: statement_iterator.next()
        if next_statement = null
            set required_type: new_ String$(r.get_page(), "int32")

        try let new_instructions plan_statement(get_page(), ep, program.module_.file, environment, program.module_.symbols, null, statement, required_type, blocks, &instructions)
            else throw
        set instructions: *new_instructions
        if next_statement = null
            break
    }

    if (*(instructions.get_head())).result
    {
        var ret_list: ref[List[String]] *List[String]$()
        ret_list.add(*(*(instructions.get_head())).result)
        instructions.add(Plan->PlanInstruction(null, String(get_page(), "ret"), Vector[String](get_page(), ret_list), String(get_page(), "void"), null, String(get_page(), "ret"), HashMap[String, String](get_page(), HashMapBuilder[String, String]()), false, false, String(), 0, null))
    } else {
        instructions.add(Plan->PlanInstruction(null, String(get_page(), "ret"), Vector[String](get_page(), List[String]()), String(get_page(), "void"), null, String(get_page(), "ret"), HashMap[String, String](get_page(), HashMapBuilder[String, String]()), false, false, String(), 0, null))
    }

    var block Plan->BasicBlock(String(get_page(), "entry"), Vector[PlanInstruction](get_page(), instructions), Vector[String](get_page(), List[String]()), Vector[String](get_page(), List[String]()), true, null)
    blocks.add(block)

    let int_name String(get_page(), "int32")
    var plan_function Plan->PlanFunction(source, main_name, Vector[PlanArgument](get_page(), input_list), int_name, Vector[BasicBlock](get_page(), blocks), null, String(get_page(), "external"), String(), Vector[String](get_page(), List[String]()), Vector[Variable](get_page(), List[Variable]()), false, true, String(get_page(), "default"), String())
    functions_builder.add(main_name, plan_function)
    return Void()
}

function plan_module(this: Planner, module_: ref[Module]) returns pointer[Plan.Source] throws PlannerError {
    var r Region()

    let file module_.file
    var path Path->get_directory_name(r.get_page(), file)
    var path_builder: ref[StringBuilder] *StringBuilder$(".")
    if path.get_length() > 0
        path_builder.append('/')
    path_builder.append(path)
    var file_builder: ref[StringBuilder] *StringBuilder$(module_.name)
    file_builder.append(".scaly")

    var page get_page()
    var source new_ Plan.Source^page(
        path_builder.to_string(page),
        file_builder.to_string(page))

    try plan_symbols(ep, source, module_.file, module_.symbols, module_.members)
        else throw

    return source
}

function plan_symbols(this: Planner, source: pointer[Plan.Source], file: String, symbols: ref[HashMap[String, Nameable]], members: Vector[Member]) throws PlannerError {
    var r Region()

    for member in members
    {
        choose member
            when func: Member.Function
                try plan_function(ep, source, file, symbols, func)
                    else throw
            when concept: Member.Concept
                try plan_concept(ep, file, symbols, concept)
                    else throw
            when op: Member.Operator
                throw FeatureNotImplemented(file, op.span, String(ep, "operator symbol"))
            when p: Member.Package
                throw FeatureNotImplemented(file, Span(0, 0), String(ep, "package"))
    }

    return Void()
}

function plan_concept(this: Planner, file: String, symbols: ref[HashMap[String, Nameable]], concept: ref[Concept]) throws PlannerError {
    choose concept.definition
        when ns: Definition.Namespace
            return plan_namespace(ep, concept.name, file, ns)
        when structure: Definition.Structure
            throw FeatureNotImplemented(file, structure.span, String(ep, "structure"))
        when i: Definition.Intrinsic
            return plan_intrinsic(ep, concept.name)
        when g: Definition.Global
            throw FeatureNotImplemented(file, g.span, String(ep, "global"))
        when u: Definition.Union
            throw FeatureNotImplemented(file, u.span, String(ep, "union"))
        when t: Definition.Type
            return plan_type_definition(ep, concept.name, t)
}

function plan_intrinsic(this: Planner, name: String) throws PlannerError {
    var r Region()

    if intrinsics_builder.contains(name)
        throw DuplicateIntrinsic(String(ep, name))

    intrinsics_builder.add(name)

    return Void()
}

function plan_namespace(this: Planner, namespace_name: String, file: String, ns: ref[Namespace]) throws PlannerError {
    var r Region()

    ; Process all members in the namespace and register qualified intrinsics
    for member in ns.members
    {
        choose member
            when concept: Member.Concept
            {
                choose concept.definition
                    when i: Definition.Intrinsic
                    {
                        ; Register the qualified intrinsic name (e.g., "LLVM.int32")
                        var qualified_name_builder: ref[StringBuilder] *StringBuilder$()
                        qualified_name_builder.append(namespace_name)
                        qualified_name_builder.append('.')
                        qualified_name_builder.append(concept.name)
                        let qualified_name qualified_name_builder.to_string(r.get_page())

                        if intrinsics_builder.contains(qualified_name)
                            throw DuplicateIntrinsic(String(ep, qualified_name))

                        intrinsics_builder.add(qualified_name)
                    }
                    else
                        throw FeatureNotImplemented(file, concept.span, String(ep, "Non-intrinsic namespace member"))
            }
            else
                throw FeatureNotImplemented(file, Span(0, 0), String(ep, "Non-concept namespace member"))
    }

    return Void()
}

function plan_type_definition(this: Planner, name: String, type_def: ref[Type]) throws PlannerError {
    var r Region()

    ; Create a type alias that maps the new type name to the target type
    ; For now, we just resolve the target type to its string representation
    let target_type_name *type_def.name.get(0)

    ; Add the type alias to the types builder
    ; This allows resolve_type to later map "int" to "int32"
    let plan_type Plan->PlanType(name, Vector[String](get_page(), List[String]()))
    types_builder.add(name, plan_type)

    return Void()
}

function resolve_type(this: Planner, file: String, symbols: ref[HashMap[String, Nameable]], type: Type) returns String throws PlannerError {
    if type.name.length = 1
    {
        ; Simple name resolution (existing logic)
        let name *type.name.get(0)
        if intrinsics_builder.contains(name)
            return name

        ; Check if this is a type alias first
        if types_builder.contains(name)
        {
            ; This is a type alias, but we need to resolve it to the actual target type
            ; For now, we need to look up the symbol and get the target type from the Definition.Type
            if symbols.contains(name)
            {
                choose *symbols.get(name)
                    when concept: Nameable.Concept
                    {
                        choose concept.definition
                            when t: Definition.Type
                            {
                                ; Recursively resolve the target type
                                return resolve_type(rp, ep, file, symbols, t)
                            }
                            when i: Definition.Intrinsic
                            {
                                return name
                            }
                            else
                                throw FeatureNotImplemented(file, concept.span, String(ep, "Concept type other than intrinsic or type"))
                    } else {
                        throw ConceptExpected(file, type.span, name)
                    }
            }
        }

        if symbols.contains(name)
        {
            choose *symbols.get(name)
                when concept: Nameable.Concept
                {
                    choose concept.definition
                        when i: Definition.Intrinsic
                        {
                            return name
                        }
                        else
                            throw FeatureNotImplemented(file, concept.span, String(ep, "Concept type other than intrinsic"))
                }
                else
                    throw ConceptExpected(file, type.span, name)
        }

        throw UndefinedType(file, type.span, String(ep, name))
    } else {
        ; Qualified name resolution (e.g., LLVM.int32)
        return resolve_qualified_type(rp, ep, file, symbols, type.name, type.span)
    }
}

function resolve_qualified_type(this: Planner, file: String, symbols: ref[HashMap[String, Nameable]], name_path: Vector[String], span: Span) returns String throws PlannerError {
    var r Region()

    ; Build qualified name for intrinsic lookup (e.g., "LLVM.int32")
    var qualified_name_builder: ref[StringBuilder] *StringBuilder$()
    var i 0
    while i < name_path.length
    {
        if i > 0
            qualified_name_builder.append('.')
        qualified_name_builder.append(*name_path.get(i))
        set i: i + 1
    }
    let qualified_name qualified_name_builder.to_string(r.get_page())

    ; Check if the qualified name is a registered intrinsic
    if intrinsics_builder.contains(qualified_name)
    {
        let last_index name_path.length - 1
        let intrinsic_name *name_path.get(last_index)
        return String(r.get_page(), intrinsic_name)
    }

    ; Navigate through namespace hierarchy
    let namespace_name *name_path.get(0)
    if symbols.contains(namespace_name) = false
        throw UndefinedType(file, span, String(ep, namespace_name))

    choose *symbols.get(namespace_name)
        when concept: Nameable.Concept
        {
            choose concept.definition
                when ns: Definition.Namespace
                {
                    ; Look up the remaining path in the namespace
                    if name_path.length = 2
                    {
                        let member_name *name_path.get(1)
                        if ns.symbols.contains(member_name)
                        {
                            choose *ns.symbols.get(member_name)
                                when member_concept: Nameable.Concept
                                {
                                    choose member_concept.definition
                                        when i: Definition.Intrinsic
                                        {
                                            ; Return the qualified name for the intrinsic
                                            return String(r.get_page(), *name_path.get(name_path.length - 1))
                                        }
                                        else
                                            throw FeatureNotImplemented(file, span, String(ep, "Non-intrinsic namespace member"))
                                }
                                else
                                    throw FeatureNotImplemented(file, span, String(ep, "Non-concept namespace member"))
                        } else {
                            throw UndefinedType(file, span, String(ep, member_name))
                        }
                    } else {
                        throw FeatureNotImplemented(file, span, String(ep, "Nested namespace paths"))
                    }
                }
                else
                    throw FeatureNotImplemented(file, span, String(ep, "Non-namespace qualified reference"))
        }
        else
            throw ConceptExpected(file, span, namespace_name)
}

function get_type_from_environment(name: String, environment: ref[List[HashMap[String, String]]]) returns pointer[String]$ {
    for scope in environment
    {
        if scope.contains(name)
            return scope.get(name)
    }

    return null
}

function plan_function_arguments(this: Planner, file: String, environment: ref[List[HashMap[String, String]]], symbols: ref[HashMap[String, Nameable]], function_: ref[Function], tuple: ref[Tuple], blocks: ref[List[BasicBlock]], instructions: pointer[List[PlanInstruction]], values: ref[List[String]]) returns pointer[List[PlanInstruction]] throws PlannerError {
    if function_.input.length <> tuple.components.length
        throw InvalidNumberOfArguments(file, tuple.span, String(ep, function_.name), function_.input.length, tuple.components.length)

    var item_iterator function_.input.get_iterator()
    for actual_argument in tuple.components
    {
        var item *item_iterator.next()
        var formal_argument_type item.type
        if formal_argument_type = null
            FeatureNotImplemented(file, item.span, String(ep, "Type inference"))
        try let required_argument_type resolve_type(get_page(), ep, file, symbols, *formal_argument_type)
            else throw
        if actual_argument.name
            throw TupleComponentNamesNotSupported()
        try plan_operation(get_page(), ep, file, environment, symbols, actual_argument.value, &required_argument_type, blocks, instructions, values)
            else throw
        let last_instruction (*instructions).get_head()
        if last_instruction
            values.add(*(*last_instruction).result)
    }
    return instructions
}

function allocate_value_name(this: Planner, blocks: ref[List[BasicBlock]], instructions: ref[List[PlanInstruction]]) returns String {
    var r Region()
    var value_name_builder: ref[StringBuilder] *StringBuilder$()
    value_name_builder.append('v')
    value_name_builder.append(number_to_string(r.get_page(), blocks.count()))
    value_name_builder.append('_')
    value_name_builder.append(number_to_string(r.get_page(), instructions.count()))
    return String(value_name_builder.to_string(rp))
}

function plan_instruction_call(this: Planner, file: String, environment: ref[List[HashMap[String, String]]], symbols: ref[HashMap[String, Nameable]], operation: pointer[VectorIterator[Operand]], function_: ref[Function], tuple: ref[Tuple], blocks: ref[List[BasicBlock]], instructions: pointer[List[PlanInstruction]]) returns pointer[List[PlanInstruction]] throws PlannerError {
    var r Region()
    var values_list: ref[List[String]] *List[String]$()
    try plan_function_arguments(get_page(), ep, file, environment, symbols, function_, tuple, blocks, instructions, values_list)
        else throw
    var values Vector[String](get_page(), values_list)
    var page get_page()
    let value allocate_value_name(get_page(), blocks, *instructions)
    (*instructions).add(Plan->PlanInstruction(new_ String^page(get_page(), value), function_.name, values, String(get_page(), "void"), null, String(get_page(), "call"), HashMap[String, String](get_page(), HashMapBuilder[String, String]()), false, false, String(), 0, null))
    return instructions
}

function plan_type_expression(this: Planner, file: String, environment: ref[List[HashMap[String, String]]], symbols: ref[HashMap[String, Nameable]], operation: pointer[VectorIterator[Operand]], type: ref[Type], required_type: pointer[String], blocks: ref[List[BasicBlock]], instructions: pointer[List[PlanInstruction]], values: ref[List[String]]) returns pointer[List[PlanInstruction]] throws PlannerError {
    if type.name.length > 1
        throw FeatureNotImplemented(file, type.span, String(ep, "Qualified type name"))
    if type.generics
        throw FeatureNotImplemented(file, type.span, String(ep, "Generic type"))

    choose type.lifetime
        when unspecified: Lifetime.Unspecified {}
        when call: Lifetime.Call
            throw FeatureNotImplemented(file, call.span, String(ep, "Call lifetime"))
        when local: Lifetime.Local
            throw FeatureNotImplemented(file, local.span, String(ep, "Local lifetime"))
        when reference: Lifetime.Reference
            throw FeatureNotImplemented(file, reference.span, String(ep, "Reference lifetime"))
        when thrown: Lifetime.Thrown
            throw FeatureNotImplemented(file, thrown.span, String(ep, "Thrown lifetime"))

    let name *type.name.get(0)
    if symbols.contains(name)
    {
        choose *symbols.get(name)
            when modules: Nameable.Package
                throw FeatureNotImplemented(file, Span(0, 0), String(ep, "Package reference"))
            when concept: Nameable.Concept
            {
                ; Intrinsics are type names, not expressions that generate values
                choose concept.definition
                    when i: Definition.Intrinsic
                        throw UndefinedTypeOrValue(file, type.span, String(ep, name))
                    else
                        throw FeatureNotImplemented(file, concept.span, String(ep, "Non-intrinsic concept reference"))
            }
            when operator_: Nameable.Operator
                throw FeatureNotImplemented(file, operator_.span, String(ep, "Operator reference"))
            when functions: Nameable.Functions {
                if functions.length > 1
                    throw FeatureNotImplemented(file, (*(functions.get(0))).span, String(ep, "Overloaded functions"))
                var function_ *functions.get(0)
                if required_type
                {
                    if function_.returns_ = null
                        throw TypeMismatch(file, function_.span, *required_type, String(ep, "void"))
                    let function_return_type *function_.returns_
                    try let resolved_function_return_type resolve_type(get_page(), ep, file, symbols, function_return_type)
                        else throw
                    if resolved_function_return_type.equals(*required_type) = false
                        throw TypeMismatch(file, function_return_type.span, *required_type, resolved_function_return_type)
                }
                choose function_.implementation
                    when action: Implementation.Action
                        throw FeatureNotImplemented(file, function_.span, String(ep, "Internal Function call"))
                    when extern_: Implementation.Extern
                        throw FeatureNotImplemented(file, extern_.span, String(ep, "External Function call"))
                    when instruction_: Implementation.Instruction {
                        if operation = null
                            throw InstructionWithoutArguments(String(ep, name))
                        var next_operand (*operation).next()
                        if next_operand = null
                            throw InstructionWithoutArguments(String(ep, name))
                        choose (*next_operand).expression
                            when tuple: Expression.Tuple {
                                return plan_instruction_call(get_page(), ep, file, environment, symbols, operation, function_, tuple, blocks, instructions)
                            }
                            else throw InstructionWithoutArguments(String(ep, name))

                    }
                    when intrinsic_: Implementation.Intrinsic
                        throw FeatureNotImplemented(file, intrinsic_.span, String(ep, "Intrinsic call"))
            }
            when property: Nameable.Property
                throw FeatureNotImplemented(file, property.span, String(ep, "Property reference"))
            when variant: Nameable.Variant
                throw FeatureNotImplemented(file, variant.span, String(ep, "Variant reference"))
    } else {
        ; Check if this is a variable reference from the environment
        var actual_type get_type_from_environment(name, environment)
        if actual_type = null
            throw UndefinedTypeOrValue(file, type.span, String(ep, name))
        if required_type
        {
            if (*required_type).equals(*actual_type) = false
                throw TypeMismatch(file, type.span, *required_type, *actual_type)
        }
        values.add(name)
    }

    return instructions
}

function plan_statement(this: Planner, file: String, environment: ref[List[HashMap[String, String]]], symbols: ref[HashMap[String, Nameable]], operation: pointer[VectorIterator[Operand]], statement: ref[Statement], required_type: pointer[String], blocks: ref[List[BasicBlock]], instructions: pointer[List[PlanInstruction]]) returns pointer[List[PlanInstruction]] throws PlannerError {
    choose statement
        when action: Statement.Action
        {
            var r Region()
            var values: ref[List[String]] *List[String]$()
            return plan_action(get_page(), ep, file, environment, symbols, operation, action, required_type, blocks, instructions, values)
        }
        when binding: Statement.Binding
            throw FeatureNotImplemented(file, binding.span, String(ep, "Binding statement"))
        when break_: Statement.Break
            throw FeatureNotImplemented(file, break_.span, String(ep, "Break statement"))
        when continue_: Statement.Continue
            throw FeatureNotImplemented(file, continue_.span, String(ep, "Continue statement"))
        when return_: Statement.Return
            throw FeatureNotImplemented(file, return_.span, String(ep, "Return statement"))
        when throw_: Statement.Throw
            throw FeatureNotImplemented(file, throw_.span, String(ep, "Throw statement"))

    return instructions
}

function plan_block(this: Planner, file: String, environment: ref[List[HashMap[String, String]]], symbols: ref[HashMap[String, Nameable]], operation: pointer[VectorIterator[Operand]], block: ref[Block], required_type: pointer[String], blocks: ref[List[BasicBlock]], instructions: pointer[List[PlanInstruction]]) returns pointer[List[PlanInstruction]] throws PlannerError {
    for statement in block.statements
    {
        try let new_instructions plan_statement(get_page(), ep, file, environment, symbols, operation, statement, required_type, blocks, instructions)
            else throw
        set instructions: new_instructions
    }
    return instructions
}

function plan_operand(this: Planner, file: String, environment: ref[List[HashMap[String, String]]], symbols: ref[HashMap[String, Nameable]], operation: pointer[VectorIterator[Operand]], operand: ref[Operand], required_type: pointer[String], blocks: ref[List[BasicBlock]], instructions: pointer[List[PlanInstruction]], values: ref[List[String]]) returns pointer[List[PlanInstruction]] throws PlannerError {
    var r Region()
    if operand.member_access
        throw FeatureNotImplemented(file, operand.span, String(ep, "member access"))

    choose operand.expression
        when constant: Expression.Constant
        {
            choose constant
                when boolean: Constant.Boolean
                    throw FeatureNotImplemented(file, boolean.span, String(ep, "Boolean expression"))
                when integer: Constant.Integer
                    throw FeatureNotImplemented(file, integer.span, String(ep, "Integer expression"))
                when hex: Constant.Hex
                    throw FeatureNotImplemented(file, hex.span, String(ep, "Hex expression"))
                when floating_point: Constant.FloatingPoint
                    throw FeatureNotImplemented(file, floating_point.span, String(ep, "Floating point expression"))
                when string: Constant.String
                    throw FeatureNotImplemented(file, string.span, String(ep, "String expression"))
                when string: Constant.Character
                    throw FeatureNotImplemented(file, string.span, String(ep, "Character expression"))
                when fragment: Constant.Fragment
                    throw FeatureNotImplemented(file, fragment.span, String(ep, "Fragment expression"))
        }
        when type: Expression.Type
            return plan_type_expression(get_page(), ep, file, environment, symbols, operation, type, required_type, blocks, instructions, values)
        when tuple: Expression.Tuple
            throw FeatureNotImplemented(file, tuple.span, String(ep, "Tuple expression"))
        when matrix: Expression.Matrix
            throw FeatureNotImplemented(file, matrix.span, String(ep, "Matrix expression"))
        when block: Expression.Block
            return plan_block(get_page(), ep, file, environment, symbols, operation, block, required_type, blocks, instructions)
        when if_: Expression.If
            throw FeatureNotImplemented(file, if_.span, String(ep, "If expression"))
        when match_: Expression.Match
            throw FeatureNotImplemented(file, match_.span, String(ep, "Match expression"))
        when choose_: Expression.Choose
            throw FeatureNotImplemented(file, choose_.span, String(ep, "Choose expression"))
        when for_: Expression.For
            throw FeatureNotImplemented(file, for_.span, String(ep, "For expression"))
        when while_: Expression.While
            throw FeatureNotImplemented(file, while_.span, String(ep, "While expression"))
        when try_: Expression.Try
            throw FeatureNotImplemented(file, try_.span, String(ep, "Try expression"))
        when sizeof_: Expression.SizeOf
            throw FeatureNotImplemented(file, sizeof_.span, String(ep, "SizeOf expression"))
        when is_: Expression.Is
            throw FeatureNotImplemented(file, is_.span, String(ep, "Is expression"))
        when new__: Expression.New
            throw FeatureNotImplemented(file, new__.span, String(ep, "New expression"))
}

function plan_operation(this: Planner, file: String, environment: ref[List[HashMap[String, String]]], symbols: ref[HashMap[String, Nameable]], operation: ref[Vector[Operand]], required_type: pointer[String], blocks: ref[List[BasicBlock]], instructions: pointer[List[PlanInstruction]], values: ref[List[String]]) returns pointer[List[PlanInstruction]] throws PlannerError {
    var r Region()

    var operand_iterator operation.get_iterator()
    while let operand operand_iterator.next()
    {
        try let new_instructions plan_operand(get_page(), ep, file, environment, symbols, &operand_iterator, *operand, required_type, blocks, instructions, values)
            else throw
    }

    return instructions
}

function plan_action(this: Planner, file: String, environment: ref[List[HashMap[String, String]]], symbols: ref[HashMap[String, Nameable]], operation: pointer[VectorIterator[Operand]], action: ref[Action], required_type: pointer[String], blocks: ref[List[BasicBlock]], instructions: pointer[List[PlanInstruction]], values: ref[List[String]]) returns pointer[List[PlanInstruction]] throws PlannerError {
    var r Region()
    if action.target.length > 0
        throw FeatureNotImplemented(file, (*(action.target.get(0))).span, String(ep, "set"))

    try let new_instructions plan_operation(get_page(), ep, file, environment, symbols, action.source, required_type,  blocks, instructions, values)
        else throw

    return instructions
}

function plan_function(this: Planner, source: pointer[Plan.Source], file: String, symbols: ref[HashMap[String, Nameable]], func: ref[Function]) throws PlannerError {
    var r Region()

    if functions_builder.contains(func.name)
        throw DuplicateFunction(String(ep, func.name))

    try let returnType resolve_type(get_page(), ep, file, symbols, *func.returns_)
        else throw

    var input_list: ref[List[PlanArgument]] *new_ List[PlanArgument]$()
    var input_environment_builder: ref[HashMapBuilder[String, String]] *new_ HashMapBuilder[String, String]$()
    for item in func.input
    {
        if item.type = null
            throw FeatureNotImplemented(file, item.span, String(ep, "Type inference"))

        try let type resolve_type(get_page(), ep, file, symbols, *item.type)
            else throw

        input_list.add(Plan->PlanArgument(*item.name, type, Vector[String](get_page(), List[String]()), null))
        input_environment_builder.add(*item.name, type)
    }
    var page get_page()
    var environment: ref[List[HashMap[String, String]]] *new_ List[HashMap[String, String]]^page()
    environment.add(HashMap[String, String](page, input_environment_builder))

    var blocks: ref[List[BasicBlock]] *new_ List[BasicBlock]$()
    var instructions: ref[List[PlanInstruction]] *new_ List[PlanInstruction]$()
    choose func.implementation
        when action: Implementation.Action
        {
            var values: ref[List[String]] *List[String]$()
            var required_argument_type: pointer[String] null
            if func.returns_
            {

            }
            try let new_instructions plan_action(get_page(), ep, file, environment, symbols, null, action, required_argument_type, blocks, &instructions, values)
                else throw
            set instructions: *new_instructions
            if func.returns_
            {
                var ret_list: ref[List[String]] *List[String]$()
                ret_list.add(*(*(instructions.get_head())).result)
                instructions.add(Plan->PlanInstruction(null, String(get_page(), "ret"), Vector[String](get_page(), ret_list), String(get_page(), "void"), null, String(get_page(), "ret"), HashMap[String, String](get_page(), HashMapBuilder[String, String]()), false, false, String(), 0, null))
            } else {
                instructions.add(Plan->PlanInstruction(null, String(get_page(), "ret"), Vector[String](get_page(), List[String]()), String(get_page(), "void"), null, String(get_page(), "ret"), HashMap[String, String](get_page(), HashMapBuilder[String, String]()), false, false, String(), 0, null))
            }

            var block Plan->BasicBlock(String(get_page(), "entry"), Vector[PlanInstruction](get_page(), instructions), Vector[String](get_page(), List[String]()), Vector[String](get_page(), List[String]()), true, null)
            blocks.add(block)
        }
        when e: Implementation.Extern {}
        when i: Implementation.Instruction
            return Void()
        when i: Implementation.Intrinsic
            return Void()

    var plan_function Plan->PlanFunction(source, func.name, Vector[PlanArgument](get_page(), input_list), returnType, Vector[BasicBlock](get_page(), blocks), null, String(get_page(), "external"), String(), Vector[String](get_page(), List[String]()), Vector[Variable](get_page(), List[Variable]()), false, true, String(get_page(), "default"), String())
    functions_builder.add(func.name, plan_function)
    return Void()
}

}