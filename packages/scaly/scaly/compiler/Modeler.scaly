use scaly.containers
use scaly.io

define model {

function parse_program(program: String) returns ProgramSyntax throws ParserError {
    var r Region()
    var parser: ref[Parser] *Parser$(program)
    let program_syntax_result parser.parse_program(rp, ep)
    if parser.is_at_end() = false
        throw ParserError(InvalidSyntax(parser.lexer.previous_position, parser.lexer.position, String(ep, "a valid declaration")))

    return program_syntax_result
}

function handle_property(private_: bool, property: ref[PropertySyntax], file: String) returns Property throws ModelError {
    var r Region()
    
    try let type handle_type(rp, ep, property.annotation.type, file)
        else throw

    var initializer: pointer[Vector[Operand]] null
    if property.initializer <> null
    {
        try let i handle_operands(rp, ep, (*property.initializer).operands, file)
            else throw
        set initializer: Vector[Operand]#(i)
    }

    var attributes: ref[List[Attribute]] *List[Attribute]$()
    if property.attributes <> null
    {
        for attribute_syntax in (*property.attributes)
            try let attribute handle_attribute(rp, ep, attribute_syntax, file)
                else throw
    }

    return Property(Span(property.start, property.end), false, String(rp, property.name), type, initializer, Vector[Attribute](rp, attributes))
}

function handle_item(private_: bool, item: ref[ItemSyntax], file: String) returns Item throws ModelError {
    var r Region()
    var type: pointer[Type] null
    if item.annotation <> null
    {
        try let type_result handle_type(rp, ep, (*item.annotation).type, file)
            else throw
        set type: type_result
    }

    var attributes: ref[List[Attribute]] *List[Attribute]$()
    if item.attributes <> null
    {
        for attribute_syntax in (*item.attributes)
        {
            try let attribute handle_attribute(rp, ep, attribute_syntax, file)
                else throw
            attributes.add(attribute)
        }
    }
    return Item(Span(item.start, item.end), false, String#(rp, item.name), type, Vector[Attribute](rp, attributes))
}

function handle_parameterset(parameterSetSyntax: ref[ParameterSetSyntax], file: String) returns Vector[Item] throws ModelError {
    var r Region()
    var items: ref[List[Item]] *List[Item]$()
    choose parameterSetSyntax
        when parameters_syntax: ParameterSetSyntax.Parameters
        {
            if parameters_syntax.items <> null
            {
                for item_syntax in (*parameters_syntax.items)
                {
                    try let item handle_item(rp, ep, false, item_syntax, file)
                        else throw
                    items.add(item)
                }
            }
        }
        when type_syntax: ParameterSetSyntax.Type
        {
            try let type handle_type(rp, ep, type_syntax, file)
                else throw
            items.add(Item(Span(type_syntax.start, type_syntax.end), false, null, type, Vector[Attribute]()))
        }

    return Vector[Item](rp, items)
}

function handle_body(name: String, path: String, body: ref[BodySyntax], uses: ref[List[Use]], modules_checker: ref[HashSetBuilder[String]], modules: ref[List[Module]], initializers_builder: ref[List[Initializer]], functions_builder: ref[MultiMapBuilder[String, Function]], members_builder: ref[Array[Member]], symbols_builder: ref[HashMapBuilder[String, Nameable]], file: String) returns pointer[DeInitializer] throws ModelError {
    var r Region()
    if body.uses <> null
    {
        for use_syntax in (*body.uses)
        {
            try let use_result handle_use(rp, ep, use_syntax)
                else throw
            uses.add(use_result)
        }
    }

    if (body.inits <> null)
    {
        for initializer in (*body.inits)
        {
            try let initializer_result handle_initializer(rp, ep, initializer, false, file)
                else throw
            initializers_builder.add(initializer_result)
        }
    }

    var de_initializer: pointer[DeInitializer]  null
    if body.deInit <> null
    {
        try let de_initializer_result handle_deinitializer(rp, ep, *body.deInit, file)
            else throw
        set de_initializer: de_initializer_result
    }

    if body.members <> null
    {
        for member in (*body.members)
        {
            choose member.constituent
                when definition_syntax: ConstituentSyntax.Definition
                {
                    try let concept handle_definition(rp, ep, path, definition_syntax, false, file)
                        else throw

                    if functions_builder.contains(concept.name)
                        throw ModelError(ModelBuilderError(FunctionSymbolExists(file, Span(definition_syntax.start, definition_syntax.end))))

                    if symbols_builder.add(concept.name, Nameable(concept)) = false
                        throw ModelError(ModelBuilderError(DuplicateName(concept.name, Span(definition_syntax.start, definition_syntax.end))))

                    members_builder.add(Member(concept))
                }
                when function_syntax: ConstituentSyntax.Function
                {
                    try let function_result build_function(rp, ep, function_syntax.start, function_syntax.end, function_syntax.target, false, true, file)
                        else throw

                    let symbol_with_function_name symbols_builder.get(function_result.name)
                    if symbol_with_function_name <> null
                        throw ModelError(ModelBuilderError(NonFunctionSymbolExists(file, Span(function_syntax.start, function_syntax.end))))

                    functions_builder.add(function_result.name, function_result)
                    members_builder.add(Member(function_result))
                }
                when procedure_syntax: ConstituentSyntax.Procedure
                {
                    try let procedure_result build_function(rp, ep, procedure_syntax.start, procedure_syntax.end, procedure_syntax.target, false, false, file)
                        else throw

                    let symbol_with_function_name symbols_builder.get(procedure_result.name)
                    if symbol_with_function_name <> null
                        throw ModelError(ModelBuilderError(NonFunctionSymbolExists(file, Span(procedure_syntax.start, procedure_syntax.end))))
                    functions_builder.add(procedure_result.name, procedure_result)
                    members_builder.add(Member(procedure_result))
                }
                when operator_syntax: ConstituentSyntax.Operator
                {
                    try let operator_result handle_operator(rp, ep, operator_syntax, false, file)
                        else throw

                    if symbols_builder.add(operator_result.name, operator_result) = false
                        throw ModelError(ModelBuilderError(DuplicateName(file, Span(operator_syntax.start, operator_syntax.end))))

                    members_builder.add(Member(operator_result))
                }
                when implement_syntax: ConstituentSyntax.Implement
                    throw ModelError(ModelBuilderError(NotImplemented(file, String(ep, "Implement"), Span(implement_syntax.start, implement_syntax.end))))
                when trait_syntax: ConstituentSyntax.Trait
                    throw ModelError(ModelBuilderError(NotImplemented(file, String(ep, "Trait"), Span(trait_syntax.start, trait_syntax.end))))
                when macro_syntax: ConstituentSyntax.Macro
                    throw ModelError(ModelBuilderError(NotImplemented(file, String(ep, "Macro"), Span(macro_syntax.start, macro_syntax.end))))
                when module_syntax: ConstituentSyntax.Module
                {
                    try let module_result handle_module(rp, ep, path, module_syntax, false)
                        else throw
                    if modules_checker.add(module_result.name) = false
                        throw ModelError(ModelBuilderError(NonFunctionSymbolExists(file, Span(module_syntax.start, module_syntax.end))))
                    modules.add(module_result)
                }

        }
    }

    var multi_map MultiMap[String, Function](r.get_page(), functions_builder)
    for functions in multi_map
    {
        let name (*functions.get(0)).name
        symbols_builder.add(String(name), Nameable(Vector<Function>(rp, functions)))
    }

    return de_initializer
}

function handle_class(name: String, path: String, class_syntax: ref[ClassSyntax], private_: bool, file: String) returns Structure throws ModelError {
    var r Region()
    var symbols_builder: ref[HashMapBuilder[String, Nameable]] *HashMapBuilder[String, Nameable]$()
    var properties_builder: ref[Array[Property]] *Array[Property]$()
    if class_syntax.structure.parts <> null
    {
        for part in (*class_syntax.structure.parts)
        {
            choose part 
                when field_syntax: PartSyntax.Field
                {
                    try let property handle_property(rp, ep, true, field_syntax.property, file)
                        else throw

                    if symbols_builder.add(property.name, property) = false
                        throw ModelError(ModelBuilderError(DuplicateName(property.name, Span(field_syntax.start, field_syntax.end))))

                    properties_builder.add(property)
                }
                when property_syntax: PartSyntax.Property
                {
                    try let property handle_property(rp, ep, false, property_syntax, file)
                        else throw

                    if symbols_builder.add(property.name, property) = false
                        throw ModelError(ModelBuilderError(DuplicateName(property.name, Span(property_syntax.start, property_syntax.end))))

                    properties_builder.add(property)
                }
        }
    }

    var modules_checker: ref[HashSetBuilder[String]] *HashSetBuilder[String]$()
    var modules: ref[List[Module]] *List[Module]$()
    var uses: ref[List[Use]] *List[Use]$()
    var functions_builder: ref[MultiMapBuilder[String, Function]] *MultiMapBuilder[String, Function]$()
    var initializers_builder: ref[List[Initializer]] *List[Initializer]$()
    var members_builder: ref[Array[Member]] *Array[Member]$()
    var de_initializer: pointer[DeInitializer] null

    if class_syntax.body <> null
    {
        try let de_initializer_result handle_body(rp, ep, name, path, *class_syntax.body, uses, modules_checker, modules, initializers_builder, functions_builder, members_builder, symbols_builder, file)
            else throw
        set de_initializer: de_initializer_result
    }

    return Structure(Span(class_syntax.start, class_syntax.end), private_, Vector[Property](rp, properties_builder), Vector[Module](rp, modules), Vector[Use](rp, uses), Vector[Initializer](rp, initializers_builder), de_initializer, Vector[Member](rp, members_builder), HashMap[String, Nameable](rp, symbols_builder))
}

function handle_namespace(name: String, path: String, namespace_syntax: ref[NamespaceSyntax], private_: bool, file: String) returns Namespace throws ModelError {
    var r Region()
    var symbols_builder: ref[HashMapBuilder[String, Nameable]] *HashMapBuilder[String, Nameable]$()
    var members_builder: ref[Array[Member]] *Array[Member]$()
    var functions_builder: ref[MultiMapBuilder[String, Function]] *MultiMapBuilder[String, Function]$()
    var modules_checker: ref[HashSetBuilder[String]] *HashSetBuilder[String]$()
    var modules: ref[List[Module]] *List[Module]$()

    if namespace_syntax.declarations <> null
    {
        for declaration in (*namespace_syntax.declarations)
        {
            choose declaration.symbol
                when private_syntax: SymbolSyntax.Private
                {
                    let export_syntax private_syntax.export_
                    choose export_syntax
                        when definition_syntax: ExportSyntax.Definition
                        {
                            try let concept handle_definition(rp, ep, path, definition_syntax, true, file)
                                else throw

                            if functions_builder.contains(concept.name)
                                throw ModelError(ModelBuilderError(FunctionSymbolExists(file, Span(definition_syntax.start, definition_syntax.end))))

                            if symbols_builder.add(concept.name, Nameable(concept)) = false
                                throw ModelError(ModelBuilderError(DuplicateName(concept.name, Span(definition_syntax.start, definition_syntax.end))))

                            members_builder.add(Member(concept))
                        }
                        when function_syntax: ExportSyntax.Function
                        {
                            try let function_result build_function(rp, ep, function_syntax.start, function_syntax.end, function_syntax.target, true, true, file)
                                else throw

                            let symbol_with_function_name symbols_builder.get(function_result.name)
                            if symbol_with_function_name <> null
                                throw ModelError(ModelBuilderError(NonFunctionSymbolExists(file, Span(function_syntax.start, function_syntax.end))))

                            functions_builder.add(function_result.name, function_result)
                            members_builder.add(Member(function_result))
                        }
                        when operator_syntax: ExportSyntax.Operator
                        {
                            try let operator_result handle_operator(rp, ep, operator_syntax, true, file)
                                else throw

                            if symbols_builder.add(operator_result.name, Nameable(operator_result)) = false
                                throw ModelBuilderError(DuplicateName(file, Span(operator_syntax.start, operator_syntax.end)))

                            members_builder.add(Member(operator_result))
                        }
                        when trait_syntax: ExportSyntax.Trait
                            throw ModelError(ModelBuilderError(NotImplemented(file, String(ep, "Private Trait"), Span(trait_syntax.start, trait_syntax.end))))
                        when module_syntax: ExportSyntax.Module
                        {
                            try let module_result handle_module(rp, ep, path, module_syntax, true)
                                else throw

                            if modules_checker.add(module_result.name) = false
                                throw ModelError(ModelBuilderError(NonFunctionSymbolExists(file, Span(module_syntax.start, module_syntax.end))))

                            modules.add(module_result)
                        }
                }
                when definition_syntax: SymbolSyntax.Definition
                {
                    try let concept handle_definition(rp, ep, path, definition_syntax, true, file)
                        else throw

                    if functions_builder.contains(concept.name)
                        throw ModelError(ModelBuilderError(FunctionSymbolExists(file, Span(definition_syntax.start, definition_syntax.end))))

                    if symbols_builder.add(concept.name, Nameable(concept)) = false
                        throw ModelError(ModelBuilderError(DuplicateName(concept.name, Span(definition_syntax.start, definition_syntax.end))))

                    members_builder.add(Member(concept))
                }
                when function_syntax: SymbolSyntax.Function
                {
                    try let function_result build_function(rp, ep, function_syntax.start, function_syntax.end, function_syntax.target, true, true, file)
                        else throw

                    let symbol_with_function_name symbols_builder.get(function_result.name)
                    if symbol_with_function_name <> null
                        throw ModelError(ModelBuilderError(NonFunctionSymbolExists(file, Span(function_syntax.start, function_syntax.end))))

                    functions_builder.add(function_result.name, function_result)
                    members_builder.add(Member(function_result))
                }
                when operator_syntax: SymbolSyntax.Operator
                {
                    try let operator_result handle_operator(rp, ep, operator_syntax, true, file)
                        else throw

                    if symbols_builder.add(operator_result.name, Nameable(operator_result)) = false
                        throw ModelBuilderError(DuplicateName(file, Span(operator_syntax.start, operator_syntax.end)))

                    members_builder.add(Member(operator_result))
                }
                when trait_syntax: SymbolSyntax.Trait
                    throw ModelError(ModelBuilderError(NotImplemented(file, String(ep, "Private Trait"), Span(trait_syntax.start, trait_syntax.end))))
                when macro_syntax: SymbolSyntax.Macro
                    throw ModelError(ModelBuilderError(NotImplemented(file, String(ep, "Macro"), Span(macro_syntax.start, macro_syntax.end))))
                when module_syntax: SymbolSyntax.Module
                {
                    try let module_result handle_module(rp, ep, path, module_syntax, true)
                        else throw

                    if modules_checker.add(module_result.name) = false
                        throw ModelError(ModelBuilderError(NonFunctionSymbolExists(file, Span(module_syntax.start, module_syntax.end))))

                    modules.add(module_result)
                }
        }
    }

    var multi_map MultiMap[String, Function](r.get_page(), functions_builder)
    for functions in multi_map
    {
        let name (*functions.get(0)).name
        symbols_builder.add(String(name), Nameable(Vector[Function](rp, functions)))
    }

    Span(namespace_syntax.start, namespace_syntax.end)
    return Namespace(Span(namespace_syntax.start, namespace_syntax.end), Vector[Module](rp, modules), Vector[Member](rp, members_builder), HashMap[String, Nameable](rp, symbols_builder))
}

function handle_union(name: String, path: String, union_syntax: ref[UnionSyntax], private_: bool, file: String) returns Union throws ModelError {    
    var r Region()
    var variants_builder: ref[Array[Variant]] *Array[Variant]$()
    var symbols_builder: ref[HashMapBuilder[String, Nameable]] *HashMapBuilder[String, Nameable]$()
    if union_syntax.variants <> null
    {
        for variant_syntax in (*union_syntax.variants)
        {
            var type: pointer[Type] null
            if variant_syntax.annotation <> null
            {
                try let type_result handle_type(rp, ep, (*variant_syntax.annotation).type, file)
                    else throw
                set type: type_result
            }

            var attributes: ref[List[Attribute]] *List[Attribute]$()
            if variant_syntax.attributes <> null
            {
                for attribute_syntax in (*variant_syntax.attributes)
                {
                    try let attribute handle_attribute(rp, ep, attribute_syntax, file)
                        else throw

                    attributes.add(attribute)
                }
            }
            let variant Variant(Span(variant_syntax.start, variant_syntax.end), variant_syntax.name, type, Vector[Attribute](rp, attributes))
            if symbols_builder.add(variant_syntax.name, Nameable(variant)) = false
                throw ModelError(ModelBuilderError(DuplicateName(variant_syntax.name, Span(variant_syntax.start, variant_syntax.end))))

            variants_builder.add(variant)
        }
    }

    var modules_checker: ref[HashSetBuilder[String]] *HashSetBuilder[String]$()
    var modules: ref[List[Module]] *List[Module]$()
    var uses: ref[List[Use]] *List[Use]$()
    var functions_builder: ref[MultiMapBuilder[String, Function]] *MultiMapBuilder[String, Function]$()
    var initializers_builder: ref[List[Initializer]] *List[Initializer]$()
    var members_builder: ref[Array[Member]] *Array[Member]$()
    var de_initializer: pointer[DeInitializer] null
    if (union_syntax.body <> null)
    {
        try let de_initializer_result handle_body(rp, ep, name, path, *union_syntax.body, uses, modules_checker, modules, initializers_builder, functions_builder, members_builder, symbols_builder, file)
            else throw
        set de_initializer: de_initializer_result
    }

    return Union(Span(union_syntax.start, union_syntax.end), private_, Vector[Variant](rp, variants_builder), Vector[Member](rp, members_builder), HashMap[String, Nameable](rp, symbols_builder))
}

function handle_literal(literal: ref[LiteralSyntax], file: String) returns Constant throws ModelError {
    var r Region()
    choose literal.literal
        when boolean: Literal.Boolean
            return Constant(BooleanConstant(Span(literal.start, literal.end), boolean.value))
        when integer: Literal.Integer
        {
            let value (size_t)strtol(integer.value.to_c_string(r.get_page()), null, 10)
            if errno = ERANGE
                throw ModelError(ModelBuilderError(InvalidConstant(file, Span(literal.start, literal.end))))

            return Constant(IntegerConstant(Span(literal.start, literal.end), value))
        }
        when hex: Literal.Hex
        {
            let value (size_t)strtoul(hex.value.to_c_string(r.get_page()), null, 16)
            if errno = ERANGE
                throw ModelError(ModelBuilderError(InvalidConstant(file, Span(literal.start, literal.end))))

            return Constant(HexConstant(Span(literal.start, literal.end), value))
        }
        when floating_point: Literal.FloatingPoint
        {
            let value strtod(floating_point.value.to_c_string(r.get_page()), null)
            if errno = ERANGE
                throw ModelError(ModelBuilderError(InvalidConstant(file, Span(literal.start, literal.end))))

            return Constant(FloatingPointConstant(Span(literal.start, literal.end), value))
        }
        when string: Literal.String
            return Constant(StringConstant(Span(literal.start, literal.end), string.value))
        when character: Literal.Character
            return Constant(CharacterConstant(Span(literal.start, literal.end), character.value))
        when fragment: Literal.Fragment
            return Constant(FragmentConstant(Span(literal.start, literal.end), fragment.value))

    throw ModelError(ModelBuilderError(InvalidConstant(file, Span(literal.start, literal.end))))
}

function handle_type(type_syntax: ref[TypeSyntax], file: String) returns pointer[Type] throws ModelError {
    var r Region()

    var path: ref[List[String]] *List[String]$()
    path.add(String(rp, type_syntax.name.name))
    if type_syntax.name.extensions <> null
    {
        for extension in (*type_syntax.name.extensions)
        {
            path.add(extension.name)
        }
    }

    var generics: pointer[Vector[Type]] null
    var lifetime Lifetime(Unspecified())
    var generics_builder: ref[List[Type]] *List[Type]$()
    if type_syntax.generics <> null
    {
        let generic_arguments (*type_syntax.generics).generics
        if generic_arguments <> null
        {
            for generic in (*generic_arguments)
            {
                try let type handle_type(rp, ep, generic.type, file)
                    else throw

                generics_builder.add(*type)
            }

            set generics: Vector[Type]#(rp, generics_builder)
        } else {
            set generics: Vector[Type]#()
        }
    }

    if type_syntax.lifetime <> null
    {
        let lifetime_syntax *type_syntax.lifetime
        choose lifetime_syntax
            when c: LifetimeSyntax.Call
                set lifetime: Lifetime(Call(Span(c.start, c.end)))
            when l: LifetimeSyntax.Local
                set lifetime: Lifetime(Local(Span(l.start, l.end)))
            when r: LifetimeSyntax.Reference
                set lifetime: Lifetime(Reference(Span(r.start, r.end), String(rp, r.location)))
            when t: LifetimeSyntax.Thrown
                set lifetime: Lifetime(Thrown(Span(t.start, t.end)))
    }

    return Type#(Span(type_syntax.start, type_syntax.end), Vector[String](rp, path), generics, lifetime)
}

function handle_binding_annotation(binding_annotation: ref[BindingAnnotationSyntax], file: String) returns pointer[Type] throws ModelError {
    choose binding_annotation.spec
        when type: BindingSpecSyntax.Type
        {
            try let type_result handle_type(rp, ep, type, file)
                else throw

            return type_result
        }
        when structure: BindingSpecSyntax.Structure
            throw ModelError(ModelBuilderError(NotImplemented(file, String(ep, "Structure"), Span(structure.start, structure.end))))
        when array: BindingSpecSyntax.Array
            throw ModelError(ModelBuilderError(NotImplemented(file, String(ep, "Array"), Span(array.start, array.end))))
}

function handle_break(break_syntax: ref[BreakSyntax], file: String) returns Break throws ModelError {
    var r Region()
    if break_syntax.result <> null
    {
        try let result handle_operands(rp, ep, break_syntax.result, file)
            else throw
        return Break(Span(break_syntax.start, break_syntax.end), result)
    }

    return Break(Span(break_syntax.start, break_syntax.end), Vector[Operand]())
}

function handle_continue(continue_syntax: ref[ContinueSyntax], file: String) returns Continue throws ModelError {
    return Continue(Span(continue_syntax.start, continue_syntax.end))
}

function handle_return(return_syntax: ref[ReturnSyntax], file: String) returns Return throws ModelError {
    var r Region()
    if return_syntax.result <> null
    {
        try let result handle_operands(rp, ep, return_syntax.result, file)
            else throw
        return Return(Span(return_syntax.start, return_syntax.end), result)
    }
    return Return(Span(return_syntax.start, return_syntax.end), Vector[Operand]())
}

function handle_throw(throw_syntax: ref[ThrowSyntax], file: String) returns Throw throws ModelError {
    var r Region()
    if throw_syntax.result <> null
    {
        try let result handle_operands(rp, ep, throw_syntax.result, file)
            else throw
        return Throw(Span(throw_syntax.start, throw_syntax.end), result)
    }
    return Throw(Span(throw_syntax.start, throw_syntax.end), Vector[Operand]())
}

function handle_command(command_syntax: ref[CommandSyntax], file: String) returns Statement throws ModelError {
    var r Region()
    choose command_syntax
        when operation_syntax: CommandSyntax.Operation
        {
            try let operation_result handle_operation(rp, ep, operation_syntax, file)
                else throw
            return Statement(Action(operation_result, Vector[Operand]()))
        }
        when let_syntax: CommandSyntax.Let
        {
            var type: pointer[Type] null
            if let_syntax.binding.annotation <> null
            {
                try let type_result handle_binding_annotation(rp, ep, *let_syntax.binding.annotation, file)
                    else throw
                set type: type_result
            }

            try let operation handle_operands(rp, ep, let_syntax.binding.operation, file)
                else throw
            return Statement(Binding(Span(let_syntax.start, let_syntax.end), String(rp, "const"), Item(Span(let_syntax.start, let_syntax.end), false, String#(rp, let_syntax.binding.name), type, Vector[Attribute]()), operation))
        }
        when var_syntax: CommandSyntax.Var
        {
            var type: pointer[Type] null
            if var_syntax.binding.annotation <> null
            {
                try let type_result handle_binding_annotation(rp, ep, *var_syntax.binding.annotation, file)
                    else throw
                set type: type_result
            }
            try let operation handle_operands(rp, ep, var_syntax.binding.operation, file)
                else throw
            return Statement(Binding(Span(var_syntax.start, var_syntax.end), String(rp, "var"), Item(Span(var_syntax.start, var_syntax.end), false, String#(rp, var_syntax.binding.name), type, Vector[Attribute]()), operation))
        }
        when mutable_syntax: CommandSyntax.Mutable
        {
            var type: pointer[Type] null
            if mutable_syntax.binding.annotation <> null
            {
                try let type_result handle_binding_annotation(rp, ep, *mutable_syntax.binding.annotation, file)
                    else throw
                set type: type_result
            }
            try let operation handle_operands(rp, ep, mutable_syntax.binding.operation, file)
                else throw
            return Statement(Binding(Span(mutable_syntax.start, mutable_syntax.end), String(rp, "mutable"), Item(Span(mutable_syntax.start, mutable_syntax.end), false, String#(rp, mutable_syntax.binding.name), type, Vector[Attribute]()), operation))
        }
        when set_syntax: CommandSyntax.Set
        {
            try let target handle_operands(rp, ep, set_syntax.target, file)
                else throw

            try let source handle_operands(rp, ep, set_syntax.source, file)
                else throw

            return Statement(Action(source, target))
        }
        when continue_syntax: CommandSyntax.Continue
        {
            try let continue_result handle_continue(rp, ep, continue_syntax, file)
                else throw

            return Statement(continue_result)
        }
        when break_syntax: CommandSyntax.Break
        {
            try let break_result handle_break(rp, ep, break_syntax, file)
                else throw
            return Statement(break_result)
        }
        when return_syntax: CommandSyntax.Return
        {
            try let return_result handle_return(rp, ep, return_syntax, file)
                else throw
            return Statement(return_result)
        }
        when throw_syntax: CommandSyntax.Throw
        {
            try let throw_result handle_throw(rp, ep, throw_syntax, file)
                else throw
            return Statement(throw_result)
        }
}

function handle_statement(statement_syntax: ref[StatementSyntax], file: String) returns Statement throws ModelError {
    try let statement handle_command(rp, ep, statement_syntax.command, file)
        else throw

    return statement
}

function handle_statements(statements: ref[Vector[StatementSyntax]], file: String) returns Vector[Statement] throws ModelError {
    var r Region()
    var statements_builder: ref[List[Statement]] *List[Statement]$()
    for statement in statements
    {
        try let statement_result handle_statement(rp, ep, statement, file)
            else throw
        statements_builder.add(statement_result)
    }
    
    return Vector[Statement](rp, statements_builder)
}

function handle_component(component: ref[ComponentSyntax], file: String) returns Component throws ModelError {
    var r Region()
    var name: pointer[String] null

    var attributes: ref[List[Attribute]] *List[Attribute]$()
    if component.attributes <> null
    {
        for attribute_syntax in (*component.attributes)
        {
            try let attribute handle_attribute(rp, ep, attribute_syntax, file)
                else throw
            attributes.add(attribute)
        }
    }

    if component.value <> null
    {
        if component.operands <> null
        {
            var name_operands *component.operands
            if name_operands.length > 0
            {
                var name_operand *name_operands.get(0)
                if name_operands.length > 1
                    return ModelError(ModelBuilderError(InvalidComponentName(file, Span(name_operand.start, name_operand.end))))
                choose name_operand.expression
                    when type: ExpressionSyntax.Type
                        set name: String#(rp, type.name.name)
                    else {}
            }
        }

        let value (*component.value).value
        if value <> null
        {
            try let value_result handle_operands(rp, ep, value, file)
                else throw
            return Component(Span(component.start, component.end), name, value_result, Vector[Attribute](rp, attributes))
        } else {
            return Component(Span(component.start, component.end), name, Vector[Operand](), Vector[Attribute](rp, attributes))
        }
    } else {
        if component.operands <> null
        {
            try let value_result handle_operands(rp, ep, component.operands, file)
                else throw
            return Component(Span(component.start, component.end), name, value_result, Vector[Attribute](rp, attributes))
        } else {
            return Component(Span(component.start, component.end), name, Vector[Operand](), Vector[Attribute](rp, attributes))
        }
    }
}

function handle_object(object: ref[ObjectSyntax], file: String) returns Tuple throws ModelError {
    var r Region()
    var components_builder: ref[List[Component]] *List[Component]$()
    if object.components <> null
    {
        for component in (*object.components)
        {
            try let component_result handle_component(rp, ep, component, file)
                else throw

            components_builder.add(component_result)
        }
    }
    return Tuple(Span(object.start, object.end), Vector[Component](rp, components_builder))
}

function handle_vector(vector: ref[VectorSyntax], file: String) returns Matrix throws ModelError {
    var r Region()
    var operations_builder: ref[List[Vector[Operand]]] *List[Vector[Operand]]$()
    if vector.elements <> null
    {
        for element in (*vector.elements)
        {
            try let operation_result handle_operands(rp, ep, element.operation, file)
                else throw
            operations_builder.add(operation_result)
        }
    }
    return Matrix(Span(vector.start, vector.end), Vector[Vector[Operand]](rp, operations_builder))
}

function handle_model(model: ref[ModelSyntax], file: String) returns Model throws ModelError {
    choose model
        when literal: ModelSyntax.Literal
        {
            try let constant handle_literal(rp, ep, literal, file)
                else throw
            return constant
        }
        when name: ModelSyntax.Name
        {
            return String(rp, name.name)
        }
        when object_syntax: ModelSyntax.Object
        {
            try let tuple handle_object(rp, ep, object_syntax, file)
                else throw
            return tuple
        }
        when vector: ExpressionSyntax.Vector
        {
            try let matrix handle_vector(rp, ep, vector, file)
                else throw
            return matrix
        }
}

function handle_attribute(attribute: ref[AttributeSyntax], file: String) returns Attribute throws ModelError {
    try let model handle_model(rp, ep, attribute.model, file)
        else throw
    return Attribute(Span(attribute.start, attribute.end), attribute.name, model)
}

function handle_block(block: ref[BlockSyntax], file: String) returns Block throws ModelError {
    var r Region()
    if block.statements <> null
    {
        try let statements handle_statements(rp, ep, *block.statements, file)
            else throw
        return Block(Span(block.start, block.end), statements)
    }

    return Block(Span(block.start, block.end), Vector<Statement>())
}

function handle_if(if_syntax: ref[IfSyntax], file: String) returns If throws ModelError {
    var r Region()

    var property: pointer[Property] null

    try let condition handle_operands(rp, ep, if_syntax.condition, file)
        else throw

    try let consequent handle_command(rp, ep, if_syntax.consequent, file)
        else throw

    var alternative: pointer[Statement] null
    if if_syntax.alternative <> null
    {
        try let alternative_result handle_command(rp, ep, (*if_syntax.alternative).alternative, file)
            else throw
        set alternative: Statement#(alternative_result)
    }

    return If(Span(if_syntax.start, if_syntax.end), condition, property, consequent, alternative)
}

function handle_match(match_syntax: ref[MatchSyntax], file: String) returns Match throws ModelError {
    var r Region()

    try let condition handle_operands(rp, ep, match_syntax.scrutinee, file)
        else throw

    var branches_builder: ref[List[Branch]] *List[Branch]$()
    if match_syntax.branches <> null
    {
        for branch in (*match_syntax.branches)
        {
            var cases_builder: ref[List[Case]] *List[Case]$()
            for case_syntax in (*branch.cases)
            {
                try let condition handle_operands(rp, ep, case_syntax.condition, file)
                    else throw
                cases_builder.add(Case(Span(case_syntax.start, case_syntax.end), condition))
            }

            try let consequent handle_statement(rp, ep, branch.consequent, file)
                else throw
            branches_builder.add(Branch(Span(branch.start, branch.end), Vector<Case>(rp, cases_builder), consequent))
        }
    }

    var alternative: pointer[Statement] null
    if match_syntax.alternative <> null
    {
        try let alternative_result handle_command(rp, ep, (*match_syntax.alternative).alternative, file)
            else throw
        set alternative: Statement#(alternative_result)
    }
    return Match(Span(match_syntax.start, match_syntax.end), condition, Vector[Branch](rp, branches_builder), alternative)
}

function handle_when(when_syntax: ref[WhenSyntax], file: String) returns When throws ModelError {
    var r Region()

    var name_builder: ref[List[String]] *List[String]$()
    name_builder.add(when_syntax.variant.name)
    if when_syntax.variant.extensions <> null
    {
        for name in (*when_syntax.variant.extensions)
        {
            name_builder.add(name.name)
        }
    }

    try let consequent handle_command(rp, ep, when_syntax.command, file)
        else throw

    return When(Span(when_syntax.start, when_syntax.end), when_syntax.name, Vector[String](rp, name_builder), consequent)
}

function handle_choose(choose_syntax: ref[ChooseSyntax], file: String) returns Choose throws ModelError {
    var r Region()

    try let condition handle_operands(rp, ep, choose_syntax.condition, file)
        else throw

    var cases_builder: ref[List[When]] *List[When]$()
    if choose_syntax.cases <> null
    {
        for case_syntax in (*choose_syntax.cases)
        {
            try let case_result handle_when(rp, ep, case_syntax, file)
                else throw

            cases_builder.add(case_result)
        }
    }

    var alternative: pointer[Statement] null
    if choose_syntax.alternative <> null
    {
        try let alternative_result handle_command(rp, ep, (*choose_syntax.alternative).alternative, file)
            else throw

        set alternative: Statement#(alternative_result)
    }

    return Choose(Span(choose_syntax.start, choose_syntax.end), condition, Vector[When](rp, cases_builder), alternative)
}

function handle_for(for_syntax: ref[ForSyntax], file: String) returns For throws ModelError {
    var r Region()

    try let expression handle_operands(rp, ep, for_syntax.operation, file)
        else throw

    if for_syntax.name <> null
        throw ModelError(ModelBuilderError(NotImplemented(file, String(ep, "Label in For"), Span((*for_syntax.name).start, (*for_syntax.name).end))))

    try let action handle_action(rp, ep, for_syntax.action, file)
        else throw

    return For(Span(for_syntax.start, for_syntax.end), String(rp, for_syntax.variable), expression, action)
}

function handle_condition(condition: ref[ConditionSyntax], file: String) returns Binding throws ModelError {
    var r Region()
    choose condition
        when operation_syntax: ConditionSyntax.Operation
        {
            try let operation_result handle_operation(rp, ep, operation_syntax, file)
                else throw

            return Binding(Span(operation_syntax.start, operation_syntax.end), String(rp, "const"), Item(Span(operation_syntax.start, operation_syntax.end), false, null, null, Vector[Attribute]()), operation_result)
        }
        when let_syntax: ConditionSyntax.Let
        {
            var type: pointer[Type] null
            if let_syntax.binding.annotation <> null
            {
                try let type_result handle_binding_annotation(rp, ep, *let_syntax.binding.annotation, file)
                    else throw

                set type: type_result
            }

            try let operation_result handle_operands(rp, ep, let_syntax.binding.operation, file)
                else throw

            return Binding(Span(let_syntax.start, let_syntax.end), String(rp, "const"), Item(Span(let_syntax.start, let_syntax.end), false, String#(rp, let_syntax.binding.name), null, Vector[Attribute]()), operation_result)
        }
}

function handle_while(while_syntax: ref[WhileSyntax], file: String) returns While throws ModelError {
    var r Region()

    try let condition handle_condition(rp, ep, while_syntax.condition, file)
        else throw

    if while_syntax.name <> null
        throw ModelError(ModelBuilderError(NotImplemented(file, String(ep, "Label in While"), Span((*while_syntax.name).start, (*while_syntax.name).end))))

    try let action handle_action(rp, ep, while_syntax.action, file)
        else throw

    return While(Span(while_syntax.start, while_syntax.end), condition, action)
}

function handle_try(try_syntax: ref[TrySyntax], file: String) returns Try throws ModelError {
    var r Region()

    try let condition handle_condition(rp, ep, try_syntax.condition, file)
        else throw

    var catches_builder: ref[List[When]] *List[When]$()
    if try_syntax.cases <> null
    {
        for catch_syntax in (*try_syntax.cases)
        {
            try let catch_result handle_when(rp, ep, catch_syntax, file)
                else throw
            catches_builder.add(catch_result)
        }
    }

    var dropper: pointer[Statement] null
    if try_syntax.dropper <> null
    {
        var drop_syntax *try_syntax.dropper
        try let drop_result handle_command(rp, ep, drop_syntax.alternative, file)
            else throw
        set dropper: Statement#(drop_result)
    }

    return Try(Span(try_syntax.start, try_syntax.end), condition, Vector[When](rp, catches_builder), dropper)
}

function handle_size_of(size_of_syntax: ref[SizeOfSyntax] file: String) returns SizeOf throws ModelError {
    var r Region()

    try let type handle_type(rp, ep, size_of_syntax.type, file)
        else throw

    return SizeOf(Span(size_of_syntax.start, size_of_syntax.end), *type)
}

function handle_is(is_syntax: ref[IsSyntax] file: String) returns Is throws ModelError {
    var r Region()
    var name_builder: ref[List[String]] *List[String]$()
    name_builder.add(is_syntax.name.name)
    if is_syntax.name.extensions <> null
    {
        for name in (*is_syntax.name.extensions)
        {
            name_builder.add(name.name)
        }
    }
    return Is(Span(is_syntax.start, is_syntax.end), Vector[String](rp, name_builder))
}

function handle_new(new_syntax: ref[NewSyntax] file: String) returns New throws ModelError {
    var r Region()

    try let type handle_type(rp, ep, new_syntax.type, file)
        else throw

    try let arguments handle_object(rp, ep, new_syntax.arguments, file)
        else throw

    return New(Span(new_syntax.start, new_syntax.end), *type, arguments)
}

function handle_expression(expression: ref[ExpressionSyntax], file: String) returns Expression throws ModelError {
    var r Region()
    choose expression
        when literal_syntax: ExpressionSyntax.Literal
        {
            try let constant handle_literal(rp, ep, literal_syntax, file)
                else throw
            return constant
        }
        when type_syntax: ExpressionSyntax.Type
        {
            try let type_result handle_type(rp, ep, type_syntax, file)
                else throw
            return *type_result
        }
        when object_syntax: ExpressionSyntax.Object
        {
            try let object_result handle_object(rp, ep, object_syntax, file)
                else throw
            return object_result
        }
        when vector_syntax: ExpressionSyntax.Vector
        {
            try let vector_result handle_vector(rp, ep, vector_syntax, file)
                else throw
            return vector_result
        }
        when block_syntax: ExpressionSyntax.Block
        {
            try let block_result handle_block(rp, ep, block_syntax, file)
                else throw
            return block_result
        }
        when if_syntax: ExpressionSyntax.If
        {
            try let if_result handle_if(rp, ep, if_syntax, file)
                else throw
            return if_result
        }
        when match_syntax: ExpressionSyntax.Match
        {
            try let match_result handle_match(rp, ep, match_syntax, file)
                else throw
            return match_result
        }
        when lambda_syntax: ExpressionSyntax.Lambda
            throw ModelError(ModelBuilderError(NotImplemented(file, String(ep, "Lambda"), Span(lambda_syntax.start, lambda_syntax.end))))
        when for_syntax: ExpressionSyntax.For
        {
            try let for_result handle_for(rp, ep, for_syntax, file)
                else throw
            return for_result
        }
        when while_syntax: ExpressionSyntax.While
        {
            try let while_result handle_while(rp, ep, while_syntax, file)
                else throw
            return while_result
        }
        when choose_syntax: ExpressionSyntax.Choose
        {
            try let choose_result handle_choose(rp, ep, choose_syntax, file)
                else throw
            return choose_result
        }
        when try_syntax: ExpressionSyntax.Try
        {
            try let try_result handle_try(rp, ep, try_syntax, file)
                else throw
            return try_result
        }
        when repeat_syntax: ExpressionSyntax.Repeat
            throw ModelError(ModelBuilderError(NotImplemented(file, String(ep, "Repeat"), Span(repeat_syntax.start, repeat_syntax.end))))
        when sizeof_syntax: ExpressionSyntax.SizeOf
        {
            try let size_of_result handle_size_of(rp, ep, sizeof_syntax, file)
                else throw
            return size_of_result
        }
        when is_syntax: ExpressionSyntax.Is
        {
            try let is_result handle_is(rp, ep, is_syntax, file)
                else throw
            return is_result
        }
        when new_syntax: ExpressionSyntax.New
        {
            try let new_result handle_new(rp, ep, new_syntax, file)
                else throw
            return new_result
        }
}

function handle_operand(operand: ref[OperandSyntax], file: String) returns Operand throws ModelError {
    var r Region()
    var member_access: pointer[Vector[String]] null
    if operand.members <> null
    {
        var path: ref[List[String]] *List[String]$()
        for member in (*operand.members)
        {
            path.add(String(rp, member.name.name))
            if member.name.extensions <> null
            {
                for extension in (*member.name.extensions)
                {
                    path.add(extension.name)
                }
            }
        }
        set member_access: Vector[String]#(rp, path)
    }

    try let expression handle_expression(rp, ep, operand.expression, file)
        else throw

    return Operand(Span(operand.start, operand.end), expression, member_access)
}

function handle_operands(operands: pointer[Vector[OperandSyntax]], file: String) returns Vector[Operand] throws ModelError {
    var r Region()
    var operands_builder: ref[List[Operand]] *List[Operand]$()
    if operands <> null
    {
        for operand_syntax in (*operands)
        {
            try let operand handle_operand(rp, ep, operand_syntax, file)
                else throw
            operands_builder.add(operand)
        }
    }
    return Vector[Operand](rp, operands_builder)
}

function handle_operation(operation: ref[OperationSyntax], file: String) returns Vector[Operand] throws ModelError {
    if operation.operands <> null
    {
        try let operands_result handle_operands(rp, ep, operation.operands, file)
            else throw
        return operands_result
    }
    return Vector[Operand]()
}

function handle_generic_parameter(generic_parameter: ref[GenericParameterSyntax], file: String) returns GenericParameter throws ModelError {
    var r Region()
    var attributes: ref[List[Attribute]] *List[Attribute]$()
    if generic_parameter.attributes <> null
    {
        for attribute_syntax in (*generic_parameter.attributes)
        {
            try let attribute handle_attribute(rp, ep, attribute_syntax, file)
                else throw

            attributes.add(attribute)
        }
    }
    return GenericParameter(Span(generic_parameter.start, generic_parameter.end), String(rp, generic_parameter.name), Vector[Attribute](rp, attributes))
}

function handle_use(use_syntax: ref[UseSyntax]) returns Use throws ModelError {
    var r Region()
    var path: ref[List[String]] *List[String]$()
    path.add(String(rp, use_syntax.name.name))
    if use_syntax.name.extensions <> null
    {
        for extension in (*use_syntax.name.extensions)
        {
            path.add(extension.name)
        }
    }

    return Use(Span(use_syntax.start, use_syntax.end), Vector[String](rp, path))
}

function handle_definition(path: String, definition: ref[DefinitionSyntax], private_: bool, file: String) returns Concept throws ModelError {
    var r Region()
    let concept definition.concept_
    let span Span(definition.start, definition.end)

    var parameters: ref[List[GenericParameter]] *List[GenericParameter]$()
    if definition.parameters <> null
    {
        let generic_parameters *definition.parameters
        if generic_parameters.parameters <> null
        {
            for generic_parameter in (*generic_parameters.parameters)
            {
                try let parameter handle_generic_parameter(rp, ep, generic_parameter, file)
                    else throw

                parameters.add(parameter)
            }
        }
    }

    var attributes: ref[List[Attribute]] *List[Attribute]$()
    if definition.attributes <> null
    {
        for attribute_syntax in (*definition.attributes)
        {
            try let attribute handle_attribute(rp, ep, attribute_syntax, file)
                else throw

            attributes.add(attribute)
        }
    }

    choose concept
        when class_syntax: ConceptSyntax.Class
        {
            try let structure handle_class(rp, ep, definition.name, path, class_syntax, private_, file)
                else throw

            return Concept(span, String(rp, definition.name), Vector[GenericParameter](rp, parameters), Vector[Attribute](rp, attributes), Definition(structure))
        }
        when namespace_syntax: ConceptSyntax.Namespace
        {
            try let namespace_result handle_namespace(rp, ep, definition.name, Path->join(rp, path, definition.name), namespace_syntax, private_, file)
                else throw

            return Concept(span, String(rp, definition.name), Vector[GenericParameter](rp, parameters), Vector[Attribute](rp, attributes), Definition(namespace_result))
        }
        when union_syntax: ConceptSyntax.Union
        {
            try let union_result handle_union(rp, ep, definition.name, path, union_syntax, private_, file)
                else throw

            return Concept(span, String(rp, definition.name), Vector[GenericParameter](rp, parameters), Vector[Attribute](rp, attributes), Definition(union_result))
        }
        when constant_syntax: ConceptSyntax.Constant
        {
            if constant_syntax.operation = null
            {
                ; This is a type definition (no operands)
                ; The type field contains the target type reference
                try let type_ref handle_type(rp, ep, constant_syntax.type, file)
                    else throw

                return Concept(span, String(rp, definition.name), Vector[GenericParameter](rp, parameters), Vector[Attribute](rp, attributes), Definition(*type_ref))
            }

            ; This is a global constant definition (has operands)
            try let operation handle_operands(rp, ep, constant_syntax.operation, file)
                else throw

            try let type handle_type(rp, ep, constant_syntax.type, file)
                else throw

            return Concept(span, String(rp, definition.name), Vector[GenericParameter](rp, parameters), Vector[Attribute](rp, attributes), Definition(Global(span, *type, operation)))
        }
        when delegate_syntax: ConceptSyntax.Delegate
            throw ModelError(ModelBuilderError(NotImplemented(file, String(ep, "Delegate"), Span(delegate_syntax.start, delegate_syntax.end))))
        when intrinsic_syntax: ConceptSyntax.Intrinsic
            return Concept(span, String(rp, definition.name), Vector[GenericParameter](rp, parameters), Vector[Attribute](rp, attributes), Definition(Intrinsic(Span(intrinsic_syntax.start, intrinsic_syntax.end))))

    throw ModelError(ModelBuilderError(NotImplemented(file, String(ep, "Unknown concept type"), span)))
}

function handle_action(action: ref[ActionSyntax], file: String) returns Action throws ModelError {
    choose action
        when operation_syntax: ActionSyntax.Operation
        {
            try let operation handle_operation(rp, ep, operation_syntax, file)
                else throw

            return Action(operation, Vector[Operand]())
        }
        when set_syntax: ActionSyntax.Set
        {
            try let target handle_operands(rp, ep, set_syntax.target, file)
                else throw

            try let source handle_operands(rp, ep, set_syntax.source, file)
                else throw

            return Action(source, target)
        }
}

function build_function(start: size_t, end: size_t, target_syntax: ref[TargetSyntax], private_: bool, pure: bool, file: String) returns Function throws ModelError {
    var input Vector[Item]()
    var output Vector[Item]()
    choose target_syntax
        when routine_syntax: TargetSyntax.Routine
            throw ModelError(ModelBuilderError(NotImplemented(file, String(ep, "Non-Symbol Function"), Span(start, end))))
        when named_syntax: TargetSyntax.Named
        {
            if named_syntax.routine.parameters <> null
            {
                try let input_result handle_parameterset(rp, ep, *named_syntax.routine.parameters, file)
                    else throw

                set input: input_result
            }

            var returns_: pointer[Type] null
            if named_syntax.routine.returns_ <> null
            {
                try let type handle_type(rp, ep, (*named_syntax.routine.returns_).type, file)
                    else throw
                set returns_: type
            }

            var throws_: pointer[Type] null
            if named_syntax.routine.throws_ <> null
            {
                try let type handle_type(rp, ep, (*named_syntax.routine.throws_).type, file)
                    else throw
                set throws_: type
            }

            var lifetime Lifetime(Unspecified())
            if named_syntax.routine.lifetime <> null
            {
                choose (*named_syntax.routine.lifetime)
                    when call: LifetimeSyntax.Call
                        set lifetime: Lifetime(Call(Span(call.start, call.end)))
                    when local: LifetimeSyntax.Local
                        set lifetime: Lifetime(Local(Span(local.start, local.end)))
                    when reference: LifetimeSyntax.Reference
                        set lifetime: Lifetime(Reference(Span(reference.start, reference.end), String(rp, reference.location)))
                    when thrown: LifetimeSyntax.Thrown
                        set lifetime: Lifetime(Thrown(Span(thrown.start, thrown.end)))
            }

            choose named_syntax.routine.implementation
                when action_syntax: ImplementationSyntax.Action
                {
                    try let action handle_action(rp, ep, action_syntax, file)
                        else throw
                    return Function(Span(start, end), private_, pure, String(rp, named_syntax.name), input, returns_, throws_, lifetime, Implementation(action))
                }
                when extern_syntax: ImplementationSyntax.Extern
                    return Function(Span(start, end), private_, pure, String(rp, named_syntax.name), input, returns_, null, lifetime, Implementation(Extern(Span(extern_syntax.start, extern_syntax.end))))
                when instruction_syntax: ImplementationSyntax.Instruction
                    return Function(Span(start, end), private_, pure, String(rp, named_syntax.name), input, returns_, null, lifetime, Implementation(Instruction(Span(instruction_syntax.start, instruction_syntax.end))))
                when intrinsic_syntax: ImplementationSyntax.Intrinsic
                    return Function(Span(start, end), private_, pure, String(rp, named_syntax.end), input, returns_, null, lifetime, Implementation(Intrinsic(Span(intrinsic_syntax.start, intrinsic_syntax.end))))
        }
}

function handle_initializer(init_syntax: ref[InitSyntax], private_: bool, file: String) returns Initializer throws ModelError {
    var input Vector[Item]()

    if init_syntax.parameters <> null
    {
        try let parameter_set handle_parameterset(rp, ep, *init_syntax.parameters, file)
            else throw

        set input: parameter_set
    }

    try let action handle_action(rp, ep, init_syntax.action, file)
        else throw

    return Initializer(Span(init_syntax.start, init_syntax.end), private_, input, Implementation(action))
}

function handle_deinitializer(de_init_syntax: ref[DeInitSyntax], file: String) returns pointer[DeInitializer] throws ModelError {
    try let action handle_action(rp, ep, de_init_syntax.action, file)
        else throw

    return DeInitializer#(Span(de_init_syntax.start, de_init_syntax.end), Implementation(action))
}

function handle_operator(operator_syntax: ref[OperatorSyntax], private_: bool, file: String) returns Operator throws ModelError {
    var input Vector[Item]()
    let start operator_syntax.start
    let end operator_syntax.end
    var operation: pointer[Vector[Operand]] null
    choose operator_syntax.target
        when routine: TargetSyntax.Routine
        {
            if routine.generics <> null
            {
                if routine.parameters <> null
                {
                    try let input_result handle_parameterset(rp, ep, *routine.parameters, file)
                        else throw

                    set input: input_result
                }

                var returns_: pointer[Type] null
                if routine.returns_ <> null
                {
                    try let type handle_type(rp, ep, (*routine.returns_).type, file)
                        else throw

                    set returns_: type
                }

                var throws_: pointer[Type]  null
                if routine.throws_ <> null
                {
                    try let type handle_type(rp, ep, (*routine.throws_).type, file)
                        else throw

                    set throws_: type
                }

                choose routine.implementation
                    when action_syntax: ImplementationSyntax.Action
                    {
                        try let action handle_action(rp, ep, action_syntax, file)
                            else throw

                        return Operator(Span(start, end), private_, String(rp, "[]"), input, returns_, throws_, Implementation(action))
                    }
                    when extern_syntax: ImplementationSyntax.Extern
                        return Operator(Span(start, end), private_, String(rp, "[]"), input, returns_, throws_, Implementation(Extern(Span(extern_syntax.start, extern_syntax.end))))
                    when instruction_syntax: ImplementationSyntax.Instruction
                        return Operator(Span(start, end), private_, String(rp, "[]"), input, returns_, throws_, Implementation(Instruction(Span(instruction_syntax.start, instruction_syntax.end))))
                    when intrinsic_syntax: ImplementationSyntax.Intrinsic
                        return Operator(Span(start, end), private_, String(rp, "[]"), input, returns_, throws_, Implementation(Intrinsic(Span(intrinsic_syntax.start, intrinsic_syntax.end))))
            }
            throw ModelError(ModelBuilderError(NotImplemented(file, String(ep, "Non-Symbol Operator"), Span(operator_syntax.start, operator_syntax.end))))
        }
        when named: TargetSyntax.Named
        {
            if named.routine.parameters <> null
            {
                try let input_result handle_parameterset(rp, ep, *named.routine.parameters, file)
                    else throw
                set input: input_result
            }

            var returns_: pointer[Type] null
            if named.routine.returns_ <> null
            {
                try let type handle_type(rp, ep, (*named.routine.returns_).type, file)
                    else throw
                set returns_: type
            }

            var throws_: pointer[Type] null
            if named.routine.throws_ <> null
            {
                try let type handle_type(rp, ep, (*named.routine.throws_).type, file)
                    else throw
                set throws_: type
            }

            choose named.routine.implementation
                when action_syntax: ImplementationSyntax.Action
                {
                    try let action handle_action(rp, ep, action_syntax, file)
                        else throw
                    return Operator(Span(start, end), private_, String(rp, named.name), input, returns_, throws_, Implementation(action))
                }
                when extern_syntax: ImplementationSyntax.Extern
                    return Operator(Span(start, end), private_, String(rp, named.name), input, returns_, throws_, Implementation(Extern(Span(extern_syntax.start, extern_syntax.end))))
                when instruction_syntax: ImplementationSyntax.Instruction
                    return Operator(Span(start, end), private_, String(rp, named.name), input, returns_, throws_, Implementation(Instruction(Span(instruction_syntax.start, instruction_syntax.end))))
                when intrinsic_syntax: ImplementationSyntax.Intrinsic
                    return Operator(Span(start, end), private_, String(rp, named.name), input, returns_, throws_, Implementation(Intrinsic(Span(intrinsic_syntax.start, intrinsic_syntax.end))))
        }
}

function build_module(path: String, file_name: String, name: String, file_syntax: ref[FileSyntax] , private_: bool) returns Module throws ModelError {
    var r Region()
    var uses: ref[List[Use]] *List[Use]$()
    if file_syntax.uses <> null
    {
        for use_syntax in (*file_syntax.uses)
        {
            try let use_result handle_use(rp, ep, use_syntax)
                else throw
            uses.add(use_result)
        }
    }

    var members_builder: ref[Array[Member]] *Array[Member]$()
    var symbols_builder: ref[HashMapBuilder[String, Nameable]] *HashMapBuilder[String, Nameable]$()
    var functions_builder: ref[MultiMapBuilder[String, Function]] *MultiMapBuilder[String, Function]$()
    var modules_checker: ref[HashSetBuilder[String]] *HashSetBuilder[String]$()
    var modules: ref[List[Module]] *List[Module]$()

    if file_syntax.declarations <> null
    {
        for declaration in (*file_syntax.declarations)
        {
            choose declaration.symbol
                when private_syntax: SymbolSyntax.Private
                {
                    choose private_syntax.export_
                        when definition_syntax: ExportSyntax.Definition
                        {
                            try let concept handle_definition(rp, ep, path, definition_syntax, true, file_name)
                                else throw

                            if (functions_builder.contains(concept.name))
                                throw ModelError(ModelBuilderError(FunctionSymbolExists(file_name, Span(definition_syntax.start, definition_syntax.end))))

                            if symbols_builder.add(concept.name, Nameable(concept)) = false
                                throw ModelError(ModelBuilderError(DuplicateName(concept.name, Span(definition_syntax.start, definition_syntax.end))))

                            members_builder.add(Member(concept))
                        }
                        when function_syntax: ExportSyntax.Function
                        {
                            try let function_result build_function(rp, ep, function_syntax.start, function_syntax.end, function_syntax.target, true, true, file_name)
                                else throw

                            let symbol_with_function_name symbols_builder.get(function_result.name)
                            if symbol_with_function_name <> null
                                throw ModelError(ModelBuilderError(NonFunctionSymbolExists(file_name, Span(function_syntax.start, function_syntax.end))))

                            functions_builder.add(function_result.name, function_result)
                            members_builder.add(Member(function_result))
                        }
                        when operator_syntax: ExportSyntax.Operator
                        {
                            try let operator_result handle_operator(rp, ep, operator_syntax, true, file_name)
                                else throw
                            if symbols_builder.add(operator_result.name, Nameable(operator_result)) = false
                                throw ModelError(ModelBuilderError(DuplicateName(file_name, Span(operator_syntax.start, operator_syntax.end))))

                            members_builder.add(Member(operator_result))
                        }
                        when trait_syntax: ExportSyntax.Trait
                            throw ModelError(ModelBuilderError(NotImplemented(file_name, String(ep, "Private Trait"), Span(trait_syntax.start, trait_syntax.end))))
                        when module_syntax: ExportSyntax.Module
                        {
                            try let module_result handle_module(rp, ep, path, module_syntax, true)
                                else throw
                            if modules_checker.add(module_result.name) = false
                                throw ModelError(ModelBuilderError(NonFunctionSymbolExists(file_name, Span(module_syntax.start, module_syntax.end))))
                            modules.add(module_result)
                        }
                }
                when definition_syntax: SymbolSyntax.Definition
                {
                    try let concept handle_definition(rp, ep, path, definition_syntax, false, file_name)
                        else throw

                    if (functions_builder.contains(concept.name))
                        throw ModelError(ModelBuilderError(FunctionSymbolExists(file_name, Span(definition_syntax.start, definition_syntax.end))))

                    if symbols_builder.add(concept.name, Nameable(concept)) = false
                        throw ModelError(ModelBuilderError(DuplicateName(file_name, Span(definition_syntax.start, definition_syntax.end))))

                    members_builder.add(Member(concept))
                }
                when function_syntax: SymbolSyntax.Function
                {
                    try let function_result build_function(rp, ep, function_syntax.start, function_syntax.end, function_syntax.target, false, true, file_name)
                        else throw

                    let symbol_with_function_name symbols_builder.get(function_result.name)
                    if symbol_with_function_name <> null
                        throw ModelError(ModelBuilderError(NonFunctionSymbolExists(file_name, Span(function_syntax.start, function_syntax.end))))

                    functions_builder.add(function_result.name, function_result)
                    members_builder.add(Member(function_result))
                }
                when operator_syntax: SymbolSyntax.Operator
                {
                    try let operator_result handle_operator(rp, ep, operator_syntax, false, file_name)
                        else throw
                    if symbols_builder.add(operator_result.name, Nameable(operator_result)) = false
                        throw ModelError(ModelBuilderError(DuplicateName(file_name, Span(operator_syntax.start, operator_syntax.end))))
                    members_builder.add(Member(operator_result))
                }
                when trait_syntax: SymbolSyntax.Trait
                    throw ModelError(ModelBuilderError(NotImplemented(file_name, String(ep, "Trait"), Span(trait_syntax.start, trait_syntax.end))))
                when macro_syntax: SymbolSyntax.Macro
                    throw ModelError(ModelBuilderError(NotImplemented(file_name, String(ep, "Macro"), Span(macro_syntax.start, macro_syntax.end))))
                when module_syntax: SymbolSyntax.Module
                {
                    try let module_result handle_module(rp, ep, path, module_syntax, false)
                        else throw

                    if modules_checker.add(module_result.name) = false
                        throw ModelError(ModelBuilderError(NonFunctionSymbolExists(file_name, Span(module_syntax.start, module_syntax.end))))

                    modules.add(module_result)
            }
        }
    }

    var multi_map MultiMap[String, Function](r.get_page(), functions_builder)
    for functions in multi_map
    {
        let name (*functions.get(0)).name
        symbols_builder.add(String(name), Nameable(Vector[Function](rp, functions)))
    }

    return Module(private_, String(rp, file_name), name, Vector[Module](rp, modules), Vector[Use](rp, uses), Vector[Member](rp, members_builder), HashMap[String, Nameable](rp, symbols_builder))
}

function build_referenced_module(path: String, name: String, private_: bool) returns Module throws ModelError {
    var r Region()
    var file_name_builder: ref[StringBuilder] *StringBuilder$(Path->join(r.get_page(), path, name))
    file_name_builder.append(".scaly")
    let file_name file_name_builder.to_string(rp)
    let module_text_result File->read_to_string(r.get_page(), ep, file_name)
    choose module_text_result
        when error: Success.Error
            throw ModelError(error)
        when module_text: Success.Ok
        {
            var parser: ref[Parser] *Parser$(module_text)
            try let file_syntax parser.parse_file(rp, ep)
                when invalid_syntax: ParserError.Invalid
                    throw ModelError(ParserModelError(file_name, invalid_syntax))
                when different_syntax: ParserError.Different
                    throw ModelError(ParserModelError(file_name, different_syntax))

            if parser.is_at_end() = false
                throw ModelError(ParserModelError(file_name, ParserError(InvalidSyntax(parser.lexer.previous_position, parser.lexer.position, String(ep, "a valid declaration")))))

            try let module_result build_module(rp, ep, path, file_name, name, file_syntax, private_)
                else throw
            return module_result
        }
}

function handle_module(path: String, module_syntax: ref[ModuleSyntax], private_: bool) returns Module throws ModelError {
    try let module_result build_referenced_module(rp, ep, path, module_syntax.name, private_)
        else throw
    return module_result
}

function build_program(file_name: String, program_name: String) returns Program throws ModelError {
    var r Region()
    let file_text_result File->read_to_string(r.get_page(), r.get_page(), file_name)
    choose file_text_result
        when error: Success.Error
            throw ModelError(error)
        when file_text: Success.Ok
        {
            try let program_syntax parse_program(rp, ep, file_text)
                when invalid_syntax: ParserError.Invalid
                    throw ModelError(ParserModelError(file_name, invalid_syntax))
                when different_syntax: ParserError.Different
                    throw ModelError(ParserModelError(file_name, different_syntax))

            let path Path->get_directory_name(rp, file_name)
            var packages: ref[List[Module]] *List[Module]$()
            if program_syntax.file.packages <> null
            {
                for package_syntax in (*program_syntax.file.packages)
                {
                    try let package_result build_referenced_module(rp, ep, Path->join(r.get_page(), String(rp, ".."), package_syntax.name.name), package_syntax.name.name, false)
                        else throw
                    packages.add(package_result)
                }
            }

            try let module_result build_module(rp, ep, Path->get_directory_name(rp, file_name), file_name, program_name, program_syntax.file, false)
                else throw

            var statements Vector[Statement]()
            if program_syntax.statements <> null
            {
                try let statements_result handle_statements(rp, ep, *program_syntax.statements, file_name)
                    else throw
                set statements: statements_result
            }

            return Program(Vector[Module](rp, packages), module_result, statements)
        }
}

}