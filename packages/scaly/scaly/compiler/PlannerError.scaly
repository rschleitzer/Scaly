use scaly.io

define DuplicateIntrinsic(name: String)
define DuplicateFunction(name: String)
define InstructionWithoutArguments(name: String)
define UnknownInstruction(name: String)
define InstructionWithInvalidNumberOfArguments(name: String)
define TupleComponentNamesNotSupported()
define UndefinedType(file: String, span: Span, name: String)
{
    function to_string(this: UndefinedType) returns String {
        var r Region()
        var message_builder: ref[StringBuilder] *StringBuilder$()
        append_error_message_header(message_builder, file, span.start)
        message_builder.append("The ")
        message_builder.append(name)
        message_builder.append(" type is not defined.")
        append_hint_lines(message_builder, file, span.start, span.end)

        return message_builder.to_string(rp)
    }
}

define UndefinedTypeOrValue(file: String, span: Span, name: String)
{
    function to_string(this: UndefinedTypeOrValue) returns String {
        var r Region()
        var message_builder: ref[StringBuilder] *StringBuilder$()
        append_error_message_header(message_builder, file, span.start)
        message_builder.append("The ")
        message_builder.append(name)
        message_builder.append(" type or value is not defined.")
        append_hint_lines(message_builder, file, span.start, span.end)

        return message_builder.to_string(rp)
    }
}

define ConceptExpected(file: String, span: Span, name: String)
{
    function to_string(this: UndefinedType) returns String {
        var r Region()
        var message_builder: ref[StringBuilder] *StringBuilder$()
        append_error_message_header(message_builder, file, span.start)
        message_builder.append("A type is not expected here.")
        append_hint_lines(message_builder, file, span.start, span.end)

        return message_builder.to_string(rp)
    }
}

define InvalidNumberOfArguments(file: String, span: Span, name: String, expected: int, provided: int)
{
    function to_string(this: UndefinedType) returns String {
        var r Region()
        var message_builder: ref[StringBuilder] *StringBuilder$()
        append_error_message_header(message_builder, file, span.start)
        message_builder.append("The function ")
        message_builder.append(name)
        message_builder.append(" expects ")
        message_builder.append(number_to_string(r.get_page(), expected))
        message_builder.append(" arguments, provided were ")
        message_builder.append(number_to_string(r.get_page(), provided))
        message_builder.append(".")
        append_hint_lines(message_builder, file, span.start, span.end)

        return message_builder.to_string(rp)
    }
}

define TypeMismatch(file: String, span: Span, expected: String, provided: String)
{
    function to_string(this: UndefinedType) returns String {
        var r Region()
        var message_builder: ref[StringBuilder] *StringBuilder$()
        append_error_message_header(message_builder, file, span.start)
        message_builder.append("The type ")
        message_builder.append(expected)
        message_builder.append(" is expected here, provided was ")
        message_builder.append(provided)
        message_builder.append(".")
        append_hint_lines(message_builder, file, span.start, span.end)

        return message_builder.to_string(rp)
    }
}

define PlannerError union
(
    NotImplemented: FeatureNotImplemented
    FileError: FileError
    DuplicateIntrinsic: DuplicateIntrinsic
    DuplicateFunction: DuplicateFunction
    InstructionWithoutArguments: InstructionWithoutArguments
    UnknownInstruction: UnknownInstruction
    InstructionWithInvalidNumberOfArguments: InstructionWithInvalidNumberOfArguments
    TupleComponentNamesNotSupported: TupleComponentNamesNotSupported
    UndefinedType: UndefinedType
    UndefinedTypeOrValue: UndefinedTypeOrValue
    ConceptExpected: ConceptExpected
    InvalidNumberOfArguments: InvalidNumberOfArguments
    TypeMismatch: TypeMismatch
)
{
    function to_string(this: PlannerError) returns String {
        var r Region()
        var message_builder: ref[StringBuilder] *StringBuilder$()
        choose *this
            when ni: PlannerError.NotImplemented
            {
                return ni.to_string(rp)
            }
            when fe: PlannerError.FileError
                message_builder.append(fe.to_string(r.get_page()))
            when di: PlannerError.DuplicateIntrinsic
            {
                message_builder.append("The intrinsic \"")
                message_builder.append(di.name)
                message_builder.append("\" is already defined.")
            }
            when df: PlannerError.DuplicateFunction
            {
                message_builder.append("The function \"")
                message_builder.append(df.name)
                message_builder.append("\" is already defined.")
            }
            when iwa: PlannerError.InstructionWithoutArguments
            {
                message_builder.append("The instruction \"")
                message_builder.append(iwa.name)
                message_builder.append("\" must be provided with arguments.")
            }
            when ui: PlannerError.UnknownInstruction
            {
                message_builder.append("The instruction \"")
                message_builder.append(ui.name)
                message_builder.append("\" is unknown.")
            }
            when ina: PlannerError.InstructionWithInvalidNumberOfArguments
            {
                message_builder.append("The instruction \"")
                message_builder.append(ina.name)
                message_builder.append("\" is called with an invalid number of arguments.")
            }
            when tcns: PlannerError.TupleComponentNamesNotSupported
            {
                message_builder.append("Tuple component names are not supported.")
            }
            when ut: PlannerError.UndefinedType
            {
                return ut.to_string(rp)
            }
            when utv: PlannerError.UndefinedTypeOrValue
            {
                return utv.to_string(rp)
            }
            when ce: PlannerError.ConceptExpected
            {
                return ce.to_string(rp)
            }
            when ina: PlannerError.InvalidNumberOfArguments
            {
                return ina.to_string(rp)
            }
            when tm: PlannerError.TypeMismatch
            {
                return tm.to_string(rp)
            }

        message_builder.append('\n')
        return message_builder.to_string(rp)
    }
}
