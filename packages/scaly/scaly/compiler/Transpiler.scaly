use scaly.containers
use scaly.io

define transpiler {

function program(program: ref[Program]) throws TranspilerError {
    var r Region()

    let file program.module_.file
    var path Path->get_directory_name(r.get_page(), file)
    if path.get_length() > 0
    {
        try let exists Directory->exists(ep, path)
            else throw

        if exists = false
        {
            try Directory->create(ep, path)
                else throw
        }
    }
    try build_module(ep, path, program.module_, program.module_.name, String(), String())
       else throw

    for module_ in program.module_.modules
    {
        try build_module(ep, path, module_, module_.name, String(), String())
            else throw
    }

    if program.statements.length > 0
        main_file(ep, path, program)
    main_include_file(ep, path, program.module_.name)
    forward_includes(ep, path, program)
    vscode_files(ep, path, program)

    return Void()
}

function build_module(path: String, module_: ref[Module], main_header: String, namespace_open: String, namespace_close: String) throws TranspilerError {
    var r Region()

    try create_directory(ep, path)
        else throw

    set path: Path->join(r.get_page(), path, module_.name)

    var header_builder: ref[StringBuilder] *StringBuilder$()
    var cpp_builder: ref[StringBuilder] *StringBuilder$()

    cpp_builder.append("#include \"")
    cpp_builder.append(main_header)
    cpp_builder.append(".h\"")
    cpp_builder.append(namespace_open)

    header_builder.append("#ifndef _")
    header_builder.append(module_.name)
    header_builder.append("_h\n")
    header_builder.append("#define _")
    header_builder.append(module_.name)
    header_builder.append("_h\n")
    if module_.name.equals(main_header)
    {
        if module_.name.equals("scaly")
        {
            header_builder.append("#include <stdlib.h>
#include <memory.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/stat.h>
#include <errno.h>
#include <math.h>
#include <libgen.h>
#include <fcntl.h>
#include \"forwards.h\"

struct Void {};
enum Success { Ok, Error };

template<class OK, class ERROR>
struct Result {
    Result(OK _Ok) : _tag(Ok), _Ok(_Ok) {}
    Result(ERROR _ERROR) : _tag(Error), _Error(_ERROR) {}
    Success _tag;
    union {
        OK _Ok;
        ERROR _Error;
    };
};

")
        } else {
            header_builder.append("#include \"../scaly/scaly.h\"\n#include \"forwards.h\"\n")
        }
    } else {
        header_builder.append("#include \"")
        header_builder.append(main_header)
        header_builder.append(".h\"\n")
    }
    if module_.name.equals("scaly") = false && module_.name.equals("memory") = false
        header_builder.append("using namespace scaly;\nusing namespace scaly::memory;\n")
    
    build_uses(header_builder, module_.uses)
    build_uses(cpp_builder, module_.uses)

    var namespace_open_builder: ref[StringBuilder] *StringBuilder$(namespace_open)

    try build_symbols(ep, path, module_.file, null, header_builder, cpp_builder, main_header, namespace_open, namespace_close, module_.members)
        else throw

    cpp_builder.append('\n')
    cpp_builder.append(namespace_close)

    header_builder.append("\n#endif")

    var header_name_builder: ref[StringBuilder] *StringBuilder$(path)
    header_name_builder.append(".h")
    let header_name header_name_builder.to_string(r.get_page())
    try File->write_from_string(ep, header_name, header_builder.to_string(r.get_page()))
        else throw

    var cpp_name_builder: ref[StringBuilder] *StringBuilder$(path)
    cpp_name_builder.append(".cpp")
    let cpp_name cpp_name_builder.to_string(r.get_page())
    try File->write_from_string(ep, cpp_name, cpp_builder.to_string(r.get_page()))
        else throw

    return Void()
}

function create_directory(path: String) throws FileError {
    if path.get_length() > 0
    {
        try let exists Directory->exists(ep, path)
            else throw

        if exists = false
        {
            try Directory->create(ep, path)
                else throw
        }
    }
    return Void()
}

function build_concept(path: String, source: String, header_builder: ref[StringBuilder], cpp_builder: ref[StringBuilder], main_header: String, namespace_open: String, namespace_close: String, concept: ref[Concept]) throws TranspilerError { 
    choose concept.definition
        when ns: Definition.Namespace
            return build_namespace(ep, path, source, concept.name, header_builder, cpp_builder, main_header, namespace_open, namespace_close, ns)
        when structure: Definition.Structure
            return build_structure(ep, header_builder, cpp_builder, concept.name, structure, concept.parameters)
        when i: Definition.Intrinsic
            return build_intrinsic(ep, header_builder, concept.name)
        when g: Definition.Global
            return build_global(ep, header_builder, concept.name, g)
        when u: Definition.Union
            return build_union(ep, header_builder, cpp_builder, concept.name, u, concept.parameters)
}

function build_union(header_builder: ref[StringBuilder], cpp_builder: ref[StringBuilder], name: String, union_: ref[Union], parameters: Vector[GenericParameter]) throws TranspilerError {
    header_builder.append('\n')
    full_struct_name(header_builder, name, parameters)
    header_builder.append(" : Object")
    header_builder.append(" {\n")
    {
        for variant in union_.variants
        {
            header_builder.append("    ")
            header_builder.append(name)
            header_builder.append('(')
            build_type(header_builder, variant.type)
            header_builder.append(")")
            if (parameters.length > 0)
            {
                header_builder.append(" : _tag(")
                header_builder.append(variant.name)
                header_builder.append(") { _")
                header_builder.append(variant.name)
                header_builder.append(" = _")
                build_type(header_builder, variant.type)
                header_builder.append("; }")
            } else {
                header_builder.append(";")
            }
            header_builder.append("\n")
        }
    }
    header_builder.append("    enum {\n")
    for variant in union_.variants
    {
        header_builder.append("        ")
        header_builder.append(variant.name)
        header_builder.append(",\n")
    }
    header_builder.append("    } _tag;\n    union {\n")
    {
        for variant in union_.variants
        {
            if variant.type = null
                continue
            header_builder.append("        struct ")
            build_type(header_builder, variant.type)
            header_builder.append(" _")
            header_builder.append(variant.name)
            header_builder.append(";\n")
        }
    }
    header_builder.append("    };")

    for member in union_.members
    {
        choose member
            when func: Member.Function
                try build_function(ep, header_builder, cpp_builder, func, &name, parameters.length > 0, true)
                    else throw
            when op: Member.Operator
                try build_operator(ep, header_builder, cpp_builder, op, &name, parameters.length > 0)
                    else throw
            when p: Member.Package
                throw FeatureNotImplemented(String(ep, "structure local package"))
            when concept: Member.Concept
                throw FeatureNotImplemented(String(ep, "structure local concept"))
    }

    header_builder.append("\n};")

    if parameters.length = 0
    {
        for variant in union_.variants
        {
            cpp_builder.append('\n')
            cpp_builder.append(name)
            cpp_builder.append("::")
            cpp_builder.append(name)
            cpp_builder.append("(struct ")
            build_type(cpp_builder, variant.type)
            cpp_builder.append(" _")
            cpp_builder.append(variant.name)
            cpp_builder.append(") : _tag(")
            cpp_builder.append(variant.name)
            cpp_builder.append("), _")
            cpp_builder.append(variant.name)
            cpp_builder.append("(_")
            cpp_builder.append(variant.name)
            cpp_builder.append(") {}\n")
        }
    }
    return Void()
}

function build_type(builder: ref[StringBuilder], type: pointer[Type]) returns bool {
    var r Region()
    if (*type).name.length == 1 && (*(*type).name.get(0)).equals(String(r.get_page(), "pointer"))
    {
        for generic in (*(*type).generics)
        {
            build_type(builder, &generic)
            break
        }
        builder.append('*')
        return false
    }

    if (*type).name.length == 1 && (*(*type).name.get(0)).equals(String(r.get_page(), "ref"))
    {
        for generic in (*(*type).generics)
        {
            build_type(builder, &generic)
            break
        }
        builder.append('&')
        return false
    }

    {
        var i: size_t 0
        for name_part in (*type).name
        {
            builder.append(name_part)
            if i < (*type).name.length - 1
                builder.append(".")
            set i: i + 1
        }
    }

    if (*type).generics <> null
    {
        if (*(*type).generics).length > 0
        {
            builder.append('<')
            var i: size_t 0
            for generic in (*(*type).generics)
            {
                build_type(builder, &generic)
                if i < (*(*type).generics).length - 1
                    builder.append(", ")
                set i: i + 1
            }
            builder.append('>')
            return false
        } else {
            return true
        }
    }
    return false
}

function build_namespace(path: String, source: String, name: String, header_builder: ref[StringBuilder], cpp_builder: ref[StringBuilder], main_header: String, namespace_open: String, namespace_close: String, namespace_: ref[Namespace]) throws TranspilerError {
    var r Region()
    header_builder.append("namespace ")
    header_builder.append(name)
    header_builder.append(" {\n")
    var namespace_open_builder: ref[StringBuilder] *StringBuilder$(namespace_open)
    namespace_open_builder.append("\nnamespace ")
    namespace_open_builder.append(name)
    namespace_open_builder.append(" {")
    set namespace_open: namespace_open_builder.to_string(r.get_page())
    var namespace_close_builder: ref[StringBuilder] *StringBuilder$(namespace_close)
    namespace_close_builder.append("\n}")
    set namespace_close: namespace_close_builder.to_string(r.get_page())
    var main_header_builder: ref[StringBuilder] *StringBuilder$("../")
    main_header_builder.append(main_header)
    try build_modules(ep, path, name, header_builder, namespace_.modules, main_header_builder.to_string(r.get_page()), namespace_open, namespace_close)
        else throw
    try build_symbols(ep, path, source, &name, header_builder, cpp_builder, main_header_builder.to_string(r.get_page()), namespace_open, namespace_close, namespace_.members)
        else throw
    header_builder.append("\n}")

    return Void()
}

function build_modules(path: String, name: String, header_builder: ref[StringBuilder], modules: ref[Vector[Module]], main_header: String, namespace_open: String, namespace_close: String) throws TranspilerError {
    var r Region()
    for module_ in modules
    {
        header_builder.append("#include \"")
        header_builder.append(name)
        header_builder.append('/')
        header_builder.append(String(r.get_page(), module_.name))
        header_builder.append(".h\"\n")
        try build_module(ep, path, module_, main_header, namespace_open, namespace_close)
            else throw
    }
    return Void()
}

function build_symbols(path: String, source: String, name: pointer[String], header_builder: ref[StringBuilder], cpp_builder: ref[StringBuilder], main_header: String, namespace_open: String, namespace_close: String, symbols: Vector[Member]) throws TranspilerError {
    var r Region()
    for member in symbols
    {
        choose member
            when func: Member.Function
                try build_function(ep, header_builder, cpp_builder, func, name, false, false)
                    else throw
            when concept: Member.Concept
                try build_concept(ep, path, source, header_builder, cpp_builder, main_header, namespace_open, namespace_close, concept)
                    else throw
            when op: Member.Operator
                throw FeatureNotImplemented(String(ep, "namespace local operator"))
            when p: Member.Package
                throw FeatureNotImplemented(String(ep, "namespace local package"))
    }

    return Void()
}

function build_structure(header_builder: ref[StringBuilder], cpp_builder: ref[StringBuilder], name: String, structure: ref[Structure], parameters: Vector[GenericParameter]) throws TranspilerError {
    var r Region()
    header_builder.append('\n')
    full_struct_name(header_builder, name, parameters)
    if name.equals(String(r.get_page(), "Object")) = false && name.equals(String(r.get_page(), "Void")) = false
        header_builder.append(" : Object")
    header_builder.append(" {")

    var must_build_properties_initializer false
    for property in structure.properties
    {
        if (property.type)
        {
            header_builder.append('\n')
            header_builder.append("    ")
            build_type(header_builder, property.type)
        }

        header_builder.append(' ')
        header_builder.append(property.name)
        header_builder.append(';')

        if property.initializer <> null
            set must_build_properties_initializer: true
    }

    if parameters.length = 0
        header_builder.append('\n')

    if structure.properties.length > 0
        build_default_initializer(ep, header_builder, cpp_builder, name, parameters.length > 0, structure.properties)

    if must_build_properties_initializer
        try build_properties_initializer(ep, header_builder, cpp_builder, name, parameters.length > 0, structure.properties)
            else throw

    for initializer in structure.initializers
    {
        try build_initializer(ep, header_builder, cpp_builder, name, parameters.length > 0, &initializer)
            else throw
    }

    if structure.deinitializer <> null
        try build_deinitializer(ep, header_builder, cpp_builder, name, parameters.length > 0, structure.deinitializer)
            else throw

    for member in structure.members
    {
        choose member
            when func: Member.Function
                try build_function(ep, header_builder, cpp_builder, func, &name, parameters.length > 0, true)
                    else throw
            when op: Member.Operator
                try build_operator(ep, header_builder, cpp_builder, op, &name, parameters.length > 0)
                    else throw
            when p: Member.Package
                throw FeatureNotImplemented(String(ep, "structure local package"))
            when c: Member.Concept
                throw FeatureNotImplemented(String(ep, "structure local concept"))
    }

    header_builder.append("\n};\n")
    return Void() 
}

function build_default_initializer(header_builder: ref[StringBuilder], cpp_builder: ref[StringBuilder], name: String, is_generic: bool, properties: ref[Vector[Property]]) throws TranspilerError {
    var r Region()
    build_initializer_header(header_builder, cpp_builder, name, is_generic)
    if is_generic
    {
        build_default_initializer_list(ep, header_builder, is_generic, properties, String(r.get_page(), "        "))
        header_builder.append(" {}")
    } else {
        build_default_initializer_list(ep, cpp_builder, is_generic, properties, String(r.get_page(), "    "))
        cpp_builder.append(" {}")
        header_builder.append("(")
        var first true
        for property in properties
        {
            if (first)
            {
                set first: false
            } else {
                header_builder.append(", ")
            }
            build_type(header_builder, property.type)
            header_builder.append(' ')
            header_builder.append(property.name)
        }
        header_builder.append(");")
    }
    return Void()
}

function build_default_initializer_list(builder: ref[StringBuilder], is_generic: bool, properties: ref[Vector[Property]], indent: String) throws TranspilerError {
    builder.append('(')
    {
        var first true
        for property in properties
        {
            if first
            {
                set first: false
            } else {
                builder.append(", ")
            }
            build_type(builder, property.type)
            builder.append(' ')
            builder.append(property.name)
        }
    }
    builder.append(") : ")
    {
        var first true
        for property in properties
        {
            if first
            {
                set first: false
            } else {
                builder.append(", ")
            }
            builder.append(property.name)
            builder.append('(')
            builder.append(property.name)
            builder.append(')')
        }
    }
    return Void()
}

function build_properties_initializer(header_builder: ref[StringBuilder], cpp_builder: ref[StringBuilder], name: String, is_generic: bool, properties: ref[Vector[Property]]) throws TranspilerError {
    var r Region()
    build_initializer_header(header_builder, cpp_builder, name, is_generic)
    if (is_generic)
    {
        build_properties_initializer_list(ep, header_builder, is_generic, properties, String(r.get_page(), "        "))
        header_builder.append(" {}")
    } else {
        build_properties_initializer_list(ep, cpp_builder, is_generic, properties, String(r.get_page(), "    "))
        cpp_builder.append(" {}")
        header_builder.append(" ();")
    }
    return Void()
}

function build_properties_initializer_list(builder: ref[StringBuilder], is_generic: bool, properties: ref[Vector[Property]], indent: String) throws TranspilerError {
    builder.append("() : ")
    var first true
    for property in properties
    {
        if property.initializer = null
            continue
        if first
        {
            set first: false
        } else {
            builder.append(", ")
        }
        builder.append(property.name)
        builder.append('(')
        try build_operation(ep, builder, *property.initializer, null, null, null, indent)
            else throw
        builder.append(')')
    }
    return Void()
}

function build_initializer(header_builder: ref[StringBuilder], cpp_builder: ref[StringBuilder], name: String, is_generic: bool, initializer: pointer[Initializer]) throws TranspilerError {
    var r Region()
    build_initializer_header(header_builder, cpp_builder, name, is_generic)
    if is_generic = false
    {
        build_input(cpp_builder, (*initializer).input, null, null, null, Lifetime(Unspecified()))
        cpp_builder.append(' ')
        try build_implementation(ep, cpp_builder, (*initializer).implementation, null, null, String(), true)
            else throw
    }
    build_input(header_builder, (*initializer).input, null, null, null, Lifetime(Unspecified()))
    if is_generic
    {
        header_builder.append(' ')
        try build_implementation(ep, header_builder, (*initializer).implementation, null, null, String(r.get_page(), "    "), true)
            else throw
    } else {
        header_builder.append(';')
    }

    return Void() 
}

function build_initializer_header(header_builder: ref[StringBuilder], cpp_builder: ref[StringBuilder], name: String, is_generic: bool) {
    if (is_generic)
        header_builder.append('\n')
    header_builder.append("\n    ")
    header_builder.append(name)
    if is_generic = false
    {
        cpp_builder.append("\n\n")
        cpp_builder.append(name)
        cpp_builder.append("::")
        cpp_builder.append(name)
    }        
}

function build_deinitializer(header_builder: ref[StringBuilder], cpp_builder: ref[StringBuilder], name: String, is_generic: bool, de_initializer: pointer[DeInitializer]) throws TranspilerError {
    var r Region()
    header_builder.append("\n    ")
    header_builder.append('~')
    header_builder.append(name)
    if is_generic = false
    {
        cpp_builder.append('\n')
        cpp_builder.append(name)
        cpp_builder.append("::~")
        cpp_builder.append(name)
        cpp_builder.append("() ")
        try build_implementation(ep, cpp_builder, (*de_initializer).implementation, null, null, String(r.get_page(), String()), true)
            else throw
        cpp_builder.append(';')
    }
    if is_generic
    {
        header_builder.append("() ")
        try build_implementation(ep, header_builder, (*de_initializer).implementation, null, null, String(r.get_page(), "    "), true)
            else throw
        header_builder.append(';')
    } else {
        header_builder.append("();")
    }

    return Void() 
}

function build_uses(builder: ref[StringBuilder], uses: ref[Vector[Use]]) {
    var r Region()
    for use_ in uses
    {
        builder.append("\nusing namespace ")
        var first true
        for namespace_ in use_.path
        {
            if first
            {
                set first: false
            } else {
                builder.append("::")
            }
            builder.append(namespace_)
        }
        builder.append(";\n")
    }
}

function build_intrinsic(header_builder: ref[StringBuilder], name: String) throws TranspilerError {
    var r Region()
    if name.equals("size_t")
    {
        header_builder.append("typedef __SIZE_TYPE__ size_t\n")
    } else {
        throw FeatureNotImplemented(String(ep, name))
    }        

    return Void()
}

function build_global(header_builder: ref[StringBuilder], name: String, global: ref[Global]) throws TranspilerError {
    var r Region()

    if global.type.generics <> null && (*global.type.generics).length = 0 && global.value.length = 1 && (*global.value.get(0)).expression is Expression.Matrix
    {
        choose (*global.value.get(0)).expression
            when matrix: Expression.Matrix
            {
                header_builder.append("static ")
                build_type(header_builder, &global.type)
                header_builder.append(' ')
                header_builder.append(name)
                header_builder.append("[]")
                header_builder.append(" = { ")
                for operation in matrix.operations
                {
                    build_operation(ep, header_builder, operation, null, null, null, String())
                    header_builder.append(", ")
                }
                header_builder.append('}')
            }
            else {}
    } else {
        header_builder.append("const ")            
        build_type(header_builder, &global.type)
        header_builder.append(' ')
        header_builder.append(name)
        header_builder.append(" = ")
        build_operation(ep, header_builder, global.value, null, null, null, String())
    }
    header_builder.append(";\n")
    return Void()
}

function build_function(header_builder: ref[StringBuilder], cpp_builder: ref[StringBuilder], func: ref[Function], name: pointer[String], is_template: bool, in_class: bool) throws TranspilerError {
    var r Region()

    var location: pointer[String] null
    choose func.lifetime
        when c: Lifetime.Call
            set location: String$(r.get_page(), "rp")
        when reference: Lifetime.Reference
            set location: &reference.location
        when u: Lifetime.Unspecified
            {}
        when l: Lifetime.Local
            {}
        when t: Lifetime.Thrown
            {}

    choose func.implementation
        when e: Implementation.Extern
        {
            header_builder.append("extern \"C\" ")
            build_output_type(header_builder, func.returns_, func.throws_)
            header_builder.append(' ')
            header_builder.append(func.name)
            build_input(header_builder, func.input, location, func.returns_, func.throws_, func.lifetime)
            header_builder.append(";\n")
            return Void()
        }
        else {}

    if is_template
        header_builder.append('\n')

    function_prefix(header_builder, func, name <> null, in_class)
    if is_template = false
    {
        cpp_builder.append('\n')
        function_prefix(cpp_builder, func, false, false)
        if name <> null
        {
            cpp_builder.append(*name)
            cpp_builder.append("::")
        }
        cpp_builder.append(func.name)
        build_input(cpp_builder, func.input, location, func.returns_, func.throws_, func.lifetime)
        cpp_builder.append(' ')
        try build_implementation(ep, cpp_builder, func.implementation, func.returns_, func.throws_, String(), false)
            else throw
    }
    header_builder.append(func.name)
    build_input(header_builder, func.input, location, func.returns_, func.throws_, func.lifetime)
    if is_template
    {
        header_builder.append(' ')
        try build_implementation(ep, header_builder, func.implementation, func.returns_, func.throws_, String(r.get_page(), "    "), false)
            else throw
    }
    header_builder.append(';')

    return Void() 
}

function build_output_type(builder: ref[StringBuilder], returns_: pointer[Type] , throws_: pointer[Type] ) {
    if throws_ <> null 
    {
        builder.append("Result<")
        if returns_ = null
        {
            builder.append("Void")
        } else {
            build_type(builder, returns_)
        }
        builder.append(", ")
        build_type(builder, throws_)
        builder.append('>')
        
    } else {
        if returns_ = null
        {
            builder.append("void")
        } else {
            build_type(builder, returns_)
        }
    }
}

function build_implementation(builder: ref[StringBuilder], implementation: ref[Implementation], returns_: pointer[Type], throws_: pointer[Type], indent: String, is_initializer: bool) throws TranspilerError {
    choose implementation
        when action: Implementation.Action
        {
            if action.target.length == 0 && action.source.length == 1 && (*action.source.get(0)).expression is Expression.Block
            {
                try build_action(ep, builder, action, returns_, throws_, null, indent)
                    else throw
            } else {
                if is_initializer
                {
                    var first true
                    for operand in action.source
                    {
                        choose operand.expression
                            when tuple: Expression.Tuple
                            {
                                for component in tuple.components
                                {
                                    if (first)
                                    {
                                        set first: false
                                        builder.append(": ")
                                    } else {
                                        builder.append(", ")
                                    }

                                    try build_operation(ep, builder, component.value, returns_, throws_, null, indent)
                                        else throw
                                }
                            }
                            when block: Expression.Block
                            {
                                try build_block(ep, builder, block, returns_, throws_, null, indent)
                                    else throw
                            }
                            else throw FeatureNotImplemented(String(ep, "Other than Tuple or Block in initializer implementation"))
                    }
                } else {
                    builder.append("{\n")
                    builder.append(indent)
                    builder.append("    return ")
                    try build_action(ep, builder, action, returns_, throws_, null, indent)
                        else throw
                    builder.append("; }")
                }

            }
        }
        when e: Implementation.Extern
            throw FeatureNotImplemented(String(ep, "Extern"))
        when i: Implementation.Instruction
            throw FeatureNotImplemented(String(ep, "Instruction"))
        when i: Implementation.Intrinsic
            throw FeatureNotImplemented(String(ep, "Intrinsic"))

    return Void()
}

function build_binding(builder: ref[StringBuilder], binding: ref[Binding], returns_: pointer[Type] , throws_: pointer[Type], re_throw: pointer[String], indent: String) throws TranspilerError {
    if binding.binding_type.equals("const")
        builder.append("const ")
    var simple_array false
    if binding.item.type <> null
    {
        set simple_array: build_type(builder, binding.item.type)
    } else {
        builder.append("auto")
    }

    if binding.item.name <> null
    {
        builder.append(' ')
        builder.append(*binding.item.name)
    }
    if simple_array
    {
        builder.append('[')
        try build_operation(ep, builder, binding.operation, returns_, throws_, re_throw, indent)
            else throw
        builder.append(']')
    } else {
        builder.append(" = ")

        try build_operation(ep, builder, binding.operation, returns_, throws_, re_throw, indent)
            else throw
    }
    return Void()
}

function build_action(builder: ref[StringBuilder], action: ref[Action], returns_: pointer[Type], throws_: pointer[Type], re_throw: pointer[String], indent: String) throws TranspilerError {
    if action.target.length > 0
    {
        try build_operation(ep, builder, action.target, returns_, throws_, re_throw, indent)
            else throw
        builder.append(" = ")
    }

    try build_operation(ep, builder, action.source, returns_, throws_, re_throw, indent)
        else throw

    return Void()
}

function build_operation(builder: ref[StringBuilder], operation: ref[Vector[Operand]], returns_: pointer[Type], throws_: pointer[Type], re_throw: pointer[String], indent: String) throws TranspilerError {
    for operand in operation
    {
        choose operand.expression
            when constant: Expression.Constant
                try build_constant(ep, builder, constant)
                    else throw
            when type: Expression.Type
                try build_variable(ep, builder, type, operand.member_access)
                    else throw
            when tuple: Expression.Tuple
                try build_tuple(ep, builder, tuple, operand.member_access, returns_, throws_, re_throw, indent)
                    else throw
            when matrix: Expression.Matrix
                try build_matrix(ep, builder, matrix, returns_, throws_, re_throw, indent)
                    else throw
            when block: Expression.Block
                try build_block(ep, builder, block, returns_, throws_, re_throw, indent)
                    else throw
            when if_: Expression.If
                try build_if(ep, builder, if_, returns_, throws_, re_throw, indent)
                    else throw
            when match_: Expression.Match
                try build_match(ep, builder, match_, returns_, throws_, re_throw, indent)
                    else throw
            when choose_: Expression.Choose
                try build_choose(ep, builder, choose_, returns_, throws_, re_throw, indent)
                    else throw
            when for_: Expression.For
                try build_for(ep, builder, for_, returns_, throws_, re_throw, indent)
                    else throw
            when while_: Expression.While
                try build_while(ep, builder, while_, returns_, throws_, re_throw, indent)
                    else throw
            when try_: Expression.Try
                try build_try(ep, builder, try_, returns_, throws_, null, indent)
                    else throw
            when sizeof_: Expression.SizeOf
                build_sizeof(builder, sizeof_, indent)
            when is_: Expression.Is
                build_is(builder, is_, indent)
    }
    return Void()
}

function build_string(builder: ref[StringBuilder], string: String) {
    builder.append('\"')
    for c in string
    {
        if c = '\n'
            builder.append("\\n\\")
        builder.append(c)
    }
    builder.append('\"')
}

function build_constant(builder: ref[StringBuilder], constant: ref[Constant]) throws TranspilerError {
    var r Region()
    choose constant
        when boolean: Constant.Boolean
        {
            if boolean.value
            {
                builder.append("true")
            } else {
                builder.append("false")
            }
        }
        when integer: Constant.Integer
        {
            var str (char*)(*r.get_page()).allocate(32, 1)
            snprintf(str, 32, "%zd", integer.value)
            builder.append(String(r.get_page(), str))
        }
        when hex: Constant.Hex
        {
            var str (char*)(*r.get_page()).allocate(32, 1)
            snprintf(str, 32, "0x%zx", hex.value)
            builder.append(String(r.get_page(), str))
        }
        when floating_point: Constant.FloatingPoint
        {
            var str (char*)(*r.get_page()).allocate(32, 1)
            snprintf(str, 32, "%lg", floating_point.value)
            builder.append(String(r.get_page(), str))
        }
        when string: Constant.String
        {
            build_string(builder, string.value)
        }
        when string: Constant.Character
        {
            builder.append('\'')
            builder.append(string.value)
            builder.append('\'')
        }
        when fragment: Constant.Fragment
        {
            throw FeatureNotImplemented(String(ep, "Bool"))
        }

    return Void()
}

function build_variable(builder: ref[StringBuilder], type: ref[Type], member_access: pointer[Vector[String]]) throws TranspilerError {
    var name_iterator type.name.get_iterator()
    let first_name_part name_iterator.next()
    if (*first_name_part).equals("=")
    {
        builder.append(" == ")
        return Void()
    }
    if (*first_name_part).equals("<>")
    {
        builder.append(" != ")
        return Void()
    }
    if (*first_name_part).equals("//")
    {
        builder.append(" ^ ")
        return Void()
    }
    if (*first_name_part).equals("->")
    {
        builder.append("::")
        return Void()
    }
    if (*first_name_part).equals("null")
    {
        builder.append("nullptr")
        return Void()
    }
    if (*first_name_part).equals("pointer")
    {
        if type.generics <> null
        {
            var generics *(type.generics)
            build_variable(ep, builder, *generics.get(0), member_access)
        }
        builder.append('*')
        return Void()
    }

    choose type.lifetime
        when u: Lifetime.Unspecified
            {}
        when l: Lifetime.Local
        {
            builder.append("new (alignof(")
            build_type(builder, &type)
            builder.append("), r.get_page()) ")
        }
        when call: Lifetime.Call
        {
            builder.append("new (alignof(")
            build_type(builder, &type)
            builder.append("), rp) ")
        }
        when reference: Lifetime.Reference
        {
            builder.append("new (alignof(")
            build_type(builder, &type)
            builder.append("), ")
            builder.append(reference.location)
            builder.append(") ")
        }
        when t: Lifetime.Thrown
            throw FeatureNotImplemented(String(ep, "Thrown"))

    build_type(builder, &type)

    if member_access <> null
    {
        for member in (*member_access)
        {
            if (*first_name_part).equals("this")
            {
                builder.append("->")
            } else {
                builder.append('.')
            }
            builder.append(member)
        }
    }

    return Void()
}

function build_tuple(builder: ref[StringBuilder], tuple: ref[Tuple], member_access: pointer[Vector[String]], returns_: pointer[Type], throws_: pointer[Type], re_throw: pointer[String], indent: String) throws TranspilerError {
    builder.append('(')
    var first true
    for property in tuple.components
    {
        if first
        {
            set first: false
        } else {
            builder.append(", ")
        }
        build_operation(ep, builder, property.value, returns_, throws_, re_throw, indent)
    }
    builder.append(')')

    if member_access <> null
    {
        for member in (*member_access)
        {
            builder.append('.')
            builder.append(member)
        }
    }

    return Void()
}

function build_matrix(builder: ref[StringBuilder], matrix: ref[Matrix], returns_: pointer[Type], throws_: pointer[Type], re_throw: pointer[String], indent: String) throws TranspilerError {
    builder.append('[')
    var first true
    for operation in matrix.operations
    {
        if first
        {
            set first: false
        } else {
            builder.append(", ")
        }
        try build_operation(ep, builder, operation, returns_, throws_, re_throw, indent)
            else throw
    }
    builder.append(']')
    return Void()
}

function build_block(builder: ref[StringBuilder], block: ref[Block], returns_: pointer[Type], throws_: pointer[Type], re_throw: pointer[String], indent: String) throws TranspilerError{
    var r Region()
    var indent_builder: ref[StringBuilder] *StringBuilder$(indent)
    indent_builder.append("    ")
    builder.append('{')
    try build_statements(ep, builder, block.statements, returns_, throws_, re_throw, indent_builder.to_string(r.get_page()))
        else throw
    builder.append('\n')
    builder.append(indent)
    builder.append('}')
    return Void()
}

function build_if(builder: ref[StringBuilder], if_: ref[If], returns_: pointer[Type], throws_: pointer[Type], re_throw: pointer[String], indent: String) throws TranspilerError {
    var r Region()
    builder.append("if (")
    try build_operation(ep, builder, if_.condition, returns_, throws_, re_throw, indent)
        else throw
    builder.append(") ")
    var is_block false
    choose if_.consequent
        when action: Statement.Action
        {
            if (*action.source.get(0)).expression is Expression.Block
                set is_block: true
        }
        else {}

    if is_block = false
    {
        builder.append('\n')
        builder.append(indent)
        builder.append("    ")
    }

    try build_statement(ep, builder, if_.consequent, returns_, throws_, re_throw, indent)
        else throw

    if if_.alternative <> null
    {
        builder.append('\n')
        builder.append(indent)
        builder.append("else ")
        try build_statement(ep, builder, *if_.alternative, returns_, throws_, re_throw, indent)
            else throw
    }

    return Void()
}

function build_match(builder: ref[StringBuilder], match_: ref[Match], returns_: pointer[Type], throws_: pointer[Type], re_throw: pointer[String], indent: String) throws TranspilerError {
    var r Region()
    builder.append("switch (")
    try build_operation(ep, builder, match_.condition, returns_, throws_, re_throw, indent)
        else throw
    builder.append(")\n")
    builder.append(indent)
    builder.append("{")

    var indent_builder: ref[StringBuilder] *StringBuilder$(indent)
    indent_builder.append("        ")
    var indented indent_builder.to_string(r.get_page())
    for branch in match_.branches
    {
        builder.append('\n')
        builder.append(indent)
        builder.append("    ")
        for case_ in branch.cases
        {
            builder.append("case ")
            {
                try build_operation(ep, builder, case_.condition, returns_, throws_, re_throw, indented)
                    else throw
            }
            builder.append(": ")
        }
        builder.append('\n')
        builder.append(indented)
        try build_statement(ep, builder, branch.consequent, returns_, throws_, re_throw, indented)
            else throw
        builder.append(";\n")
        builder.append(indented)
        builder.append("break;")
    }

    if match_.alternative <> null
    {
        builder.append('\n')
        builder.append(indent)
        builder.append("    default:\n")
        builder.append(indented)
        try build_statement(ep, builder, *match_.alternative, returns_, throws_, re_throw, indented)
            else throw
        builder.append(';')
    }
    builder.append('\n')
    builder.append(indent)
    builder.append("}")

    return Void()
}

function build_choose(builder: ref[StringBuilder], choose_: ref[Choose], returns_: pointer[Type], throws_: pointer[Type], re_throw: pointer[String], indent: String) throws TranspilerError {
    var r Region()
    builder.append("{\n")
    var indent_builder: ref[StringBuilder] *StringBuilder$(indent)
    indent_builder.append("    ")
    let indent1 indent_builder.to_string(r.get_page())
    builder.append(indent1)
    builder.append("auto _result = ")
    try build_operation(ep, builder, choose_.condition, returns_, throws_, re_throw, indent)
        else throw
    builder.append(";\n")
    builder.append(indent1)
    builder.append("switch (_result._tag)\n")
    builder.append(indent1)
    builder.append("{")
    indent_builder.append("    ")
    let indented indent_builder.to_string(r.get_page())
    indent_builder.append("    ")
    let indented2 indent_builder.to_string(r.get_page())
    for case_ in choose_.cases
    {
        builder.append('\n')
        builder.append(indented)
        builder.append("case ")
        var first true
        {
            for variant in case_.variant
            {
                if first
                {
                    set first: false
                } else {
                    builder.append("::")
                }
                builder.append(variant)
            }
        }
        builder.append(":\n")
        builder.append(indent1)
        builder.append("    {\n")
        builder.append(indented2)
        builder.append("auto ")
        builder.append(case_.name)
        builder.append(" = _result._")
        set first: true
        {
            for variant in case_.variant
            {
                if(first)
                {
                    set first: false
                } else {
                    builder.append(variant)
                }
            }
        }
        builder.append(";\n")
        builder.append(indented2)
        try build_statement(ep, builder, case_.consequent, returns_, throws_, re_throw, indented2)
            else throw
        builder.append(";\n")
        builder.append(indented2)
        builder.append("break;")
        builder.append('\n')
        builder.append(indent1)
        builder.append("    }")
    }
    if choose_.alternative <> null
    {
        builder.append('\n')
        builder.append(indent1)
        builder.append("    default:\n")
        builder.append(indented2)
        try build_statement(ep, builder, *choose_.alternative, returns_, throws_, re_throw, indented)
            else throw
        builder.append(';')
    }
    builder.append('\n')
    builder.append(indent)
    builder.append("    }\n")
    builder.append(indent)
    builder.append("}")

    return Void()
}

function build_for(builder: ref[StringBuilder], for_: ref[For], returns_: pointer[Type], throws_: pointer[Type], re_throw: pointer[String], indent: String) throws TranspilerError {
    var r Region()
    builder.append('\n')
    builder.append(indent)
    builder.append("auto _")
    builder.append(for_.identifier)
    builder.append("_iterator = ")
    build_operation(ep, builder, for_.expression, returns_, throws_, re_throw, indent)
    builder.append(".get_iterator();\n")
    builder.append(indent)
    builder.append("while (auto _")
    builder.append(for_.identifier)
    builder.append(" = _")
    builder.append(for_.identifier)
    builder.append("_iterator.next()) {\n")
    var indent_builder: ref[StringBuilder] *StringBuilder$(indent)
    indent_builder.append("    ")
    let indented indent_builder.to_string(r.get_page())
    builder.append(indented)
    builder.append("auto ")
    builder.append(for_.identifier)
    builder.append(" = *_")
    builder.append(for_.identifier)
    builder.append(';')
    try build_action(ep, builder, for_.action, returns_, throws_, re_throw, indented)
        else throw
    builder.append('\n')
    builder.append(indent)
    builder.append('}')

    return Void()
}

function build_condition(builder: ref[StringBuilder], binding: ref[Binding], returns_: pointer[Type], throws_: pointer[Type], re_throw: pointer[String], indent: String) throws TranspilerError {
    if binding.item.name <> null
    {
        if binding.item.type <> null
        {
            build_type(builder, binding.item.type)
        } else {
            builder.append("auto")
        }
        builder.append(' ')
        builder.append(*binding.item.name)
        builder.append(" = ")
    }

    try build_operation(ep, builder, binding.operation, returns_, throws_, re_throw, indent)
        else throw
    return Void()
}

function build_while(builder: ref[StringBuilder], while_: ref[While], returns_: pointer[Type], throws_: pointer[Type], re_throw: pointer[String], indent: String) throws TranspilerError {
    var r Region()
    builder.append("while (")
    try build_condition(ep, builder, while_.condition, returns_, throws_, re_throw, indent)
        else throw
    builder.append(") ")
    try build_action(ep, builder, while_.action, returns_, throws_, re_throw, indent)
        else throw
    return Void()
}

function build_drop(builder: ref[StringBuilder], drop_: ref[Drop], returns_: pointer[Type], throws_: pointer[Type], re_throw: pointer[String], indent: String) throws TranspilerError {
    var r Region()
    builder.append('\n')
    builder.append(indent)
    builder.append("default: {\n")
    var indent_builder: ref[StringBuilder] *StringBuilder$(indent)
    indent_builder.append("    ")
    let indented indent_builder.to_string(r.get_page())
    builder.append(indented)
    build_action(ep, builder, drop_.action, returns_, throws_, re_throw, indented)
    builder.append(";\n")
    builder.append(indented)
    builder.append("break;\n")
    builder.append(indent)
    builder.append("}\n")
    return Void()
}

function build_try(builder: ref[StringBuilder], try_: ref[Try], returns_: pointer[Type], throws_: pointer[Type], re_throw: pointer[String], indent: String) throws TranspilerError {
    var r Region()
    var name String(r.get_page(), "void")
    var indent_builder: ref[StringBuilder] *StringBuilder$(indent)
    if try_.binding.item.name <> null
    {
        set name: *try_.binding.item.name
    } else {
        builder.append("{\n")
        indent_builder.append("    ")
        set indent: indent_builder.to_string(r.get_page())
        builder.append(indent)
    }
    builder.append("const auto _")
    builder.append(name)
    builder.append("_result = ")
    try build_operation(ep, builder, try_.binding.operation, returns_, throws_, re_throw, indent)
        else throw
    builder.append(";\n")
    builder.append(indent)
    if name.equals("void") = false
    {
        builder.append("auto ")
        builder.append(name)
        builder.append(" = _")
        builder.append(name)
        builder.append("_result._Ok;\n")
        builder.append(indent)
    }
    builder.append("if (_")
    builder.append(name)
    builder.append("_result._tag == Success::Error) {\n")
    indent_builder.append("    ")
    var indented indent_builder.to_string(r.get_page())
    builder.append(indented)
    builder.append("const auto _")
    builder.append(name)
    builder.append("_Error = _")
    builder.append(name)
    builder.append("_result._Error;\n")
    builder.append(indented)
    builder.append("switch (_")
    builder.append(name)
    builder.append("_Error._tag) {")
    indent_builder.append("    ")
    let indented2 indent_builder.to_string(r.get_page())
    indent_builder.append("    ")
    let indented3 indent_builder.to_string(r.get_page())
    for catch_ in try_.catches
    {
        builder.append('\n')
        builder.append(indented)
        builder.append("    case ")
        var first true
        for error in catch_.variant
        {
            if first
            {
                set first: false
            } else {
                builder.append("::")
            }
            builder.append(error)
        }
        builder.append(": {\n")
        builder.append(indented3)
        builder.append("const auto ")
        builder.append(catch_.name)
        builder.append(" = _")
        builder.append(name)
        builder.append("_Error._")
        builder.append(*catch_.variant.get(1))
        builder.append(";\n")
        builder.append(indented3)
        try build_statement(ep, builder, catch_.consequent, returns_, throws_, null, indented3)
            else throw
        builder.append(";\n")
        builder.append(indented3)
        builder.append("break;\n")
        builder.append(indented2)
        builder.append("}")
    }
    if try_.alternative <> null
    {
        builder.append('\n')
        builder.append(indented)
        builder.append("default:\n")
        builder.append(indented2)
        {
            var re_throw_builder: ref[StringBuilder] *StringBuilder$("_")
            re_throw_builder.append(name)
            re_throw_builder.append("_result._Error")
            var re_throw re_throw_builder.to_string(r.get_page())
            try build_statement(ep, builder, *try_.alternative, returns_, throws_, &re_throw, indented2)
                else throw
            builder.append(";\n")
        }
    }
    builder.append('\n')
    builder.append(indented)
    builder.append("}\n")
    builder.append(indent)
    builder.append("}")
    if name.equals("void")
    {
        builder.append("}\n")
        builder.append(indent)
    }
    return Void()
}

function build_sizeof(builder: ref[StringBuilder], sizeof_: ref[SizeOf], indent: String) {
    var r Region()
    builder.append("sizeof(")
    build_type(builder, &sizeof_.type)
    builder.append(")")
}

function build_is(builder: ref[StringBuilder], is_: ref[Is], indent: String) {
    var r Region()
    builder.append("._tag == ")
    var first true
    for name in is_.name
    {
        if first
        {
            set first: false
        } else {
            builder.append("::")
        }
        builder.append(name)
    }
}

function build_break(builder: ref[StringBuilder], break_: ref[Break], returns_: pointer[Type], throws_: pointer[Type], re_throw: pointer[String], indent: String) throws TranspilerError {
    var r Region()
    builder.append("break")
    if (break_.result.length > 0)
        builder.append(' ')
    try build_operation(ep, builder, break_.result, returns_, throws_, re_throw, indent)
        else throw
    return Void()
}

function build_continue(builder: ref[StringBuilder], continue_: ref[Continue], returns_: pointer[Type], throws_: pointer[Type], re_throw: pointer[String], indent: String) {
    builder.append("continue;")
}

function build_return(builder: ref[StringBuilder], return_: ref[Return], returns_: pointer[Type], throws_: pointer[Type], re_throw: pointer[String], indent: String) throws TranspilerError {
    var r Region()
    builder.append("return")
    if (return_.result.length > 0) || (throws_ <> null)
        builder.append(' ')
    if throws_ <> null
    {
        builder.append("Result<")
        if returns_ = null
        {
            builder.append("Void")
        } else {
            build_type(builder, returns_)
        }
        builder.append(", ")
        build_type(builder, throws_)
        builder.append(">(")
        if return_.result.length = 0
            builder.append("Void()")
    }
    try build_operation(ep, builder, return_.result, returns_, throws_, re_throw, indent)
        else throw

    if throws_ <> null
        builder.append(")")

    return Void()
}

function build_throw(builder: ref[StringBuilder], throw_: ref[Throw], returns_: pointer[Type], throws_: pointer[Type], re_throw: pointer[String], indent: String) throws TranspilerError {
    var r Region()
    builder.append("return Result<")
    if returns_ = null
    {
        builder.append("Void")
    } else {
        build_type(builder, returns_)
    }
    builder.append(", ")
    build_type(builder, throws_)
    builder.append(">(")
    if throw_.result.length = 0 && re_throw
    {
        builder.append(*re_throw)
    } else {
        try build_operation(ep, builder, throw_.result, returns_, throws_, null, indent)
            else throw
    }
    builder.append(")")
    return Void()
}

function build_statements(builder: ref[StringBuilder], statements: ref[Vector[Statement]], returns_: pointer[Type], throws_: pointer[Type], re_throw: pointer[String], indent: String) throws TranspilerError {
    for statement in statements
    {
        builder.append('\n')
        builder.append(indent)
        try build_statement(ep, builder, statement, returns_, throws_, re_throw, indent)
            else throw
        builder.append(';')
    }
    return Void()
}

function build_statement(builder: ref[StringBuilder], statement: ref[Statement], returns_: pointer[Type], throws_: pointer[Type], re_throw: pointer[String], indent: String) throws TranspilerError {
    choose statement
        when action: Statement.Action
            try build_action(ep, builder, action, returns_, throws_, re_throw, indent)
                else throw
        when binding: Statement.Binding
            try build_binding(ep, builder, binding, returns_, throws_, re_throw, indent)
                else throw
        when break_: Statement.Break
            try build_break(ep, builder, break_, returns_, throws_, re_throw, indent)
                else throw
        when continue_: Statement.Continue
            build_continue(builder, continue_, returns_, throws_, re_throw, indent)
        when return_: Statement.Return
            try build_return(ep, builder, return_, returns_, throws_, re_throw, indent)
                else throw
        when throw_: Statement.Throw
            try build_throw(ep, builder, throw_, returns_, throws_, re_throw, indent)
                else throw
    return Void()
}

function function_prefix(builder: ref[StringBuilder], func: ref[Function], indent: bool, static_if_applicable: bool) {
    var r Region()
    builder.append('\n')
    if indent
        builder.append("    ")
    if static_if_applicable && ((func.input.length == 0) || ((*func.input.get(0)).name == null) || ((*(*func.input.get(0)).name).equals("this")) = false)
        builder.append("static ")
    build_output_type(builder, func.returns_, func.throws_)
    builder.append(' ')
}

function build_operator(header_builder: ref[StringBuilder], cpp_builder: ref[StringBuilder], operator_: ref[Operator], name: pointer[String], is_template: bool) throws TranspilerError {
    var r Region()
    if is_template
        header_builder.append('\n')
    header_builder.append("\n    ")
    build_output_type(header_builder, operator_.returns_, operator_.throws_)
    header_builder.append(" operator ")
    header_builder.append(operator_.name)
    build_input(header_builder, operator_.input, null, operator_.returns_, operator_.throws_, Lifetime(Unspecified()))
    if is_template
    {
        try build_implementation(ep, header_builder, operator_.implementation, operator_.returns_, operator_.throws_, String(r.get_page(), "    "), false)
            else throw
    } else {
        header_builder.append(';')
        cpp_builder.append("\n\n")
        build_output_type(cpp_builder, operator_.returns_, operator_.throws_)
        cpp_builder.append(' ')
        cpp_builder.append(*name)
        cpp_builder.append("::operator ")
        cpp_builder.append(operator_.name)
        let is_static build_input(cpp_builder, operator_.input, null, operator_.returns_, operator_.throws_, Lifetime(Unspecified()))
        cpp_builder.append(' ')
        try build_implementation(ep, cpp_builder, operator_.implementation, operator_.returns_, operator_.throws_, String(), false)
            else throw
    }
    return Void() 
}

function needs_return_page(type: pointer[Type]) returns bool {
    if type = null
        return false

    if (*type).name.length = 1
    {
        var name *(*type).name.get(0)
        if name.equals("bool") || name.equals("int") || name.equals("size_t")
            return false
    }
    
    if (*type).lifetime is Lifetime.Local
        return false
    
    return true
}

function build_input(builder: ref[StringBuilder], input: Vector[Item], location: pointer[String], returns_: pointer[Type], throws_: pointer[Type], lifetime: Lifetime) returns bool {
    var r Region()
    builder.append('(')

    var parameters_there false
    if input.length > 0
    {
        if (*(*input.get(0)).name).equals("this")
        {
            set parameters_there: input.length > 1
        } else {
            set parameters_there: true
        }
    }

    let needs_rp needs_return_page(returns_)
    if (location <> null)
    {
        builder.append("Page* ")
        builder.append(*location)
        if throws_ <> null || parameters_there || needs_rp
            builder.append(", ")
    }

    if needs_rp
    {
        builder.append("Page* rp")
        if (throws_ <> null || parameters_there)
            builder.append(", ")
    }

    if throws_ <> null
    {
        builder.append("Page* ep")
        if parameters_there
            builder.append(", ")
    }

    var first true
    var is_static true
    for property in input
    {
        if first
        {
            if property.name && (*property.name).equals(String(r.get_page(), "this"))
            {
                set is_static: false
                continue
            }
            set first: false
        } else {
            builder.append(", ")
        }
        if (property.type <> null)
        {
            build_type(builder, property.type)
            builder.append(' ')
        }

        if property.name <> null
            builder.append(*property.name)
    }
    builder.append(')')
    return is_static
}

function full_struct_name(builder: ref[StringBuilder], name: String, parameters: Vector[GenericParameter]) {
    var r Region()

    if parameters.length > 0
    {
        builder.append("template<")
        {
            var i: size_t 0
            for generic in parameters
            {
                builder.append("class ")
                builder.append(generic.name)
                if (i < parameters.length - 1)
                    builder.append(", ")
                set i: i + 1
            }
        }
        builder.append(">\n")
    }
    builder.append("struct ")
    builder.append(name)
}

function forward_includes(path: String, program: ref[Program]) throws TranspilerError {
    var r Region()
    var builder: ref[StringBuilder] *StringBuilder$()
    builder.append(
"typedef const char const_char;
typedef struct stat struct_stat;
typedef const void const_void;\n")
    try forward_includes_for_modules(ep, builder,  program.module_.modules)
        else throw
    try forward_includes_for_symbols(ep, builder,  program.module_.members)
        else throw

    if builder.get_length() > 0
    {
        let main_file_name Path->join(r.get_page(), path, String(r.get_page(), "forwards.h"))
        try File->write_from_string(ep, main_file_name, builder.to_string(r.get_page()))
            else throw
    }

    return Void()
}

function forward_include(builder: ref[StringBuilder], concept: ref[Concept]) throws TranspilerError {
    var r Region()

    choose concept.definition 
        when namespace_: Definition.Namespace
            try forward_includes_for_namespace(ep, concept.name, builder, namespace_)
                else throw
        when structure: Definition.Structure
        {
            full_struct_name(builder, concept.name, concept.parameters)
            builder.append(";\n")
            try forward_includes_for_modules(ep, builder, structure.modules)
                else throw
            return Void()
        }

        when u: Definition.Union
        {
            builder.append("struct ")
            builder.append(concept.name)
            builder.append(";\n")
            return Void()
        }
        
        else return Void()

    return Void()
}

function forward_includes_for_namespace(name: String, builder: ref[StringBuilder], namespace_: ref[Namespace]) throws TranspilerError {
    var r Region()
    builder.append("namespace ")
    builder.append(name)
    builder.append(" {\n")
    try forward_includes_for_modules(ep, builder, namespace_.modules)
        else throw
    try forward_includes_for_symbols(ep, builder, namespace_.members)
        else throw
    builder.append("}\n")
    return Void()
}

function forward_includes_for_modules(builder: ref[StringBuilder], modules: ref[Vector[Module]]) throws TranspilerError {
    var r Region()
    for module_ in modules
    {
        try forward_includes_for_symbols(ep, builder, module_.members)
            else throw
    }

    return Void()
}

function forward_includes_for_symbols(builder: ref[StringBuilder], members: ref[Vector[Member]]) throws TranspilerError {
    var r Region()
    for member in members
    {
        choose member
            when concept: Member.Concept
                try forward_include(ep, builder, concept)
                    else throw
            else continue
    }

    return Void()
}

function vscode_files(path: String, program: ref[Program]) throws TranspilerError {
    var r Region()
    let vscode_dir Path->join(r.get_page(), path, String(r.get_page(), ".vscode"))
    try create_directory(ep, vscode_dir)
        else throw

    var script_file_builder:ref[StringBuilder] *StringBuilder$(Path->join(r.get_page(), path, String(r.get_page(), "build.sh"))) 
    var script_builder:ref[StringBuilder] *StringBuilder$(
"#!/usr/bin/env bash
set -x
set -e
scalyc ")
    script_builder.append(program.module_.name)
    script_builder.append(".scaly ")
    script_builder.append(program.module_.name)
    script_builder.append("
clang++ -fcolor-diagnostics -fansi-escape-codes -ferror-limit=5 \\
    -g \\
")
    build_script_files(script_builder, String(), program.module_, String(r.get_page(), ".cpp"), true)
    for package_ in program.packages
    {
        script_builder.append("    ../")
        script_builder.append(package_.name)
        script_builder.append('/')
        script_builder.append(package_.name)
        script_builder.append(".a \\
")
    }
    if program.statements.length > 0
    {
        script_builder.append("    main.cpp \\
")
        script_builder.append(
"    -o bin/")
        script_builder.append(program.module_.name)
        script_builder.append("\\
    `llvm-config --cxxflags --ldflags --system-libs --libs core`
")
    } else {
        script_builder.append(
"    -c\\
    `llvm-config --cxxflags`

/opt/homebrew/opt/llvm/bin/llvm-ar \\
    rc ")
        script_builder.append(program.module_.name)
        script_builder.append(".a \\
")
        build_script_files(script_builder, String(), program.module_, String(r.get_page(), ".o"), false)
        script_builder.append(
"
rm \\
")
        build_script_files(script_builder, String(), program.module_, String(r.get_page(), ".o"), false)
    }
    var script_file script_file_builder.to_string(r.get_page())
    try File->write_from_string(ep, script_file, script_builder.to_string(r.get_page()))
        else throw
    
    var mask_string String(r.get_page(), "0755")
    var i strtol(mask_string.get_buffer(), 0, 8)
    chmod(script_file.to_c_string(r.get_page()), i)

    var tasks_file_builder: ref[StringBuilder] *StringBuilder$(Path->join(r.get_page(), vscode_dir, String(r.get_page(), "tasks.json")))
    try File->write_from_string(ep, tasks_file_builder.to_string(r.get_page()), String(r.get_page(), "{
	\"version\": \"2.0.0\",
	\"tasks\": [
		{
			\"label\": \"Build Scaly package\",
			\"type\": \"shell\",
			\"command\": \"./build.sh\",
			\"group\": {
				\"kind\": \"build\",
				\"isDefault\": true
			},
			\"presentation\": {
				\"reveal\": \"always\",
				\"panel\": \"shared\"
			},
			\"problemMatcher\": []
		}
	]
}"))
        else throw

;*    var launch_builder: ref[StringBuilder] *StringBuilder$("{
	\"version\": \"0.2.0\",
	\"configurations\": [
		{
			\"type\": \"lldb\",
			\"request\": \"launch\",
			\"name\": \"Debug\",
			\"program\": \"${workspaceFolder}/bin/")
        launch_builder.append(program.module_.name)
        launch_builder.append("\",
			\"args\": [],
			\"cwd\": \"${workspaceFolder}\"
		}
	]
}")
    try File->write_from_string(ep, Path->join(r.get_page(), vscode_dir, String(r.get_page(), "launch.json")), launch_builder.to_string(r.get_page()))
        else throw
*;
    return Void()
}

function build_script_files(builder: ref[StringBuilder], path: String, module_: ref[Module], extension: String, include_path: bool) {
    var r Region()
    builder.append("    ")
    if include_path
        builder.append(path)
    builder.append(module_.name)
    builder.append(extension)
    builder.append(" \\\n")
    if include_path
    {
        var path_builder: ref[StringBuilder] *StringBuilder$(path)
        path_builder.append(module_.name)
        path_builder.append('/')
        build_script_files_list(builder, path_builder.to_string(r.get_page()), module_.modules, module_.members, extension, include_path)
    } else {
        build_script_files_list(builder, path, module_.modules, module_.members, extension, include_path)
    }
}

function build_script_files_list(builder: ref[StringBuilder], path: String, modules: ref[Vector[Module]], members: ref[Vector[Member]], extension: String, include_path: bool) {
    var r Region()
    for module_ in modules
    {
        build_script_files(builder, path, module_, extension, include_path)
    }

    for member in members
    {
        choose member
            when concept: Member.Concept
                {
                    choose concept.definition
                        when namespace_: Definition.Namespace
                            build_script_files_list(builder, path, namespace_.modules, namespace_.members, extension, include_path)
                        when structure: Definition.Structure
                            build_script_files_list(builder, path, structure.modules, structure.members, extension, include_path)
                        else {}
                }
            else continue
    }
}

function main_file(path: String, program: ref[Program]) throws TranspilerError {
    var r Region()
    var builder: ref[StringBuilder] *StringBuilder$("#include \"main.h\"

int main(int argc, char** argv) {")
    for statement in program.statements
    {
        builder.append("\n    ")
        build_statement(ep, builder, statement, null, null, null, String())
        builder.append(';')
    }
    builder.append("\n    return 0;\n}\n")
    if builder.get_length() > 0
    {
        let main_file_name Path->join(r.get_page(), path, String(r.get_page(), "main.cpp"))
        try File->write_from_string(ep, main_file_name, builder.to_string(r.get_page()))
            else throw
    }

    return Void()
}

function main_include_file(path: String, name: String) throws TranspilerError {
    var r Region()
    var main_include_file_builder: ref[StringBuilder]  *StringBuilder$(Path->join(r.get_page(), path, String(r.get_page(), "main")))
    main_include_file_builder.append(".h")
    var main_include_builder: ref[StringBuilder] *StringBuilder$("#include \"")
    main_include_builder.append(name)
    main_include_builder.append(".h\"\n")
    try File->write_from_string(ep, main_include_file_builder.to_string(r.get_page()), main_include_builder.to_string(r.get_page()))
        else throw
    return Void()
}

}