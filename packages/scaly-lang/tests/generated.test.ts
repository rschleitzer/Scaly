// Generated test cases from tests.sgm
// DO NOT EDIT - generated by codegen

import { describe, it, expect, beforeEach } from 'vitest'
import { evaluate, evaluateProgram, resetEvaluator } from '../src/index.js'

describe('Boolean Literals', () => {
  it('bool-true', () => {
    const result = evaluate(`true`)
    expect(result._tag).toBe('Ok')
    expect(result.value).toBe(true)
  })
  it('bool-false', () => {
    const result = evaluate(`false`)
    expect(result._tag).toBe('Ok')
    expect(result.value).toBe(false)
  })
})

describe('Integer Literals', () => {
  it('int-positive', () => {
    const result = evaluate(`42`)
    expect(result._tag).toBe('Ok')
    expect(result.value).toBe(42)
  })
  it('int-zero', () => {
    const result = evaluate(`0`)
    expect(result._tag).toBe('Ok')
    expect(result.value).toBe(0)
  })
  it('int-negative', () => {
    const result = evaluate(`-7`)
    expect(result._tag).toBe('Ok')
    expect(result.value).toBe(-7)
  })
})

describe('Hexadecimal Literals', () => {
  it('hex-ff', () => {
    const result = evaluate(`0xFF`)
    expect(result._tag).toBe('Ok')
    expect(result.value).toBe(255)
  })
  it('hex-1a', () => {
    const result = evaluate(`0x1A`)
    expect(result._tag).toBe('Ok')
    expect(result.value).toBe(26)
  })
  it('hex-zero', () => {
    const result = evaluate(`0x0`)
    expect(result._tag).toBe('Ok')
    expect(result.value).toBe(0)
  })
})

describe('Floating-Point Literals', () => {
  it('float-pi', () => {
    const result = evaluate(`3.14`)
    expect(result._tag).toBe('Ok')
    expect(result.value).toBe(3.14)
  })
  it('float-two', () => {
    const result = evaluate(`2.0`)
    expect(result._tag).toBe('Ok')
    expect(result.value).toBe(2)
  })
  it('float-half', () => {
    const result = evaluate(`0.5`)
    expect(result._tag).toBe('Ok')
    expect(result.value).toBe(0.5)
  })
})

describe('String Literals', () => {
  it('string-hello', () => {
    const result = evaluate(`"hello"`)
    expect(result._tag).toBe('Ok')
    expect(result.value).toBe('hello')
  })
  it('string-empty', () => {
    const result = evaluate(`""`)
    expect(result._tag).toBe('Ok')
    expect(result.value).toBe('')
  })
})

describe('Character Literals', () => {
  it('char-a', () => {
    const result = evaluate('`a`')
    expect(result._tag).toBe('Ok')
    expect(result.value).toBe('a')
  })
  it('char-z', () => {
    const result = evaluate('`Z`')
    expect(result._tag).toBe('Ok')
    expect(result.value).toBe('Z')
  })
})

describe('Prefix Functions', () => {
  it('negate-positive', () => {
    const result = evaluate(`-7`)
    expect(result._tag).toBe('Ok')
    expect(result.value).toBe(-7)
  })
  it('negate-negative', () => {
    const result = evaluate(`-(-3)`)
    expect(result._tag).toBe('Ok')
    expect(result.value).toBe(3)
  })
  it('prefix-add', () => {
    const result = evaluate(`+ 3`)
    expect(result._tag).toBe('Ok')
    expect(result.value).toBe(3)
  })
})

describe('Operator Chains', () => {
  it('simple-add', () => {
    const result = evaluate(`3 + 4`)
    expect(result._tag).toBe('Ok')
    expect(result.value).toBe(7)
  })
  it('simple-subtract', () => {
    const result = evaluate(`10 - 3`)
    expect(result._tag).toBe('Ok')
    expect(result.value).toBe(7)
  })
  it('simple-multiply', () => {
    const result = evaluate(`6 * 7`)
    expect(result._tag).toBe('Ok')
    expect(result.value).toBe(42)
  })
  it('chain-with-precedence', () => {
    const result = evaluate(`3 + 4 * 2`)
    expect(result._tag).toBe('Ok')
    expect(result.value).toBe(11)
  })
  it('chain-left-to-right', () => {
    const result = evaluate(`20 - 5 - 3`)
    expect(result._tag).toBe('Ok')
    expect(result.value).toBe(12)
  })
})

describe('Parentheses and Grouping', () => {
  it('parens-negate', () => {
    const result = evaluate(`5 * (- 2)`)
    expect(result._tag).toBe('Ok')
    expect(result.value).toBe(-10)
  })
  it('parens-grouping', () => {
    const result = evaluate(`2 * (3 + 4)`)
    expect(result._tag).toBe('Ok')
    expect(result.value).toBe(14)
  })
  it('nested-parens', () => {
    const result = evaluate(`(2 + 3) * (4 + 1)`)
    expect(result._tag).toBe('Ok')
    expect(result.value).toBe(25)
  })
})

describe('Identifier Shapes', () => {
  it('name-as-operator', () => {
    const result = evaluate(`10 div 3`)
    expect(result._tag).toBe('Ok')
    expect(result.value).toBe(3)
  })
  it('name-as-function', () => {
    const result = evaluate(`abs (- 5)`)
    expect(result._tag).toBe('Ok')
    expect(result.value).toBe(5)
  })
})

describe('Structure Definitions', () => {
  it('define-point', () => {
    resetEvaluator()
    const result = evaluateProgram(`define Point(x: int, y: int)
Point(3, 4)`)
    expect(result._tag).toBe('Ok')
    expect(JSON.stringify(result.value)).toBe('{"_type":"Point","x":3,"y":4}')
  })
  it('define-field-access', () => {
    resetEvaluator()
    const result = evaluateProgram(`define Point(x: int, y: int)
Point(3, 4).x`)
    expect(result._tag).toBe('Ok')
    expect(result.value).toBe(3)
  })
  it('define-with-let', () => {
    resetEvaluator()
    const result = evaluateProgram(`define Point(x: int, y: int)
let p Point(3, 4): p.x + p.y`)
    expect(result._tag).toBe('Ok')
    expect(result.value).toBe(7)
  })
  it('define-nested', () => {
    resetEvaluator()
    const result = evaluateProgram(`define Point(x: int, y: int)
define Rectangle(origin: Point, width: int, height: int)
Rectangle(Point(0, 0), 10, 5).width`)
    expect(result._tag).toBe('Ok')
    expect(result.value).toBe(10)
  })
})

