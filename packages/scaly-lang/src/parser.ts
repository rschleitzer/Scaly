// Parser generated from scaly.sgm
// DO NOT EDIT - generated by codegen

import { Lexer } from './lexer.js'
import * as Syntax from './syntax.js'

export type ParseResult<T> =
  | { ok: true; value: T }
  | { ok: false; error: ParserError }

export type ParserError =
  | { _tag: 'DifferentSyntax' }
  | { _tag: 'InvalidSyntax'; start: number; end: number; message: string }

function different(): ParseResult<never> {
  return { ok: false, error: { _tag: 'DifferentSyntax' } }
}

function invalid(start: number, end: number, message: string): ParseResult<never> {
  return { ok: false, error: { _tag: 'InvalidSyntax', start, end, message } }
}

function ok<T>(value: T): ParseResult<T> {
  return { ok: true, value }
}

const KEYWORDS = new Set([
  'break',
  'case',
  'choose',
  'continue',
  'define',
  'deinit',
  'delegate',
  'else',
  'extends',
  'extern',
  'for',
  'function',
  'if',
  'is',
  'init',
  'implement',
  'in',
  'instruction',
  'intrinsic',
  'label',
  'lambda',
  'let',
  'loop',
  'macro',
  'match',
  'module',
  'mutable',
  'operator',
  'procedure',
  'private',
  'return',
  'returns',
  'repeat',
  'set',
  'sizeof',
  'throw',
  'throws',
  'trait',
  'try',
  'union',
  'use',
  'var',
  'when',
  'while',
  'package',
])

export class Parser {
  private lexer: Lexer

  constructor(text: string) {
    this.lexer = new Lexer(text)
  }

  parseLiteralToken(): ParseResult<Syntax.Literal> {
    if (this.lexer.token._tag === 'Empty') this.lexer.advance()

    const token = this.lexer.token
    switch (token._tag) {
      case 'String': {
        const ret: Syntax.StringLiteral = {
          _syntax: 'StringLiteral',
          start: this.lexer.previousPosition,
          end: this.lexer.position,
          value: token.value
        }
        this.lexer.empty()
        return ok(ret)
      }
      case 'Character': {
        const ret: Syntax.CharacterLiteral = {
          _syntax: 'CharacterLiteral',
          start: this.lexer.previousPosition,
          end: this.lexer.position,
          value: token.value
        }
        this.lexer.empty()
        return ok(ret)
      }
      case 'Integer': {
        const ret: Syntax.IntegerLiteral = {
          _syntax: 'IntegerLiteral',
          start: this.lexer.previousPosition,
          end: this.lexer.position,
          value: token.value
        }
        this.lexer.empty()
        return ok(ret)
      }
      case 'FloatingPoint': {
        const ret: Syntax.FloatingPointLiteral = {
          _syntax: 'FloatingPointLiteral',
          start: this.lexer.previousPosition,
          end: this.lexer.position,
          value: token.value
        }
        this.lexer.empty()
        return ok(ret)
      }
      case 'Hex': {
        const ret: Syntax.HexLiteral = {
          _syntax: 'HexLiteral',
          start: this.lexer.previousPosition,
          end: this.lexer.position,
          value: token.value
        }
        this.lexer.empty()
        return ok(ret)
      }
      case 'Boolean': {
        const ret: Syntax.BooleanLiteral = {
          _syntax: 'BooleanLiteral',
          start: this.lexer.previousPosition,
          end: this.lexer.position,
          value: token.value
        }
        this.lexer.empty()
        return ok(ret)
      }
      case 'Fragment': {
        const ret: Syntax.FragmentLiteral = {
          _syntax: 'FragmentLiteral',
          start: this.lexer.previousPosition,
          end: this.lexer.position,
          value: token.value
        }
        this.lexer.empty()
        return ok(ret)
      }
      default:
        return different()
    }
  }

  parseProgram(): ParseResult<Syntax.ProgramSyntax> {
    const start = this.lexer.previousPosition

    const fileStart = this.lexer.position
    const fileResult = this.parseFile()
    if (!fileResult.ok) {
      return fileResult
    }
    const file = fileResult.value

    const statementsStart = this.lexer.position
    let statements: Syntax.StatementSyntax[] | null = null
    {
      const statementsResult = this.parseStatementList()
      if (statementsResult.ok) statements = statementsResult.value
      else if (statementsResult.error._tag === 'InvalidSyntax') return statementsResult
    }

    const end = this.lexer.position

    return ok({
      _syntax: 'ProgramSyntax',
      start,
      end,
      file,
      statements
    })
  }

  parseFile(): ParseResult<Syntax.FileSyntax> {
    const start = this.lexer.previousPosition

    const packagesStart = this.lexer.position
    let packages: Syntax.PackageSyntax[] | null = null
    {
      const packagesResult = this.parsePackageList()
      if (packagesResult.ok) packages = packagesResult.value
      else if (packagesResult.error._tag === 'InvalidSyntax') return packagesResult
    }

    const usesStart = this.lexer.position
    let uses: Syntax.UseSyntax[] | null = null
    {
      const usesResult = this.parseUseList()
      if (usesResult.ok) uses = usesResult.value
      else if (usesResult.error._tag === 'InvalidSyntax') return usesResult
    }

    const declarationsStart = this.lexer.position
    let declarations: Syntax.DeclarationSyntax[] | null = null
    {
      const declarationsResult = this.parseDeclarationList()
      if (declarationsResult.ok) declarations = declarationsResult.value
      else if (declarationsResult.error._tag === 'InvalidSyntax') return declarationsResult
    }

    const end = this.lexer.position

    return ok({
      _syntax: 'FileSyntax',
      start,
      end,
      packages,
      uses,
      declarations
    })
  }

  parseDeclarationList(): ParseResult<Syntax.DeclarationSyntax[]> {
    const list: Syntax.DeclarationSyntax[] = []
    while (true) {
      const result = this.parseDeclaration()
      if (!result.ok) {
        if (result.error._tag === 'InvalidSyntax') return result
        if (list.length === 0) return result
        return ok(list)
      }
      list.push(result.value)
    }
  }

  parseDeclaration(): ParseResult<Syntax.DeclarationSyntax> {
    const start = this.lexer.previousPosition

    const symbolStart = this.lexer.position
    const symbolResult = this.parseSymbol()
    if (!symbolResult.ok) {
      return symbolResult
    }
    const symbol = symbolResult.value

    const start_colon_2 = this.lexer.previousPosition
    const success_colon_2 = this.lexer.parseColon()

    const end = this.lexer.position

    return ok({
      _syntax: 'DeclarationSyntax',
      start,
      end,
      symbol
    })
  }

  parseSymbol(): ParseResult<Syntax.SymbolSyntax> {
    {
      const result = this.parsePrivate()
      if (result.ok) return ok(result.value as Syntax.SymbolSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    {
      const result = this.parseDefinition()
      if (result.ok) return ok(result.value as Syntax.SymbolSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    {
      const result = this.parseFunction()
      if (result.ok) return ok(result.value as Syntax.SymbolSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    {
      const result = this.parseOperator()
      if (result.ok) return ok(result.value as Syntax.SymbolSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    {
      const result = this.parseTrait()
      if (result.ok) return ok(result.value as Syntax.SymbolSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    {
      const result = this.parseMacro()
      if (result.ok) return ok(result.value as Syntax.SymbolSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    {
      const result = this.parseModule()
      if (result.ok) return ok(result.value as Syntax.SymbolSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    return different()
  }

  parsePrivate(): ParseResult<Syntax.PrivateSyntax> {
    const start = this.lexer.previousPosition

    const start_private_1 = this.lexer.previousPosition
    const success_private_1 = this.lexer.parseKeyword('private')
    if (!success_private_1) return different()

    const export_Start = this.lexer.position
    const export_Result = this.parseExport()
    if (!export_Result.ok) {
      if (export_Result.error._tag === 'InvalidSyntax') return export_Result
      return invalid(export_Start, this.lexer.position, 'a valid Export syntax')
    }
    const export_ = export_Result.value

    const end = this.lexer.position

    return ok({
      _syntax: 'PrivateSyntax',
      start,
      end,
      export_
    })
  }

  parseExport(): ParseResult<Syntax.ExportSyntax> {
    {
      const result = this.parseDefinition()
      if (result.ok) return ok(result.value as Syntax.ExportSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    {
      const result = this.parseFunction()
      if (result.ok) return ok(result.value as Syntax.ExportSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    {
      const result = this.parseOperator()
      if (result.ok) return ok(result.value as Syntax.ExportSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    {
      const result = this.parseTrait()
      if (result.ok) return ok(result.value as Syntax.ExportSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    {
      const result = this.parseModule()
      if (result.ok) return ok(result.value as Syntax.ExportSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    return different()
  }

  parseMemberList(): ParseResult<Syntax.MemberSyntax[]> {
    const list: Syntax.MemberSyntax[] = []
    while (true) {
      const result = this.parseMember()
      if (!result.ok) {
        if (result.error._tag === 'InvalidSyntax') return result
        if (list.length === 0) return result
        return ok(list)
      }
      list.push(result.value)
    }
  }

  parseMember(): ParseResult<Syntax.MemberSyntax> {
    const start = this.lexer.previousPosition

    const constituentStart = this.lexer.position
    const constituentResult = this.parseConstituent()
    if (!constituentResult.ok) {
      return constituentResult
    }
    const constituent = constituentResult.value

    const start_colon_2 = this.lexer.previousPosition
    const success_colon_2 = this.lexer.parseColon()

    const end = this.lexer.position

    return ok({
      _syntax: 'MemberSyntax',
      start,
      end,
      constituent
    })
  }

  parseConstituent(): ParseResult<Syntax.ConstituentSyntax> {
    {
      const result = this.parseDefinition()
      if (result.ok) return ok(result.value as Syntax.ConstituentSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    {
      const result = this.parseFunction()
      if (result.ok) return ok(result.value as Syntax.ConstituentSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    {
      const result = this.parseProcedure()
      if (result.ok) return ok(result.value as Syntax.ConstituentSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    {
      const result = this.parseOperator()
      if (result.ok) return ok(result.value as Syntax.ConstituentSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    {
      const result = this.parseImplement()
      if (result.ok) return ok(result.value as Syntax.ConstituentSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    {
      const result = this.parseTrait()
      if (result.ok) return ok(result.value as Syntax.ConstituentSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    {
      const result = this.parseMacro()
      if (result.ok) return ok(result.value as Syntax.ConstituentSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    {
      const result = this.parseModule()
      if (result.ok) return ok(result.value as Syntax.ConstituentSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    return different()
  }

  parseDefinition(): ParseResult<Syntax.DefinitionSyntax> {
    const start = this.lexer.previousPosition

    const start_define_1 = this.lexer.previousPosition
    const success_define_1 = this.lexer.parseKeyword('define')
    if (!success_define_1) return different()

    const start_name = this.lexer.previousPosition
    const name = this.lexer.parseIdentifier(KEYWORDS)
    if (!name) {
      return invalid(start_name, this.lexer.position, 'an identifier')
    }

    const parametersStart = this.lexer.position
    let parameters: Syntax.GenericParametersSyntax | null = null
    {
      const parametersResult = this.parseGenericParameters()
      if (parametersResult.ok) parameters = parametersResult.value
      else if (parametersResult.error._tag === 'InvalidSyntax') return parametersResult
    }

    const start_colon_4 = this.lexer.previousPosition
    const success_colon_4 = this.lexer.parseColon()

    const attributesStart = this.lexer.position
    let attributes: Syntax.AttributeSyntax[] | null = null
    {
      const attributesResult = this.parseAttributeList()
      if (attributesResult.ok) attributes = attributesResult.value
      else if (attributesResult.error._tag === 'InvalidSyntax') return attributesResult
    }

    const concept_Start = this.lexer.position
    const concept_Result = this.parseConcept()
    if (!concept_Result.ok) {
      if (concept_Result.error._tag === 'InvalidSyntax') return concept_Result
      return invalid(concept_Start, this.lexer.position, 'a valid Concept syntax')
    }
    const concept_ = concept_Result.value

    const end = this.lexer.position

    return ok({
      _syntax: 'DefinitionSyntax',
      start,
      end,
      name,
      parameters,
      attributes,
      concept_
    })
  }

  parseGenericParameters(): ParseResult<Syntax.GenericParametersSyntax> {
    const start = this.lexer.previousPosition

    const start_left_bracket_1 = this.lexer.previousPosition
    const success_left_bracket_1 = this.lexer.parsePunctuation('[')
    if (!success_left_bracket_1) return different()

    const parametersStart = this.lexer.position
    const parametersResult = this.parseGenericParameterList()
    if (!parametersResult.ok) {
      if (parametersResult.error._tag === 'InvalidSyntax') return parametersResult
      return invalid(parametersStart, this.lexer.position, 'a valid GenericParameter syntax')
    }
    const parameters = parametersResult.value

    const start_right_bracket_3 = this.lexer.previousPosition
    const success_right_bracket_3 = this.lexer.parsePunctuation(']')
    if (!success_right_bracket_3) {
      return invalid(start_right_bracket_3, this.lexer.position, ']')
    }

    const end = this.lexer.position

    return ok({
      _syntax: 'GenericParametersSyntax',
      start,
      end,
      parameters
    })
  }

  parseGenericParameterList(): ParseResult<Syntax.GenericParameterSyntax[]> {
    const list: Syntax.GenericParameterSyntax[] = []
    while (true) {
      const result = this.parseGenericParameter()
      if (!result.ok) {
        if (result.error._tag === 'InvalidSyntax') return result
        if (list.length === 0) return result
        return ok(list)
      }
      list.push(result.value)
    }
  }

  parseGenericParameter(): ParseResult<Syntax.GenericParameterSyntax> {
    const start = this.lexer.previousPosition

    const start_name = this.lexer.previousPosition
    const name = this.lexer.parseIdentifier(KEYWORDS)
    if (!name) return different()

    const attributesStart = this.lexer.position
    let attributes: Syntax.AttributeSyntax[] | null = null
    {
      const attributesResult = this.parseAttributeList()
      if (attributesResult.ok) attributes = attributesResult.value
      else if (attributesResult.error._tag === 'InvalidSyntax') return attributesResult
    }

    const start_comma_3 = this.lexer.previousPosition
    const success_comma_3 = this.lexer.parsePunctuation(',')

    const end = this.lexer.position

    return ok({
      _syntax: 'GenericParameterSyntax',
      start,
      end,
      name,
      attributes
    })
  }

  parseConcept(): ParseResult<Syntax.ConceptSyntax> {
    {
      const result = this.parseClass()
      if (result.ok) return ok(result.value as Syntax.ConceptSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    {
      const result = this.parseNamespace()
      if (result.ok) return ok(result.value as Syntax.ConceptSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    {
      const result = this.parseUnion()
      if (result.ok) return ok(result.value as Syntax.ConceptSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    {
      const result = this.parseConstant()
      if (result.ok) return ok(result.value as Syntax.ConceptSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    {
      const result = this.parseDelegate()
      if (result.ok) return ok(result.value as Syntax.ConceptSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    {
      const result = this.parseIntrinsic()
      if (result.ok) return ok(result.value as Syntax.ConceptSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    return different()
  }

  parseClass(): ParseResult<Syntax.ClassSyntax> {
    const start = this.lexer.previousPosition

    const structureStart = this.lexer.position
    const structureResult = this.parseStructure()
    if (!structureResult.ok) {
      return structureResult
    }
    const structure = structureResult.value

    const start_colon_2 = this.lexer.previousPosition
    const success_colon_2 = this.lexer.parseColon()

    const bodyStart = this.lexer.position
    let body: Syntax.BodySyntax | null = null
    {
      const bodyResult = this.parseBody()
      if (bodyResult.ok) body = bodyResult.value
      else if (bodyResult.error._tag === 'InvalidSyntax') return bodyResult
    }

    const start_colon_4 = this.lexer.previousPosition
    const success_colon_4 = this.lexer.parseColon()

    const end = this.lexer.position

    return ok({
      _syntax: 'ClassSyntax',
      start,
      end,
      structure,
      body
    })
  }

  parseBody(): ParseResult<Syntax.BodySyntax> {
    const start = this.lexer.previousPosition

    const start_left_curly_1 = this.lexer.previousPosition
    const success_left_curly_1 = this.lexer.parsePunctuation('{')
    if (!success_left_curly_1) return different()

    const usesStart = this.lexer.position
    let uses: Syntax.UseSyntax[] | null = null
    {
      const usesResult = this.parseUseList()
      if (usesResult.ok) uses = usesResult.value
      else if (usesResult.error._tag === 'InvalidSyntax') return usesResult
    }

    const initsStart = this.lexer.position
    let inits: Syntax.InitSyntax[] | null = null
    {
      const initsResult = this.parseInitList()
      if (initsResult.ok) inits = initsResult.value
      else if (initsResult.error._tag === 'InvalidSyntax') return initsResult
    }

    const deInitStart = this.lexer.position
    let deInit: Syntax.DeInitSyntax | null = null
    {
      const deInitResult = this.parseDeInit()
      if (deInitResult.ok) deInit = deInitResult.value
      else if (deInitResult.error._tag === 'InvalidSyntax') return deInitResult
    }

    const membersStart = this.lexer.position
    let members: Syntax.MemberSyntax[] | null = null
    {
      const membersResult = this.parseMemberList()
      if (membersResult.ok) members = membersResult.value
      else if (membersResult.error._tag === 'InvalidSyntax') return membersResult
    }

    const start_right_curly_6 = this.lexer.previousPosition
    const success_right_curly_6 = this.lexer.parsePunctuation('}')
    if (!success_right_curly_6) {
      return invalid(start_right_curly_6, this.lexer.position, '}')
    }

    const start_colon_7 = this.lexer.previousPosition
    const success_colon_7 = this.lexer.parseColon()

    const end = this.lexer.position

    return ok({
      _syntax: 'BodySyntax',
      start,
      end,
      uses,
      inits,
      deInit,
      members
    })
  }

  parseNamespace(): ParseResult<Syntax.NamespaceSyntax> {
    const start = this.lexer.previousPosition

    const start_left_curly_1 = this.lexer.previousPosition
    const success_left_curly_1 = this.lexer.parsePunctuation('{')
    if (!success_left_curly_1) return different()

    const usesStart = this.lexer.position
    let uses: Syntax.UseSyntax[] | null = null
    {
      const usesResult = this.parseUseList()
      if (usesResult.ok) uses = usesResult.value
      else if (usesResult.error._tag === 'InvalidSyntax') return usesResult
    }

    const declarationsStart = this.lexer.position
    let declarations: Syntax.DeclarationSyntax[] | null = null
    {
      const declarationsResult = this.parseDeclarationList()
      if (declarationsResult.ok) declarations = declarationsResult.value
      else if (declarationsResult.error._tag === 'InvalidSyntax') return declarationsResult
    }

    const start_right_curly_4 = this.lexer.previousPosition
    const success_right_curly_4 = this.lexer.parsePunctuation('}')
    if (!success_right_curly_4) {
      return invalid(start_right_curly_4, this.lexer.position, '}')
    }

    const start_colon_5 = this.lexer.previousPosition
    const success_colon_5 = this.lexer.parseColon()

    const end = this.lexer.position

    return ok({
      _syntax: 'NamespaceSyntax',
      start,
      end,
      uses,
      declarations
    })
  }

  parseUnion(): ParseResult<Syntax.UnionSyntax> {
    const start = this.lexer.previousPosition

    const start_union_1 = this.lexer.previousPosition
    const success_union_1 = this.lexer.parseKeyword('union')
    if (!success_union_1) return different()

    const start_colon_2 = this.lexer.previousPosition
    const success_colon_2 = this.lexer.parseColon()

    const start_left_paren_3 = this.lexer.previousPosition
    const success_left_paren_3 = this.lexer.parsePunctuation('(')
    if (!success_left_paren_3) {
      return invalid(start_left_paren_3, this.lexer.position, '(')
    }

    const variantsStart = this.lexer.position
    const variantsResult = this.parseVariantList()
    if (!variantsResult.ok) {
      if (variantsResult.error._tag === 'InvalidSyntax') return variantsResult
      return invalid(variantsStart, this.lexer.position, 'a valid Variant syntax')
    }
    const variants = variantsResult.value

    const start_right_paren_5 = this.lexer.previousPosition
    const success_right_paren_5 = this.lexer.parsePunctuation(')')
    if (!success_right_paren_5) {
      return invalid(start_right_paren_5, this.lexer.position, ')')
    }

    const start_colon_6 = this.lexer.previousPosition
    const success_colon_6 = this.lexer.parseColon()

    const bodyStart = this.lexer.position
    let body: Syntax.BodySyntax | null = null
    {
      const bodyResult = this.parseBody()
      if (bodyResult.ok) body = bodyResult.value
      else if (bodyResult.error._tag === 'InvalidSyntax') return bodyResult
    }

    const start_colon_8 = this.lexer.previousPosition
    const success_colon_8 = this.lexer.parseColon()

    const end = this.lexer.position

    return ok({
      _syntax: 'UnionSyntax',
      start,
      end,
      variants,
      body
    })
  }

  parseVariantList(): ParseResult<Syntax.VariantSyntax[]> {
    const list: Syntax.VariantSyntax[] = []
    while (true) {
      const result = this.parseVariant()
      if (!result.ok) {
        if (result.error._tag === 'InvalidSyntax') return result
        if (list.length === 0) return result
        return ok(list)
      }
      list.push(result.value)
    }
  }

  parseVariant(): ParseResult<Syntax.VariantSyntax> {
    const start = this.lexer.previousPosition

    const start_name = this.lexer.previousPosition
    const name = this.lexer.parseIdentifier(KEYWORDS)
    if (!name) return different()

    const attributesStart = this.lexer.position
    let attributes: Syntax.AttributeSyntax[] | null = null
    {
      const attributesResult = this.parseAttributeList()
      if (attributesResult.ok) attributes = attributesResult.value
      else if (attributesResult.error._tag === 'InvalidSyntax') return attributesResult
    }

    const annotationStart = this.lexer.position
    let annotation: Syntax.TypeAnnotationSyntax | null = null
    {
      const annotationResult = this.parseTypeAnnotation()
      if (annotationResult.ok) annotation = annotationResult.value
      else if (annotationResult.error._tag === 'InvalidSyntax') return annotationResult
    }

    const start_comma_4 = this.lexer.previousPosition
    const success_comma_4 = this.lexer.parsePunctuation(',')

    const start_colon_5 = this.lexer.previousPosition
    const success_colon_5 = this.lexer.parseColon()

    const end = this.lexer.position

    return ok({
      _syntax: 'VariantSyntax',
      start,
      end,
      name,
      attributes,
      annotation
    })
  }

  parseConstant(): ParseResult<Syntax.ConstantSyntax> {
    const start = this.lexer.previousPosition

    const typeStart = this.lexer.position
    const typeResult = this.parseType()
    if (!typeResult.ok) {
      return typeResult
    }
    const type = typeResult.value

    const operationStart = this.lexer.position
    let operation: Syntax.OperandSyntax[] | null = null
    {
      const operationResult = this.parseOperandList()
      if (operationResult.ok) operation = operationResult.value
      else if (operationResult.error._tag === 'InvalidSyntax') return operationResult
    }

    const start_colon_3 = this.lexer.previousPosition
    const success_colon_3 = this.lexer.parseColon()

    const end = this.lexer.position

    return ok({
      _syntax: 'ConstantSyntax',
      start,
      end,
      type,
      operation
    })
  }

  parseDelegate(): ParseResult<Syntax.DelegateSyntax> {
    const start = this.lexer.previousPosition

    const start_delegate_1 = this.lexer.previousPosition
    const success_delegate_1 = this.lexer.parseKeyword('delegate')
    if (!success_delegate_1) return different()

    const parametersStart = this.lexer.position
    let parameters: Syntax.ParameterSetSyntax | null = null
    {
      const parametersResult = this.parseParameterSet()
      if (parametersResult.ok) parameters = parametersResult.value
      else if (parametersResult.error._tag === 'InvalidSyntax') return parametersResult
    }

    const attributesStart = this.lexer.position
    let attributes: Syntax.AttributeSyntax[] | null = null
    {
      const attributesResult = this.parseAttributeList()
      if (attributesResult.ok) attributes = attributesResult.value
      else if (attributesResult.error._tag === 'InvalidSyntax') return attributesResult
    }

    const resultStart = this.lexer.position
    let result: Syntax.ReturnsSyntax | null = null
    {
      const resultResult = this.parseReturns()
      if (resultResult.ok) result = resultResult.value
      else if (resultResult.error._tag === 'InvalidSyntax') return resultResult
    }

    const errorStart = this.lexer.position
    let error: Syntax.ThrowsSyntax | null = null
    {
      const errorResult = this.parseThrows()
      if (errorResult.ok) error = errorResult.value
      else if (errorResult.error._tag === 'InvalidSyntax') return errorResult
    }

    const end = this.lexer.position

    return ok({
      _syntax: 'DelegateSyntax',
      start,
      end,
      parameters,
      attributes,
      result,
      error
    })
  }

  parseGenericArguments(): ParseResult<Syntax.GenericArgumentsSyntax> {
    const start = this.lexer.previousPosition

    const start_left_bracket_1 = this.lexer.previousPosition
    const success_left_bracket_1 = this.lexer.parsePunctuation('[')
    if (!success_left_bracket_1) return different()

    const genericsStart = this.lexer.position
    let generics: Syntax.GenericArgumentSyntax[] | null = null
    {
      const genericsResult = this.parseGenericArgumentList()
      if (genericsResult.ok) generics = genericsResult.value
      else if (genericsResult.error._tag === 'InvalidSyntax') return genericsResult
    }

    const start_right_bracket_3 = this.lexer.previousPosition
    const success_right_bracket_3 = this.lexer.parsePunctuation(']')
    if (!success_right_bracket_3) {
      return invalid(start_right_bracket_3, this.lexer.position, ']')
    }

    const end = this.lexer.position

    return ok({
      _syntax: 'GenericArgumentsSyntax',
      start,
      end,
      generics
    })
  }

  parseGenericArgumentList(): ParseResult<Syntax.GenericArgumentSyntax[]> {
    const list: Syntax.GenericArgumentSyntax[] = []
    while (true) {
      const result = this.parseGenericArgument()
      if (!result.ok) {
        if (result.error._tag === 'InvalidSyntax') return result
        if (list.length === 0) return result
        return ok(list)
      }
      list.push(result.value)
    }
  }

  parseGenericArgument(): ParseResult<Syntax.GenericArgumentSyntax> {
    const start = this.lexer.previousPosition

    const typeStart = this.lexer.position
    const typeResult = this.parseType()
    if (!typeResult.ok) {
      return typeResult
    }
    const type = typeResult.value

    const start_comma_2 = this.lexer.previousPosition
    const success_comma_2 = this.lexer.parsePunctuation(',')

    const end = this.lexer.position

    return ok({
      _syntax: 'GenericArgumentSyntax',
      start,
      end,
      type
    })
  }

  parseOptional(): ParseResult<Syntax.OptionalSyntax> {
    const start = this.lexer.previousPosition

    const start_question_1 = this.lexer.previousPosition
    const success_question_1 = this.lexer.parsePunctuation('?')
    if (!success_question_1) return different()

    const end = this.lexer.position

    return ok({
      _syntax: 'OptionalSyntax',
      start,
      end
    })
  }

  parseParameterSet(): ParseResult<Syntax.ParameterSetSyntax> {
    {
      const result = this.parseParameters()
      if (result.ok) return ok(result.value as Syntax.ParameterSetSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    {
      const result = this.parseType()
      if (result.ok) return ok(result.value as Syntax.ParameterSetSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    return different()
  }

  parseParameters(): ParseResult<Syntax.ParametersSyntax> {
    const start = this.lexer.previousPosition

    const start_left_paren_1 = this.lexer.previousPosition
    const success_left_paren_1 = this.lexer.parsePunctuation('(')
    if (!success_left_paren_1) return different()

    const itemsStart = this.lexer.position
    let items: Syntax.ItemSyntax[] | null = null
    {
      const itemsResult = this.parseItemList()
      if (itemsResult.ok) items = itemsResult.value
      else if (itemsResult.error._tag === 'InvalidSyntax') return itemsResult
    }

    const start_right_paren_3 = this.lexer.previousPosition
    const success_right_paren_3 = this.lexer.parsePunctuation(')')
    if (!success_right_paren_3) {
      return invalid(start_right_paren_3, this.lexer.position, ')')
    }

    const end = this.lexer.position

    return ok({
      _syntax: 'ParametersSyntax',
      start,
      end,
      items
    })
  }

  parseItemList(): ParseResult<Syntax.ItemSyntax[]> {
    const list: Syntax.ItemSyntax[] = []
    while (true) {
      const result = this.parseItem()
      if (!result.ok) {
        if (result.error._tag === 'InvalidSyntax') return result
        if (list.length === 0) return result
        return ok(list)
      }
      list.push(result.value)
    }
  }

  parseItem(): ParseResult<Syntax.ItemSyntax> {
    const start = this.lexer.previousPosition

    const start_name = this.lexer.previousPosition
    const name = this.lexer.parseIdentifier(KEYWORDS)
    if (!name) return different()

    const annotationStart = this.lexer.position
    let annotation: Syntax.TypeAnnotationSyntax | null = null
    {
      const annotationResult = this.parseTypeAnnotation()
      if (annotationResult.ok) annotation = annotationResult.value
      else if (annotationResult.error._tag === 'InvalidSyntax') return annotationResult
    }

    const start_comma_3 = this.lexer.previousPosition
    const success_comma_3 = this.lexer.parsePunctuation(',')

    const start_colon_4 = this.lexer.previousPosition
    const success_colon_4 = this.lexer.parseColon()

    const attributesStart = this.lexer.position
    let attributes: Syntax.AttributeSyntax[] | null = null
    {
      const attributesResult = this.parseAttributeList()
      if (attributesResult.ok) attributes = attributesResult.value
      else if (attributesResult.error._tag === 'InvalidSyntax') return attributesResult
    }

    const start_colon_6 = this.lexer.previousPosition
    const success_colon_6 = this.lexer.parseColon()

    const end = this.lexer.position

    return ok({
      _syntax: 'ItemSyntax',
      start,
      end,
      name,
      annotation,
      attributes
    })
  }

  parseReturns(): ParseResult<Syntax.ReturnsSyntax> {
    const start = this.lexer.previousPosition

    const start_returns_1 = this.lexer.previousPosition
    const success_returns_1 = this.lexer.parseKeyword('returns')
    if (!success_returns_1) return different()

    const typeStart = this.lexer.position
    const typeResult = this.parseType()
    if (!typeResult.ok) {
      if (typeResult.error._tag === 'InvalidSyntax') return typeResult
      return invalid(typeStart, this.lexer.position, 'a valid Type syntax')
    }
    const type = typeResult.value

    const attributesStart = this.lexer.position
    let attributes: Syntax.AttributeSyntax[] | null = null
    {
      const attributesResult = this.parseAttributeList()
      if (attributesResult.ok) attributes = attributesResult.value
      else if (attributesResult.error._tag === 'InvalidSyntax') return attributesResult
    }

    const end = this.lexer.position

    return ok({
      _syntax: 'ReturnsSyntax',
      start,
      end,
      type,
      attributes
    })
  }

  parseThrows(): ParseResult<Syntax.ThrowsSyntax> {
    const start = this.lexer.previousPosition

    const start_throws_1 = this.lexer.previousPosition
    const success_throws_1 = this.lexer.parseKeyword('throws')
    if (!success_throws_1) return different()

    const typeStart = this.lexer.position
    const typeResult = this.parseType()
    if (!typeResult.ok) {
      if (typeResult.error._tag === 'InvalidSyntax') return typeResult
      return invalid(typeStart, this.lexer.position, 'a valid Type syntax')
    }
    const type = typeResult.value

    const attributesStart = this.lexer.position
    let attributes: Syntax.AttributeSyntax[] | null = null
    {
      const attributesResult = this.parseAttributeList()
      if (attributesResult.ok) attributes = attributesResult.value
      else if (attributesResult.error._tag === 'InvalidSyntax') return attributesResult
    }

    const end = this.lexer.position

    return ok({
      _syntax: 'ThrowsSyntax',
      start,
      end,
      type,
      attributes
    })
  }

  parseUseList(): ParseResult<Syntax.UseSyntax[]> {
    const list: Syntax.UseSyntax[] = []
    while (true) {
      const result = this.parseUse()
      if (!result.ok) {
        if (result.error._tag === 'InvalidSyntax') return result
        if (list.length === 0) return result
        return ok(list)
      }
      list.push(result.value)
    }
  }

  parseUse(): ParseResult<Syntax.UseSyntax> {
    const start = this.lexer.previousPosition

    const start_use_1 = this.lexer.previousPosition
    const success_use_1 = this.lexer.parseKeyword('use')
    if (!success_use_1) return different()

    const nameStart = this.lexer.position
    const nameResult = this.parseName()
    if (!nameResult.ok) {
      if (nameResult.error._tag === 'InvalidSyntax') return nameResult
      return invalid(nameStart, this.lexer.position, 'a valid Name syntax')
    }
    const name = nameResult.value

    const start_colon_3 = this.lexer.previousPosition
    const success_colon_3 = this.lexer.parseColon()

    const end = this.lexer.position

    return ok({
      _syntax: 'UseSyntax',
      start,
      end,
      name
    })
  }

  parseImplement(): ParseResult<Syntax.ImplementSyntax> {
    const start = this.lexer.previousPosition

    const start_implement_1 = this.lexer.previousPosition
    const success_implement_1 = this.lexer.parseKeyword('implement')
    if (!success_implement_1) return different()

    const typeStart = this.lexer.position
    const typeResult = this.parseType()
    if (!typeResult.ok) {
      if (typeResult.error._tag === 'InvalidSyntax') return typeResult
      return invalid(typeStart, this.lexer.position, 'a valid Type syntax')
    }
    const type = typeResult.value

    const attributesStart = this.lexer.position
    let attributes: Syntax.AttributeSyntax[] | null = null
    {
      const attributesResult = this.parseAttributeList()
      if (attributesResult.ok) attributes = attributesResult.value
      else if (attributesResult.error._tag === 'InvalidSyntax') return attributesResult
    }

    const start_colon_4 = this.lexer.previousPosition
    const success_colon_4 = this.lexer.parseColon()

    const start_left_curly_5 = this.lexer.previousPosition
    const success_left_curly_5 = this.lexer.parsePunctuation('{')
    if (!success_left_curly_5) {
      return invalid(start_left_curly_5, this.lexer.position, '{')
    }

    const usesStart = this.lexer.position
    let uses: Syntax.UseSyntax[] | null = null
    {
      const usesResult = this.parseUseList()
      if (usesResult.ok) uses = usesResult.value
      else if (usesResult.error._tag === 'InvalidSyntax') return usesResult
    }

    const methodsStart = this.lexer.position
    let methods: Syntax.MethodSyntax[] | null = null
    {
      const methodsResult = this.parseMethodList()
      if (methodsResult.ok) methods = methodsResult.value
      else if (methodsResult.error._tag === 'InvalidSyntax') return methodsResult
    }

    const start_right_curly_8 = this.lexer.previousPosition
    const success_right_curly_8 = this.lexer.parsePunctuation('}')
    if (!success_right_curly_8) {
      return invalid(start_right_curly_8, this.lexer.position, '}')
    }

    const start_colon_9 = this.lexer.previousPosition
    const success_colon_9 = this.lexer.parseColon()

    const end = this.lexer.position

    return ok({
      _syntax: 'ImplementSyntax',
      start,
      end,
      type,
      attributes,
      uses,
      methods
    })
  }

  parseTrait(): ParseResult<Syntax.TraitSyntax> {
    const start = this.lexer.previousPosition

    const start_trait_1 = this.lexer.previousPosition
    const success_trait_1 = this.lexer.parseKeyword('trait')
    if (!success_trait_1) return different()

    const nameStart = this.lexer.position
    const nameResult = this.parseName()
    if (!nameResult.ok) {
      if (nameResult.error._tag === 'InvalidSyntax') return nameResult
      return invalid(nameStart, this.lexer.position, 'a valid Name syntax')
    }
    const name = nameResult.value

    const extensionStart = this.lexer.position
    let extension: Syntax.ExtendsSyntax | null = null
    {
      const extensionResult = this.parseExtends()
      if (extensionResult.ok) extension = extensionResult.value
      else if (extensionResult.error._tag === 'InvalidSyntax') return extensionResult
    }

    const attributesStart = this.lexer.position
    let attributes: Syntax.AttributeSyntax[] | null = null
    {
      const attributesResult = this.parseAttributeList()
      if (attributesResult.ok) attributes = attributesResult.value
      else if (attributesResult.error._tag === 'InvalidSyntax') return attributesResult
    }

    const start_left_curly_5 = this.lexer.previousPosition
    const success_left_curly_5 = this.lexer.parsePunctuation('{')
    if (!success_left_curly_5) {
      return invalid(start_left_curly_5, this.lexer.position, '{')
    }

    const usesStart = this.lexer.position
    let uses: Syntax.UseSyntax[] | null = null
    {
      const usesResult = this.parseUseList()
      if (usesResult.ok) uses = usesResult.value
      else if (usesResult.error._tag === 'InvalidSyntax') return usesResult
    }

    const functionsStart = this.lexer.position
    let functions: Syntax.MethodSyntax[] | null = null
    {
      const functionsResult = this.parseMethodList()
      if (functionsResult.ok) functions = functionsResult.value
      else if (functionsResult.error._tag === 'InvalidSyntax') return functionsResult
    }

    const start_right_curly_8 = this.lexer.previousPosition
    const success_right_curly_8 = this.lexer.parsePunctuation('}')
    if (!success_right_curly_8) {
      return invalid(start_right_curly_8, this.lexer.position, '}')
    }

    const start_colon_9 = this.lexer.previousPosition
    const success_colon_9 = this.lexer.parseColon()

    const end = this.lexer.position

    return ok({
      _syntax: 'TraitSyntax',
      start,
      end,
      name,
      extension,
      attributes,
      uses,
      functions
    })
  }

  parseMethodList(): ParseResult<Syntax.MethodSyntax[]> {
    const list: Syntax.MethodSyntax[] = []
    while (true) {
      const result = this.parseMethod()
      if (!result.ok) {
        if (result.error._tag === 'InvalidSyntax') return result
        if (list.length === 0) return result
        return ok(list)
      }
      list.push(result.value)
    }
  }

  parseMethod(): ParseResult<Syntax.MethodSyntax> {
    {
      const result = this.parseFunction()
      if (result.ok) return ok(result.value as Syntax.MethodSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    {
      const result = this.parseProcedure()
      if (result.ok) return ok(result.value as Syntax.MethodSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    {
      const result = this.parseOperator()
      if (result.ok) return ok(result.value as Syntax.MethodSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    return different()
  }

  parseInitList(): ParseResult<Syntax.InitSyntax[]> {
    const list: Syntax.InitSyntax[] = []
    while (true) {
      const result = this.parseInit()
      if (!result.ok) {
        if (result.error._tag === 'InvalidSyntax') return result
        if (list.length === 0) return result
        return ok(list)
      }
      list.push(result.value)
    }
  }

  parseInit(): ParseResult<Syntax.InitSyntax> {
    const start = this.lexer.previousPosition

    const start_init_1 = this.lexer.previousPosition
    const success_init_1 = this.lexer.parseKeyword('init')
    if (!success_init_1) return different()

    const parametersStart = this.lexer.position
    let parameters: Syntax.ParameterSetSyntax | null = null
    {
      const parametersResult = this.parseParameterSet()
      if (parametersResult.ok) parameters = parametersResult.value
      else if (parametersResult.error._tag === 'InvalidSyntax') return parametersResult
    }

    const start_colon_3 = this.lexer.previousPosition
    const success_colon_3 = this.lexer.parseColon()

    const actionStart = this.lexer.position
    const actionResult = this.parseAction()
    if (!actionResult.ok) {
      if (actionResult.error._tag === 'InvalidSyntax') return actionResult
      return invalid(actionStart, this.lexer.position, 'a valid Action syntax')
    }
    const action = actionResult.value

    const start_colon_5 = this.lexer.previousPosition
    const success_colon_5 = this.lexer.parseColon()

    const end = this.lexer.position

    return ok({
      _syntax: 'InitSyntax',
      start,
      end,
      parameters,
      action
    })
  }

  parseDeInit(): ParseResult<Syntax.DeInitSyntax> {
    const start = this.lexer.previousPosition

    const start_deinit_1 = this.lexer.previousPosition
    const success_deinit_1 = this.lexer.parseKeyword('deinit')
    if (!success_deinit_1) return different()

    const start_colon_2 = this.lexer.previousPosition
    const success_colon_2 = this.lexer.parseColon()

    const actionStart = this.lexer.position
    const actionResult = this.parseAction()
    if (!actionResult.ok) {
      if (actionResult.error._tag === 'InvalidSyntax') return actionResult
      return invalid(actionStart, this.lexer.position, 'a valid Action syntax')
    }
    const action = actionResult.value

    const start_colon_4 = this.lexer.previousPosition
    const success_colon_4 = this.lexer.parseColon()

    const end = this.lexer.position

    return ok({
      _syntax: 'DeInitSyntax',
      start,
      end,
      action
    })
  }

  parseFunction(): ParseResult<Syntax.FunctionSyntax> {
    const start = this.lexer.previousPosition

    const start_function_1 = this.lexer.previousPosition
    const success_function_1 = this.lexer.parseKeyword('function')
    if (!success_function_1) return different()

    const targetStart = this.lexer.position
    const targetResult = this.parseTarget()
    if (!targetResult.ok) {
      if (targetResult.error._tag === 'InvalidSyntax') return targetResult
      return invalid(targetStart, this.lexer.position, 'a valid Target syntax')
    }
    const target = targetResult.value

    const end = this.lexer.position

    return ok({
      _syntax: 'FunctionSyntax',
      start,
      end,
      target
    })
  }

  parseProcedure(): ParseResult<Syntax.ProcedureSyntax> {
    const start = this.lexer.previousPosition

    const start_procedure_1 = this.lexer.previousPosition
    const success_procedure_1 = this.lexer.parseKeyword('procedure')
    if (!success_procedure_1) return different()

    const targetStart = this.lexer.position
    const targetResult = this.parseTarget()
    if (!targetResult.ok) {
      if (targetResult.error._tag === 'InvalidSyntax') return targetResult
      return invalid(targetStart, this.lexer.position, 'a valid Target syntax')
    }
    const target = targetResult.value

    const end = this.lexer.position

    return ok({
      _syntax: 'ProcedureSyntax',
      start,
      end,
      target
    })
  }

  parseOperator(): ParseResult<Syntax.OperatorSyntax> {
    const start = this.lexer.previousPosition

    const start_operator_1 = this.lexer.previousPosition
    const success_operator_1 = this.lexer.parseKeyword('operator')
    if (!success_operator_1) return different()

    const targetStart = this.lexer.position
    const targetResult = this.parseTarget()
    if (!targetResult.ok) {
      if (targetResult.error._tag === 'InvalidSyntax') return targetResult
      return invalid(targetStart, this.lexer.position, 'a valid Target syntax')
    }
    const target = targetResult.value

    const end = this.lexer.position

    return ok({
      _syntax: 'OperatorSyntax',
      start,
      end,
      target
    })
  }

  parseTarget(): ParseResult<Syntax.TargetSyntax> {
    {
      const result = this.parseNamed()
      if (result.ok) return ok(result.value as Syntax.TargetSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    {
      const result = this.parseRoutine()
      if (result.ok) return ok(result.value as Syntax.TargetSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    return different()
  }

  parseNamed(): ParseResult<Syntax.NamedSyntax> {
    const start = this.lexer.previousPosition

    const start_name = this.lexer.previousPosition
    const name = this.lexer.parseIdentifier(KEYWORDS)
    if (!name) return different()

    const routineStart = this.lexer.position
    const routineResult = this.parseRoutine()
    if (!routineResult.ok) {
      if (routineResult.error._tag === 'InvalidSyntax') return routineResult
      return invalid(routineStart, this.lexer.position, 'a valid Routine syntax')
    }
    const routine = routineResult.value

    const end = this.lexer.position

    return ok({
      _syntax: 'NamedSyntax',
      start,
      end,
      name,
      routine
    })
  }

  parseRoutine(): ParseResult<Syntax.RoutineSyntax> {
    const start = this.lexer.previousPosition

    const genericsStart = this.lexer.position
    let generics: Syntax.GenericArgumentsSyntax | null = null
    {
      const genericsResult = this.parseGenericArguments()
      if (genericsResult.ok) generics = genericsResult.value
      else if (genericsResult.error._tag === 'InvalidSyntax') return genericsResult
    }

    const lifetimeStart = this.lexer.position
    let lifetime: Syntax.LifetimeSyntax | null = null
    {
      const lifetimeResult = this.parseLifetime()
      if (lifetimeResult.ok) lifetime = lifetimeResult.value
      else if (lifetimeResult.error._tag === 'InvalidSyntax') return lifetimeResult
    }

    const parametersStart = this.lexer.position
    let parameters: Syntax.ParameterSetSyntax | null = null
    {
      const parametersResult = this.parseParameterSet()
      if (parametersResult.ok) parameters = parametersResult.value
      else if (parametersResult.error._tag === 'InvalidSyntax') return parametersResult
    }

    const attributesStart = this.lexer.position
    let attributes: Syntax.AttributeSyntax[] | null = null
    {
      const attributesResult = this.parseAttributeList()
      if (attributesResult.ok) attributes = attributesResult.value
      else if (attributesResult.error._tag === 'InvalidSyntax') return attributesResult
    }

    const returns_Start = this.lexer.position
    let returns_: Syntax.ReturnsSyntax | null = null
    {
      const returns_Result = this.parseReturns()
      if (returns_Result.ok) returns_ = returns_Result.value
      else if (returns_Result.error._tag === 'InvalidSyntax') return returns_Result
    }

    const start_colon_6 = this.lexer.previousPosition
    const success_colon_6 = this.lexer.parseColon()

    const throws_Start = this.lexer.position
    let throws_: Syntax.ThrowsSyntax | null = null
    {
      const throws_Result = this.parseThrows()
      if (throws_Result.ok) throws_ = throws_Result.value
      else if (throws_Result.error._tag === 'InvalidSyntax') return throws_Result
    }

    const start_colon_8 = this.lexer.previousPosition
    const success_colon_8 = this.lexer.parseColon()

    const implementationStart = this.lexer.position
    const implementationResult = this.parseImplementation()
    if (!implementationResult.ok) {
      if (implementationResult.error._tag === 'InvalidSyntax') return implementationResult
      return invalid(implementationStart, this.lexer.position, 'a valid Implementation syntax')
    }
    const implementation = implementationResult.value

    const end = this.lexer.position

    return ok({
      _syntax: 'RoutineSyntax',
      start,
      end,
      generics,
      lifetime,
      parameters,
      attributes,
      returns_,
      throws_,
      implementation
    })
  }

  parseImplementation(): ParseResult<Syntax.ImplementationSyntax> {
    {
      const result = this.parseAction()
      if (result.ok) return ok(result.value as Syntax.ImplementationSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    {
      const result = this.parseExtern()
      if (result.ok) return ok(result.value as Syntax.ImplementationSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    {
      const result = this.parseInstruction()
      if (result.ok) return ok(result.value as Syntax.ImplementationSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    {
      const result = this.parseIntrinsic()
      if (result.ok) return ok(result.value as Syntax.ImplementationSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    return different()
  }

  parseExtern(): ParseResult<Syntax.ExternSyntax> {
    const start = this.lexer.previousPosition

    const start_extern_1 = this.lexer.previousPosition
    const success_extern_1 = this.lexer.parseKeyword('extern')
    if (!success_extern_1) return different()

    const end = this.lexer.position

    return ok({
      _syntax: 'ExternSyntax',
      start,
      end
    })
  }

  parseInstruction(): ParseResult<Syntax.InstructionSyntax> {
    const start = this.lexer.previousPosition

    const start_instruction_1 = this.lexer.previousPosition
    const success_instruction_1 = this.lexer.parseKeyword('instruction')
    if (!success_instruction_1) return different()

    const start_colon_2 = this.lexer.previousPosition
    const success_colon_2 = this.lexer.parseColon()

    const end = this.lexer.position

    return ok({
      _syntax: 'InstructionSyntax',
      start,
      end
    })
  }

  parseIntrinsic(): ParseResult<Syntax.IntrinsicSyntax> {
    const start = this.lexer.previousPosition

    const start_intrinsic_1 = this.lexer.previousPosition
    const success_intrinsic_1 = this.lexer.parseKeyword('intrinsic')
    if (!success_intrinsic_1) return different()

    const start_colon_2 = this.lexer.previousPosition
    const success_colon_2 = this.lexer.parseColon()

    const end = this.lexer.position

    return ok({
      _syntax: 'IntrinsicSyntax',
      start,
      end
    })
  }

  parseExtends(): ParseResult<Syntax.ExtendsSyntax> {
    const start = this.lexer.previousPosition

    const start_extends_1 = this.lexer.previousPosition
    const success_extends_1 = this.lexer.parseKeyword('extends')
    if (!success_extends_1) return different()

    const extensionsStart = this.lexer.position
    let extensions: Syntax.ExtendSyntax[] | null = null
    {
      const extensionsResult = this.parseExtendList()
      if (extensionsResult.ok) extensions = extensionsResult.value
      else if (extensionsResult.error._tag === 'InvalidSyntax') return extensionsResult
    }

    const end = this.lexer.position

    return ok({
      _syntax: 'ExtendsSyntax',
      start,
      end,
      extensions
    })
  }

  parseExtendList(): ParseResult<Syntax.ExtendSyntax[]> {
    const list: Syntax.ExtendSyntax[] = []
    while (true) {
      const result = this.parseExtend()
      if (!result.ok) {
        if (result.error._tag === 'InvalidSyntax') return result
        if (list.length === 0) return result
        return ok(list)
      }
      list.push(result.value)
    }
  }

  parseExtend(): ParseResult<Syntax.ExtendSyntax> {
    const start = this.lexer.previousPosition

    const typeStart = this.lexer.position
    const typeResult = this.parseType()
    if (!typeResult.ok) {
      return typeResult
    }
    const type = typeResult.value

    const start_comma_2 = this.lexer.previousPosition
    const success_comma_2 = this.lexer.parsePunctuation(',')

    const end = this.lexer.position

    return ok({
      _syntax: 'ExtendSyntax',
      start,
      end,
      type
    })
  }

  parseMacro(): ParseResult<Syntax.MacroSyntax> {
    const start = this.lexer.previousPosition

    const start_macro_1 = this.lexer.previousPosition
    const success_macro_1 = this.lexer.parseKeyword('macro')
    if (!success_macro_1) return different()

    const start_name = this.lexer.previousPosition
    const name = this.lexer.parseIdentifier(KEYWORDS)
    if (!name) {
      return invalid(start_name, this.lexer.position, 'an identifier')
    }

    const modelStart = this.lexer.position
    const modelResult = this.parseModel()
    if (!modelResult.ok) {
      if (modelResult.error._tag === 'InvalidSyntax') return modelResult
      return invalid(modelStart, this.lexer.position, 'a valid Model syntax')
    }
    const model = modelResult.value

    const ruleStart = this.lexer.position
    const ruleResult = this.parseOperandList()
    if (!ruleResult.ok) {
      if (ruleResult.error._tag === 'InvalidSyntax') return ruleResult
      return invalid(ruleStart, this.lexer.position, 'a valid Operand syntax')
    }
    const rule = ruleResult.value

    const end = this.lexer.position

    return ok({
      _syntax: 'MacroSyntax',
      start,
      end,
      name,
      model,
      rule
    })
  }

  parseAttributeList(): ParseResult<Syntax.AttributeSyntax[]> {
    const list: Syntax.AttributeSyntax[] = []
    while (true) {
      const result = this.parseAttribute()
      if (!result.ok) {
        if (result.error._tag === 'InvalidSyntax') return result
        if (list.length === 0) return result
        return ok(list)
      }
      list.push(result.value)
    }
  }

  parseAttribute(): ParseResult<Syntax.AttributeSyntax> {
    const start = this.lexer.previousPosition

    const start_name = this.lexer.previousPosition
    const name = this.lexer.parseAttribute()
    if (!name) return different()

    const modelStart = this.lexer.position
    const modelResult = this.parseModel()
    if (!modelResult.ok) {
      if (modelResult.error._tag === 'InvalidSyntax') return modelResult
      return invalid(modelStart, this.lexer.position, 'a valid Model syntax')
    }
    const model = modelResult.value

    const start_colon_3 = this.lexer.previousPosition
    const success_colon_3 = this.lexer.parseColon()

    const end = this.lexer.position

    return ok({
      _syntax: 'AttributeSyntax',
      start,
      end,
      name,
      model
    })
  }

  parseModel(): ParseResult<Syntax.ModelSyntax> {
    {
      const result = this.parseLiteral()
      if (result.ok) return ok(result.value as Syntax.ModelSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    {
      const result = this.parseName()
      if (result.ok) return ok(result.value as Syntax.ModelSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    {
      const result = this.parseObject()
      if (result.ok) return ok(result.value as Syntax.ModelSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    {
      const result = this.parseVector()
      if (result.ok) return ok(result.value as Syntax.ModelSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    return different()
  }

  parseModule(): ParseResult<Syntax.ModuleSyntax> {
    const start = this.lexer.previousPosition

    const start_module_1 = this.lexer.previousPosition
    const success_module_1 = this.lexer.parseKeyword('module')
    if (!success_module_1) return different()

    const start_name = this.lexer.previousPosition
    const name = this.lexer.parseIdentifier(KEYWORDS)
    if (!name) {
      return invalid(start_name, this.lexer.position, 'an identifier')
    }

    const start_colon_3 = this.lexer.previousPosition
    const success_colon_3 = this.lexer.parseColon()

    const end = this.lexer.position

    return ok({
      _syntax: 'ModuleSyntax',
      start,
      end,
      name
    })
  }

  parsePackageList(): ParseResult<Syntax.PackageSyntax[]> {
    const list: Syntax.PackageSyntax[] = []
    while (true) {
      const result = this.parsePackage()
      if (!result.ok) {
        if (result.error._tag === 'InvalidSyntax') return result
        if (list.length === 0) return result
        return ok(list)
      }
      list.push(result.value)
    }
  }

  parsePackage(): ParseResult<Syntax.PackageSyntax> {
    const start = this.lexer.previousPosition

    const start_package_1 = this.lexer.previousPosition
    const success_package_1 = this.lexer.parseKeyword('package')
    if (!success_package_1) return different()

    const nameStart = this.lexer.position
    const nameResult = this.parseName()
    if (!nameResult.ok) {
      if (nameResult.error._tag === 'InvalidSyntax') return nameResult
      return invalid(nameStart, this.lexer.position, 'a valid Name syntax')
    }
    const name = nameResult.value

    const start_colon_3 = this.lexer.previousPosition
    const success_colon_3 = this.lexer.parseColon()

    const end = this.lexer.position

    return ok({
      _syntax: 'PackageSyntax',
      start,
      end,
      name
    })
  }

  parseInitializer(): ParseResult<Syntax.InitializerSyntax> {
    const start = this.lexer.previousPosition

    const start_left_paren_1 = this.lexer.previousPosition
    const success_left_paren_1 = this.lexer.parsePunctuation('(')
    if (!success_left_paren_1) return different()

    const operandsStart = this.lexer.position
    const operandsResult = this.parseOperandList()
    if (!operandsResult.ok) {
      if (operandsResult.error._tag === 'InvalidSyntax') return operandsResult
      return invalid(operandsStart, this.lexer.position, 'a valid Operand syntax')
    }
    const operands = operandsResult.value

    const start_right_paren_3 = this.lexer.previousPosition
    const success_right_paren_3 = this.lexer.parsePunctuation(')')
    if (!success_right_paren_3) {
      return invalid(start_right_paren_3, this.lexer.position, ')')
    }

    const end = this.lexer.position

    return ok({
      _syntax: 'InitializerSyntax',
      start,
      end,
      operands
    })
  }

  parseOperandList(): ParseResult<Syntax.OperandSyntax[]> {
    const list: Syntax.OperandSyntax[] = []
    while (true) {
      const result = this.parseOperand()
      if (!result.ok) {
        if (result.error._tag === 'InvalidSyntax') return result
        if (list.length === 0) return result
        return ok(list)
      }
      list.push(result.value)
    }
  }

  parseOperand(): ParseResult<Syntax.OperandSyntax> {
    const start = this.lexer.previousPosition

    const expressionStart = this.lexer.position
    const expressionResult = this.parseExpression()
    if (!expressionResult.ok) {
      return expressionResult
    }
    const expression = expressionResult.value

    const membersStart = this.lexer.position
    let members: Syntax.MemberAccessSyntax[] | null = null
    {
      const membersResult = this.parseMemberAccessList()
      if (membersResult.ok) members = membersResult.value
      else if (membersResult.error._tag === 'InvalidSyntax') return membersResult
    }

    const end = this.lexer.position

    return ok({
      _syntax: 'OperandSyntax',
      start,
      end,
      expression,
      members
    })
  }

  parseMemberAccessList(): ParseResult<Syntax.MemberAccessSyntax[]> {
    const list: Syntax.MemberAccessSyntax[] = []
    while (true) {
      const result = this.parseMemberAccess()
      if (!result.ok) {
        if (result.error._tag === 'InvalidSyntax') return result
        if (list.length === 0) return result
        return ok(list)
      }
      list.push(result.value)
    }
  }

  parseMemberAccess(): ParseResult<Syntax.MemberAccessSyntax> {
    const start = this.lexer.previousPosition

    const start_dot_1 = this.lexer.previousPosition
    const success_dot_1 = this.lexer.parsePunctuation('.')
    if (!success_dot_1) return different()

    const nameStart = this.lexer.position
    const nameResult = this.parseName()
    if (!nameResult.ok) {
      if (nameResult.error._tag === 'InvalidSyntax') return nameResult
      return invalid(nameStart, this.lexer.position, 'a valid Name syntax')
    }
    const name = nameResult.value

    const end = this.lexer.position

    return ok({
      _syntax: 'MemberAccessSyntax',
      start,
      end,
      name
    })
  }

  parseExpression(): ParseResult<Syntax.ExpressionSyntax> {
    {
      const result = this.parseLiteral()
      if (result.ok) return ok(result.value as Syntax.ExpressionSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    {
      const result = this.parseType()
      if (result.ok) return ok(result.value as Syntax.ExpressionSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    {
      const result = this.parseObject()
      if (result.ok) return ok(result.value as Syntax.ExpressionSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    {
      const result = this.parseVector()
      if (result.ok) return ok(result.value as Syntax.ExpressionSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    {
      const result = this.parseBlock()
      if (result.ok) return ok(result.value as Syntax.ExpressionSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    {
      const result = this.parseIf()
      if (result.ok) return ok(result.value as Syntax.ExpressionSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    {
      const result = this.parseMatch()
      if (result.ok) return ok(result.value as Syntax.ExpressionSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    {
      const result = this.parseLambda()
      if (result.ok) return ok(result.value as Syntax.ExpressionSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    {
      const result = this.parseFor()
      if (result.ok) return ok(result.value as Syntax.ExpressionSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    {
      const result = this.parseWhile()
      if (result.ok) return ok(result.value as Syntax.ExpressionSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    {
      const result = this.parseChoose()
      if (result.ok) return ok(result.value as Syntax.ExpressionSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    {
      const result = this.parseTry()
      if (result.ok) return ok(result.value as Syntax.ExpressionSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    {
      const result = this.parseRepeat()
      if (result.ok) return ok(result.value as Syntax.ExpressionSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    {
      const result = this.parseSizeOf()
      if (result.ok) return ok(result.value as Syntax.ExpressionSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    {
      const result = this.parseIs()
      if (result.ok) return ok(result.value as Syntax.ExpressionSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    return different()
  }

  parseLiteral(): ParseResult<Syntax.LiteralSyntax> {
    const start = this.lexer.previousPosition

    const literalResult = this.parseLiteralToken()
    if (!literalResult.ok) return literalResult
    const literal = literalResult.value

    const end = this.lexer.position

    return ok({
      _syntax: 'LiteralSyntax',
      start,
      end,
      literal
    })
  }

  parseObject(): ParseResult<Syntax.ObjectSyntax> {
    const start = this.lexer.previousPosition

    const start_left_paren_1 = this.lexer.previousPosition
    const success_left_paren_1 = this.lexer.parsePunctuation('(')
    if (!success_left_paren_1) return different()

    const componentsStart = this.lexer.position
    let components: Syntax.ComponentSyntax[] | null = null
    {
      const componentsResult = this.parseComponentList()
      if (componentsResult.ok) components = componentsResult.value
      else if (componentsResult.error._tag === 'InvalidSyntax') return componentsResult
    }

    const start_right_paren_3 = this.lexer.previousPosition
    const success_right_paren_3 = this.lexer.parsePunctuation(')')
    if (!success_right_paren_3) {
      return invalid(start_right_paren_3, this.lexer.position, ')')
    }

    const end = this.lexer.position

    return ok({
      _syntax: 'ObjectSyntax',
      start,
      end,
      components
    })
  }

  parseComponentList(): ParseResult<Syntax.ComponentSyntax[]> {
    const list: Syntax.ComponentSyntax[] = []
    while (true) {
      const result = this.parseComponent()
      if (!result.ok) {
        if (result.error._tag === 'InvalidSyntax') return result
        if (list.length === 0) return result
        return ok(list)
      }
      list.push(result.value)
    }
  }

  parseComponent(): ParseResult<Syntax.ComponentSyntax> {
    const start = this.lexer.previousPosition

    const operandsStart = this.lexer.position
    const operandsResult = this.parseOperandList()
    if (!operandsResult.ok) {
      return operandsResult
    }
    const operands = operandsResult.value

    const attributesStart = this.lexer.position
    let attributes: Syntax.AttributeSyntax[] | null = null
    {
      const attributesResult = this.parseAttributeList()
      if (attributesResult.ok) attributes = attributesResult.value
      else if (attributesResult.error._tag === 'InvalidSyntax') return attributesResult
    }

    const valueStart = this.lexer.position
    let value: Syntax.ValueSyntax | null = null
    {
      const valueResult = this.parseValue()
      if (valueResult.ok) value = valueResult.value
      else if (valueResult.error._tag === 'InvalidSyntax') return valueResult
    }

    const start_comma_4 = this.lexer.previousPosition
    const success_comma_4 = this.lexer.parsePunctuation(',')

    const end = this.lexer.position

    return ok({
      _syntax: 'ComponentSyntax',
      start,
      end,
      operands,
      attributes,
      value
    })
  }

  parseValue(): ParseResult<Syntax.ValueSyntax> {
    const start = this.lexer.previousPosition

    const start_colon_1 = this.lexer.previousPosition
    const success_colon_1 = this.lexer.parseColon()
    if (!success_colon_1) return different()

    const valueStart = this.lexer.position
    const valueResult = this.parseOperandList()
    if (!valueResult.ok) {
      if (valueResult.error._tag === 'InvalidSyntax') return valueResult
      return invalid(valueStart, this.lexer.position, 'a valid Operand syntax')
    }
    const value = valueResult.value

    const attributesStart = this.lexer.position
    let attributes: Syntax.AttributeSyntax[] | null = null
    {
      const attributesResult = this.parseAttributeList()
      if (attributesResult.ok) attributes = attributesResult.value
      else if (attributesResult.error._tag === 'InvalidSyntax') return attributesResult
    }

    const end = this.lexer.position

    return ok({
      _syntax: 'ValueSyntax',
      start,
      end,
      value,
      attributes
    })
  }

  parseVector(): ParseResult<Syntax.VectorSyntax> {
    const start = this.lexer.previousPosition

    const start_left_bracket_1 = this.lexer.previousPosition
    const success_left_bracket_1 = this.lexer.parsePunctuation('[')
    if (!success_left_bracket_1) return different()

    const elementsStart = this.lexer.position
    const elementsResult = this.parseElementList()
    if (!elementsResult.ok) {
      if (elementsResult.error._tag === 'InvalidSyntax') return elementsResult
      return invalid(elementsStart, this.lexer.position, 'a valid Element syntax')
    }
    const elements = elementsResult.value

    const start_right_bracket_3 = this.lexer.previousPosition
    const success_right_bracket_3 = this.lexer.parsePunctuation(']')
    if (!success_right_bracket_3) {
      return invalid(start_right_bracket_3, this.lexer.position, ']')
    }

    const lifetimeStart = this.lexer.position
    let lifetime: Syntax.LifetimeSyntax | null = null
    {
      const lifetimeResult = this.parseLifetime()
      if (lifetimeResult.ok) lifetime = lifetimeResult.value
      else if (lifetimeResult.error._tag === 'InvalidSyntax') return lifetimeResult
    }

    const end = this.lexer.position

    return ok({
      _syntax: 'VectorSyntax',
      start,
      end,
      elements,
      lifetime
    })
  }

  parseElementList(): ParseResult<Syntax.ElementSyntax[]> {
    const list: Syntax.ElementSyntax[] = []
    while (true) {
      const result = this.parseElement()
      if (!result.ok) {
        if (result.error._tag === 'InvalidSyntax') return result
        if (list.length === 0) return result
        return ok(list)
      }
      list.push(result.value)
    }
  }

  parseElement(): ParseResult<Syntax.ElementSyntax> {
    const start = this.lexer.previousPosition

    const operationStart = this.lexer.position
    const operationResult = this.parseOperandList()
    if (!operationResult.ok) {
      return operationResult
    }
    const operation = operationResult.value

    const attributesStart = this.lexer.position
    let attributes: Syntax.AttributeSyntax[] | null = null
    {
      const attributesResult = this.parseAttributeList()
      if (attributesResult.ok) attributes = attributesResult.value
      else if (attributesResult.error._tag === 'InvalidSyntax') return attributesResult
    }

    const start_comma_3 = this.lexer.previousPosition
    const success_comma_3 = this.lexer.parsePunctuation(',')

    const end = this.lexer.position

    return ok({
      _syntax: 'ElementSyntax',
      start,
      end,
      operation,
      attributes
    })
  }

  parseBlock(): ParseResult<Syntax.BlockSyntax> {
    const start = this.lexer.previousPosition

    const start_left_curly_1 = this.lexer.previousPosition
    const success_left_curly_1 = this.lexer.parsePunctuation('{')
    if (!success_left_curly_1) return different()

    const usesStart = this.lexer.position
    let uses: Syntax.UseSyntax[] | null = null
    {
      const usesResult = this.parseUseList()
      if (usesResult.ok) uses = usesResult.value
      else if (usesResult.error._tag === 'InvalidSyntax') return usesResult
    }

    const statementsStart = this.lexer.position
    let statements: Syntax.StatementSyntax[] | null = null
    {
      const statementsResult = this.parseStatementList()
      if (statementsResult.ok) statements = statementsResult.value
      else if (statementsResult.error._tag === 'InvalidSyntax') return statementsResult
    }

    const start_right_curly_4 = this.lexer.previousPosition
    const success_right_curly_4 = this.lexer.parsePunctuation('}')
    if (!success_right_curly_4) {
      return invalid(start_right_curly_4, this.lexer.position, '}')
    }

    const end = this.lexer.position

    return ok({
      _syntax: 'BlockSyntax',
      start,
      end,
      uses,
      statements
    })
  }

  parseIf(): ParseResult<Syntax.IfSyntax> {
    const start = this.lexer.previousPosition

    const start_if_1 = this.lexer.previousPosition
    const success_if_1 = this.lexer.parseKeyword('if')
    if (!success_if_1) return different()

    const conditionStart = this.lexer.position
    const conditionResult = this.parseOperandList()
    if (!conditionResult.ok) {
      if (conditionResult.error._tag === 'InvalidSyntax') return conditionResult
      return invalid(conditionStart, this.lexer.position, 'a valid Operand syntax')
    }
    const condition = conditionResult.value

    const start_colon_3 = this.lexer.previousPosition
    const success_colon_3 = this.lexer.parseColon()
    if (!success_colon_3) {
      return invalid(start_colon_3, this.lexer.position, 'a colon or a line feed')
    }

    const consequentStart = this.lexer.position
    const consequentResult = this.parseCommand()
    if (!consequentResult.ok) {
      if (consequentResult.error._tag === 'InvalidSyntax') return consequentResult
      return invalid(consequentStart, this.lexer.position, 'a valid Command syntax')
    }
    const consequent = consequentResult.value

    const alternativeStart = this.lexer.position
    let alternative: Syntax.ElseSyntax | null = null
    {
      const alternativeResult = this.parseElse()
      if (alternativeResult.ok) alternative = alternativeResult.value
      else if (alternativeResult.error._tag === 'InvalidSyntax') return alternativeResult
    }

    const end = this.lexer.position

    return ok({
      _syntax: 'IfSyntax',
      start,
      end,
      condition,
      consequent,
      alternative
    })
  }

  parseElse(): ParseResult<Syntax.ElseSyntax> {
    const start = this.lexer.previousPosition

    const start_else_1 = this.lexer.previousPosition
    const success_else_1 = this.lexer.parseKeyword('else')
    if (!success_else_1) return different()

    const start_colon_2 = this.lexer.previousPosition
    const success_colon_2 = this.lexer.parseColon()

    const alternativeStart = this.lexer.position
    const alternativeResult = this.parseCommand()
    if (!alternativeResult.ok) {
      if (alternativeResult.error._tag === 'InvalidSyntax') return alternativeResult
      return invalid(alternativeStart, this.lexer.position, 'a valid Command syntax')
    }
    const alternative = alternativeResult.value

    const end = this.lexer.position

    return ok({
      _syntax: 'ElseSyntax',
      start,
      end,
      alternative
    })
  }

  parseMatch(): ParseResult<Syntax.MatchSyntax> {
    const start = this.lexer.previousPosition

    const start_match_1 = this.lexer.previousPosition
    const success_match_1 = this.lexer.parseKeyword('match')
    if (!success_match_1) return different()

    const scrutineeStart = this.lexer.position
    const scrutineeResult = this.parseOperandList()
    if (!scrutineeResult.ok) {
      if (scrutineeResult.error._tag === 'InvalidSyntax') return scrutineeResult
      return invalid(scrutineeStart, this.lexer.position, 'a valid Operand syntax')
    }
    const scrutinee = scrutineeResult.value

    const start_colon_3 = this.lexer.previousPosition
    const success_colon_3 = this.lexer.parseColon()
    if (!success_colon_3) {
      return invalid(start_colon_3, this.lexer.position, 'a colon or a line feed')
    }

    const branchesStart = this.lexer.position
    const branchesResult = this.parseBranchList()
    if (!branchesResult.ok) {
      if (branchesResult.error._tag === 'InvalidSyntax') return branchesResult
      return invalid(branchesStart, this.lexer.position, 'a valid Branch syntax')
    }
    const branches = branchesResult.value

    const alternativeStart = this.lexer.position
    let alternative: Syntax.ElseSyntax | null = null
    {
      const alternativeResult = this.parseElse()
      if (alternativeResult.ok) alternative = alternativeResult.value
      else if (alternativeResult.error._tag === 'InvalidSyntax') return alternativeResult
    }

    const end = this.lexer.position

    return ok({
      _syntax: 'MatchSyntax',
      start,
      end,
      scrutinee,
      branches,
      alternative
    })
  }

  parseBranchList(): ParseResult<Syntax.BranchSyntax[]> {
    const list: Syntax.BranchSyntax[] = []
    while (true) {
      const result = this.parseBranch()
      if (!result.ok) {
        if (result.error._tag === 'InvalidSyntax') return result
        if (list.length === 0) return result
        return ok(list)
      }
      list.push(result.value)
    }
  }

  parseBranch(): ParseResult<Syntax.BranchSyntax> {
    const start = this.lexer.previousPosition

    const casesStart = this.lexer.position
    const casesResult = this.parseCaseList()
    if (!casesResult.ok) {
      return casesResult
    }
    const cases = casesResult.value

    const start_colon_2 = this.lexer.previousPosition
    const success_colon_2 = this.lexer.parseColon()
    if (!success_colon_2) {
      return invalid(start_colon_2, this.lexer.position, 'a colon or a line feed')
    }

    const consequentStart = this.lexer.position
    const consequentResult = this.parseStatement()
    if (!consequentResult.ok) {
      if (consequentResult.error._tag === 'InvalidSyntax') return consequentResult
      return invalid(consequentStart, this.lexer.position, 'a valid Statement syntax')
    }
    const consequent = consequentResult.value

    const end = this.lexer.position

    return ok({
      _syntax: 'BranchSyntax',
      start,
      end,
      cases,
      consequent
    })
  }

  parseCaseList(): ParseResult<Syntax.CaseSyntax[]> {
    const list: Syntax.CaseSyntax[] = []
    while (true) {
      const result = this.parseCase()
      if (!result.ok) {
        if (result.error._tag === 'InvalidSyntax') return result
        if (list.length === 0) return result
        return ok(list)
      }
      list.push(result.value)
    }
  }

  parseCase(): ParseResult<Syntax.CaseSyntax> {
    const start = this.lexer.previousPosition

    const start_case_1 = this.lexer.previousPosition
    const success_case_1 = this.lexer.parseKeyword('case')
    if (!success_case_1) return different()

    const conditionStart = this.lexer.position
    const conditionResult = this.parseOperandList()
    if (!conditionResult.ok) {
      if (conditionResult.error._tag === 'InvalidSyntax') return conditionResult
      return invalid(conditionStart, this.lexer.position, 'a valid Operand syntax')
    }
    const condition = conditionResult.value

    const end = this.lexer.position

    return ok({
      _syntax: 'CaseSyntax',
      start,
      end,
      condition
    })
  }

  parseStatementList(): ParseResult<Syntax.StatementSyntax[]> {
    const list: Syntax.StatementSyntax[] = []
    while (true) {
      const result = this.parseStatement()
      if (!result.ok) {
        if (result.error._tag === 'InvalidSyntax') return result
        if (list.length === 0) return result
        return ok(list)
      }
      list.push(result.value)
    }
  }

  parseStatement(): ParseResult<Syntax.StatementSyntax> {
    const start = this.lexer.previousPosition

    const commandStart = this.lexer.position
    const commandResult = this.parseCommand()
    if (!commandResult.ok) {
      return commandResult
    }
    const command = commandResult.value

    const start_colon_2 = this.lexer.previousPosition
    const success_colon_2 = this.lexer.parseColon()

    const end = this.lexer.position

    return ok({
      _syntax: 'StatementSyntax',
      start,
      end,
      command
    })
  }

  parseWhile(): ParseResult<Syntax.WhileSyntax> {
    const start = this.lexer.previousPosition

    const start_while_1 = this.lexer.previousPosition
    const success_while_1 = this.lexer.parseKeyword('while')
    if (!success_while_1) return different()

    const conditionStart = this.lexer.position
    const conditionResult = this.parseCondition()
    if (!conditionResult.ok) {
      if (conditionResult.error._tag === 'InvalidSyntax') return conditionResult
      return invalid(conditionStart, this.lexer.position, 'a valid Condition syntax')
    }
    const condition = conditionResult.value

    const start_colon_3 = this.lexer.previousPosition
    const success_colon_3 = this.lexer.parseColon()
    if (!success_colon_3) {
      return invalid(start_colon_3, this.lexer.position, 'a colon or a line feed')
    }

    const nameStart = this.lexer.position
    let name: Syntax.LabelSyntax | null = null
    {
      const nameResult = this.parseLabel()
      if (nameResult.ok) name = nameResult.value
      else if (nameResult.error._tag === 'InvalidSyntax') return nameResult
    }

    const actionStart = this.lexer.position
    const actionResult = this.parseAction()
    if (!actionResult.ok) {
      if (actionResult.error._tag === 'InvalidSyntax') return actionResult
      return invalid(actionStart, this.lexer.position, 'a valid Action syntax')
    }
    const action = actionResult.value

    const end = this.lexer.position

    return ok({
      _syntax: 'WhileSyntax',
      start,
      end,
      condition,
      name,
      action
    })
  }

  parseChoose(): ParseResult<Syntax.ChooseSyntax> {
    const start = this.lexer.previousPosition

    const start_choose_1 = this.lexer.previousPosition
    const success_choose_1 = this.lexer.parseKeyword('choose')
    if (!success_choose_1) return different()

    const conditionStart = this.lexer.position
    const conditionResult = this.parseOperandList()
    if (!conditionResult.ok) {
      if (conditionResult.error._tag === 'InvalidSyntax') return conditionResult
      return invalid(conditionStart, this.lexer.position, 'a valid Operand syntax')
    }
    const condition = conditionResult.value

    const start_colon_3 = this.lexer.previousPosition
    const success_colon_3 = this.lexer.parseColon()
    if (!success_colon_3) {
      return invalid(start_colon_3, this.lexer.position, 'a colon or a line feed')
    }

    const casesStart = this.lexer.position
    let cases: Syntax.WhenSyntax[] | null = null
    {
      const casesResult = this.parseWhenList()
      if (casesResult.ok) cases = casesResult.value
      else if (casesResult.error._tag === 'InvalidSyntax') return casesResult
    }

    const alternativeStart = this.lexer.position
    let alternative: Syntax.ElseSyntax | null = null
    {
      const alternativeResult = this.parseElse()
      if (alternativeResult.ok) alternative = alternativeResult.value
      else if (alternativeResult.error._tag === 'InvalidSyntax') return alternativeResult
    }

    const end = this.lexer.position

    return ok({
      _syntax: 'ChooseSyntax',
      start,
      end,
      condition,
      cases,
      alternative
    })
  }

  parseTry(): ParseResult<Syntax.TrySyntax> {
    const start = this.lexer.previousPosition

    const start_try_1 = this.lexer.previousPosition
    const success_try_1 = this.lexer.parseKeyword('try')
    if (!success_try_1) return different()

    const conditionStart = this.lexer.position
    const conditionResult = this.parseCondition()
    if (!conditionResult.ok) {
      if (conditionResult.error._tag === 'InvalidSyntax') return conditionResult
      return invalid(conditionStart, this.lexer.position, 'a valid Condition syntax')
    }
    const condition = conditionResult.value

    const start_colon_3 = this.lexer.previousPosition
    const success_colon_3 = this.lexer.parseColon()
    if (!success_colon_3) {
      return invalid(start_colon_3, this.lexer.position, 'a colon or a line feed')
    }

    const casesStart = this.lexer.position
    let cases: Syntax.WhenSyntax[] | null = null
    {
      const casesResult = this.parseWhenList()
      if (casesResult.ok) cases = casesResult.value
      else if (casesResult.error._tag === 'InvalidSyntax') return casesResult
    }

    const dropperStart = this.lexer.position
    let dropper: Syntax.ElseSyntax | null = null
    {
      const dropperResult = this.parseElse()
      if (dropperResult.ok) dropper = dropperResult.value
      else if (dropperResult.error._tag === 'InvalidSyntax') return dropperResult
    }

    const end = this.lexer.position

    return ok({
      _syntax: 'TrySyntax',
      start,
      end,
      condition,
      cases,
      dropper
    })
  }

  parseCondition(): ParseResult<Syntax.ConditionSyntax> {
    {
      const result = this.parseOperation()
      if (result.ok) return ok(result.value as Syntax.ConditionSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    {
      const result = this.parseLet()
      if (result.ok) return ok(result.value as Syntax.ConditionSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    return different()
  }

  parseWhenList(): ParseResult<Syntax.WhenSyntax[]> {
    const list: Syntax.WhenSyntax[] = []
    while (true) {
      const result = this.parseWhen()
      if (!result.ok) {
        if (result.error._tag === 'InvalidSyntax') return result
        if (list.length === 0) return result
        return ok(list)
      }
      list.push(result.value)
    }
  }

  parseWhen(): ParseResult<Syntax.WhenSyntax> {
    const start = this.lexer.previousPosition

    const start_when_1 = this.lexer.previousPosition
    const success_when_1 = this.lexer.parseKeyword('when')
    if (!success_when_1) return different()

    const start_name = this.lexer.previousPosition
    const name = this.lexer.parseIdentifier(KEYWORDS)
    if (!name) {
      return invalid(start_name, this.lexer.position, 'an identifier')
    }

    const start_colon_3 = this.lexer.previousPosition
    const success_colon_3 = this.lexer.parseColon()
    if (!success_colon_3) {
      return invalid(start_colon_3, this.lexer.position, 'a colon or a line feed')
    }

    const variantStart = this.lexer.position
    const variantResult = this.parseName()
    if (!variantResult.ok) {
      if (variantResult.error._tag === 'InvalidSyntax') return variantResult
      return invalid(variantStart, this.lexer.position, 'a valid Name syntax')
    }
    const variant = variantResult.value

    const start_colon_5 = this.lexer.previousPosition
    const success_colon_5 = this.lexer.parseColon()

    const commandStart = this.lexer.position
    const commandResult = this.parseCommand()
    if (!commandResult.ok) {
      if (commandResult.error._tag === 'InvalidSyntax') return commandResult
      return invalid(commandStart, this.lexer.position, 'a valid Command syntax')
    }
    const command = commandResult.value

    const start_colon_7 = this.lexer.previousPosition
    const success_colon_7 = this.lexer.parseColon()

    const end = this.lexer.position

    return ok({
      _syntax: 'WhenSyntax',
      start,
      end,
      name,
      variant,
      command
    })
  }

  parseCommand(): ParseResult<Syntax.CommandSyntax> {
    {
      const result = this.parseOperation()
      if (result.ok) return ok(result.value as Syntax.CommandSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    {
      const result = this.parseLet()
      if (result.ok) return ok(result.value as Syntax.CommandSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    {
      const result = this.parseVar()
      if (result.ok) return ok(result.value as Syntax.CommandSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    {
      const result = this.parseMutable()
      if (result.ok) return ok(result.value as Syntax.CommandSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    {
      const result = this.parseSet()
      if (result.ok) return ok(result.value as Syntax.CommandSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    {
      const result = this.parseContinue()
      if (result.ok) return ok(result.value as Syntax.CommandSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    {
      const result = this.parseBreak()
      if (result.ok) return ok(result.value as Syntax.CommandSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    {
      const result = this.parseReturn()
      if (result.ok) return ok(result.value as Syntax.CommandSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    {
      const result = this.parseThrow()
      if (result.ok) return ok(result.value as Syntax.CommandSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    return different()
  }

  parseLet(): ParseResult<Syntax.LetSyntax> {
    const start = this.lexer.previousPosition

    const start_let_1 = this.lexer.previousPosition
    const success_let_1 = this.lexer.parseKeyword('let')
    if (!success_let_1) return different()

    const bindingStart = this.lexer.position
    const bindingResult = this.parseBinding()
    if (!bindingResult.ok) {
      if (bindingResult.error._tag === 'InvalidSyntax') return bindingResult
      return invalid(bindingStart, this.lexer.position, 'a valid Binding syntax')
    }
    const binding = bindingResult.value

    const end = this.lexer.position

    return ok({
      _syntax: 'LetSyntax',
      start,
      end,
      binding
    })
  }

  parseVar(): ParseResult<Syntax.VarSyntax> {
    const start = this.lexer.previousPosition

    const start_var_1 = this.lexer.previousPosition
    const success_var_1 = this.lexer.parseKeyword('var')
    if (!success_var_1) return different()

    const bindingStart = this.lexer.position
    const bindingResult = this.parseBinding()
    if (!bindingResult.ok) {
      if (bindingResult.error._tag === 'InvalidSyntax') return bindingResult
      return invalid(bindingStart, this.lexer.position, 'a valid Binding syntax')
    }
    const binding = bindingResult.value

    const end = this.lexer.position

    return ok({
      _syntax: 'VarSyntax',
      start,
      end,
      binding
    })
  }

  parseMutable(): ParseResult<Syntax.MutableSyntax> {
    const start = this.lexer.previousPosition

    const start_mutable_1 = this.lexer.previousPosition
    const success_mutable_1 = this.lexer.parseKeyword('mutable')
    if (!success_mutable_1) return different()

    const bindingStart = this.lexer.position
    const bindingResult = this.parseBinding()
    if (!bindingResult.ok) {
      if (bindingResult.error._tag === 'InvalidSyntax') return bindingResult
      return invalid(bindingStart, this.lexer.position, 'a valid Binding syntax')
    }
    const binding = bindingResult.value

    const end = this.lexer.position

    return ok({
      _syntax: 'MutableSyntax',
      start,
      end,
      binding
    })
  }

  parseBinding(): ParseResult<Syntax.BindingSyntax> {
    const start = this.lexer.previousPosition

    const start_name = this.lexer.previousPosition
    const name = this.lexer.parseIdentifier(KEYWORDS)
    if (!name) return different()

    const annotationStart = this.lexer.position
    let annotation: Syntax.BindingAnnotationSyntax | null = null
    {
      const annotationResult = this.parseBindingAnnotation()
      if (annotationResult.ok) annotation = annotationResult.value
      else if (annotationResult.error._tag === 'InvalidSyntax') return annotationResult
    }

    const operationStart = this.lexer.position
    const operationResult = this.parseOperandList()
    if (!operationResult.ok) {
      if (operationResult.error._tag === 'InvalidSyntax') return operationResult
      return invalid(operationStart, this.lexer.position, 'a valid Operand syntax')
    }
    const operation = operationResult.value

    const end = this.lexer.position

    return ok({
      _syntax: 'BindingSyntax',
      start,
      end,
      name,
      annotation,
      operation
    })
  }

  parseBindingAnnotation(): ParseResult<Syntax.BindingAnnotationSyntax> {
    const start = this.lexer.previousPosition

    const start_colon_1 = this.lexer.previousPosition
    const success_colon_1 = this.lexer.parseColon()
    if (!success_colon_1) return different()

    const specStart = this.lexer.position
    const specResult = this.parseBindingSpec()
    if (!specResult.ok) {
      if (specResult.error._tag === 'InvalidSyntax') return specResult
      return invalid(specStart, this.lexer.position, 'a valid BindingSpec syntax')
    }
    const spec = specResult.value

    const end = this.lexer.position

    return ok({
      _syntax: 'BindingAnnotationSyntax',
      start,
      end,
      spec
    })
  }

  parseBindingSpecList(): ParseResult<Syntax.BindingSpecSyntax[]> {
    const list: Syntax.BindingSpecSyntax[] = []
    while (true) {
      const result = this.parseBindingSpec()
      if (!result.ok) {
        if (result.error._tag === 'InvalidSyntax') return result
        if (list.length === 0) return result
        return ok(list)
      }
      list.push(result.value)
    }
  }

  parseBindingSpec(): ParseResult<Syntax.BindingSpecSyntax> {
    {
      const result = this.parseStructure()
      if (result.ok) return ok(result.value as Syntax.BindingSpecSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    {
      const result = this.parseType()
      if (result.ok) return ok(result.value as Syntax.BindingSpecSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    {
      const result = this.parseArray()
      if (result.ok) return ok(result.value as Syntax.BindingSpecSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    return different()
  }

  parseArray(): ParseResult<Syntax.ArraySyntax> {
    const start = this.lexer.previousPosition

    const start_left_bracket_1 = this.lexer.previousPosition
    const success_left_bracket_1 = this.lexer.parsePunctuation('[')
    if (!success_left_bracket_1) return different()

    const membersStart = this.lexer.position
    let members: Syntax.TypeSyntax[] | null = null
    {
      const membersResult = this.parseTypeList()
      if (membersResult.ok) members = membersResult.value
      else if (membersResult.error._tag === 'InvalidSyntax') return membersResult
    }

    const start_right_bracket_3 = this.lexer.previousPosition
    const success_right_bracket_3 = this.lexer.parsePunctuation(']')
    if (!success_right_bracket_3) {
      return invalid(start_right_bracket_3, this.lexer.position, ']')
    }

    const end = this.lexer.position

    return ok({
      _syntax: 'ArraySyntax',
      start,
      end,
      members
    })
  }

  parseStructure(): ParseResult<Syntax.StructureSyntax> {
    const start = this.lexer.previousPosition

    const start_left_paren_1 = this.lexer.previousPosition
    const success_left_paren_1 = this.lexer.parsePunctuation('(')
    if (!success_left_paren_1) return different()

    const partsStart = this.lexer.position
    let parts: Syntax.PartSyntax[] | null = null
    {
      const partsResult = this.parsePartList()
      if (partsResult.ok) parts = partsResult.value
      else if (partsResult.error._tag === 'InvalidSyntax') return partsResult
    }

    const start_right_paren_3 = this.lexer.previousPosition
    const success_right_paren_3 = this.lexer.parsePunctuation(')')
    if (!success_right_paren_3) {
      return invalid(start_right_paren_3, this.lexer.position, ')')
    }

    const end = this.lexer.position

    return ok({
      _syntax: 'StructureSyntax',
      start,
      end,
      parts
    })
  }

  parsePartList(): ParseResult<Syntax.PartSyntax[]> {
    const list: Syntax.PartSyntax[] = []
    while (true) {
      const result = this.parsePart()
      if (!result.ok) {
        if (result.error._tag === 'InvalidSyntax') return result
        if (list.length === 0) return result
        return ok(list)
      }
      list.push(result.value)
    }
  }

  parsePart(): ParseResult<Syntax.PartSyntax> {
    {
      const result = this.parseField()
      if (result.ok) return ok(result.value as Syntax.PartSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    {
      const result = this.parseProperty()
      if (result.ok) return ok(result.value as Syntax.PartSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    return different()
  }

  parseField(): ParseResult<Syntax.FieldSyntax> {
    const start = this.lexer.previousPosition

    const start_private_1 = this.lexer.previousPosition
    const success_private_1 = this.lexer.parseKeyword('private')
    if (!success_private_1) return different()

    const propertyStart = this.lexer.position
    const propertyResult = this.parseProperty()
    if (!propertyResult.ok) {
      if (propertyResult.error._tag === 'InvalidSyntax') return propertyResult
      return invalid(propertyStart, this.lexer.position, 'a valid Property syntax')
    }
    const property = propertyResult.value

    const end = this.lexer.position

    return ok({
      _syntax: 'FieldSyntax',
      start,
      end,
      property
    })
  }

  parsePropertyList(): ParseResult<Syntax.PropertySyntax[]> {
    const list: Syntax.PropertySyntax[] = []
    while (true) {
      const result = this.parseProperty()
      if (!result.ok) {
        if (result.error._tag === 'InvalidSyntax') return result
        if (list.length === 0) return result
        return ok(list)
      }
      list.push(result.value)
    }
  }

  parseProperty(): ParseResult<Syntax.PropertySyntax> {
    const start = this.lexer.previousPosition

    const start_name = this.lexer.previousPosition
    const name = this.lexer.parseIdentifier(KEYWORDS)
    if (!name) return different()

    const annotationStart = this.lexer.position
    const annotationResult = this.parseTypeAnnotation()
    if (!annotationResult.ok) {
      if (annotationResult.error._tag === 'InvalidSyntax') return annotationResult
      return invalid(annotationStart, this.lexer.position, 'a valid TypeAnnotation syntax')
    }
    const annotation = annotationResult.value

    const initializerStart = this.lexer.position
    let initializer: Syntax.InitializerSyntax | null = null
    {
      const initializerResult = this.parseInitializer()
      if (initializerResult.ok) initializer = initializerResult.value
      else if (initializerResult.error._tag === 'InvalidSyntax') return initializerResult
    }

    const start_comma_4 = this.lexer.previousPosition
    const success_comma_4 = this.lexer.parsePunctuation(',')

    const start_colon_5 = this.lexer.previousPosition
    const success_colon_5 = this.lexer.parseColon()

    const attributesStart = this.lexer.position
    let attributes: Syntax.AttributeSyntax[] | null = null
    {
      const attributesResult = this.parseAttributeList()
      if (attributesResult.ok) attributes = attributesResult.value
      else if (attributesResult.error._tag === 'InvalidSyntax') return attributesResult
    }

    const start_colon_7 = this.lexer.previousPosition
    const success_colon_7 = this.lexer.parseColon()

    const end = this.lexer.position

    return ok({
      _syntax: 'PropertySyntax',
      start,
      end,
      name,
      annotation,
      initializer,
      attributes
    })
  }

  parseTypeAnnotation(): ParseResult<Syntax.TypeAnnotationSyntax> {
    const start = this.lexer.previousPosition

    const start_colon_1 = this.lexer.previousPosition
    const success_colon_1 = this.lexer.parseColon()
    if (!success_colon_1) return different()

    const typeStart = this.lexer.position
    const typeResult = this.parseType()
    if (!typeResult.ok) {
      if (typeResult.error._tag === 'InvalidSyntax') return typeResult
      return invalid(typeStart, this.lexer.position, 'a valid Type syntax')
    }
    const type = typeResult.value

    const end = this.lexer.position

    return ok({
      _syntax: 'TypeAnnotationSyntax',
      start,
      end,
      type
    })
  }

  parseContinue(): ParseResult<Syntax.ContinueSyntax> {
    const start = this.lexer.previousPosition

    const start_continue_1 = this.lexer.previousPosition
    const success_continue_1 = this.lexer.parseKeyword('continue')
    if (!success_continue_1) return different()

    const nameStart = this.lexer.position
    let name: Syntax.LoopSyntax | null = null
    {
      const nameResult = this.parseLoop()
      if (nameResult.ok) name = nameResult.value
      else if (nameResult.error._tag === 'InvalidSyntax') return nameResult
    }

    const start_colon_3 = this.lexer.previousPosition
    const success_colon_3 = this.lexer.parseColon()

    const end = this.lexer.position

    return ok({
      _syntax: 'ContinueSyntax',
      start,
      end,
      name
    })
  }

  parseBreak(): ParseResult<Syntax.BreakSyntax> {
    const start = this.lexer.previousPosition

    const start_break_1 = this.lexer.previousPosition
    const success_break_1 = this.lexer.parseKeyword('break')
    if (!success_break_1) return different()

    const nameStart = this.lexer.position
    let name: Syntax.LoopSyntax | null = null
    {
      const nameResult = this.parseLoop()
      if (nameResult.ok) name = nameResult.value
      else if (nameResult.error._tag === 'InvalidSyntax') return nameResult
    }

    const resultStart = this.lexer.position
    let result: Syntax.OperandSyntax[] | null = null
    {
      const resultResult = this.parseOperandList()
      if (resultResult.ok) result = resultResult.value
      else if (resultResult.error._tag === 'InvalidSyntax') return resultResult
    }

    const start_colon_4 = this.lexer.previousPosition
    const success_colon_4 = this.lexer.parseColon()

    const end = this.lexer.position

    return ok({
      _syntax: 'BreakSyntax',
      start,
      end,
      name,
      result
    })
  }

  parseLoop(): ParseResult<Syntax.LoopSyntax> {
    const start = this.lexer.previousPosition

    const start_loop_1 = this.lexer.previousPosition
    const success_loop_1 = this.lexer.parseKeyword('loop')
    if (!success_loop_1) return different()

    const start_name = this.lexer.previousPosition
    const name = this.lexer.parseIdentifier(KEYWORDS)
    if (!name) {
      return invalid(start_name, this.lexer.position, 'an identifier')
    }

    const end = this.lexer.position

    return ok({
      _syntax: 'LoopSyntax',
      start,
      end,
      name
    })
  }

  parseReturn(): ParseResult<Syntax.ReturnSyntax> {
    const start = this.lexer.previousPosition

    const start_return_1 = this.lexer.previousPosition
    const success_return_1 = this.lexer.parseKeyword('return')
    if (!success_return_1) return different()

    const resultStart = this.lexer.position
    let result: Syntax.OperandSyntax[] | null = null
    {
      const resultResult = this.parseOperandList()
      if (resultResult.ok) result = resultResult.value
      else if (resultResult.error._tag === 'InvalidSyntax') return resultResult
    }

    const end = this.lexer.position

    return ok({
      _syntax: 'ReturnSyntax',
      start,
      end,
      result
    })
  }

  parseThrow(): ParseResult<Syntax.ThrowSyntax> {
    const start = this.lexer.previousPosition

    const start_throw_1 = this.lexer.previousPosition
    const success_throw_1 = this.lexer.parseKeyword('throw')
    if (!success_throw_1) return different()

    const resultStart = this.lexer.position
    let result: Syntax.OperandSyntax[] | null = null
    {
      const resultResult = this.parseOperandList()
      if (resultResult.ok) result = resultResult.value
      else if (resultResult.error._tag === 'InvalidSyntax') return resultResult
    }

    const end = this.lexer.position

    return ok({
      _syntax: 'ThrowSyntax',
      start,
      end,
      result
    })
  }

  parseLambda(): ParseResult<Syntax.LambdaSyntax> {
    const start = this.lexer.previousPosition

    const start_lambda_1 = this.lexer.previousPosition
    const success_lambda_1 = this.lexer.parseKeyword('lambda')
    if (!success_lambda_1) return different()

    const inputStart = this.lexer.position
    const inputResult = this.parseOperandList()
    if (!inputResult.ok) {
      if (inputResult.error._tag === 'InvalidSyntax') return inputResult
      return invalid(inputStart, this.lexer.position, 'a valid Operand syntax')
    }
    const input = inputResult.value

    const start_colon_3 = this.lexer.previousPosition
    const success_colon_3 = this.lexer.parseColon()
    if (!success_colon_3) {
      return invalid(start_colon_3, this.lexer.position, 'a colon or a line feed')
    }

    const blockStart = this.lexer.position
    const blockResult = this.parseAction()
    if (!blockResult.ok) {
      if (blockResult.error._tag === 'InvalidSyntax') return blockResult
      return invalid(blockStart, this.lexer.position, 'a valid Action syntax')
    }
    const block = blockResult.value

    const end = this.lexer.position

    return ok({
      _syntax: 'LambdaSyntax',
      start,
      end,
      input,
      block
    })
  }

  parseFor(): ParseResult<Syntax.ForSyntax> {
    const start = this.lexer.previousPosition

    const start_for_1 = this.lexer.previousPosition
    const success_for_1 = this.lexer.parseKeyword('for')
    if (!success_for_1) return different()

    const start_variable = this.lexer.previousPosition
    const variable = this.lexer.parseIdentifier(KEYWORDS)
    if (!variable) {
      return invalid(start_variable, this.lexer.position, 'an identifier')
    }

    const annotationStart = this.lexer.position
    let annotation: Syntax.TypeAnnotationSyntax | null = null
    {
      const annotationResult = this.parseTypeAnnotation()
      if (annotationResult.ok) annotation = annotationResult.value
      else if (annotationResult.error._tag === 'InvalidSyntax') return annotationResult
    }

    const start_in_4 = this.lexer.previousPosition
    const success_in_4 = this.lexer.parseKeyword('in')
    if (!success_in_4) {
      return invalid(start_in_4, this.lexer.position, 'in')
    }

    const operationStart = this.lexer.position
    const operationResult = this.parseOperandList()
    if (!operationResult.ok) {
      if (operationResult.error._tag === 'InvalidSyntax') return operationResult
      return invalid(operationStart, this.lexer.position, 'a valid Operand syntax')
    }
    const operation = operationResult.value

    const start_colon_6 = this.lexer.previousPosition
    const success_colon_6 = this.lexer.parseColon()
    if (!success_colon_6) {
      return invalid(start_colon_6, this.lexer.position, 'a colon or a line feed')
    }

    const nameStart = this.lexer.position
    let name: Syntax.LabelSyntax | null = null
    {
      const nameResult = this.parseLabel()
      if (nameResult.ok) name = nameResult.value
      else if (nameResult.error._tag === 'InvalidSyntax') return nameResult
    }

    const actionStart = this.lexer.position
    const actionResult = this.parseAction()
    if (!actionResult.ok) {
      if (actionResult.error._tag === 'InvalidSyntax') return actionResult
      return invalid(actionStart, this.lexer.position, 'a valid Action syntax')
    }
    const action = actionResult.value

    const end = this.lexer.position

    return ok({
      _syntax: 'ForSyntax',
      start,
      end,
      variable,
      annotation,
      operation,
      name,
      action
    })
  }

  parseLabel(): ParseResult<Syntax.LabelSyntax> {
    const start = this.lexer.previousPosition

    const start_label_1 = this.lexer.previousPosition
    const success_label_1 = this.lexer.parseKeyword('label')
    if (!success_label_1) return different()

    const start_name = this.lexer.previousPosition
    const name = this.lexer.parseIdentifier(KEYWORDS)
    if (!name) {
      return invalid(start_name, this.lexer.position, 'an identifier')
    }

    const start_colon_3 = this.lexer.previousPosition
    const success_colon_3 = this.lexer.parseColon()

    const end = this.lexer.position

    return ok({
      _syntax: 'LabelSyntax',
      start,
      end,
      name
    })
  }

  parseRepeat(): ParseResult<Syntax.RepeatSyntax> {
    const start = this.lexer.previousPosition

    const start_repeat_1 = this.lexer.previousPosition
    const success_repeat_1 = this.lexer.parseKeyword('repeat')
    if (!success_repeat_1) return different()

    const nameStart = this.lexer.position
    let name: Syntax.LabelSyntax | null = null
    {
      const nameResult = this.parseLabel()
      if (nameResult.ok) name = nameResult.value
      else if (nameResult.error._tag === 'InvalidSyntax') return nameResult
    }

    const actionStart = this.lexer.position
    const actionResult = this.parseAction()
    if (!actionResult.ok) {
      if (actionResult.error._tag === 'InvalidSyntax') return actionResult
      return invalid(actionStart, this.lexer.position, 'a valid Action syntax')
    }
    const action = actionResult.value

    const end = this.lexer.position

    return ok({
      _syntax: 'RepeatSyntax',
      start,
      end,
      name,
      action
    })
  }

  parseActionList(): ParseResult<Syntax.ActionSyntax[]> {
    const list: Syntax.ActionSyntax[] = []
    while (true) {
      const result = this.parseAction()
      if (!result.ok) {
        if (result.error._tag === 'InvalidSyntax') return result
        if (list.length === 0) return result
        return ok(list)
      }
      list.push(result.value)
    }
  }

  parseAction(): ParseResult<Syntax.ActionSyntax> {
    {
      const result = this.parseOperation()
      if (result.ok) return ok(result.value as Syntax.ActionSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    {
      const result = this.parseSet()
      if (result.ok) return ok(result.value as Syntax.ActionSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    return different()
  }

  parseOperation(): ParseResult<Syntax.OperationSyntax> {
    const start = this.lexer.previousPosition

    const operandsStart = this.lexer.position
    const operandsResult = this.parseOperandList()
    if (!operandsResult.ok) {
      return operandsResult
    }
    const operands = operandsResult.value

    const end = this.lexer.position

    return ok({
      _syntax: 'OperationSyntax',
      start,
      end,
      operands
    })
  }

  parseSet(): ParseResult<Syntax.SetSyntax> {
    const start = this.lexer.previousPosition

    const start_set_1 = this.lexer.previousPosition
    const success_set_1 = this.lexer.parseKeyword('set')
    if (!success_set_1) return different()

    const targetStart = this.lexer.position
    const targetResult = this.parseOperandList()
    if (!targetResult.ok) {
      if (targetResult.error._tag === 'InvalidSyntax') return targetResult
      return invalid(targetStart, this.lexer.position, 'a valid Operand syntax')
    }
    const target = targetResult.value

    const start_colon_3 = this.lexer.previousPosition
    const success_colon_3 = this.lexer.parseColon()
    if (!success_colon_3) {
      return invalid(start_colon_3, this.lexer.position, 'a colon or a line feed')
    }

    const sourceStart = this.lexer.position
    const sourceResult = this.parseOperandList()
    if (!sourceResult.ok) {
      if (sourceResult.error._tag === 'InvalidSyntax') return sourceResult
      return invalid(sourceStart, this.lexer.position, 'a valid Operand syntax')
    }
    const source = sourceResult.value

    const end = this.lexer.position

    return ok({
      _syntax: 'SetSyntax',
      start,
      end,
      target,
      source
    })
  }

  parseSizeOf(): ParseResult<Syntax.SizeOfSyntax> {
    const start = this.lexer.previousPosition

    const start_sizeof_1 = this.lexer.previousPosition
    const success_sizeof_1 = this.lexer.parseKeyword('sizeof')
    if (!success_sizeof_1) return different()

    const typeStart = this.lexer.position
    const typeResult = this.parseType()
    if (!typeResult.ok) {
      if (typeResult.error._tag === 'InvalidSyntax') return typeResult
      return invalid(typeStart, this.lexer.position, 'a valid Type syntax')
    }
    const type = typeResult.value

    const end = this.lexer.position

    return ok({
      _syntax: 'SizeOfSyntax',
      start,
      end,
      type
    })
  }

  parseIs(): ParseResult<Syntax.IsSyntax> {
    const start = this.lexer.previousPosition

    const start_is_1 = this.lexer.previousPosition
    const success_is_1 = this.lexer.parseKeyword('is')
    if (!success_is_1) return different()

    const nameStart = this.lexer.position
    const nameResult = this.parseName()
    if (!nameResult.ok) {
      if (nameResult.error._tag === 'InvalidSyntax') return nameResult
      return invalid(nameStart, this.lexer.position, 'a valid Name syntax')
    }
    const name = nameResult.value

    const end = this.lexer.position

    return ok({
      _syntax: 'IsSyntax',
      start,
      end,
      name
    })
  }

  parseTypeList(): ParseResult<Syntax.TypeSyntax[]> {
    const list: Syntax.TypeSyntax[] = []
    while (true) {
      const result = this.parseType()
      if (!result.ok) {
        if (result.error._tag === 'InvalidSyntax') return result
        if (list.length === 0) return result
        return ok(list)
      }
      list.push(result.value)
    }
  }

  parseType(): ParseResult<Syntax.TypeSyntax> {
    const start = this.lexer.previousPosition

    const nameStart = this.lexer.position
    const nameResult = this.parseName()
    if (!nameResult.ok) {
      return nameResult
    }
    const name = nameResult.value

    const genericsStart = this.lexer.position
    let generics: Syntax.GenericArgumentsSyntax | null = null
    {
      const genericsResult = this.parseGenericArguments()
      if (genericsResult.ok) generics = genericsResult.value
      else if (genericsResult.error._tag === 'InvalidSyntax') return genericsResult
    }

    const optionalStart = this.lexer.position
    let optional: Syntax.OptionalSyntax | null = null
    {
      const optionalResult = this.parseOptional()
      if (optionalResult.ok) optional = optionalResult.value
      else if (optionalResult.error._tag === 'InvalidSyntax') return optionalResult
    }

    const lifetimeStart = this.lexer.position
    let lifetime: Syntax.LifetimeSyntax | null = null
    {
      const lifetimeResult = this.parseLifetime()
      if (lifetimeResult.ok) lifetime = lifetimeResult.value
      else if (lifetimeResult.error._tag === 'InvalidSyntax') return lifetimeResult
    }

    const end = this.lexer.position

    return ok({
      _syntax: 'TypeSyntax',
      start,
      end,
      name,
      generics,
      optional,
      lifetime
    })
  }

  parseName(): ParseResult<Syntax.NameSyntax> {
    const start = this.lexer.previousPosition

    const start_name = this.lexer.previousPosition
    const name = this.lexer.parseIdentifier(KEYWORDS)
    if (!name) return different()

    const extensionsStart = this.lexer.position
    let extensions: Syntax.ExtensionSyntax[] | null = null
    {
      const extensionsResult = this.parseExtensionList()
      if (extensionsResult.ok) extensions = extensionsResult.value
      else if (extensionsResult.error._tag === 'InvalidSyntax') return extensionsResult
    }

    const end = this.lexer.position

    return ok({
      _syntax: 'NameSyntax',
      start,
      end,
      name,
      extensions
    })
  }

  parseExtensionList(): ParseResult<Syntax.ExtensionSyntax[]> {
    const list: Syntax.ExtensionSyntax[] = []
    while (true) {
      const result = this.parseExtension()
      if (!result.ok) {
        if (result.error._tag === 'InvalidSyntax') return result
        if (list.length === 0) return result
        return ok(list)
      }
      list.push(result.value)
    }
  }

  parseExtension(): ParseResult<Syntax.ExtensionSyntax> {
    const start = this.lexer.previousPosition

    const start_dot_1 = this.lexer.previousPosition
    const success_dot_1 = this.lexer.parsePunctuation('.')
    if (!success_dot_1) return different()

    const start_name = this.lexer.previousPosition
    const name = this.lexer.parseIdentifier(KEYWORDS)
    if (!name) {
      return invalid(start_name, this.lexer.position, 'an identifier')
    }

    const end = this.lexer.position

    return ok({
      _syntax: 'ExtensionSyntax',
      start,
      end,
      name
    })
  }

  parseLifetime(): ParseResult<Syntax.LifetimeSyntax> {
    {
      const result = this.parseCall()
      if (result.ok) return ok(result.value as Syntax.LifetimeSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    {
      const result = this.parseLocal()
      if (result.ok) return ok(result.value as Syntax.LifetimeSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    {
      const result = this.parseReference()
      if (result.ok) return ok(result.value as Syntax.LifetimeSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    {
      const result = this.parseThrown()
      if (result.ok) return ok(result.value as Syntax.LifetimeSyntax)
      if (result.error._tag === 'InvalidSyntax') return result
    }
    return different()
  }

  parseCall(): ParseResult<Syntax.CallSyntax> {
    const start = this.lexer.previousPosition

    const start_hash_1 = this.lexer.previousPosition
    const success_hash_1 = this.lexer.parsePunctuation('#')
    if (!success_hash_1) return different()

    const end = this.lexer.position

    return ok({
      _syntax: 'CallSyntax',
      start,
      end
    })
  }

  parseLocal(): ParseResult<Syntax.LocalSyntax> {
    const start = this.lexer.previousPosition

    const start_dollar_1 = this.lexer.previousPosition
    const success_dollar_1 = this.lexer.parsePunctuation('$')
    if (!success_dollar_1) return different()

    const end = this.lexer.position

    return ok({
      _syntax: 'LocalSyntax',
      start,
      end
    })
  }

  parseReference(): ParseResult<Syntax.ReferenceSyntax> {
    const start = this.lexer.previousPosition

    const start_caret_1 = this.lexer.previousPosition
    const success_caret_1 = this.lexer.parsePunctuation('^')
    if (!success_caret_1) return different()

    const start_location = this.lexer.previousPosition
    const location = this.lexer.parseIdentifier(KEYWORDS)
    if (!location) {
      return invalid(start_location, this.lexer.position, 'an identifier')
    }

    const end = this.lexer.position

    return ok({
      _syntax: 'ReferenceSyntax',
      start,
      end,
      location
    })
  }

  parseThrown(): ParseResult<Syntax.ThrownSyntax> {
    const start = this.lexer.previousPosition

    const start_exclamation_1 = this.lexer.previousPosition
    const success_exclamation_1 = this.lexer.parsePunctuation('!')
    if (!success_exclamation_1) return different()

    const end = this.lexer.position

    return ok({
      _syntax: 'ThrownSyntax',
      start,
      end
    })
  }

  isAtEnd(): boolean {
    return this.lexer.isAtEnd()
  }
}
