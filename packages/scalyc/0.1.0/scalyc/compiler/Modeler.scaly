; Modeler.scaly - Syntax to semantic model transformation
; Ported from retired proto-Scaly Modeler.scaly

package scaly 0.1.0

use scaly.containers.String
use scaly.containers.Vector
use scaly.containers.HashMap
use scaly.containers.HashMapBuilder

; Model types
use scaly.compiler.Model.Span
use scaly.compiler.Model.Constant
use scaly.compiler.Model.BooleanConstant
use scaly.compiler.Model.IntegerConstant
use scaly.compiler.Model.HexConstant
use scaly.compiler.Model.FloatingPointConstant
use scaly.compiler.Model.StringConstant
use scaly.compiler.Model.CharacterConstant
use scaly.compiler.Model.FragmentConstant
use scaly.compiler.Model.Unspecified
use scaly.compiler.Model.Call
use scaly.compiler.Model.Local
use scaly.compiler.Model.Reference
use scaly.compiler.Model.Thrown
use scaly.compiler.Model.Lifetime
use scaly.compiler.Model.Type
use scaly.compiler.Model.Operand
use scaly.compiler.Model.Component
use scaly.compiler.Model.Tuple
use scaly.compiler.Model.Matrix
use scaly.compiler.Model.Block
use scaly.compiler.Model.Expression
use scaly.compiler.Model.Action
use scaly.compiler.Model.Binding
use scaly.compiler.Model.Break
use scaly.compiler.Model.Continue
use scaly.compiler.Model.Return
use scaly.compiler.Model.Throw
use scaly.compiler.Model.Statement
use scaly.compiler.Model.Item
use scaly.compiler.Model.If
use scaly.compiler.Model.Case
use scaly.compiler.Model.Branch
use scaly.compiler.Model.Match
use scaly.compiler.Model.When
use scaly.compiler.Model.Choose
use scaly.compiler.Model.For
use scaly.compiler.Model.While
use scaly.compiler.Model.Try
use scaly.compiler.Model.SizeOf
use scaly.compiler.Model.Is
use scaly.compiler.Model.Property
use scaly.compiler.Model.Attribute
use scaly.compiler.Model.Model
use scaly.compiler.Model.GenericParameter
use scaly.compiler.Model.Use
use scaly.compiler.Model.Extern
use scaly.compiler.Model.Instruction
use scaly.compiler.Model.Intrinsic
use scaly.compiler.Model.Implementation
use scaly.compiler.Model.Function
use scaly.compiler.Model.Initializer
use scaly.compiler.Model.DeInitializer
use scaly.compiler.Model.Operator
use scaly.compiler.Model.Variant
use scaly.compiler.Model.Structure
use scaly.compiler.Model.Union
use scaly.compiler.Model.Namespace
use scaly.compiler.Model.Global
use scaly.compiler.Model.Definition
use scaly.compiler.Model.Concept
use scaly.compiler.Model.Member
use scaly.compiler.Model.Module
use scaly.compiler.Model.Program
use scaly.compiler.Model.Nameable

; Syntax types
use scaly.compiler.Syntax.Literal
use scaly.compiler.Syntax.StringLiteral
use scaly.compiler.Syntax.CharacterLiteral
use scaly.compiler.Syntax.FragmentLiteral
use scaly.compiler.Syntax.IntegerLiteral
use scaly.compiler.Syntax.BooleanLiteral
use scaly.compiler.Syntax.FloatingPointLiteral
use scaly.compiler.Syntax.HexLiteral
use scaly.compiler.Syntax.LiteralSyntax
use scaly.compiler.Syntax.LifetimeSyntax
use scaly.compiler.Syntax.CallSyntax
use scaly.compiler.Syntax.LocalSyntax
use scaly.compiler.Syntax.ReferenceSyntax
use scaly.compiler.Syntax.ThrownSyntax
use scaly.compiler.Syntax.NameSyntax
use scaly.compiler.Syntax.TypeSyntax
use scaly.compiler.Syntax.GenericArgumentSyntax
use scaly.compiler.Syntax.GenericArgumentsSyntax
use scaly.compiler.Syntax.ExpressionSyntax
use scaly.compiler.Syntax.OperandSyntax
use scaly.compiler.Syntax.StatementSyntax
use scaly.compiler.Syntax.CommandSyntax
use scaly.compiler.Syntax.OperationSyntax
use scaly.compiler.Syntax.LetSyntax
use scaly.compiler.Syntax.VarSyntax
use scaly.compiler.Syntax.MutableSyntax
use scaly.compiler.Syntax.SetSyntax
use scaly.compiler.Syntax.BreakSyntax
use scaly.compiler.Syntax.ContinueSyntax
use scaly.compiler.Syntax.ReturnSyntax
use scaly.compiler.Syntax.ThrowSyntax
use scaly.compiler.Syntax.BindingSyntax
use scaly.compiler.Syntax.BindingAnnotationSyntax
use scaly.compiler.Syntax.BindingSpecSyntax
use scaly.compiler.Syntax.ObjectSyntax
use scaly.compiler.Syntax.ComponentSyntax
use scaly.compiler.Syntax.ValueSyntax
use scaly.compiler.Syntax.VectorSyntax
use scaly.compiler.Syntax.ElementSyntax
use scaly.compiler.Syntax.BlockSyntax
use scaly.compiler.Syntax.IfSyntax
use scaly.compiler.Syntax.ThenSyntax
use scaly.compiler.Syntax.ElseSyntax
use scaly.compiler.Syntax.MatchSyntax
use scaly.compiler.Syntax.BranchSyntax
use scaly.compiler.Syntax.CaseSyntax
use scaly.compiler.Syntax.ChooseSyntax
use scaly.compiler.Syntax.WhenSyntax
use scaly.compiler.Syntax.ForSyntax
use scaly.compiler.Syntax.WhileSyntax
use scaly.compiler.Syntax.TrySyntax
use scaly.compiler.Syntax.ConditionSyntax
use scaly.compiler.Syntax.ActionSyntax
use scaly.compiler.Syntax.SizeOfSyntax
use scaly.compiler.Syntax.IsSyntax
use scaly.compiler.Syntax.ItemSyntax
use scaly.compiler.Syntax.PropertySyntax
use scaly.compiler.Syntax.PartSyntax
use scaly.compiler.Syntax.FieldSyntax
use scaly.compiler.Syntax.AttributeSyntax
use scaly.compiler.Syntax.ModelSyntax
use scaly.compiler.Syntax.UseSyntax
use scaly.compiler.Syntax.GenericParameterSyntax
use scaly.compiler.Syntax.GenericParametersSyntax
use scaly.compiler.Syntax.ParametersSyntax
use scaly.compiler.Syntax.ParameterSetSyntax
use scaly.compiler.Syntax.RoutineSyntax
use scaly.compiler.Syntax.NamedSyntax
use scaly.compiler.Syntax.TargetSyntax
use scaly.compiler.Syntax.ImplementationSyntax
use scaly.compiler.Syntax.ExternSyntax
use scaly.compiler.Syntax.InstructionSyntax
use scaly.compiler.Syntax.IntrinsicSyntax
use scaly.compiler.Syntax.FunctionSyntax
use scaly.compiler.Syntax.ProcedureSyntax
use scaly.compiler.Syntax.OperatorSyntax
use scaly.compiler.Syntax.InitSyntax
use scaly.compiler.Syntax.DeInitSyntax
use scaly.compiler.Syntax.BodySyntax
use scaly.compiler.Syntax.ReturnsSyntax
use scaly.compiler.Syntax.ThrowsSyntax
use scaly.compiler.Syntax.StructureSyntax
use scaly.compiler.Syntax.ClassSyntax
use scaly.compiler.Syntax.VariantSyntax
use scaly.compiler.Syntax.UnionSyntax
use scaly.compiler.Syntax.NamespaceSyntax
use scaly.compiler.Syntax.ConstantSyntax
use scaly.compiler.Syntax.ConceptSyntax
use scaly.compiler.Syntax.DefinitionSyntax
use scaly.compiler.Syntax.PrivateSyntax
use scaly.compiler.Syntax.ExportSyntax
use scaly.compiler.Syntax.SymbolSyntax
use scaly.compiler.Syntax.DeclarationSyntax
use scaly.compiler.Syntax.MemberSyntax
use scaly.compiler.Syntax.ConstituentSyntax
use scaly.compiler.Syntax.ModuleSyntax
use scaly.compiler.Syntax.FileSyntax
use scaly.compiler.Syntax.ProgramSyntax
use scaly.compiler.Syntax.ExtensionSyntax

; ============================================================================
; Literal/Constant handling
; ============================================================================

function handle_literal(syntax: LiteralSyntax) returns Constant
{
    let loc Span(syntax.start, syntax.end)
    choose syntax.literal
        when str: StringLiteral
            Constant.String(StringConstant(loc, str.value))
        when chr: CharacterLiteral
            Constant.Character(CharacterConstant(loc, chr.value))
        when frag: FragmentLiteral
            Constant.Fragment(FragmentConstant(loc, frag.value))
        when int_lit: IntegerLiteral
            Constant.Integer(IntegerConstant(loc, 0))
        when bool_lit: BooleanLiteral
            Constant.Boolean(BooleanConstant(loc, bool_lit.value))
        when float_lit: FloatingPointLiteral
            Constant.FloatingPoint(FloatingPointConstant(loc, 0.0))
        when hex_lit: HexLiteral
            Constant.Hex(HexConstant(loc, 0))
        else
            Constant.Integer(IntegerConstant(loc, 0))
}

; ============================================================================
; Lifetime handling
; ============================================================================

function handle_lifetime(syntax: ref[LifetimeSyntax]?) returns Lifetime
{
    if syntax = null
        return Lifetime.Unspecified(Unspecified())

    let lifetime_syntax (*syntax)
    choose lifetime_syntax
        when call: CallSyntax
            Lifetime.Call(Call(Span(call.start, call.end)))
        when local: LocalSyntax
            Lifetime.Local(Local(Span(local.start, local.end)))
        when ref: ReferenceSyntax
            Lifetime.Reference(Reference(Span(ref.start, ref.end), ref.location))
        when thrown: ThrownSyntax
            Lifetime.Thrown(Thrown(Span(thrown.start, thrown.end)))
        else
            Lifetime.Unspecified(Unspecified())
}

; ============================================================================
; Type handling
; ============================================================================

function handle_type#(syntax: TypeSyntax) returns ref[Type]?
{
    ; Count extensions to determine path size
    var ext_count: size_t 0
    if syntax.name.extensions <> null
        set ext_count: (*syntax.name.extensions).length

    ; Create path with correct size
    var path Vector[String]#(1 + ext_count)
    path.put(0, syntax.name.name)

    ; Add extensions
    if syntax.name.extensions <> null
    {
        let exts (*syntax.name.extensions)
        var i: size_t 0
        while i < exts.length
        {
            let ext_ptr exts.get(i)
            if ext_ptr <> null
            {
                let ext (*ext_ptr)
                path.put(1 + i, ext.name)
            }
            set i: i + 1
        }
    }

    var generics: ref[Vector[Type]]? null
    if syntax.generics <> null
    {
        let gen_args_syntax (*syntax.generics)
        if gen_args_syntax.generics <> null
        {
            let gen_syns (*gen_args_syntax.generics)
            var gen_types Vector[Type]#(gen_syns.length)
            var gi: size_t 0
            while gi < gen_syns.length
            {
                let ga_ptr gen_syns.get(gi)
                if ga_ptr <> null
                {
                    let ga (*ga_ptr)
                    let inner_type handle_type#(ga.type)
                    if inner_type <> null
                        gen_types.put(gi, *inner_type)
                }
                set gi: gi + 1
            }
            set generics: &gen_types
        }
    }

    let life handle_lifetime(syntax.lifetime)
    Type#(Span(syntax.start, syntax.end), path, generics, life)
}

function handle_binding_annotation#(annotation: BindingAnnotationSyntax) returns ref[Type]?
{
    choose annotation.spec
        when type_syntax: TypeSyntax
            handle_type#(type_syntax)
        else
            null
}

; ============================================================================
; Object/Tuple handling
; ============================================================================

function handle_object#(syntax: ObjectSyntax) returns Tuple
{
    var count: size_t 0
    if syntax.components <> null
        set count: (*syntax.components).length

    var components Vector[Component]#(count)
    if syntax.components <> null
    {
        let comps (*syntax.components)
        var i: size_t 0
        while i < comps.length
        {
            let comp_ptr comps.get(i)
            if comp_ptr <> null
            {
                let comp_syntax (*comp_ptr)
                let component handle_component#(comp_syntax)
                components.put(i, component)
            }
            set i: i + 1
        }
    }
    Tuple(Span(syntax.start, syntax.end), components)
}

function handle_component#(syntax: ComponentSyntax) returns Component
{
    var name: ref[String]? null
    var operands handle_operands#(syntax.operands)

    if syntax.value <> null
    {
        let val_syntax (*syntax.value)
        set operands: handle_operands#(val_syntax.value)

        ; Extract name from operands if present
        if syntax.operands <> null
        {
            let name_ops (*syntax.operands)
            if name_ops.length > 0
            {
                let name_op_ptr name_ops.get(0)
                if name_op_ptr <> null
                {
                    let name_op (*name_op_ptr)
                    choose name_op.expression
                        when type_expr: TypeSyntax
                            set name: String$(type_expr.name.name)
                        else {}
                }
            }
        }
    }

    Component(
        Span(syntax.start, syntax.end),
        name,
        operands,
        Vector[Attribute]#(0)
    )
}

; ============================================================================
; Vector/Matrix handling
; ============================================================================

function handle_vector#(syntax: VectorSyntax) returns Matrix
{
    var count: size_t 0
    if syntax.elements <> null
        set count: (*syntax.elements).length

    var operations Vector[Vector[Operand]]#(count)
    if syntax.elements <> null
    {
        let elems (*syntax.elements)
        var i: size_t 0
        while i < elems.length
        {
            let elem_ptr elems.get(i)
            if elem_ptr <> null
            {
                let element (*elem_ptr)
                let ops handle_operands#(element.operation)
                operations.put(i, ops)
            }
            set i: i + 1
        }
    }
    Matrix(Span(syntax.start, syntax.end), operations)
}

; ============================================================================
; Block handling
; ============================================================================

function handle_block#(syntax: BlockSyntax) returns Block
{
    let statements handle_statements#(syntax.statements)
    Block(Span(syntax.start, syntax.end), statements)
}

; ============================================================================
; Expression handling
; ============================================================================

function handle_expression#(syntax: ExpressionSyntax) returns Expression
{
    choose syntax
        when lit: LiteralSyntax
            Expression.Constant(handle_literal(lit))
        when name_syntax: NameSyntax
        {
            ; Convert NameSyntax to Type expression
            ; Count extensions to determine path size
            var ext_count: size_t 0
            if name_syntax.extensions <> null
                set ext_count: (*name_syntax.extensions).length

            var path Vector[String]#(1 + ext_count)
            path.put(0, name_syntax.name)

            if name_syntax.extensions <> null
            {
                let exts (*name_syntax.extensions)
                var i: size_t 0
                while i < exts.length
                {
                    let ext_ptr exts.get(i)
                    if ext_ptr <> null
                    {
                        let ext (*ext_ptr)
                        path.put(1 + i, ext.name)
                    }
                    set i: i + 1
                }
            }

            Expression.Type(Type(
                Span(name_syntax.start, name_syntax.end),
                path,
                null,
                Lifetime.Unspecified(Unspecified())
            ))
        }
        when obj: ObjectSyntax
            Expression.Tuple(handle_object#(obj))
        when vec: VectorSyntax
            Expression.Matrix(handle_vector#(vec))
        when blk: BlockSyntax
            Expression.Block(handle_block#(blk))
        when if_syntax: IfSyntax
            Expression.If(handle_if#(if_syntax))
        when match_syntax: MatchSyntax
            Expression.Match(handle_match#(match_syntax))
        when choose_syntax: ChooseSyntax
            Expression.Choose(handle_choose#(choose_syntax))
        when for_syntax: ForSyntax
            Expression.For(handle_for#(for_syntax))
        when while_syntax: WhileSyntax
            Expression.While(handle_while#(while_syntax))
        when try_syntax: TrySyntax
            Expression.Try(handle_try#(try_syntax))
        when sizeof_syntax: SizeOfSyntax
            Expression.SizeOf(handle_sizeof#(sizeof_syntax))
        when is_syntax: IsSyntax
            Expression.Is(handle_is#(is_syntax))
        else
            Expression.Constant(Constant.Integer(IntegerConstant(Span(0, 0), 0)))
}

; ============================================================================
; Control flow handling
; ============================================================================

function handle_if#(syntax: IfSyntax) returns If
{
    let condition handle_operands#(syntax.condition)
    let cons_stmt handle_command#(syntax.consequent.command)

    var alternative: ref[Statement]? null
    if syntax.alternative <> null
    {
        let else_syntax (*syntax.alternative)
        let alt_stmt handle_command#(else_syntax.alternative)
        set alternative: Statement#(alt_stmt)
    }

    If(
        Span(syntax.start, syntax.end),
        condition,
        null,
        cons_stmt,
        alternative
    )
}

function handle_match#(syntax: MatchSyntax) returns Match
{
    let scrutinee handle_operands#(syntax.scrutinee)

    var branch_count: size_t 0
    if syntax.branches <> null
        set branch_count: (*syntax.branches).length

    var branches Vector[Branch]#(branch_count)
    if syntax.branches <> null
    {
        let brs (*syntax.branches)
        var i: size_t 0
        while i < brs.length
        {
            let br_ptr brs.get(i)
            if br_ptr <> null
            {
                let branch_syntax (*br_ptr)
                let branch handle_branch#(branch_syntax)
                branches.put(i, branch)
            }
            set i: i + 1
        }
    }

    var alternative: ref[Statement]? null
    if syntax.alternative <> null
    {
        let else_syntax (*syntax.alternative)
        let alt_stmt handle_command#(else_syntax.alternative)
        set alternative: Statement#(alt_stmt)
    }

    Match(
        Span(syntax.start, syntax.end),
        scrutinee,
        branches,
        alternative
    )
}

function handle_branch#(syntax: BranchSyntax) returns Branch
{
    var case_count: size_t 0
    if syntax.cases <> null
        set case_count: (*syntax.cases).length

    var cases Vector[Case]#(case_count)
    if syntax.cases <> null
    {
        let cs (*syntax.cases)
        var i: size_t 0
        while i < cs.length
        {
            let case_ptr cs.get(i)
            if case_ptr <> null
            {
                let case_syntax (*case_ptr)
                let case_ handle_case#(case_syntax)
                cases.put(i, case_)
            }
            set i: i + 1
        }
    }

    let stmt handle_statement#(syntax.consequent)
    Branch(Span(syntax.start, syntax.end), cases, stmt)
}

function handle_case#(syntax: CaseSyntax) returns Case
{
    let condition handle_operands#(syntax.condition)
    Case(Span(syntax.start, syntax.end), condition)
}

function handle_choose#(syntax: ChooseSyntax) returns Choose
{
    let condition handle_operands#(syntax.condition)

    var case_count: size_t 0
    if syntax.cases <> null
        set case_count: (*syntax.cases).length

    var cases Vector[When]#(case_count)
    if syntax.cases <> null
    {
        let cs (*syntax.cases)
        var i: size_t 0
        while i < cs.length
        {
            let when_ptr cs.get(i)
            if when_ptr <> null
            {
                let when_syntax (*when_ptr)
                let when_ handle_when#(when_syntax)
                cases.put(i, when_)
            }
            set i: i + 1
        }
    }

    var alternative: ref[Statement]? null
    if syntax.alternative <> null
    {
        let else_syntax (*syntax.alternative)
        let alt_stmt handle_command#(else_syntax.alternative)
        set alternative: Statement#(alt_stmt)
    }

    Choose(
        Span(syntax.start, syntax.end),
        condition,
        cases,
        alternative
    )
}

function handle_when#(syntax: WhenSyntax) returns When
{
    ; Variant is now just a simple identifier (String)
    var variant_path Vector[String]#(1)
    variant_path.put(0, syntax.variant)

    let stmt handle_command#(syntax.command)
    When(
        Span(syntax.start, syntax.end),
        syntax.name,
        variant_path,
        stmt
    )
}

function handle_action#(syntax: ActionSyntax) returns Action
{
    choose syntax
        when op: OperationSyntax
            Action(handle_operands#(op.operands), Vector[Operand]#(0))
        when set_syntax: SetSyntax
            Action(handle_operands#(set_syntax.source), handle_operands#(set_syntax.target))
        else
            Action(Vector[Operand]#(0), Vector[Operand]#(0))
}

function handle_for#(syntax: ForSyntax) returns For
{
    let expr handle_operands#(syntax.operation)
    let body handle_action#(syntax.action)

    For(
        Span(syntax.start, syntax.end),
        syntax.variable,
        expr,
        body
    )
}

function handle_while#(syntax: WhileSyntax) returns While
{
    let cond handle_condition#(syntax.condition)
    let body handle_action#(syntax.action)

    While(
        Span(syntax.start, syntax.end),
        cond,
        body
    )
}

function handle_condition#(syntax: ConditionSyntax) returns Binding
{
    choose syntax
        when op: OperationSyntax
        {
            let operands handle_operands#(op.operands)
            Binding(
                Span(op.start, op.end),
                "const",
                Item(Span(op.start, op.end), false, null, null, Vector[Attribute]#(0)),
                operands
            )
        }
        when let_syntax: LetSyntax
        {
            let item handle_binding_item#(let_syntax.binding)
            let operation handle_operands#(let_syntax.binding.operation)
            Binding(
                Span(let_syntax.start, let_syntax.end),
                "const",
                item,
                operation
            )
        }
        else
            Binding(Span(0, 0), "const", Item(Span(0, 0), false, null, null, Vector[Attribute]#(0)), Vector[Operand]#(0))
}

function handle_try#(syntax: TrySyntax) returns Try
{
    let cond handle_condition#(syntax.condition)

    var catch_count: size_t 0
    if syntax.cases <> null
        set catch_count: (*syntax.cases).length

    var catches Vector[When]#(catch_count)
    if syntax.cases <> null
    {
        let cs (*syntax.cases)
        var i: size_t 0
        while i < cs.length
        {
            let when_ptr cs.get(i)
            if when_ptr <> null
            {
                let when_syntax (*when_ptr)
                let when_ handle_when#(when_syntax)
                catches.put(i, when_)
            }
            set i: i + 1
        }
    }

    var dropper: ref[Statement]? null
    if syntax.dropper <> null
    {
        let else_syntax (*syntax.dropper)
        let drop_stmt handle_command#(else_syntax.alternative)
        set dropper: Statement#(drop_stmt)
    }

    Try(
        Span(syntax.start, syntax.end),
        cond,
        catches,
        dropper
    )
}

; ============================================================================
; Type operation handling
; ============================================================================

function handle_sizeof#(syntax: SizeOfSyntax) returns SizeOf
{
    let sized_type handle_type#(syntax.type)
    SizeOf(Span(syntax.start, syntax.end), *sized_type)
}

function handle_is#(syntax: IsSyntax) returns Is
{
    ; Count extensions
    var ext_count: size_t 0
    if syntax.name.extensions <> null
        set ext_count: (*syntax.name.extensions).length

    var name Vector[String]#(1 + ext_count)
    name.put(0, syntax.name.name)

    if syntax.name.extensions <> null
    {
        let exts (*syntax.name.extensions)
        var i: size_t 0
        while i < exts.length
        {
            let ext_ptr exts.get(i)
            if ext_ptr <> null
            {
                let ext (*ext_ptr)
                name.put(1 + i, ext.name)
            }
            set i: i + 1
        }
    }
    Is(Span(syntax.start, syntax.end), name)
}

; ============================================================================
; Operand handling
; ============================================================================

function handle_operand#(syntax: OperandSyntax) returns Operand
{
    let expr handle_expression#(syntax.expression)

    var member_access: ref[Vector[String]]? null
    if syntax.members <> null
    {
        let members (*syntax.members)
        var path Vector[String]#(members.length)
        var i: size_t 0
        while i < members.length
        {
            let member_ptr members.get(i)
            if member_ptr <> null
            {
                let member (*member_ptr)
                path.put(i, member.name.name)
            }
            set i: i + 1
        }
        set member_access: &path
    }

    Operand(Span(syntax.start, syntax.end), expr, member_access)
}

function handle_operands#(syntax: ref[Vector[OperandSyntax]]?) returns Vector[Operand]
{
    if syntax = null
        return Vector[Operand]#(0)

    let syn (*syntax)
    var result Vector[Operand]#(syn.length)
    var i: size_t 0
    while i < syn.length
    {
        let op_ptr syn.get(i)
        if op_ptr <> null
        {
            let operand_syntax (*op_ptr)
            let operand handle_operand#(operand_syntax)
            result.put(i, operand)
        }
        set i: i + 1
    }
    result
}

function handle_operation#(syntax: OperationSyntax) returns Vector[Operand]
    handle_operands#(syntax.operands)

; ============================================================================
; Statement handling
; ============================================================================

function handle_binding_item#(syntax: BindingSyntax) returns Item
{
    var item_type: ref[Type]? null
    if syntax.annotation <> null
    {
        let annotation (*syntax.annotation)
        set item_type: handle_binding_annotation#(annotation)
    }

    Item(
        Span(syntax.start, syntax.end),
        false,
        String$(syntax.name),
        item_type,
        Vector[Attribute]#(0)
    )
}

function handle_command#(syntax: CommandSyntax) returns Statement
{
    choose syntax
        when op: OperationSyntax
        {
            let operands handle_operands#(op.operands)
            Statement.Action(Action(operands, Vector[Operand]#(0)))
        }
        when let_syntax: LetSyntax
        {
            let item handle_binding_item#(let_syntax.binding)
            let operation handle_operands#(let_syntax.binding.operation)
            Statement.Binding(Binding(
                Span(let_syntax.start, let_syntax.end),
                "const",
                item,
                operation
            ))
        }
        when var_syntax: VarSyntax
        {
            let item handle_binding_item#(var_syntax.binding)
            let operation handle_operands#(var_syntax.binding.operation)
            Statement.Binding(Binding(
                Span(var_syntax.start, var_syntax.end),
                "var",
                item,
                operation
            ))
        }
        when mut_syntax: MutableSyntax
        {
            let item handle_binding_item#(mut_syntax.binding)
            let operation handle_operands#(mut_syntax.binding.operation)
            Statement.Binding(Binding(
                Span(mut_syntax.start, mut_syntax.end),
                "mutable",
                item,
                operation
            ))
        }
        when set_syntax: SetSyntax
        {
            let target handle_operands#(set_syntax.target)
            let source handle_operands#(set_syntax.source)
            Statement.Action(Action(source, target))
        }
        when break_syntax: BreakSyntax
        {
            let result handle_operands#(break_syntax.result)
            Statement.Break(Break(Span(break_syntax.start, break_syntax.end), result))
        }
        when continue_syntax: ContinueSyntax
            Statement.Continue(Continue(Span(continue_syntax.start, continue_syntax.end)))
        when return_syntax: ReturnSyntax
        {
            let result handle_operands#(return_syntax.result)
            Statement.Return(Return(Span(return_syntax.start, return_syntax.end), result))
        }
        when throw_syntax: ThrowSyntax
        {
            let result handle_operands#(throw_syntax.result)
            Statement.Throw(Throw(Span(throw_syntax.start, throw_syntax.end), result))
        }
        else
            Statement.Action(Action(Vector[Operand]#(0), Vector[Operand]#(0)))
}

function handle_statement#(syntax: StatementSyntax) returns Statement
    handle_command#(syntax.command)

function handle_statements#(syntax: ref[Vector[StatementSyntax]]?) returns Vector[Statement]
{
    if syntax = null
        return Vector[Statement]#(0)

    let stmts (*syntax)
    var result Vector[Statement]#(stmts.length)
    var i: size_t 0
    while i < stmts.length
    {
        let stmt_ptr stmts.get(i)
        if stmt_ptr <> null
        {
            let stmt_syntax (*stmt_ptr)
            let stmt handle_statement#(stmt_syntax)
            result.put(i, stmt)
        }
        set i: i + 1
    }
    result
}

; ============================================================================
; Item and Property handling
; ============================================================================

function handle_item#(is_private: bool, syntax: ItemSyntax) returns Item
{
    var item_type: ref[Type]? null
    if syntax.annotation <> null
    {
        let annotation (*syntax.annotation)
        set item_type: handle_type#(annotation.type)
    }

    Item(
        Span(syntax.start, syntax.end),
        is_private,
        String$(syntax.name),
        item_type,
        Vector[Attribute]#(0)
    )
}

function handle_property#(is_private: bool, syntax: PropertySyntax) returns Property
{
    let prop_type handle_type#(syntax.annotation.type)

    var initializer: ref[Vector[Operand]]? null
    if syntax.initializer <> null
    {
        let init_syntax (*syntax.initializer)
        let ops handle_operands#(init_syntax.operands)
        set initializer: &ops
    }

    Property(
        Span(syntax.start, syntax.end),
        is_private,
        syntax.name,
        prop_type,
        initializer,
        Vector[Attribute]#(0)
    )
}

; ============================================================================
; Attribute handling
; ============================================================================

function handle_attribute#(syntax: AttributeSyntax) returns Attribute
{
    let model_result handle_model#(syntax.model)

    Attribute(
        Span(syntax.start, syntax.end),
        syntax.name,
        model_result
    )
}

function handle_model#(syntax: ModelSyntax) returns Model
{
    choose syntax
        when lit: LiteralSyntax
            Model.Constant(handle_literal(lit))
        when name: NameSyntax
            Model.Variable(name.name)
        when obj: ObjectSyntax
            Model.Tuple(handle_object#(obj))
        when vec: VectorSyntax
            Model.Matrix(handle_vector#(vec))
        else
            Model.Variable("")
}

; ============================================================================
; Use handling
; ============================================================================

function handle_use#(syntax: UseSyntax) returns Use
{
    ; Count extensions
    var ext_count: size_t 0
    if syntax.name.extensions <> null
        set ext_count: (*syntax.name.extensions).length

    var path Vector[String]#(1 + ext_count)
    path.put(0, syntax.name.name)

    if syntax.name.extensions <> null
    {
        let exts (*syntax.name.extensions)
        var i: size_t 0
        while i < exts.length
        {
            let ext_ptr exts.get(i)
            if ext_ptr <> null
            {
                let ext (*ext_ptr)
                path.put(1 + i, ext.name)
            }
            set i: i + 1
        }
    }

    Use(Span(syntax.start, syntax.end), path)
}

; ============================================================================
; Generic parameter handling
; ============================================================================

function handle_generic_parameter#(syntax: GenericParameterSyntax) returns GenericParameter
{
    GenericParameter(
        Span(syntax.start, syntax.end),
        syntax.name,
        Vector[Attribute]#(0)
    )
}

; ============================================================================
; Parameter handling
; ============================================================================

function handle_parameter_set#(syntax: ParameterSetSyntax) returns Vector[Item]
{
    choose syntax
        when params: ParametersSyntax
        {
            if params.items = null
                return Vector[Item]#(0)
            let items (*params.items)
            var result Vector[Item]#(items.length)
            var i: size_t 0
            while i < items.length
            {
                let item_ptr items.get(i)
                if item_ptr <> null
                {
                    let item_syn (*item_ptr)
                    let item handle_item#(false, item_syn)
                    result.put(i, item)
                }
                set i: i + 1
            }
            result
        }
        when type_syn: TypeSyntax
        {
            let type_result handle_type#(type_syn)
            var result Vector[Item]#(1)
            result.put(0, Item(
                Span(type_syn.start, type_syn.end),
                false,
                null,
                type_result,
                Vector[Attribute]#(0)
            ))
            result
        }
        else
            Vector[Item]#(0)
}

; ============================================================================
; Implementation handling
; ============================================================================

function handle_implementation#(syntax: ImplementationSyntax) returns Implementation
{
    choose syntax
        when act: ActionSyntax
            Implementation.Action(handle_action#(act))
        when ext: ExternSyntax
            Implementation.Extern(Extern(Span(ext.start, ext.end)))
        when inst: InstructionSyntax
            Implementation.Instruction(Instruction(Span(inst.start, inst.end)))
        when intr: IntrinsicSyntax
            Implementation.Intrinsic(Intrinsic(Span(intr.start, intr.end)))
        else
            Implementation.Action(Action(Vector[Operand]#(0), Vector[Operand]#(0)))
}

; ============================================================================
; Function building
; ============================================================================

function build_function#(start: size_t, end_pos: size_t, syntax: TargetSyntax, is_private: bool, pure: bool) returns Function
{
    choose syntax
        when named: NamedSyntax
        {
            var input Vector[Item]#(0)
            if named.routine.parameters <> null
            {
                let params (*named.routine.parameters)
                set input: handle_parameter_set#(params)
            }

            var return_type: ref[Type]? null
            if named.routine.returns_ <> null
            {
                let returns_syntax (*named.routine.returns_)
                set return_type: handle_type#(returns_syntax.type)
            }

            var throws_type: ref[Type]? null
            if named.routine.throws_ <> null
            {
                let throws_syntax (*named.routine.throws_)
                set throws_type: handle_type#(throws_syntax.type)
            }

            let life handle_lifetime(named.routine.lifetime)
            let impl handle_implementation#(named.routine.implementation)

            Function(
                Span(start, end_pos),
                is_private,
                pure,
                named.name,
                input,
                return_type,
                throws_type,
                life,
                impl
            )
        }
        else
            Function(
                Span(start, end_pos),
                is_private,
                pure,
                "",
                Vector[Item]#(0),
                null,
                null,
                Lifetime.Unspecified(Unspecified()),
                Implementation.Action(Action(Vector[Operand]#(0), Vector[Operand]#(0)))
            )
}

; ============================================================================
; Operator handling
; ============================================================================

function handle_operator#(syntax: OperatorSyntax, is_private: bool) returns Operator
{
    choose syntax.target
        when named: NamedSyntax
        {
            var input Vector[Item]#(0)
            if named.routine.parameters <> null
            {
                let params (*named.routine.parameters)
                set input: handle_parameter_set#(params)
            }

            var return_type: ref[Type]? null
            if named.routine.returns_ <> null
            {
                let returns_syntax (*named.routine.returns_)
                set return_type: handle_type#(returns_syntax.type)
            }

            var throws_type: ref[Type]? null
            if named.routine.throws_ <> null
            {
                let throws_syntax (*named.routine.throws_)
                set throws_type: handle_type#(throws_syntax.type)
            }

            let impl handle_implementation#(named.routine.implementation)

            Operator(
                Span(syntax.start, syntax.end),
                is_private,
                named.name,
                input,
                return_type,
                throws_type,
                impl
            )
        }
        when routine: RoutineSyntax
        {
            ; Handle index operator []
            var input Vector[Item]#(0)
            if routine.parameters <> null
            {
                let params (*routine.parameters)
                set input: handle_parameter_set#(params)
            }

            var return_type: ref[Type]? null
            if routine.returns_ <> null
            {
                let returns_syntax (*routine.returns_)
                set return_type: handle_type#(returns_syntax.type)
            }

            var throws_type: ref[Type]? null
            if routine.throws_ <> null
            {
                let throws_syntax (*routine.throws_)
                set throws_type: handle_type#(throws_syntax.type)
            }

            let impl handle_implementation#(routine.implementation)

            Operator(
                Span(syntax.start, syntax.end),
                is_private,
                "[]",
                input,
                return_type,
                throws_type,
                impl
            )
        }
        else
            Operator(
                Span(syntax.start, syntax.end),
                is_private,
                "",
                Vector[Item]#(0),
                null,
                null,
                Implementation.Action(Action(Vector[Operand]#(0), Vector[Operand]#(0)))
            )
}

; ============================================================================
; Initializer handling
; ============================================================================

function handle_initializer#(syntax: InitSyntax, is_private: bool) returns Initializer
{
    var input Vector[Item]#(0)
    if syntax.parameters <> null
    {
        let params (*syntax.parameters)
        set input: handle_parameter_set#(params)
    }

    let act handle_action#(syntax.action)
    let impl Implementation.Action(act)

    Initializer(
        Span(syntax.start, syntax.end),
        is_private,
        input,
        impl
    )
}

function handle_deinitializer#(syntax: DeInitSyntax) returns ref[DeInitializer]?
{
    let act handle_action#(syntax.action)
    let impl Implementation.Action(act)

    DeInitializer#(
        Span(syntax.start, syntax.end),
        impl
    )
}

; ============================================================================
; Variant handling (for unions)
; ============================================================================

function handle_variant#(syntax: VariantSyntax) returns Variant
{
    var variant_type: ref[Type]? null
    if syntax.annotation <> null
    {
        let annotation (*syntax.annotation)
        set variant_type: handle_type#(annotation.type)
    }

    Variant(
        Span(syntax.start, syntax.end),
        syntax.name,
        variant_type,
        Vector[Attribute]#(0)
    )
}

; ============================================================================
; Class/Structure handling
; ============================================================================

function handle_class#(name: String, path: String, syntax: ClassSyntax, is_private: bool) returns Structure
{
    var symbols_builder HashMapBuilder[String, Nameable]$()

    ; Handle parts (fields/properties)
    var property_count: size_t 0
    if syntax.structure.parts <> null
        set property_count: (*syntax.structure.parts).length

    var properties Vector[Property]#(property_count)
    if syntax.structure.parts <> null
    {
        let parts (*syntax.structure.parts)
        var i: size_t 0
        while i < parts.length
        {
            let part_ptr parts.get(i)
            if part_ptr <> null
            {
                let part (*part_ptr)
                choose part
                    when field: FieldSyntax
                    {
                        let property handle_property#(true, field.property)
                        symbols_builder.add(property.name, Nameable.Property(property))
                        properties.put(i, property)
                    }
                    when prop: PropertySyntax
                    {
                        let property handle_property#(false, prop)
                        symbols_builder.add(property.name, Nameable.Property(property))
                        properties.put(i, property)
                    }
                    else {}
            }
            set i: i + 1
        }
    }

    ; Handle body (inits, deinit, functions, etc.)
    var modules Vector[Module]#(0)
    var uses Vector[Use]#(0)
    var initializers Vector[Initializer]#(0)
    var members Vector[Member]#(0)
    var deinitializer: ref[DeInitializer]? null

    if syntax.body <> null
    {
        let body (*syntax.body)

        ; Handle uses
        if body.uses <> null
        {
            let use_syns (*body.uses)
            set uses: Vector[Use]#(use_syns.length)
            var i: size_t 0
            while i < use_syns.length
            {
                let use_ptr use_syns.get(i)
                if use_ptr <> null
                {
                    let use_syntax (*use_ptr)
                    let use_ handle_use#(use_syntax)
                    uses.put(i, use_)
                }
                set i: i + 1
            }
        }

        ; Handle inits
        if body.inits <> null
        {
            let init_syns (*body.inits)
            set initializers: Vector[Initializer]#(init_syns.length)
            var i: size_t 0
            while i < init_syns.length
            {
                let init_ptr init_syns.get(i)
                if init_ptr <> null
                {
                    let init_syntax (*init_ptr)
                    let init_ handle_initializer#(init_syntax, false)
                    initializers.put(i, init_)
                }
                set i: i + 1
            }
        }

        ; Handle deinit
        if body.deInit <> null
        {
            let deinit_syntax (*body.deInit)
            set deinitializer: handle_deinitializer#(deinit_syntax)
        }

        ; Handle members
        if body.members <> null
        {
            let member_syns (*body.members)
            set members: Vector[Member]#(member_syns.length)
            var i: size_t 0
            while i < member_syns.length
            {
                let member_ptr member_syns.get(i)
                if member_ptr <> null
                {
                    let member_syntax (*member_ptr)
                    let member handle_constituent#(path, member_syntax, &symbols_builder)
                    members.put(i, member)
                }
                set i: i + 1
            }
        }
    }

    let symbols HashMap[String, Nameable]#(symbols_builder)

    Structure(
        Span(syntax.start, syntax.end),
        is_private,
        properties,
        modules,
        uses,
        initializers,
        deinitializer,
        members,
        symbols
    )
}

function handle_constituent#(path: String, syntax: MemberSyntax, symbols_builder: pointer[HashMapBuilder[String, Nameable]]) returns Member
{
    choose syntax.constituent
        when def: DefinitionSyntax
        {
            let concept handle_definition#(path, def, false)
            (*symbols_builder).add(concept.name, Nameable.Concept(concept))
            Member.Concept(concept)
        }
        when func: FunctionSyntax
        {
            let fn build_function#(func.start, func.end, func.target, false, true)
            Member.Function(fn)
        }
        when proc: ProcedureSyntax
        {
            let proc_fn build_function#(proc.start, proc.end, proc.target, false, false)
            Member.Function(proc_fn)
        }
        when op: OperatorSyntax
        {
            let operator_ handle_operator#(op, false)
            (*symbols_builder).add(operator_.name, Nameable.Operator(operator_))
            Member.Operator(operator_)
        }
        when mod: ModuleSyntax
        {
            ; Modules are handled separately
            Member.Package(Vector[Module]#(0))
        }
        else
            Member.Package(Vector[Module]#(0))
}

; ============================================================================
; Namespace handling
; ============================================================================

function handle_namespace#(name: String, path: String, syntax: NamespaceSyntax, is_private: bool) returns Namespace
{
    var symbols_builder HashMapBuilder[String, Nameable]$()
    var modules Vector[Module]#(0)
    var members Vector[Member]#(0)

    if syntax.declarations <> null
    {
        let decl_syns (*syntax.declarations)
        set members: Vector[Member]#(decl_syns.length)
        var i: size_t 0
        while i < decl_syns.length
        {
            let decl_ptr decl_syns.get(i)
            if decl_ptr <> null
            {
                let decl_syntax (*decl_ptr)
                let member handle_declaration#(path, decl_syntax, &symbols_builder)
                members.put(i, member)
            }
            set i: i + 1
        }
    }

    let symbols HashMap[String, Nameable]#(symbols_builder)

    Namespace(
        Span(syntax.start, syntax.end),
        modules,
        members,
        symbols
    )
}

function handle_declaration#(path: String, syntax: DeclarationSyntax, symbols_builder: pointer[HashMapBuilder[String, Nameable]]) returns Member
{
    choose syntax.symbol
        when private_syntax: PrivateSyntax
            handle_export#(path, private_syntax.export_, true, symbols_builder)
        when def: DefinitionSyntax
        {
            let concept handle_definition#(path, def, false)
            (*symbols_builder).add(concept.name, Nameable.Concept(concept))
            Member.Concept(concept)
        }
        when func: FunctionSyntax
        {
            let fn build_function#(func.start, func.end, func.target, false, true)
            Member.Function(fn)
        }
        when proc: ProcedureSyntax
        {
            let proc_fn build_function#(proc.start, proc.end, proc.target, false, false)
            Member.Function(proc_fn)
        }
        when op: OperatorSyntax
        {
            let operator_ handle_operator#(op, false)
            (*symbols_builder).add(operator_.name, Nameable.Operator(operator_))
            Member.Operator(operator_)
        }
        when mod: ModuleSyntax
            Member.Package(Vector[Module]#(0))
        else
            Member.Package(Vector[Module]#(0))
}

function handle_export#(path: String, syntax: ExportSyntax, is_private: bool, symbols_builder: pointer[HashMapBuilder[String, Nameable]]) returns Member
{
    choose syntax
        when def: DefinitionSyntax
        {
            let concept handle_definition#(path, def, is_private)
            (*symbols_builder).add(concept.name, Nameable.Concept(concept))
            Member.Concept(concept)
        }
        when func: FunctionSyntax
        {
            let fn build_function#(func.start, func.end, func.target, is_private, true)
            Member.Function(fn)
        }
        when op: OperatorSyntax
        {
            let operator_ handle_operator#(op, is_private)
            (*symbols_builder).add(operator_.name, Nameable.Operator(operator_))
            Member.Operator(operator_)
        }
        when mod: ModuleSyntax
            Member.Package(Vector[Module]#(0))
        else
            Member.Package(Vector[Module]#(0))
}

; ============================================================================
; Union handling
; ============================================================================

function handle_union#(name: String, path: String, syntax: UnionSyntax, is_private: bool) returns Union
{
    var symbols_builder HashMapBuilder[String, Nameable]$()

    ; Handle variants
    var variant_count: size_t 0
    if syntax.variants <> null
        set variant_count: (*syntax.variants).length

    var variants Vector[Variant]#(variant_count)
    if syntax.variants <> null
    {
        let var_syns (*syntax.variants)
        var i: size_t 0
        while i < var_syns.length
        {
            let var_ptr var_syns.get(i)
            if var_ptr <> null
            {
                let var_syntax (*var_ptr)
                let variant handle_variant#(var_syntax)
                symbols_builder.add(variant.name, Nameable.Variant(variant))
                variants.put(i, variant)
            }
            set i: i + 1
        }
    }

    ; Handle body
    var members Vector[Member]#(0)
    if syntax.body <> null
    {
        let body (*syntax.body)
        if body.members <> null
        {
            let member_syns (*body.members)
            set members: Vector[Member]#(member_syns.length)
            var i: size_t 0
            while i < member_syns.length
            {
                let member_ptr member_syns.get(i)
                if member_ptr <> null
                {
                    let member_syntax (*member_ptr)
                    let member handle_constituent#(path, member_syntax, &symbols_builder)
                    members.put(i, member)
                }
                set i: i + 1
            }
        }
    }

    let symbols HashMap[String, Nameable]#(symbols_builder)

    Union(
        Span(syntax.start, syntax.end),
        is_private,
        variants,
        members,
        symbols
    )
}

; ============================================================================
; Definition handling
; ============================================================================

function handle_definition#(path: String, syntax: DefinitionSyntax, is_private: bool) returns Concept
{
    let name syntax.name
    let loc Span(syntax.start, syntax.end)

    ; Handle generic parameters
    var parameters Vector[GenericParameter]#(0)
    if syntax.parameters <> null
    {
        let params_syntax (*syntax.parameters)
        if params_syntax.parameters <> null
        {
            let param_vec (*params_syntax.parameters)
            set parameters: Vector[GenericParameter]#(param_vec.length)
            var i: size_t 0
            while i < param_vec.length
            {
                let param_ptr param_vec.get(i)
                if param_ptr <> null
                {
                    let param_syntax (*param_ptr)
                    let param handle_generic_parameter#(param_syntax)
                    parameters.put(i, param)
                }
                set i: i + 1
            }
        }
    }

    ; Handle attributes
    var attributes Vector[Attribute]#(0)
    if syntax.attributes <> null
    {
        let attr_vec (*syntax.attributes)
        set attributes: Vector[Attribute]#(attr_vec.length)
        var i: size_t 0
        while i < attr_vec.length
        {
            let attr_ptr attr_vec.get(i)
            if attr_ptr <> null
            {
                let attr_syntax (*attr_ptr)
                let attr handle_attribute#(attr_syntax)
                attributes.put(i, attr)
            }
            set i: i + 1
        }
    }

    ; Create the Definition variant based on concept type
    let definition choose syntax.concept_
        when class_syntax: ClassSyntax
        {
            let structure handle_class#(name, path, class_syntax, is_private)
            Definition.Structure(structure)
        }
        when namespace_syntax: NamespaceSyntax
        {
            let namespace_ handle_namespace#(name, path, namespace_syntax, is_private)
            Definition.Namespace(namespace_)
        }
        when union_syntax: UnionSyntax
        {
            let union_ handle_union#(name, path, union_syntax, is_private)
            Definition.Union(union_)
        }
        when constant_syntax: ConstantSyntax
        {
            if constant_syntax.operation = null
            {
                ; Type alias
                let type_ref handle_type#(constant_syntax.type)
                Definition.Type(*type_ref)
            }
            else
            {
                ; Global constant
                let operation handle_operands#(constant_syntax.operation)
                let const_type handle_type#(constant_syntax.type)
                Definition.Global(Global(loc, *const_type, operation))
            }
        }
        when intrinsic_syntax: IntrinsicSyntax
            Definition.Intrinsic(Intrinsic(Span(intrinsic_syntax.start, intrinsic_syntax.end)))
        else
            Definition.Intrinsic(Intrinsic(loc))

    Concept(loc, name, parameters, attributes, definition)
}

; ============================================================================
; Module building
; ============================================================================

function build_module#(path: String, file_name: String, name: String, syntax: FileSyntax, is_private: bool) returns Module
{
    var symbols_builder HashMapBuilder[String, Nameable]$()

    ; Handle uses
    var uses Vector[Use]#(0)
    if syntax.uses <> null
    {
        let use_syns (*syntax.uses)
        set uses: Vector[Use]#(use_syns.length)
        var i: size_t 0
        while i < use_syns.length
        {
            let use_ptr use_syns.get(i)
            if use_ptr <> null
            {
                let use_syntax (*use_ptr)
                let use_ handle_use#(use_syntax)
                uses.put(i, use_)
            }
            set i: i + 1
        }
    }

    ; Handle declarations
    var modules Vector[Module]#(0)
    var members Vector[Member]#(0)
    if syntax.declarations <> null
    {
        let decl_syns (*syntax.declarations)
        set members: Vector[Member]#(decl_syns.length)
        var i: size_t 0
        while i < decl_syns.length
        {
            let decl_ptr decl_syns.get(i)
            if decl_ptr <> null
            {
                let decl_syntax (*decl_ptr)
                let member handle_declaration#(path, decl_syntax, &symbols_builder)
                members.put(i, member)
            }
            set i: i + 1
        }
    }

    let symbols HashMap[String, Nameable]#(symbols_builder)

    Module(
        is_private,
        file_name,
        name,
        modules,
        uses,
        members,
        symbols
    )
}

; ============================================================================
; Program building
; ============================================================================

function build_program#(file_name: String, program_name: String, syntax: ProgramSyntax) returns Program
{
    ; Handle packages
    var packages Vector[Module]#(0)

    ; Build main module
    let path String$("")
    let main_module build_module#(path, file_name, program_name, syntax.file, false)

    ; Handle top-level statements
    let statements handle_statements#(syntax.statements)

    Program(
        packages,
        main_module,
        statements
    )
}

; ============================================================================
; Test function
; ============================================================================

use scaly.scalyc.parser.Parser
use scaly.scalyc.parser.ParserError


function test() returns int
{
    ; Tests disabled - choose/when pattern bindings not yet working in JIT
    0
}
