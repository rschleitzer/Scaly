; parser.scaly - Generated from scaly.sgm
; DO NOT EDIT - generated by codegen

use scaly.containers.String
use scaly.containers.Vector
use scaly.memory.Page
use scaly.containers.Array
use scaly.containers.List
use scaly.containers.HashSet
use scaly.containers.HashSetBuilder

; Parser error types
define DifferentSyntax()
define InvalidSyntax(start: size_t, end: size_t, message: String)

define ParserError union (
    Different: DifferentSyntax
    Invalid: InvalidSyntax
)

; Syntax node definitions

define ThrownSyntax
(
    start: size_t
    end: size_t
)

define ReferenceSyntax
(
    start: size_t
    end: size_t
    location: String
)

define LocalSyntax
(
    start: size_t
    end: size_t
)

define CallSyntax
(
    start: size_t
    end: size_t
)

define LifetimeSyntax union (
    Call: CallSyntax
    Local: LocalSyntax
    Reference: ReferenceSyntax
    Thrown: ThrownSyntax
)

define ExtensionSyntax
(
    start: size_t
    end: size_t
    name: String
)

define NameSyntax
(
    start: size_t
    end: size_t
    name: String
    extensions: ref[Vector[ExtensionSyntax]]?
)

define TypeSyntax
(
    start: size_t
    end: size_t
    name: NameSyntax
    generics: ref[GenericArgumentsSyntax]?
    optional: ref[OptionalSyntax]?
    lifetime: ref[LifetimeSyntax]?
)

define AsSyntax
(
    start: size_t
    end: size_t
    type: TypeSyntax
)

define IsSyntax
(
    start: size_t
    end: size_t
    name: NameSyntax
)

define AlignOfSyntax
(
    start: size_t
    end: size_t
    type: TypeSyntax
)

define SizeOfSyntax
(
    start: size_t
    end: size_t
    type: TypeSyntax
)

define BlockSyntax
(
    start: size_t
    end: size_t
    uses: ref[Vector[UseSyntax]]?
    statements: ref[Vector[StatementSyntax]]?
)

define SetSyntax
(
    start: size_t
    end: size_t
    target: ref[Vector[OperandSyntax]]?
    source: ref[Vector[OperandSyntax]]?
)

define OperationSyntax
(
    start: size_t
    end: size_t
    operands: ref[Vector[OperandSyntax]]?
)

define ActionSyntax union (
    Operation: OperationSyntax
    Set: SetSyntax
    Block: BlockSyntax
)

define RepeatSyntax
(
    start: size_t
    end: size_t
    name: ref[LabelSyntax]?
    action: ActionSyntax
)

define LabelSyntax
(
    start: size_t
    end: size_t
    name: String
)

define ForSyntax
(
    start: size_t
    end: size_t
    variable: String
    annotation: ref[TypeAnnotationSyntax]?
    operation: ref[Vector[OperandSyntax]]?
    name: ref[LabelSyntax]?
    action: ActionSyntax
)

define LambdaSyntax
(
    start: size_t
    end: size_t
    input: ref[Vector[OperandSyntax]]?
    block: ActionSyntax
)

define ThrowSyntax
(
    start: size_t
    end: size_t
    result: ref[Vector[OperandSyntax]]?
)

define ReturnSyntax
(
    start: size_t
    end: size_t
    result: ref[Vector[OperandSyntax]]?
)

define LoopSyntax
(
    start: size_t
    end: size_t
    name: String
)

define BreakSyntax
(
    start: size_t
    end: size_t
    name: ref[LoopSyntax]?
    result: ref[Vector[OperandSyntax]]?
)

define ContinueSyntax
(
    start: size_t
    end: size_t
    name: ref[LoopSyntax]?
)

define TypeAnnotationSyntax
(
    start: size_t
    end: size_t
    type: TypeSyntax
)

define PropertySyntax
(
    start: size_t
    end: size_t
    name: String
    annotation: TypeAnnotationSyntax
    initializer: ref[InitializerSyntax]?
    attributes: ref[Vector[AttributeSyntax]]?
)

define FieldSyntax
(
    start: size_t
    end: size_t
    property: PropertySyntax
)

define PartSyntax union (
    Field: FieldSyntax
    Property: PropertySyntax
)

define StructureSyntax
(
    start: size_t
    end: size_t
    parts: ref[Vector[PartSyntax]]?
)

define ArraySyntax
(
    start: size_t
    end: size_t
    members: ref[Vector[TypeSyntax]]?
)

define BindingSpecSyntax union (
    Structure: StructureSyntax
    Type: TypeSyntax
    Array: ArraySyntax
)

define BindingAnnotationSyntax
(
    start: size_t
    end: size_t
    spec: BindingSpecSyntax
)

define BindingSyntax
(
    start: size_t
    end: size_t
    name: String
    annotation: ref[BindingAnnotationSyntax]?
    operation: ref[Vector[OperandSyntax]]?
)

define MutableSyntax
(
    start: size_t
    end: size_t
    binding: BindingSyntax
)

define VarSyntax
(
    start: size_t
    end: size_t
    binding: BindingSyntax
)

define LetSyntax
(
    start: size_t
    end: size_t
    binding: BindingSyntax
)

define CommandSyntax union (
    Operation: OperationSyntax
    Let: LetSyntax
    Var: VarSyntax
    Mutable: MutableSyntax
    Set: SetSyntax
    Continue: ContinueSyntax
    Break: BreakSyntax
    Return: ReturnSyntax
    Throw: ThrowSyntax
)

define WhenSyntax
(
    start: size_t
    end: size_t
    name: String
    variant: NameSyntax
    command: CommandSyntax
)

define ConditionSyntax union (
    Operation: OperationSyntax
    Let: LetSyntax
)

define TrySyntax
(
    start: size_t
    end: size_t
    condition: ConditionSyntax
    cases: ref[Vector[WhenSyntax]]?
    dropper: ref[ElseSyntax]?
)

define ChooseSyntax
(
    start: size_t
    end: size_t
    condition: ref[Vector[OperandSyntax]]?
    cases: ref[Vector[WhenSyntax]]?
    alternative: ref[ElseSyntax]?
)

define WhileSyntax
(
    start: size_t
    end: size_t
    condition: ConditionSyntax
    name: ref[LabelSyntax]?
    action: ActionSyntax
)

define StatementSyntax
(
    start: size_t
    end: size_t
    command: CommandSyntax
)

define CaseSyntax
(
    start: size_t
    end: size_t
    condition: ref[Vector[OperandSyntax]]?
)

define BranchSyntax
(
    start: size_t
    end: size_t
    cases: ref[Vector[CaseSyntax]]?
    consequent: StatementSyntax
)

define MatchSyntax
(
    start: size_t
    end: size_t
    scrutinee: ref[Vector[OperandSyntax]]?
    branches: ref[Vector[BranchSyntax]]?
    alternative: ref[ElseSyntax]?
)

define ElseSyntax
(
    start: size_t
    end: size_t
    alternative: CommandSyntax
)

define ThenSyntax
(
    start: size_t
    end: size_t
    command: CommandSyntax
)

define IfSyntax
(
    start: size_t
    end: size_t
    condition: ref[Vector[OperandSyntax]]?
    consequent: ThenSyntax
    alternative: ref[ElseSyntax]?
)

define ElementSyntax
(
    start: size_t
    end: size_t
    operation: ref[Vector[OperandSyntax]]?
    attributes: ref[Vector[AttributeSyntax]]?
)

define VectorSyntax
(
    start: size_t
    end: size_t
    elements: ref[Vector[ElementSyntax]]?
    lifetime: ref[LifetimeSyntax]?
)

define ValueSyntax
(
    start: size_t
    end: size_t
    value: ref[Vector[OperandSyntax]]?
    attributes: ref[Vector[AttributeSyntax]]?
)

define ComponentSyntax
(
    start: size_t
    end: size_t
    operands: ref[Vector[OperandSyntax]]?
    attributes: ref[Vector[AttributeSyntax]]?
    value: ref[ValueSyntax]?
)

define ObjectSyntax
(
    start: size_t
    end: size_t
    components: ref[Vector[ComponentSyntax]]?
)

define LiteralSyntax
(
    start: size_t
    end: size_t
    literal: Literal
)

define ExpressionSyntax union (
    Literal: LiteralSyntax
    Name: NameSyntax
    Object: ObjectSyntax
    Vector: VectorSyntax
    Block: BlockSyntax
    If: IfSyntax
    Match: MatchSyntax
    Lambda: LambdaSyntax
    For: ForSyntax
    While: WhileSyntax
    Choose: ChooseSyntax
    Try: TrySyntax
    Repeat: RepeatSyntax
    SizeOf: SizeOfSyntax
    AlignOf: AlignOfSyntax
    Is: IsSyntax
    As: AsSyntax
    Lifetime: LifetimeSyntax
)

define MemberAccessSyntax
(
    start: size_t
    end: size_t
    name: NameSyntax
)

define OperandSyntax
(
    start: size_t
    end: size_t
    expression: ExpressionSyntax
    members: ref[Vector[MemberAccessSyntax]]?
)

define InitializerSyntax
(
    start: size_t
    end: size_t
    operands: ref[Vector[OperandSyntax]]?
)

define VersionSyntax
(
    start: size_t
    end: size_t
    majorMinor: Literal
    patch: Literal
)

define PackageSyntax
(
    start: size_t
    end: size_t
    name: NameSyntax
    version: ref[VersionSyntax]?
)

define ModuleSyntax
(
    start: size_t
    end: size_t
    name: String
)

define ModelSyntax union (
    Literal: LiteralSyntax
    Name: NameSyntax
    Object: ObjectSyntax
    Vector: VectorSyntax
)

define AttributeSyntax
(
    start: size_t
    end: size_t
    name: String
    model: ModelSyntax
)

define MacroSyntax
(
    start: size_t
    end: size_t
    name: String
    model: ModelSyntax
    rule: ref[Vector[OperandSyntax]]?
)

define ExtendSyntax
(
    start: size_t
    end: size_t
    type: TypeSyntax
)

define ExtendsSyntax
(
    start: size_t
    end: size_t
    extensions: ref[Vector[ExtendSyntax]]?
)

define IntrinsicSyntax
(
    start: size_t
    end: size_t
)

define InstructionSyntax
(
    start: size_t
    end: size_t
)

define ExternSyntax
(
    start: size_t
    end: size_t
)

define ImplementationSyntax union (
    Action: ActionSyntax
    Extern: ExternSyntax
    Instruction: InstructionSyntax
    Intrinsic: IntrinsicSyntax
)

define RoutineSyntax
(
    start: size_t
    end: size_t
    generics: ref[GenericArgumentsSyntax]?
    lifetime: ref[LifetimeSyntax]?
    parameters: ref[ParameterSetSyntax]?
    attributes: ref[Vector[AttributeSyntax]]?
    returns_: ref[ReturnsSyntax]?
    throws_: ref[ThrowsSyntax]?
    implementation: ImplementationSyntax
)

define NamedSyntax
(
    start: size_t
    end: size_t
    name: String
    routine: RoutineSyntax
)

define TargetSyntax union (
    Named: NamedSyntax
    Routine: RoutineSyntax
)

define OperatorSyntax
(
    start: size_t
    end: size_t
    target: TargetSyntax
)

define ProcedureSyntax
(
    start: size_t
    end: size_t
    target: TargetSyntax
)

define FunctionSyntax
(
    start: size_t
    end: size_t
    target: TargetSyntax
)

define DeInitSyntax
(
    start: size_t
    end: size_t
    action: ActionSyntax
)

define InitSyntax
(
    start: size_t
    end: size_t
    lifetime: ref[LifetimeSyntax]?
    parameters: ref[ParameterSetSyntax]?
    action: ActionSyntax
)

define MethodSyntax union (
    Function: FunctionSyntax
    Procedure: ProcedureSyntax
    Operator: OperatorSyntax
)

define TraitSyntax
(
    start: size_t
    end: size_t
    name: NameSyntax
    extension: ref[ExtendsSyntax]?
    attributes: ref[Vector[AttributeSyntax]]?
    uses: ref[Vector[UseSyntax]]?
    functions: ref[Vector[MethodSyntax]]?
)

define ImplementSyntax
(
    start: size_t
    end: size_t
    type: TypeSyntax
    attributes: ref[Vector[AttributeSyntax]]?
    uses: ref[Vector[UseSyntax]]?
    methods: ref[Vector[MethodSyntax]]?
)

define UseSyntax
(
    start: size_t
    end: size_t
    name: NameSyntax
)

define ThrowsSyntax
(
    start: size_t
    end: size_t
    type: TypeSyntax
    attributes: ref[Vector[AttributeSyntax]]?
)

define ReturnsSyntax
(
    start: size_t
    end: size_t
    type: TypeSyntax
    attributes: ref[Vector[AttributeSyntax]]?
)

define ItemSyntax
(
    start: size_t
    end: size_t
    name: String
    annotation: ref[TypeAnnotationSyntax]?
    attributes: ref[Vector[AttributeSyntax]]?
)

define ParametersSyntax
(
    start: size_t
    end: size_t
    items: ref[Vector[ItemSyntax]]?
)

define ParameterSetSyntax union (
    Parameters: ParametersSyntax
    Type: TypeSyntax
)

define OptionalSyntax
(
    start: size_t
    end: size_t
)

define GenericArgumentSyntax
(
    start: size_t
    end: size_t
    type: TypeSyntax
)

define GenericArgumentsSyntax
(
    start: size_t
    end: size_t
    generics: ref[Vector[GenericArgumentSyntax]]?
)

define DelegateSyntax
(
    start: size_t
    end: size_t
    parameters: ref[ParameterSetSyntax]?
    attributes: ref[Vector[AttributeSyntax]]?
    result: ref[ReturnsSyntax]?
    error: ref[ThrowsSyntax]?
)

define ConstantSyntax
(
    start: size_t
    end: size_t
    type: TypeSyntax
    operation: ref[Vector[OperandSyntax]]?
)

define VariantSyntax
(
    start: size_t
    end: size_t
    name: String
    attributes: ref[Vector[AttributeSyntax]]?
    annotation: ref[TypeAnnotationSyntax]?
)

define UnionSyntax
(
    start: size_t
    end: size_t
    variants: ref[Vector[VariantSyntax]]?
    body: ref[BodySyntax]?
)

define NamespaceSyntax
(
    start: size_t
    end: size_t
    uses: ref[Vector[UseSyntax]]?
    declarations: ref[Vector[DeclarationSyntax]]?
)

define BodySyntax
(
    start: size_t
    end: size_t
    uses: ref[Vector[UseSyntax]]?
    inits: ref[Vector[InitSyntax]]?
    deInit: ref[DeInitSyntax]?
    members: ref[Vector[MemberSyntax]]?
)

define ClassSyntax
(
    start: size_t
    end: size_t
    structure: StructureSyntax
    body: ref[BodySyntax]?
)

define ConceptSyntax union (
    Class: ClassSyntax
    Namespace: NamespaceSyntax
    Union: UnionSyntax
    Constant: ConstantSyntax
    Delegate: DelegateSyntax
    Intrinsic: IntrinsicSyntax
)

define GenericParameterSyntax
(
    start: size_t
    end: size_t
    name: String
    attributes: ref[Vector[AttributeSyntax]]?
)

define GenericParametersSyntax
(
    start: size_t
    end: size_t
    parameters: ref[Vector[GenericParameterSyntax]]?
)

define DefinitionSyntax
(
    start: size_t
    end: size_t
    name: String
    parameters: ref[GenericParametersSyntax]?
    attributes: ref[Vector[AttributeSyntax]]?
    concept_: ConceptSyntax
)

define ConstituentSyntax union (
    Definition: DefinitionSyntax
    Function: FunctionSyntax
    Procedure: ProcedureSyntax
    Operator: OperatorSyntax
    Implement: ImplementSyntax
    Trait: TraitSyntax
    Macro: MacroSyntax
    Module: ModuleSyntax
)

define MemberSyntax
(
    start: size_t
    end: size_t
    constituent: ConstituentSyntax
)

define ExportSyntax union (
    Definition: DefinitionSyntax
    Function: FunctionSyntax
    Operator: OperatorSyntax
    Trait: TraitSyntax
    Module: ModuleSyntax
)

define PrivateSyntax
(
    start: size_t
    end: size_t
    export_: ExportSyntax
)

define SymbolSyntax union (
    Private: PrivateSyntax
    Definition: DefinitionSyntax
    Function: FunctionSyntax
    Operator: OperatorSyntax
    Trait: TraitSyntax
    Macro: MacroSyntax
    Module: ModuleSyntax
)

define DeclarationSyntax
(
    start: size_t
    end: size_t
    symbol: SymbolSyntax
)

define FileSyntax
(
    start: size_t
    end: size_t
    packages: ref[Vector[PackageSyntax]]?
    uses: ref[Vector[UseSyntax]]?
    declarations: ref[Vector[DeclarationSyntax]]?
)

define ProgramSyntax
(
    start: size_t
    end: size_t
    file: FileSyntax
    statements: ref[Vector[StatementSyntax]]?
)

; Lexer import (uses its own char constants)
module lexer

; Character constants for punctuation (char literals use double-quote + type annotation)
define ParserConstants
{
    function CHAR_LPAREN() returns char
        "(" as char
    function CHAR_RPAREN() returns char
        ")" as char
    function CHAR_LBRACKET() returns char
        "[" as char
    function CHAR_RBRACKET() returns char
        "]" as char
    function CHAR_LBRACE() returns char
        "{" as char
    function CHAR_RBRACE() returns char
        "}" as char
    function CHAR_COMMA() returns char
        "," as char
    function CHAR_DOT() returns char
        "." as char
    function CHAR_EXCL() returns char
        "!" as char
    function CHAR_QUESTION() returns char
        "?" as char
    function CHAR_HASH() returns char
        "#" as char
    function CHAR_DOLLAR() returns char
        "$" as char
    function CHAR_CARET() returns char
        "^" as char
    function CHAR_BACKSLASH() returns char
        "\\" as char
}

define Parser
(
    lexer: Lexer
    keywords_index: Vector[String]
    keywords: HashSet[String]
)
{
    init#(rp, text: String)
    {
        set lexer: Lexer(text)
        set keywords_index: initialize_keywords_index#()
        set keywords: initialize_keywords#()
    }

    function initialize_keywords_index#(rp, this: Parser) returns Vector[String]
    {
        var keywords_builder Array[String]$()
        keywords_builder.add(String$("alignof"))
        keywords_builder.add(String$("as"))
        keywords_builder.add(String$("break"))
        keywords_builder.add(String$("case"))
        keywords_builder.add(String$("choose"))
        keywords_builder.add(String$("continue"))
        keywords_builder.add(String$("define"))
        keywords_builder.add(String$("deinit"))
        keywords_builder.add(String$("delegate"))
        keywords_builder.add(String$("else"))
        keywords_builder.add(String$("extends"))
        keywords_builder.add(String$("extern"))
        keywords_builder.add(String$("for"))
        keywords_builder.add(String$("function"))
        keywords_builder.add(String$("if"))
        keywords_builder.add(String$("is"))
        keywords_builder.add(String$("init"))
        keywords_builder.add(String$("implement"))
        keywords_builder.add(String$("in"))
        keywords_builder.add(String$("instruction"))
        keywords_builder.add(String$("intrinsic"))
        keywords_builder.add(String$("label"))
        keywords_builder.add(String$("let"))
        keywords_builder.add(String$("loop"))
        keywords_builder.add(String$("macro"))
        keywords_builder.add(String$("match"))
        keywords_builder.add(String$("module"))
        keywords_builder.add(String$("mutable"))
        keywords_builder.add(String$("operator"))
        keywords_builder.add(String$("procedure"))
        keywords_builder.add(String$("private"))
        keywords_builder.add(String$("return"))
        keywords_builder.add(String$("returns"))
        keywords_builder.add(String$("repeat"))
        keywords_builder.add(String$("set"))
        keywords_builder.add(String$("sizeof"))
        keywords_builder.add(String$("throw"))
        keywords_builder.add(String$("throws"))
        keywords_builder.add(String$("trait"))
        keywords_builder.add(String$("try"))
        keywords_builder.add(String$("union"))
        keywords_builder.add(String$("use"))
        keywords_builder.add(String$("var"))
        keywords_builder.add(String$("when"))
        keywords_builder.add(String$("while"))
        keywords_builder.add(String$("package"))
        Vector[String]#(keywords_builder)
    }

    function initialize_keywords#(rp, this: Parser) returns HashSet[String]
    {
        var hash_set_builder HashSetBuilder[String]$(keywords_index)
        HashSet[String]#(hash_set_builder)
    }

    function parse_literal_token#(rp, this: Parser) returns Literal throws ParserError
    {
        choose lexer.token
            when empty: Empty
                lexer.advance#()
            else {}

        choose lexer.token
            when literal: Literal
            {
                let ret literal.value
                lexer.empty()
                return ret
            }
            else
                throw ParserError.Different(DifferentSyntax())
    }

    function parse_program#(rp, this: Parser) returns ProgramSyntax throws ParserError
    {
        let start lexer.previous_position

        let file_start lexer.position
        var file: FileSyntax
        choose parse_file#()
            when err: Error
                throw err
            when success: Success
                set file: success

        let statements_start lexer.position
        var statements: ref[Vector[StatementSyntax]]? null
        choose parse_statement_list#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set statements: success

        let end lexer.position

        ProgramSyntax(start, end, file, statements)
    }

    function parse_file#(rp, this: Parser) returns FileSyntax throws ParserError
    {
        let start lexer.previous_position

        let packages_start lexer.position
        var packages: ref[Vector[PackageSyntax]]? null
        choose parse_package_list#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set packages: success

        let uses_start lexer.position
        var uses: ref[Vector[UseSyntax]]? null
        choose parse_use_list#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set uses: success

        let declarations_start lexer.position
        var declarations: ref[Vector[DeclarationSyntax]]? null
        choose parse_declaration_list#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set declarations: success

        let end lexer.position

        FileSyntax(start, end, packages, uses, declarations)
    }

    function parse_declaration_list#(rp, this: Parser) returns ref[Vector[DeclarationSyntax]]? throws ParserError
    {
        var list List[DeclarationSyntax]$()
        while true
        {
            choose parse_declaration#()
                when err: Error
                {
                    choose err
                        when i: Invalid
                            throw ParserError.Invalid(i)
                        when d: Different
                        {
                            if list.head = null
                                throw ParserError.Different(d)
                            else
                                return Vector[DeclarationSyntax]#(list)
                        }
                }
                when node: Success
                    list.add$(node)
        }
    }

    function parse_declaration#(rp, this: Parser) returns DeclarationSyntax throws ParserError
    {
        let start lexer.previous_position

        let symbol_start lexer.position
        var symbol: SymbolSyntax
        choose parse_symbol#()
            when err: Error
                throw err
            when success: Success
                set symbol: success

        lexer.parse_colon#()

        let end lexer.position

        DeclarationSyntax(start, end, symbol)
    }

    function parse_symbol#(rp, this: Parser) returns SymbolSyntax throws ParserError
    {
        choose parse_private#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return SymbolSyntax.Private(node)
        choose parse_definition#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return SymbolSyntax.Definition(node)
        choose parse_function#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return SymbolSyntax.Function(node)
        choose parse_operator#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return SymbolSyntax.Operator(node)
        choose parse_trait#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return SymbolSyntax.Trait(node)
        choose parse_macro#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return SymbolSyntax.Macro(node)
        choose parse_module#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return SymbolSyntax.Module(node)
        throw ParserError.Different(DifferentSyntax())
    }

    function parse_private#(rp, this: Parser) returns PrivateSyntax throws ParserError
    {
        let start lexer.previous_position

        if ~lexer.parse_keyword#(String$("private"))
            throw ParserError.Different(DifferentSyntax())

        let export__start lexer.position
        var export_: ExportSyntax
        choose parse_export#()
            when err: Error
            {
                choose err
                    when d: Different
                        throw ParserError.Invalid(InvalidSyntax(export__start, lexer.position, String$("expected Export")))
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set export_: success

        let end lexer.position

        PrivateSyntax(start, end, export_)
    }

    function parse_export#(rp, this: Parser) returns ExportSyntax throws ParserError
    {
        choose parse_definition#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return ExportSyntax.Definition(node)
        choose parse_function#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return ExportSyntax.Function(node)
        choose parse_operator#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return ExportSyntax.Operator(node)
        choose parse_trait#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return ExportSyntax.Trait(node)
        choose parse_module#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return ExportSyntax.Module(node)
        throw ParserError.Different(DifferentSyntax())
    }

    function parse_member_list#(rp, this: Parser) returns ref[Vector[MemberSyntax]]? throws ParserError
    {
        var list List[MemberSyntax]$()
        while true
        {
            choose parse_member#()
                when err: Error
                {
                    choose err
                        when i: Invalid
                            throw ParserError.Invalid(i)
                        when d: Different
                        {
                            if list.head = null
                                throw ParserError.Different(d)
                            else
                                return Vector[MemberSyntax]#(list)
                        }
                }
                when node: Success
                    list.add$(node)
        }
    }

    function parse_member#(rp, this: Parser) returns MemberSyntax throws ParserError
    {
        let start lexer.previous_position

        let constituent_start lexer.position
        var constituent: ConstituentSyntax
        choose parse_constituent#()
            when err: Error
                throw err
            when success: Success
                set constituent: success

        lexer.parse_colon#()

        let end lexer.position

        MemberSyntax(start, end, constituent)
    }

    function parse_constituent#(rp, this: Parser) returns ConstituentSyntax throws ParserError
    {
        choose parse_definition#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return ConstituentSyntax.Definition(node)
        choose parse_function#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return ConstituentSyntax.Function(node)
        choose parse_procedure#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return ConstituentSyntax.Procedure(node)
        choose parse_operator#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return ConstituentSyntax.Operator(node)
        choose parse_implement#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return ConstituentSyntax.Implement(node)
        choose parse_trait#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return ConstituentSyntax.Trait(node)
        choose parse_macro#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return ConstituentSyntax.Macro(node)
        choose parse_module#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return ConstituentSyntax.Module(node)
        throw ParserError.Different(DifferentSyntax())
    }

    function parse_definition#(rp, this: Parser) returns DefinitionSyntax throws ParserError
    {
        let start lexer.previous_position

        if ~lexer.parse_keyword#(String$("define"))
            throw ParserError.Different(DifferentSyntax())

        let name lexer.parse_identifier#(keywords)
        if name.length() = 0
            throw ParserError.Invalid(InvalidSyntax(start, lexer.position, String$("expected identifier")))

        let parameters_start lexer.position
        var parameters: ref[GenericParametersSyntax]? null
        choose parse_genericparameters#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set parameters: success

        lexer.parse_colon#()

        let attributes_start lexer.position
        var attributes: ref[Vector[AttributeSyntax]]? null
        choose parse_attribute_list#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set attributes: success

        let concept__start lexer.position
        var concept_: ConceptSyntax
        choose parse_concept#()
            when err: Error
            {
                choose err
                    when d: Different
                        throw ParserError.Invalid(InvalidSyntax(concept__start, lexer.position, String$("expected Concept")))
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set concept_: success

        let end lexer.position

        DefinitionSyntax(start, end, name, parameters, attributes, concept_)
    }

    function parse_genericparameters#(rp, this: Parser) returns GenericParametersSyntax throws ParserError
    {
        let start lexer.previous_position

        if ~lexer.parse_punctuation#(ParserConstants.CHAR_LBRACKET())
            throw ParserError.Different(DifferentSyntax())

        let parameters_start lexer.position
        var parameters: ref[Vector[GenericParameterSyntax]]?
        choose parse_genericparameter_list#()
            when err: Error
            {
                choose err
                    when d: Different
                        throw ParserError.Invalid(InvalidSyntax(parameters_start, lexer.position, String$("expected GenericParameter")))
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set parameters: success

        if ~lexer.parse_punctuation#(ParserConstants.CHAR_RBRACKET())
            throw ParserError.Invalid(InvalidSyntax(start, lexer.position, String$("expected ']'")))

        let end lexer.position

        GenericParametersSyntax(start, end, parameters)
    }

    function parse_genericparameter_list#(rp, this: Parser) returns ref[Vector[GenericParameterSyntax]]? throws ParserError
    {
        var list List[GenericParameterSyntax]$()
        while true
        {
            choose parse_genericparameter#()
                when err: Error
                {
                    choose err
                        when i: Invalid
                            throw ParserError.Invalid(i)
                        when d: Different
                        {
                            if list.head = null
                                throw ParserError.Different(d)
                            else
                                return Vector[GenericParameterSyntax]#(list)
                        }
                }
                when node: Success
                    list.add$(node)
        }
    }

    function parse_genericparameter#(rp, this: Parser) returns GenericParameterSyntax throws ParserError
    {
        let start lexer.previous_position

        let name lexer.parse_identifier#(keywords)
        if name.length() = 0
            throw ParserError.Different(DifferentSyntax())

        let attributes_start lexer.position
        var attributes: ref[Vector[AttributeSyntax]]? null
        choose parse_attribute_list#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set attributes: success

        lexer.parse_punctuation#(ParserConstants.CHAR_COMMA())

        let end lexer.position

        GenericParameterSyntax(start, end, name, attributes)
    }

    function parse_concept#(rp, this: Parser) returns ConceptSyntax throws ParserError
    {
        choose parse_class#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return ConceptSyntax.Class(node)
        choose parse_namespace#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return ConceptSyntax.Namespace(node)
        choose parse_union#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return ConceptSyntax.Union(node)
        choose parse_constant#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return ConceptSyntax.Constant(node)
        choose parse_delegate#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return ConceptSyntax.Delegate(node)
        choose parse_intrinsic#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return ConceptSyntax.Intrinsic(node)
        throw ParserError.Different(DifferentSyntax())
    }

    function parse_class#(rp, this: Parser) returns ClassSyntax throws ParserError
    {
        let start lexer.previous_position

        let structure_start lexer.position
        var structure: StructureSyntax
        choose parse_structure#()
            when err: Error
                throw err
            when success: Success
                set structure: success

        lexer.parse_colon#()

        let body_start lexer.position
        var body: ref[BodySyntax]? null
        choose parse_body#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set body: success

        lexer.parse_colon#()

        let end lexer.position

        ClassSyntax(start, end, structure, body)
    }

    function parse_body#(rp, this: Parser) returns BodySyntax throws ParserError
    {
        let start lexer.previous_position

        if ~lexer.parse_punctuation#(ParserConstants.CHAR_LBRACE())
            throw ParserError.Different(DifferentSyntax())

        let uses_start lexer.position
        var uses: ref[Vector[UseSyntax]]? null
        choose parse_use_list#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set uses: success

        let inits_start lexer.position
        var inits: ref[Vector[InitSyntax]]? null
        choose parse_init_list#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set inits: success

        let deInit_start lexer.position
        var deInit: ref[DeInitSyntax]? null
        choose parse_deinit#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set deInit: success

        let members_start lexer.position
        var members: ref[Vector[MemberSyntax]]? null
        choose parse_member_list#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set members: success

        if ~lexer.parse_punctuation#(ParserConstants.CHAR_RBRACE())
            throw ParserError.Invalid(InvalidSyntax(start, lexer.position, String$("expected '}'")))

        lexer.parse_colon#()

        let end lexer.position

        BodySyntax(start, end, uses, inits, deInit, members)
    }

    function parse_namespace#(rp, this: Parser) returns NamespaceSyntax throws ParserError
    {
        let start lexer.previous_position

        if ~lexer.parse_punctuation#(ParserConstants.CHAR_LBRACE())
            throw ParserError.Different(DifferentSyntax())

        let uses_start lexer.position
        var uses: ref[Vector[UseSyntax]]? null
        choose parse_use_list#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set uses: success

        let declarations_start lexer.position
        var declarations: ref[Vector[DeclarationSyntax]]? null
        choose parse_declaration_list#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set declarations: success

        if ~lexer.parse_punctuation#(ParserConstants.CHAR_RBRACE())
            throw ParserError.Invalid(InvalidSyntax(start, lexer.position, String$("expected '}'")))

        lexer.parse_colon#()

        let end lexer.position

        NamespaceSyntax(start, end, uses, declarations)
    }

    function parse_union#(rp, this: Parser) returns UnionSyntax throws ParserError
    {
        let start lexer.previous_position

        if ~lexer.parse_keyword#(String$("union"))
            throw ParserError.Different(DifferentSyntax())

        lexer.parse_colon#()

        if ~lexer.parse_punctuation#(ParserConstants.CHAR_LPAREN())
            throw ParserError.Invalid(InvalidSyntax(start, lexer.position, String$("expected '('")))

        let variants_start lexer.position
        var variants: ref[Vector[VariantSyntax]]?
        choose parse_variant_list#()
            when err: Error
            {
                choose err
                    when d: Different
                        throw ParserError.Invalid(InvalidSyntax(variants_start, lexer.position, String$("expected Variant")))
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set variants: success

        if ~lexer.parse_punctuation#(ParserConstants.CHAR_RPAREN())
            throw ParserError.Invalid(InvalidSyntax(start, lexer.position, String$("expected ')'")))

        lexer.parse_colon#()

        let body_start lexer.position
        var body: ref[BodySyntax]? null
        choose parse_body#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set body: success

        lexer.parse_colon#()

        let end lexer.position

        UnionSyntax(start, end, variants, body)
    }

    function parse_variant_list#(rp, this: Parser) returns ref[Vector[VariantSyntax]]? throws ParserError
    {
        var list List[VariantSyntax]$()
        while true
        {
            choose parse_variant#()
                when err: Error
                {
                    choose err
                        when i: Invalid
                            throw ParserError.Invalid(i)
                        when d: Different
                        {
                            if list.head = null
                                throw ParserError.Different(d)
                            else
                                return Vector[VariantSyntax]#(list)
                        }
                }
                when node: Success
                    list.add$(node)
        }
    }

    function parse_variant#(rp, this: Parser) returns VariantSyntax throws ParserError
    {
        let start lexer.previous_position

        let name lexer.parse_identifier#(keywords)
        if name.length() = 0
            throw ParserError.Different(DifferentSyntax())

        let attributes_start lexer.position
        var attributes: ref[Vector[AttributeSyntax]]? null
        choose parse_attribute_list#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set attributes: success

        let annotation_start lexer.position
        var annotation: ref[TypeAnnotationSyntax]? null
        choose parse_typeannotation#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set annotation: success

        lexer.parse_punctuation#(ParserConstants.CHAR_COMMA())

        lexer.parse_colon#()

        let end lexer.position

        VariantSyntax(start, end, name, attributes, annotation)
    }

    function parse_constant#(rp, this: Parser) returns ConstantSyntax throws ParserError
    {
        let start lexer.previous_position

        let type_start lexer.position
        var type: TypeSyntax
        choose parse_type#()
            when err: Error
                throw err
            when success: Success
                set type: success

        let operation_start lexer.position
        var operation: ref[Vector[OperandSyntax]]? null
        choose parse_operand_list#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set operation: success

        lexer.parse_colon#()

        let end lexer.position

        ConstantSyntax(start, end, type, operation)
    }

    function parse_delegate#(rp, this: Parser) returns DelegateSyntax throws ParserError
    {
        let start lexer.previous_position

        if ~lexer.parse_keyword#(String$("delegate"))
            throw ParserError.Different(DifferentSyntax())

        let parameters_start lexer.position
        var parameters: ref[ParameterSetSyntax]? null
        choose parse_parameterset#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set parameters: success

        let attributes_start lexer.position
        var attributes: ref[Vector[AttributeSyntax]]? null
        choose parse_attribute_list#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set attributes: success

        let result_start lexer.position
        var result: ref[ReturnsSyntax]? null
        choose parse_returns#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set result: success

        let error_start lexer.position
        var error: ref[ThrowsSyntax]? null
        choose parse_throws#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set error: success

        let end lexer.position

        DelegateSyntax(start, end, parameters, attributes, result, error)
    }

    function parse_genericarguments#(rp, this: Parser) returns GenericArgumentsSyntax throws ParserError
    {
        let start lexer.previous_position

        if ~lexer.parse_punctuation#(ParserConstants.CHAR_LBRACKET())
            throw ParserError.Different(DifferentSyntax())

        let generics_start lexer.position
        var generics: ref[Vector[GenericArgumentSyntax]]? null
        choose parse_genericargument_list#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set generics: success

        if ~lexer.parse_punctuation#(ParserConstants.CHAR_RBRACKET())
            throw ParserError.Invalid(InvalidSyntax(start, lexer.position, String$("expected ']'")))

        let end lexer.position

        GenericArgumentsSyntax(start, end, generics)
    }

    function parse_genericargument_list#(rp, this: Parser) returns ref[Vector[GenericArgumentSyntax]]? throws ParserError
    {
        var list List[GenericArgumentSyntax]$()
        while true
        {
            choose parse_genericargument#()
                when err: Error
                {
                    choose err
                        when i: Invalid
                            throw ParserError.Invalid(i)
                        when d: Different
                        {
                            if list.head = null
                                throw ParserError.Different(d)
                            else
                                return Vector[GenericArgumentSyntax]#(list)
                        }
                }
                when node: Success
                    list.add$(node)
        }
    }

    function parse_genericargument#(rp, this: Parser) returns GenericArgumentSyntax throws ParserError
    {
        let start lexer.previous_position

        let type_start lexer.position
        var type: TypeSyntax
        choose parse_type#()
            when err: Error
                throw err
            when success: Success
                set type: success

        lexer.parse_punctuation#(ParserConstants.CHAR_COMMA())

        let end lexer.position

        GenericArgumentSyntax(start, end, type)
    }

    function parse_optional#(rp, this: Parser) returns OptionalSyntax throws ParserError
    {
        let start lexer.previous_position

        if ~lexer.parse_punctuation#(ParserConstants.CHAR_QUESTION())
            throw ParserError.Different(DifferentSyntax())

        let end lexer.position

        OptionalSyntax(start, end)
    }

    function parse_parameterset#(rp, this: Parser) returns ParameterSetSyntax throws ParserError
    {
        choose parse_parameters#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return ParameterSetSyntax.Parameters(node)
        choose parse_type#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return ParameterSetSyntax.Type(node)
        throw ParserError.Different(DifferentSyntax())
    }

    function parse_parameters#(rp, this: Parser) returns ParametersSyntax throws ParserError
    {
        let start lexer.previous_position

        if ~lexer.parse_punctuation#(ParserConstants.CHAR_LPAREN())
            throw ParserError.Different(DifferentSyntax())

        let items_start lexer.position
        var items: ref[Vector[ItemSyntax]]? null
        choose parse_item_list#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set items: success

        if ~lexer.parse_punctuation#(ParserConstants.CHAR_RPAREN())
            throw ParserError.Invalid(InvalidSyntax(start, lexer.position, String$("expected ')'")))

        let end lexer.position

        ParametersSyntax(start, end, items)
    }

    function parse_item_list#(rp, this: Parser) returns ref[Vector[ItemSyntax]]? throws ParserError
    {
        var list List[ItemSyntax]$()
        while true
        {
            choose parse_item#()
                when err: Error
                {
                    choose err
                        when i: Invalid
                            throw ParserError.Invalid(i)
                        when d: Different
                        {
                            if list.head = null
                                throw ParserError.Different(d)
                            else
                                return Vector[ItemSyntax]#(list)
                        }
                }
                when node: Success
                    list.add$(node)
        }
    }

    function parse_item#(rp, this: Parser) returns ItemSyntax throws ParserError
    {
        let start lexer.previous_position

        let name lexer.parse_identifier#(keywords)
        if name.length() = 0
            throw ParserError.Different(DifferentSyntax())

        let annotation_start lexer.position
        var annotation: ref[TypeAnnotationSyntax]? null
        choose parse_typeannotation#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set annotation: success

        lexer.parse_punctuation#(ParserConstants.CHAR_COMMA())

        lexer.parse_colon#()

        let attributes_start lexer.position
        var attributes: ref[Vector[AttributeSyntax]]? null
        choose parse_attribute_list#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set attributes: success

        lexer.parse_colon#()

        let end lexer.position

        ItemSyntax(start, end, name, annotation, attributes)
    }

    function parse_returns#(rp, this: Parser) returns ReturnsSyntax throws ParserError
    {
        let start lexer.previous_position

        if ~lexer.parse_keyword#(String$("returns"))
            throw ParserError.Different(DifferentSyntax())

        let type_start lexer.position
        var type: TypeSyntax
        choose parse_type#()
            when err: Error
            {
                choose err
                    when d: Different
                        throw ParserError.Invalid(InvalidSyntax(type_start, lexer.position, String$("expected Type")))
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set type: success

        let attributes_start lexer.position
        var attributes: ref[Vector[AttributeSyntax]]? null
        choose parse_attribute_list#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set attributes: success

        let end lexer.position

        ReturnsSyntax(start, end, type, attributes)
    }

    function parse_throws#(rp, this: Parser) returns ThrowsSyntax throws ParserError
    {
        let start lexer.previous_position

        if ~lexer.parse_keyword#(String$("throws"))
            throw ParserError.Different(DifferentSyntax())

        let type_start lexer.position
        var type: TypeSyntax
        choose parse_type#()
            when err: Error
            {
                choose err
                    when d: Different
                        throw ParserError.Invalid(InvalidSyntax(type_start, lexer.position, String$("expected Type")))
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set type: success

        let attributes_start lexer.position
        var attributes: ref[Vector[AttributeSyntax]]? null
        choose parse_attribute_list#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set attributes: success

        let end lexer.position

        ThrowsSyntax(start, end, type, attributes)
    }

    function parse_use_list#(rp, this: Parser) returns ref[Vector[UseSyntax]]? throws ParserError
    {
        var list List[UseSyntax]$()
        while true
        {
            choose parse_use#()
                when err: Error
                {
                    choose err
                        when i: Invalid
                            throw ParserError.Invalid(i)
                        when d: Different
                        {
                            if list.head = null
                                throw ParserError.Different(d)
                            else
                                return Vector[UseSyntax]#(list)
                        }
                }
                when node: Success
                    list.add$(node)
        }
    }

    function parse_use#(rp, this: Parser) returns UseSyntax throws ParserError
    {
        let start lexer.previous_position

        if ~lexer.parse_keyword#(String$("use"))
            throw ParserError.Different(DifferentSyntax())

        let name_start lexer.position
        var name: NameSyntax
        choose parse_name#()
            when err: Error
            {
                choose err
                    when d: Different
                        throw ParserError.Invalid(InvalidSyntax(name_start, lexer.position, String$("expected Name")))
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set name: success

        lexer.parse_colon#()

        let end lexer.position

        UseSyntax(start, end, name)
    }

    function parse_implement#(rp, this: Parser) returns ImplementSyntax throws ParserError
    {
        let start lexer.previous_position

        if ~lexer.parse_keyword#(String$("implement"))
            throw ParserError.Different(DifferentSyntax())

        let type_start lexer.position
        var type: TypeSyntax
        choose parse_type#()
            when err: Error
            {
                choose err
                    when d: Different
                        throw ParserError.Invalid(InvalidSyntax(type_start, lexer.position, String$("expected Type")))
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set type: success

        let attributes_start lexer.position
        var attributes: ref[Vector[AttributeSyntax]]? null
        choose parse_attribute_list#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set attributes: success

        lexer.parse_colon#()

        if ~lexer.parse_punctuation#(ParserConstants.CHAR_LBRACE())
            throw ParserError.Invalid(InvalidSyntax(start, lexer.position, String$("expected '{'")))

        let uses_start lexer.position
        var uses: ref[Vector[UseSyntax]]? null
        choose parse_use_list#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set uses: success

        let methods_start lexer.position
        var methods: ref[Vector[MethodSyntax]]? null
        choose parse_method_list#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set methods: success

        if ~lexer.parse_punctuation#(ParserConstants.CHAR_RBRACE())
            throw ParserError.Invalid(InvalidSyntax(start, lexer.position, String$("expected '}'")))

        lexer.parse_colon#()

        let end lexer.position

        ImplementSyntax(start, end, type, attributes, uses, methods)
    }

    function parse_trait#(rp, this: Parser) returns TraitSyntax throws ParserError
    {
        let start lexer.previous_position

        if ~lexer.parse_keyword#(String$("trait"))
            throw ParserError.Different(DifferentSyntax())

        let name_start lexer.position
        var name: NameSyntax
        choose parse_name#()
            when err: Error
            {
                choose err
                    when d: Different
                        throw ParserError.Invalid(InvalidSyntax(name_start, lexer.position, String$("expected Name")))
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set name: success

        let extension_start lexer.position
        var extension: ref[ExtendsSyntax]? null
        choose parse_extends#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set extension: success

        let attributes_start lexer.position
        var attributes: ref[Vector[AttributeSyntax]]? null
        choose parse_attribute_list#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set attributes: success

        if ~lexer.parse_punctuation#(ParserConstants.CHAR_LBRACE())
            throw ParserError.Invalid(InvalidSyntax(start, lexer.position, String$("expected '{'")))

        let uses_start lexer.position
        var uses: ref[Vector[UseSyntax]]? null
        choose parse_use_list#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set uses: success

        let functions_start lexer.position
        var functions: ref[Vector[MethodSyntax]]? null
        choose parse_method_list#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set functions: success

        if ~lexer.parse_punctuation#(ParserConstants.CHAR_RBRACE())
            throw ParserError.Invalid(InvalidSyntax(start, lexer.position, String$("expected '}'")))

        lexer.parse_colon#()

        let end lexer.position

        TraitSyntax(start, end, name, extension, attributes, uses, functions)
    }

    function parse_method_list#(rp, this: Parser) returns ref[Vector[MethodSyntax]]? throws ParserError
    {
        var list List[MethodSyntax]$()
        while true
        {
            choose parse_method#()
                when err: Error
                {
                    choose err
                        when i: Invalid
                            throw ParserError.Invalid(i)
                        when d: Different
                        {
                            if list.head = null
                                throw ParserError.Different(d)
                            else
                                return Vector[MethodSyntax]#(list)
                        }
                }
                when node: Success
                    list.add$(node)
        }
    }

    function parse_method#(rp, this: Parser) returns MethodSyntax throws ParserError
    {
        choose parse_function#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return MethodSyntax.Function(node)
        choose parse_procedure#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return MethodSyntax.Procedure(node)
        choose parse_operator#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return MethodSyntax.Operator(node)
        throw ParserError.Different(DifferentSyntax())
    }

    function parse_init_list#(rp, this: Parser) returns ref[Vector[InitSyntax]]? throws ParserError
    {
        var list List[InitSyntax]$()
        while true
        {
            choose parse_init#()
                when err: Error
                {
                    choose err
                        when i: Invalid
                            throw ParserError.Invalid(i)
                        when d: Different
                        {
                            if list.head = null
                                throw ParserError.Different(d)
                            else
                                return Vector[InitSyntax]#(list)
                        }
                }
                when node: Success
                    list.add$(node)
        }
    }

    function parse_init#(rp, this: Parser) returns InitSyntax throws ParserError
    {
        let start lexer.previous_position

        if ~lexer.parse_keyword#(String$("init"))
            throw ParserError.Different(DifferentSyntax())

        let lifetime_start lexer.position
        var lifetime: ref[LifetimeSyntax]? null
        choose parse_lifetime#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set lifetime: success

        let parameters_start lexer.position
        var parameters: ref[ParameterSetSyntax]? null
        choose parse_parameterset#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set parameters: success

        lexer.parse_colon#()

        let action_start lexer.position
        var action: ActionSyntax
        choose parse_action#()
            when err: Error
            {
                choose err
                    when d: Different
                        throw ParserError.Invalid(InvalidSyntax(action_start, lexer.position, String$("expected Action")))
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set action: success

        lexer.parse_colon#()

        let end lexer.position

        InitSyntax(start, end, lifetime, parameters, action)
    }

    function parse_deinit#(rp, this: Parser) returns DeInitSyntax throws ParserError
    {
        let start lexer.previous_position

        if ~lexer.parse_keyword#(String$("deinit"))
            throw ParserError.Different(DifferentSyntax())

        lexer.parse_colon#()

        let action_start lexer.position
        var action: ActionSyntax
        choose parse_action#()
            when err: Error
            {
                choose err
                    when d: Different
                        throw ParserError.Invalid(InvalidSyntax(action_start, lexer.position, String$("expected Action")))
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set action: success

        lexer.parse_colon#()

        let end lexer.position

        DeInitSyntax(start, end, action)
    }

    function parse_function#(rp, this: Parser) returns FunctionSyntax throws ParserError
    {
        let start lexer.previous_position

        if ~lexer.parse_keyword#(String$("function"))
            throw ParserError.Different(DifferentSyntax())

        let target_start lexer.position
        var target: TargetSyntax
        choose parse_target#()
            when err: Error
            {
                choose err
                    when d: Different
                        throw ParserError.Invalid(InvalidSyntax(target_start, lexer.position, String$("expected Target")))
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set target: success

        let end lexer.position

        FunctionSyntax(start, end, target)
    }

    function parse_procedure#(rp, this: Parser) returns ProcedureSyntax throws ParserError
    {
        let start lexer.previous_position

        if ~lexer.parse_keyword#(String$("procedure"))
            throw ParserError.Different(DifferentSyntax())

        let target_start lexer.position
        var target: TargetSyntax
        choose parse_target#()
            when err: Error
            {
                choose err
                    when d: Different
                        throw ParserError.Invalid(InvalidSyntax(target_start, lexer.position, String$("expected Target")))
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set target: success

        let end lexer.position

        ProcedureSyntax(start, end, target)
    }

    function parse_operator#(rp, this: Parser) returns OperatorSyntax throws ParserError
    {
        let start lexer.previous_position

        if ~lexer.parse_keyword#(String$("operator"))
            throw ParserError.Different(DifferentSyntax())

        let target_start lexer.position
        var target: TargetSyntax
        choose parse_target#()
            when err: Error
            {
                choose err
                    when d: Different
                        throw ParserError.Invalid(InvalidSyntax(target_start, lexer.position, String$("expected Target")))
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set target: success

        let end lexer.position

        OperatorSyntax(start, end, target)
    }

    function parse_target#(rp, this: Parser) returns TargetSyntax throws ParserError
    {
        choose parse_named#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return TargetSyntax.Named(node)
        choose parse_routine#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return TargetSyntax.Routine(node)
        throw ParserError.Different(DifferentSyntax())
    }

    function parse_named#(rp, this: Parser) returns NamedSyntax throws ParserError
    {
        let start lexer.previous_position

        let name lexer.parse_identifier#(keywords)
        if name.length() = 0
            throw ParserError.Different(DifferentSyntax())

        let routine_start lexer.position
        var routine: RoutineSyntax
        choose parse_routine#()
            when err: Error
            {
                choose err
                    when d: Different
                        throw ParserError.Invalid(InvalidSyntax(routine_start, lexer.position, String$("expected Routine")))
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set routine: success

        let end lexer.position

        NamedSyntax(start, end, name, routine)
    }

    function parse_routine#(rp, this: Parser) returns RoutineSyntax throws ParserError
    {
        let start lexer.previous_position

        let generics_start lexer.position
        var generics: ref[GenericArgumentsSyntax]? null
        choose parse_genericarguments#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set generics: success

        let lifetime_start lexer.position
        var lifetime: ref[LifetimeSyntax]? null
        choose parse_lifetime#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set lifetime: success

        let parameters_start lexer.position
        var parameters: ref[ParameterSetSyntax]? null
        choose parse_parameterset#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set parameters: success

        let attributes_start lexer.position
        var attributes: ref[Vector[AttributeSyntax]]? null
        choose parse_attribute_list#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set attributes: success

        let returns__start lexer.position
        var returns_: ref[ReturnsSyntax]? null
        choose parse_returns#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set returns_: success

        lexer.parse_colon#()

        let throws__start lexer.position
        var throws_: ref[ThrowsSyntax]? null
        choose parse_throws#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set throws_: success

        lexer.parse_colon#()

        let implementation_start lexer.position
        var implementation: ImplementationSyntax
        choose parse_implementation#()
            when err: Error
            {
                choose err
                    when d: Different
                        throw ParserError.Invalid(InvalidSyntax(implementation_start, lexer.position, String$("expected Implementation")))
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set implementation: success

        let end lexer.position

        RoutineSyntax(start, end, generics, lifetime, parameters, attributes, returns_, throws_, implementation)
    }

    function parse_implementation#(rp, this: Parser) returns ImplementationSyntax throws ParserError
    {
        choose parse_action#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return ImplementationSyntax.Action(node)
        choose parse_extern#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return ImplementationSyntax.Extern(node)
        choose parse_instruction#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return ImplementationSyntax.Instruction(node)
        choose parse_intrinsic#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return ImplementationSyntax.Intrinsic(node)
        throw ParserError.Different(DifferentSyntax())
    }

    function parse_extern#(rp, this: Parser) returns ExternSyntax throws ParserError
    {
        let start lexer.previous_position

        if ~lexer.parse_keyword#(String$("extern"))
            throw ParserError.Different(DifferentSyntax())

        let end lexer.position

        ExternSyntax(start, end)
    }

    function parse_instruction#(rp, this: Parser) returns InstructionSyntax throws ParserError
    {
        let start lexer.previous_position

        if ~lexer.parse_keyword#(String$("instruction"))
            throw ParserError.Different(DifferentSyntax())

        lexer.parse_colon#()

        let end lexer.position

        InstructionSyntax(start, end)
    }

    function parse_intrinsic#(rp, this: Parser) returns IntrinsicSyntax throws ParserError
    {
        let start lexer.previous_position

        if ~lexer.parse_keyword#(String$("intrinsic"))
            throw ParserError.Different(DifferentSyntax())

        lexer.parse_colon#()

        let end lexer.position

        IntrinsicSyntax(start, end)
    }

    function parse_extends#(rp, this: Parser) returns ExtendsSyntax throws ParserError
    {
        let start lexer.previous_position

        if ~lexer.parse_keyword#(String$("extends"))
            throw ParserError.Different(DifferentSyntax())

        let extensions_start lexer.position
        var extensions: ref[Vector[ExtendSyntax]]? null
        choose parse_extend_list#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set extensions: success

        let end lexer.position

        ExtendsSyntax(start, end, extensions)
    }

    function parse_extend_list#(rp, this: Parser) returns ref[Vector[ExtendSyntax]]? throws ParserError
    {
        var list List[ExtendSyntax]$()
        while true
        {
            choose parse_extend#()
                when err: Error
                {
                    choose err
                        when i: Invalid
                            throw ParserError.Invalid(i)
                        when d: Different
                        {
                            if list.head = null
                                throw ParserError.Different(d)
                            else
                                return Vector[ExtendSyntax]#(list)
                        }
                }
                when node: Success
                    list.add$(node)
        }
    }

    function parse_extend#(rp, this: Parser) returns ExtendSyntax throws ParserError
    {
        let start lexer.previous_position

        let type_start lexer.position
        var type: TypeSyntax
        choose parse_type#()
            when err: Error
                throw err
            when success: Success
                set type: success

        lexer.parse_punctuation#(ParserConstants.CHAR_COMMA())

        let end lexer.position

        ExtendSyntax(start, end, type)
    }

    function parse_macro#(rp, this: Parser) returns MacroSyntax throws ParserError
    {
        let start lexer.previous_position

        if ~lexer.parse_keyword#(String$("macro"))
            throw ParserError.Different(DifferentSyntax())

        let name lexer.parse_identifier#(keywords)
        if name.length() = 0
            throw ParserError.Invalid(InvalidSyntax(start, lexer.position, String$("expected identifier")))

        let model_start lexer.position
        var model: ModelSyntax
        choose parse_model#()
            when err: Error
            {
                choose err
                    when d: Different
                        throw ParserError.Invalid(InvalidSyntax(model_start, lexer.position, String$("expected Model")))
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set model: success

        let rule_start lexer.position
        var rule: ref[Vector[OperandSyntax]]?
        choose parse_operand_list#()
            when err: Error
            {
                choose err
                    when d: Different
                        throw ParserError.Invalid(InvalidSyntax(rule_start, lexer.position, String$("expected Operand")))
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set rule: success

        let end lexer.position

        MacroSyntax(start, end, name, model, rule)
    }

    function parse_attribute_list#(rp, this: Parser) returns ref[Vector[AttributeSyntax]]? throws ParserError
    {
        var list List[AttributeSyntax]$()
        while true
        {
            choose parse_attribute#()
                when err: Error
                {
                    choose err
                        when i: Invalid
                            throw ParserError.Invalid(i)
                        when d: Different
                        {
                            if list.head = null
                                throw ParserError.Different(d)
                            else
                                return Vector[AttributeSyntax]#(list)
                        }
                }
                when node: Success
                    list.add$(node)
        }
    }

    function parse_attribute#(rp, this: Parser) returns AttributeSyntax throws ParserError
    {
        let start lexer.previous_position

        let name lexer.parse_attribute#()
        if name.length() = 0
            throw ParserError.Different(DifferentSyntax())

        let model_start lexer.position
        var model: ModelSyntax
        choose parse_model#()
            when err: Error
            {
                choose err
                    when d: Different
                        throw ParserError.Invalid(InvalidSyntax(model_start, lexer.position, String$("expected Model")))
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set model: success

        lexer.parse_colon#()

        let end lexer.position

        AttributeSyntax(start, end, name, model)
    }

    function parse_model#(rp, this: Parser) returns ModelSyntax throws ParserError
    {
        choose parse_literal#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return ModelSyntax.Literal(node)
        choose parse_name#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return ModelSyntax.Name(node)
        choose parse_object#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return ModelSyntax.Object(node)
        choose parse_vector#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return ModelSyntax.Vector(node)
        throw ParserError.Different(DifferentSyntax())
    }

    function parse_module#(rp, this: Parser) returns ModuleSyntax throws ParserError
    {
        let start lexer.previous_position

        if ~lexer.parse_keyword#(String$("module"))
            throw ParserError.Different(DifferentSyntax())

        let name lexer.parse_identifier#(keywords)
        if name.length() = 0
            throw ParserError.Invalid(InvalidSyntax(start, lexer.position, String$("expected identifier")))

        lexer.parse_colon#()

        let end lexer.position

        ModuleSyntax(start, end, name)
    }

    function parse_package_list#(rp, this: Parser) returns ref[Vector[PackageSyntax]]? throws ParserError
    {
        var list List[PackageSyntax]$()
        while true
        {
            choose parse_package#()
                when err: Error
                {
                    choose err
                        when i: Invalid
                            throw ParserError.Invalid(i)
                        when d: Different
                        {
                            if list.head = null
                                throw ParserError.Different(d)
                            else
                                return Vector[PackageSyntax]#(list)
                        }
                }
                when node: Success
                    list.add$(node)
        }
    }

    function parse_package#(rp, this: Parser) returns PackageSyntax throws ParserError
    {
        let start lexer.previous_position

        if ~lexer.parse_keyword#(String$("package"))
            throw ParserError.Different(DifferentSyntax())

        let name_start lexer.position
        var name: NameSyntax
        choose parse_name#()
            when err: Error
            {
                choose err
                    when d: Different
                        throw ParserError.Invalid(InvalidSyntax(name_start, lexer.position, String$("expected Name")))
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set name: success

        let version_start lexer.position
        var version: ref[VersionSyntax]? null
        choose parse_version#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set version: success

        lexer.parse_colon#()

        let end lexer.position

        PackageSyntax(start, end, name, version)
    }

    function parse_version#(rp, this: Parser) returns VersionSyntax throws ParserError
    {
        let start lexer.previous_position

        var majorMinor: Literal
        choose parse_literal_token#()
            when err: Error
                throw err
            when success: Success
                set majorMinor: success

        if ~lexer.parse_punctuation#(ParserConstants.CHAR_DOT())
            throw ParserError.Invalid(InvalidSyntax(start, lexer.position, String$("expected '.'")))

        var patch: Literal
        choose parse_literal_token#()
            when err: Error
                throw err
            when success: Success
                set patch: success

        let end lexer.position

        VersionSyntax(start, end, majorMinor, patch)
    }

    function parse_initializer#(rp, this: Parser) returns InitializerSyntax throws ParserError
    {
        let start lexer.previous_position

        if ~lexer.parse_punctuation#(ParserConstants.CHAR_LPAREN())
            throw ParserError.Different(DifferentSyntax())

        let operands_start lexer.position
        var operands: ref[Vector[OperandSyntax]]?
        choose parse_operand_list#()
            when err: Error
            {
                choose err
                    when d: Different
                        throw ParserError.Invalid(InvalidSyntax(operands_start, lexer.position, String$("expected Operand")))
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set operands: success

        if ~lexer.parse_punctuation#(ParserConstants.CHAR_RPAREN())
            throw ParserError.Invalid(InvalidSyntax(start, lexer.position, String$("expected ')'")))

        let end lexer.position

        InitializerSyntax(start, end, operands)
    }

    function parse_operand_list#(rp, this: Parser) returns ref[Vector[OperandSyntax]]? throws ParserError
    {
        var list List[OperandSyntax]$()
        while true
        {
            choose parse_operand#()
                when err: Error
                {
                    choose err
                        when i: Invalid
                            throw ParserError.Invalid(i)
                        when d: Different
                        {
                            if list.head = null
                                throw ParserError.Different(d)
                            else
                                return Vector[OperandSyntax]#(list)
                        }
                }
                when node: Success
                    list.add$(node)
        }
    }

    function parse_operand#(rp, this: Parser) returns OperandSyntax throws ParserError
    {
        let start lexer.previous_position

        let expression_start lexer.position
        var expression: ExpressionSyntax
        choose parse_expression#()
            when err: Error
                throw err
            when success: Success
                set expression: success

        let members_start lexer.position
        var members: ref[Vector[MemberAccessSyntax]]? null
        choose parse_memberaccess_list#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set members: success

        let end lexer.position

        OperandSyntax(start, end, expression, members)
    }

    function parse_memberaccess_list#(rp, this: Parser) returns ref[Vector[MemberAccessSyntax]]? throws ParserError
    {
        var list List[MemberAccessSyntax]$()
        while true
        {
            choose parse_memberaccess#()
                when err: Error
                {
                    choose err
                        when i: Invalid
                            throw ParserError.Invalid(i)
                        when d: Different
                        {
                            if list.head = null
                                throw ParserError.Different(d)
                            else
                                return Vector[MemberAccessSyntax]#(list)
                        }
                }
                when node: Success
                    list.add$(node)
        }
    }

    function parse_memberaccess#(rp, this: Parser) returns MemberAccessSyntax throws ParserError
    {
        let start lexer.previous_position

        if ~lexer.parse_punctuation#(ParserConstants.CHAR_DOT())
            throw ParserError.Different(DifferentSyntax())

        let name_start lexer.position
        var name: NameSyntax
        choose parse_name#()
            when err: Error
            {
                choose err
                    when d: Different
                        throw ParserError.Invalid(InvalidSyntax(name_start, lexer.position, String$("expected Name")))
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set name: success

        let end lexer.position

        MemberAccessSyntax(start, end, name)
    }

    function parse_expression#(rp, this: Parser) returns ExpressionSyntax throws ParserError
    {
        choose parse_literal#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return ExpressionSyntax.Literal(node)
        choose parse_name#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return ExpressionSyntax.Name(node)
        choose parse_object#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return ExpressionSyntax.Object(node)
        choose parse_vector#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return ExpressionSyntax.Vector(node)
        choose parse_block#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return ExpressionSyntax.Block(node)
        choose parse_if#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return ExpressionSyntax.If(node)
        choose parse_match#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return ExpressionSyntax.Match(node)
        choose parse_lambda#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return ExpressionSyntax.Lambda(node)
        choose parse_for#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return ExpressionSyntax.For(node)
        choose parse_while#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return ExpressionSyntax.While(node)
        choose parse_choose#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return ExpressionSyntax.Choose(node)
        choose parse_try#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return ExpressionSyntax.Try(node)
        choose parse_repeat#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return ExpressionSyntax.Repeat(node)
        choose parse_sizeof#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return ExpressionSyntax.SizeOf(node)
        choose parse_alignof#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return ExpressionSyntax.AlignOf(node)
        choose parse_is#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return ExpressionSyntax.Is(node)
        choose parse_as#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return ExpressionSyntax.As(node)
        choose parse_lifetime#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return ExpressionSyntax.Lifetime(node)
        throw ParserError.Different(DifferentSyntax())
    }

    function parse_literal#(rp, this: Parser) returns LiteralSyntax throws ParserError
    {
        let start lexer.previous_position

        var literal: Literal
        choose parse_literal_token#()
            when err: Error
                throw err
            when success: Success
                set literal: success

        let end lexer.position

        LiteralSyntax(start, end, literal)
    }

    function parse_object#(rp, this: Parser) returns ObjectSyntax throws ParserError
    {
        let start lexer.previous_position

        if ~lexer.parse_punctuation#(ParserConstants.CHAR_LPAREN())
            throw ParserError.Different(DifferentSyntax())

        let components_start lexer.position
        var components: ref[Vector[ComponentSyntax]]? null
        choose parse_component_list#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set components: success

        if ~lexer.parse_punctuation#(ParserConstants.CHAR_RPAREN())
            throw ParserError.Invalid(InvalidSyntax(start, lexer.position, String$("expected ')'")))

        let end lexer.position

        ObjectSyntax(start, end, components)
    }

    function parse_component_list#(rp, this: Parser) returns ref[Vector[ComponentSyntax]]? throws ParserError
    {
        var list List[ComponentSyntax]$()
        while true
        {
            choose parse_component#()
                when err: Error
                {
                    choose err
                        when i: Invalid
                            throw ParserError.Invalid(i)
                        when d: Different
                        {
                            if list.head = null
                                throw ParserError.Different(d)
                            else
                                return Vector[ComponentSyntax]#(list)
                        }
                }
                when node: Success
                    list.add$(node)
        }
    }

    function parse_component#(rp, this: Parser) returns ComponentSyntax throws ParserError
    {
        let start lexer.previous_position

        let operands_start lexer.position
        var operands: ref[Vector[OperandSyntax]]?
        choose parse_operand_list#()
            when err: Error
                throw err
            when success: Success
                set operands: success

        let attributes_start lexer.position
        var attributes: ref[Vector[AttributeSyntax]]? null
        choose parse_attribute_list#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set attributes: success

        let value_start lexer.position
        var value: ref[ValueSyntax]? null
        choose parse_value#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set value: success

        lexer.parse_punctuation#(ParserConstants.CHAR_COMMA())

        let end lexer.position

        ComponentSyntax(start, end, operands, attributes, value)
    }

    function parse_value#(rp, this: Parser) returns ValueSyntax throws ParserError
    {
        let start lexer.previous_position

        if ~lexer.parse_colon#()
            throw ParserError.Different(DifferentSyntax())

        let value_start lexer.position
        var value: ref[Vector[OperandSyntax]]?
        choose parse_operand_list#()
            when err: Error
            {
                choose err
                    when d: Different
                        throw ParserError.Invalid(InvalidSyntax(value_start, lexer.position, String$("expected Operand")))
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set value: success

        let attributes_start lexer.position
        var attributes: ref[Vector[AttributeSyntax]]? null
        choose parse_attribute_list#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set attributes: success

        let end lexer.position

        ValueSyntax(start, end, value, attributes)
    }

    function parse_vector#(rp, this: Parser) returns VectorSyntax throws ParserError
    {
        let start lexer.previous_position

        if ~lexer.parse_punctuation#(ParserConstants.CHAR_LBRACKET())
            throw ParserError.Different(DifferentSyntax())

        let elements_start lexer.position
        var elements: ref[Vector[ElementSyntax]]?
        choose parse_element_list#()
            when err: Error
            {
                choose err
                    when d: Different
                        throw ParserError.Invalid(InvalidSyntax(elements_start, lexer.position, String$("expected Element")))
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set elements: success

        if ~lexer.parse_punctuation#(ParserConstants.CHAR_RBRACKET())
            throw ParserError.Invalid(InvalidSyntax(start, lexer.position, String$("expected ']'")))

        let lifetime_start lexer.position
        var lifetime: ref[LifetimeSyntax]? null
        choose parse_lifetime#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set lifetime: success

        let end lexer.position

        VectorSyntax(start, end, elements, lifetime)
    }

    function parse_element_list#(rp, this: Parser) returns ref[Vector[ElementSyntax]]? throws ParserError
    {
        var list List[ElementSyntax]$()
        while true
        {
            choose parse_element#()
                when err: Error
                {
                    choose err
                        when i: Invalid
                            throw ParserError.Invalid(i)
                        when d: Different
                        {
                            if list.head = null
                                throw ParserError.Different(d)
                            else
                                return Vector[ElementSyntax]#(list)
                        }
                }
                when node: Success
                    list.add$(node)
        }
    }

    function parse_element#(rp, this: Parser) returns ElementSyntax throws ParserError
    {
        let start lexer.previous_position

        let operation_start lexer.position
        var operation: ref[Vector[OperandSyntax]]?
        choose parse_operand_list#()
            when err: Error
                throw err
            when success: Success
                set operation: success

        let attributes_start lexer.position
        var attributes: ref[Vector[AttributeSyntax]]? null
        choose parse_attribute_list#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set attributes: success

        lexer.parse_punctuation#(ParserConstants.CHAR_COMMA())

        let end lexer.position

        ElementSyntax(start, end, operation, attributes)
    }

    function parse_if#(rp, this: Parser) returns IfSyntax throws ParserError
    {
        let start lexer.previous_position

        if ~lexer.parse_keyword#(String$("if"))
            throw ParserError.Different(DifferentSyntax())

        let condition_start lexer.position
        var condition: ref[Vector[OperandSyntax]]?
        choose parse_operand_list#()
            when err: Error
            {
                choose err
                    when d: Different
                        throw ParserError.Invalid(InvalidSyntax(condition_start, lexer.position, String$("expected Operand")))
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set condition: success

        if ~lexer.parse_colon#()
            throw ParserError.Invalid(InvalidSyntax(start, lexer.position, String$("expected colon or newline")))

        let consequent_start lexer.position
        var consequent: ThenSyntax
        choose parse_then#()
            when err: Error
            {
                choose err
                    when d: Different
                        throw ParserError.Invalid(InvalidSyntax(consequent_start, lexer.position, String$("expected Then")))
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set consequent: success

        let alternative_start lexer.position
        var alternative: ref[ElseSyntax]? null
        choose parse_else#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set alternative: success

        let end lexer.position

        IfSyntax(start, end, condition, consequent, alternative)
    }

    function parse_then#(rp, this: Parser) returns ThenSyntax throws ParserError
    {
        let start lexer.previous_position

        let command_start lexer.position
        var command: CommandSyntax
        choose parse_command#()
            when err: Error
                throw err
            when success: Success
                set command: success

        lexer.parse_colon#()

        let end lexer.position

        ThenSyntax(start, end, command)
    }

    function parse_else#(rp, this: Parser) returns ElseSyntax throws ParserError
    {
        let start lexer.previous_position

        if ~lexer.parse_keyword#(String$("else"))
            throw ParserError.Different(DifferentSyntax())

        lexer.parse_colon#()

        let alternative_start lexer.position
        var alternative: CommandSyntax
        choose parse_command#()
            when err: Error
            {
                choose err
                    when d: Different
                        throw ParserError.Invalid(InvalidSyntax(alternative_start, lexer.position, String$("expected Command")))
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set alternative: success

        let end lexer.position

        ElseSyntax(start, end, alternative)
    }

    function parse_match#(rp, this: Parser) returns MatchSyntax throws ParserError
    {
        let start lexer.previous_position

        if ~lexer.parse_keyword#(String$("match"))
            throw ParserError.Different(DifferentSyntax())

        let scrutinee_start lexer.position
        var scrutinee: ref[Vector[OperandSyntax]]?
        choose parse_operand_list#()
            when err: Error
            {
                choose err
                    when d: Different
                        throw ParserError.Invalid(InvalidSyntax(scrutinee_start, lexer.position, String$("expected Operand")))
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set scrutinee: success

        if ~lexer.parse_colon#()
            throw ParserError.Invalid(InvalidSyntax(start, lexer.position, String$("expected colon or newline")))

        let branches_start lexer.position
        var branches: ref[Vector[BranchSyntax]]?
        choose parse_branch_list#()
            when err: Error
            {
                choose err
                    when d: Different
                        throw ParserError.Invalid(InvalidSyntax(branches_start, lexer.position, String$("expected Branch")))
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set branches: success

        let alternative_start lexer.position
        var alternative: ref[ElseSyntax]? null
        choose parse_else#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set alternative: success

        let end lexer.position

        MatchSyntax(start, end, scrutinee, branches, alternative)
    }

    function parse_branch_list#(rp, this: Parser) returns ref[Vector[BranchSyntax]]? throws ParserError
    {
        var list List[BranchSyntax]$()
        while true
        {
            choose parse_branch#()
                when err: Error
                {
                    choose err
                        when i: Invalid
                            throw ParserError.Invalid(i)
                        when d: Different
                        {
                            if list.head = null
                                throw ParserError.Different(d)
                            else
                                return Vector[BranchSyntax]#(list)
                        }
                }
                when node: Success
                    list.add$(node)
        }
    }

    function parse_branch#(rp, this: Parser) returns BranchSyntax throws ParserError
    {
        let start lexer.previous_position

        let cases_start lexer.position
        var cases: ref[Vector[CaseSyntax]]?
        choose parse_case_list#()
            when err: Error
                throw err
            when success: Success
                set cases: success

        if ~lexer.parse_colon#()
            throw ParserError.Invalid(InvalidSyntax(start, lexer.position, String$("expected colon or newline")))

        let consequent_start lexer.position
        var consequent: StatementSyntax
        choose parse_statement#()
            when err: Error
            {
                choose err
                    when d: Different
                        throw ParserError.Invalid(InvalidSyntax(consequent_start, lexer.position, String$("expected Statement")))
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set consequent: success

        let end lexer.position

        BranchSyntax(start, end, cases, consequent)
    }

    function parse_case_list#(rp, this: Parser) returns ref[Vector[CaseSyntax]]? throws ParserError
    {
        var list List[CaseSyntax]$()
        while true
        {
            choose parse_case#()
                when err: Error
                {
                    choose err
                        when i: Invalid
                            throw ParserError.Invalid(i)
                        when d: Different
                        {
                            if list.head = null
                                throw ParserError.Different(d)
                            else
                                return Vector[CaseSyntax]#(list)
                        }
                }
                when node: Success
                    list.add$(node)
        }
    }

    function parse_case#(rp, this: Parser) returns CaseSyntax throws ParserError
    {
        let start lexer.previous_position

        if ~lexer.parse_keyword#(String$("case"))
            throw ParserError.Different(DifferentSyntax())

        let condition_start lexer.position
        var condition: ref[Vector[OperandSyntax]]?
        choose parse_operand_list#()
            when err: Error
            {
                choose err
                    when d: Different
                        throw ParserError.Invalid(InvalidSyntax(condition_start, lexer.position, String$("expected Operand")))
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set condition: success

        let end lexer.position

        CaseSyntax(start, end, condition)
    }

    function parse_statement_list#(rp, this: Parser) returns ref[Vector[StatementSyntax]]? throws ParserError
    {
        var list List[StatementSyntax]$()
        while true
        {
            choose parse_statement#()
                when err: Error
                {
                    choose err
                        when i: Invalid
                            throw ParserError.Invalid(i)
                        when d: Different
                        {
                            if list.head = null
                                throw ParserError.Different(d)
                            else
                                return Vector[StatementSyntax]#(list)
                        }
                }
                when node: Success
                    list.add$(node)
        }
    }

    function parse_statement#(rp, this: Parser) returns StatementSyntax throws ParserError
    {
        let start lexer.previous_position

        let command_start lexer.position
        var command: CommandSyntax
        choose parse_command#()
            when err: Error
                throw err
            when success: Success
                set command: success

        lexer.parse_colon#()

        let end lexer.position

        StatementSyntax(start, end, command)
    }

    function parse_while#(rp, this: Parser) returns WhileSyntax throws ParserError
    {
        let start lexer.previous_position

        if ~lexer.parse_keyword#(String$("while"))
            throw ParserError.Different(DifferentSyntax())

        let condition_start lexer.position
        var condition: ConditionSyntax
        choose parse_condition#()
            when err: Error
            {
                choose err
                    when d: Different
                        throw ParserError.Invalid(InvalidSyntax(condition_start, lexer.position, String$("expected Condition")))
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set condition: success

        if ~lexer.parse_colon#()
            throw ParserError.Invalid(InvalidSyntax(start, lexer.position, String$("expected colon or newline")))

        let name_start lexer.position
        var name: ref[LabelSyntax]? null
        choose parse_label#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set name: success

        let action_start lexer.position
        var action: ActionSyntax
        choose parse_action#()
            when err: Error
            {
                choose err
                    when d: Different
                        throw ParserError.Invalid(InvalidSyntax(action_start, lexer.position, String$("expected Action")))
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set action: success

        let end lexer.position

        WhileSyntax(start, end, condition, name, action)
    }

    function parse_choose#(rp, this: Parser) returns ChooseSyntax throws ParserError
    {
        let start lexer.previous_position

        if ~lexer.parse_keyword#(String$("choose"))
            throw ParserError.Different(DifferentSyntax())

        let condition_start lexer.position
        var condition: ref[Vector[OperandSyntax]]?
        choose parse_operand_list#()
            when err: Error
            {
                choose err
                    when d: Different
                        throw ParserError.Invalid(InvalidSyntax(condition_start, lexer.position, String$("expected Operand")))
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set condition: success

        if ~lexer.parse_colon#()
            throw ParserError.Invalid(InvalidSyntax(start, lexer.position, String$("expected colon or newline")))

        let cases_start lexer.position
        var cases: ref[Vector[WhenSyntax]]? null
        choose parse_when_list#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set cases: success

        let alternative_start lexer.position
        var alternative: ref[ElseSyntax]? null
        choose parse_else#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set alternative: success

        let end lexer.position

        ChooseSyntax(start, end, condition, cases, alternative)
    }

    function parse_try#(rp, this: Parser) returns TrySyntax throws ParserError
    {
        let start lexer.previous_position

        if ~lexer.parse_keyword#(String$("try"))
            throw ParserError.Different(DifferentSyntax())

        let condition_start lexer.position
        var condition: ConditionSyntax
        choose parse_condition#()
            when err: Error
            {
                choose err
                    when d: Different
                        throw ParserError.Invalid(InvalidSyntax(condition_start, lexer.position, String$("expected Condition")))
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set condition: success

        if ~lexer.parse_colon#()
            throw ParserError.Invalid(InvalidSyntax(start, lexer.position, String$("expected colon or newline")))

        let cases_start lexer.position
        var cases: ref[Vector[WhenSyntax]]? null
        choose parse_when_list#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set cases: success

        let dropper_start lexer.position
        var dropper: ref[ElseSyntax]? null
        choose parse_else#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set dropper: success

        let end lexer.position

        TrySyntax(start, end, condition, cases, dropper)
    }

    function parse_condition#(rp, this: Parser) returns ConditionSyntax throws ParserError
    {
        choose parse_operation#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return ConditionSyntax.Operation(node)
        choose parse_let#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return ConditionSyntax.Let(node)
        throw ParserError.Different(DifferentSyntax())
    }

    function parse_when_list#(rp, this: Parser) returns ref[Vector[WhenSyntax]]? throws ParserError
    {
        var list List[WhenSyntax]$()
        while true
        {
            choose parse_when#()
                when err: Error
                {
                    choose err
                        when i: Invalid
                            throw ParserError.Invalid(i)
                        when d: Different
                        {
                            if list.head = null
                                throw ParserError.Different(d)
                            else
                                return Vector[WhenSyntax]#(list)
                        }
                }
                when node: Success
                    list.add$(node)
        }
    }

    function parse_when#(rp, this: Parser) returns WhenSyntax throws ParserError
    {
        let start lexer.previous_position

        if ~lexer.parse_keyword#(String$("when"))
            throw ParserError.Different(DifferentSyntax())

        let name lexer.parse_identifier#(keywords)
        if name.length() = 0
            throw ParserError.Invalid(InvalidSyntax(start, lexer.position, String$("expected identifier")))

        if ~lexer.parse_colon#()
            throw ParserError.Invalid(InvalidSyntax(start, lexer.position, String$("expected colon or newline")))

        let variant_start lexer.position
        var variant: NameSyntax
        choose parse_name#()
            when err: Error
            {
                choose err
                    when d: Different
                        throw ParserError.Invalid(InvalidSyntax(variant_start, lexer.position, String$("expected Name")))
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set variant: success

        lexer.parse_colon#()

        let command_start lexer.position
        var command: CommandSyntax
        choose parse_command#()
            when err: Error
            {
                choose err
                    when d: Different
                        throw ParserError.Invalid(InvalidSyntax(command_start, lexer.position, String$("expected Command")))
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set command: success

        lexer.parse_colon#()

        let end lexer.position

        WhenSyntax(start, end, name, variant, command)
    }

    function parse_command#(rp, this: Parser) returns CommandSyntax throws ParserError
    {
        choose parse_operation#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return CommandSyntax.Operation(node)
        choose parse_let#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return CommandSyntax.Let(node)
        choose parse_var#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return CommandSyntax.Var(node)
        choose parse_mutable#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return CommandSyntax.Mutable(node)
        choose parse_set#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return CommandSyntax.Set(node)
        choose parse_continue#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return CommandSyntax.Continue(node)
        choose parse_break#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return CommandSyntax.Break(node)
        choose parse_return#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return CommandSyntax.Return(node)
        choose parse_throw#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return CommandSyntax.Throw(node)
        throw ParserError.Different(DifferentSyntax())
    }

    function parse_let#(rp, this: Parser) returns LetSyntax throws ParserError
    {
        let start lexer.previous_position

        if ~lexer.parse_keyword#(String$("let"))
            throw ParserError.Different(DifferentSyntax())

        let binding_start lexer.position
        var binding: BindingSyntax
        choose parse_binding#()
            when err: Error
            {
                choose err
                    when d: Different
                        throw ParserError.Invalid(InvalidSyntax(binding_start, lexer.position, String$("expected Binding")))
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set binding: success

        let end lexer.position

        LetSyntax(start, end, binding)
    }

    function parse_var#(rp, this: Parser) returns VarSyntax throws ParserError
    {
        let start lexer.previous_position

        if ~lexer.parse_keyword#(String$("var"))
            throw ParserError.Different(DifferentSyntax())

        let binding_start lexer.position
        var binding: BindingSyntax
        choose parse_binding#()
            when err: Error
            {
                choose err
                    when d: Different
                        throw ParserError.Invalid(InvalidSyntax(binding_start, lexer.position, String$("expected Binding")))
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set binding: success

        let end lexer.position

        VarSyntax(start, end, binding)
    }

    function parse_mutable#(rp, this: Parser) returns MutableSyntax throws ParserError
    {
        let start lexer.previous_position

        if ~lexer.parse_keyword#(String$("mutable"))
            throw ParserError.Different(DifferentSyntax())

        let binding_start lexer.position
        var binding: BindingSyntax
        choose parse_binding#()
            when err: Error
            {
                choose err
                    when d: Different
                        throw ParserError.Invalid(InvalidSyntax(binding_start, lexer.position, String$("expected Binding")))
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set binding: success

        let end lexer.position

        MutableSyntax(start, end, binding)
    }

    function parse_binding#(rp, this: Parser) returns BindingSyntax throws ParserError
    {
        let start lexer.previous_position

        let name lexer.parse_identifier#(keywords)
        if name.length() = 0
            throw ParserError.Different(DifferentSyntax())

        let annotation_start lexer.position
        var annotation: ref[BindingAnnotationSyntax]? null
        choose parse_bindingannotation#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set annotation: success

        let operation_start lexer.position
        var operation: ref[Vector[OperandSyntax]]? null
        choose parse_operand_list#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set operation: success

        let end lexer.position

        BindingSyntax(start, end, name, annotation, operation)
    }

    function parse_bindingannotation#(rp, this: Parser) returns BindingAnnotationSyntax throws ParserError
    {
        let start lexer.previous_position

        if ~lexer.parse_colon#()
            throw ParserError.Different(DifferentSyntax())

        let spec_start lexer.position
        var spec: BindingSpecSyntax
        choose parse_bindingspec#()
            when err: Error
            {
                choose err
                    when d: Different
                        throw ParserError.Invalid(InvalidSyntax(spec_start, lexer.position, String$("expected BindingSpec")))
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set spec: success

        let end lexer.position

        BindingAnnotationSyntax(start, end, spec)
    }

    function parse_bindingspec_list#(rp, this: Parser) returns ref[Vector[BindingSpecSyntax]]? throws ParserError
    {
        var list List[BindingSpecSyntax]$()
        while true
        {
            choose parse_bindingspec#()
                when err: Error
                {
                    choose err
                        when i: Invalid
                            throw ParserError.Invalid(i)
                        when d: Different
                        {
                            if list.head = null
                                throw ParserError.Different(d)
                            else
                                return Vector[BindingSpecSyntax]#(list)
                        }
                }
                when node: Success
                    list.add$(node)
        }
    }

    function parse_bindingspec#(rp, this: Parser) returns BindingSpecSyntax throws ParserError
    {
        choose parse_structure#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return BindingSpecSyntax.Structure(node)
        choose parse_type#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return BindingSpecSyntax.Type(node)
        choose parse_array#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return BindingSpecSyntax.Array(node)
        throw ParserError.Different(DifferentSyntax())
    }

    function parse_array#(rp, this: Parser) returns ArraySyntax throws ParserError
    {
        let start lexer.previous_position

        if ~lexer.parse_punctuation#(ParserConstants.CHAR_LBRACKET())
            throw ParserError.Different(DifferentSyntax())

        let members_start lexer.position
        var members: ref[Vector[TypeSyntax]]? null
        choose parse_type_list#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set members: success

        if ~lexer.parse_punctuation#(ParserConstants.CHAR_RBRACKET())
            throw ParserError.Invalid(InvalidSyntax(start, lexer.position, String$("expected ']'")))

        let end lexer.position

        ArraySyntax(start, end, members)
    }

    function parse_structure#(rp, this: Parser) returns StructureSyntax throws ParserError
    {
        let start lexer.previous_position

        if ~lexer.parse_punctuation#(ParserConstants.CHAR_LPAREN())
            throw ParserError.Different(DifferentSyntax())

        let parts_start lexer.position
        var parts: ref[Vector[PartSyntax]]? null
        choose parse_part_list#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set parts: success

        if ~lexer.parse_punctuation#(ParserConstants.CHAR_RPAREN())
            throw ParserError.Invalid(InvalidSyntax(start, lexer.position, String$("expected ')'")))

        let end lexer.position

        StructureSyntax(start, end, parts)
    }

    function parse_part_list#(rp, this: Parser) returns ref[Vector[PartSyntax]]? throws ParserError
    {
        var list List[PartSyntax]$()
        while true
        {
            choose parse_part#()
                when err: Error
                {
                    choose err
                        when i: Invalid
                            throw ParserError.Invalid(i)
                        when d: Different
                        {
                            if list.head = null
                                throw ParserError.Different(d)
                            else
                                return Vector[PartSyntax]#(list)
                        }
                }
                when node: Success
                    list.add$(node)
        }
    }

    function parse_part#(rp, this: Parser) returns PartSyntax throws ParserError
    {
        choose parse_field#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return PartSyntax.Field(node)
        choose parse_property#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return PartSyntax.Property(node)
        throw ParserError.Different(DifferentSyntax())
    }

    function parse_field#(rp, this: Parser) returns FieldSyntax throws ParserError
    {
        let start lexer.previous_position

        if ~lexer.parse_keyword#(String$("private"))
            throw ParserError.Different(DifferentSyntax())

        let property_start lexer.position
        var property: PropertySyntax
        choose parse_property#()
            when err: Error
            {
                choose err
                    when d: Different
                        throw ParserError.Invalid(InvalidSyntax(property_start, lexer.position, String$("expected Property")))
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set property: success

        let end lexer.position

        FieldSyntax(start, end, property)
    }

    function parse_property_list#(rp, this: Parser) returns ref[Vector[PropertySyntax]]? throws ParserError
    {
        var list List[PropertySyntax]$()
        while true
        {
            choose parse_property#()
                when err: Error
                {
                    choose err
                        when i: Invalid
                            throw ParserError.Invalid(i)
                        when d: Different
                        {
                            if list.head = null
                                throw ParserError.Different(d)
                            else
                                return Vector[PropertySyntax]#(list)
                        }
                }
                when node: Success
                    list.add$(node)
        }
    }

    function parse_property#(rp, this: Parser) returns PropertySyntax throws ParserError
    {
        let start lexer.previous_position

        let name lexer.parse_identifier#(keywords)
        if name.length() = 0
            throw ParserError.Different(DifferentSyntax())

        let annotation_start lexer.position
        var annotation: TypeAnnotationSyntax
        choose parse_typeannotation#()
            when err: Error
            {
                choose err
                    when d: Different
                        throw ParserError.Invalid(InvalidSyntax(annotation_start, lexer.position, String$("expected TypeAnnotation")))
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set annotation: success

        let initializer_start lexer.position
        var initializer: ref[InitializerSyntax]? null
        choose parse_initializer#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set initializer: success

        lexer.parse_punctuation#(ParserConstants.CHAR_COMMA())

        lexer.parse_colon#()

        let attributes_start lexer.position
        var attributes: ref[Vector[AttributeSyntax]]? null
        choose parse_attribute_list#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set attributes: success

        lexer.parse_colon#()

        let end lexer.position

        PropertySyntax(start, end, name, annotation, initializer, attributes)
    }

    function parse_typeannotation#(rp, this: Parser) returns TypeAnnotationSyntax throws ParserError
    {
        let start lexer.previous_position

        if ~lexer.parse_colon#()
            throw ParserError.Different(DifferentSyntax())

        let type_start lexer.position
        var type: TypeSyntax
        choose parse_type#()
            when err: Error
            {
                choose err
                    when d: Different
                        throw ParserError.Invalid(InvalidSyntax(type_start, lexer.position, String$("expected Type")))
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set type: success

        let end lexer.position

        TypeAnnotationSyntax(start, end, type)
    }

    function parse_continue#(rp, this: Parser) returns ContinueSyntax throws ParserError
    {
        let start lexer.previous_position

        if ~lexer.parse_keyword#(String$("continue"))
            throw ParserError.Different(DifferentSyntax())

        let name_start lexer.position
        var name: ref[LoopSyntax]? null
        choose parse_loop#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set name: success

        lexer.parse_colon#()

        let end lexer.position

        ContinueSyntax(start, end, name)
    }

    function parse_break#(rp, this: Parser) returns BreakSyntax throws ParserError
    {
        let start lexer.previous_position

        if ~lexer.parse_keyword#(String$("break"))
            throw ParserError.Different(DifferentSyntax())

        let name_start lexer.position
        var name: ref[LoopSyntax]? null
        choose parse_loop#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set name: success

        let result_start lexer.position
        var result: ref[Vector[OperandSyntax]]? null
        choose parse_operand_list#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set result: success

        lexer.parse_colon#()

        let end lexer.position

        BreakSyntax(start, end, name, result)
    }

    function parse_loop#(rp, this: Parser) returns LoopSyntax throws ParserError
    {
        let start lexer.previous_position

        if ~lexer.parse_keyword#(String$("loop"))
            throw ParserError.Different(DifferentSyntax())

        let name lexer.parse_identifier#(keywords)
        if name.length() = 0
            throw ParserError.Invalid(InvalidSyntax(start, lexer.position, String$("expected identifier")))

        let end lexer.position

        LoopSyntax(start, end, name)
    }

    function parse_return#(rp, this: Parser) returns ReturnSyntax throws ParserError
    {
        let start lexer.previous_position

        if ~lexer.parse_keyword#(String$("return"))
            throw ParserError.Different(DifferentSyntax())

        let result_start lexer.position
        var result: ref[Vector[OperandSyntax]]? null
        choose parse_operand_list#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set result: success

        let end lexer.position

        ReturnSyntax(start, end, result)
    }

    function parse_throw#(rp, this: Parser) returns ThrowSyntax throws ParserError
    {
        let start lexer.previous_position

        if ~lexer.parse_keyword#(String$("throw"))
            throw ParserError.Different(DifferentSyntax())

        let result_start lexer.position
        var result: ref[Vector[OperandSyntax]]? null
        choose parse_operand_list#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set result: success

        let end lexer.position

        ThrowSyntax(start, end, result)
    }

    function parse_lambda#(rp, this: Parser) returns LambdaSyntax throws ParserError
    {
        let start lexer.previous_position

        if ~lexer.parse_punctuation#(ParserConstants.CHAR_BACKSLASH())
            throw ParserError.Different(DifferentSyntax())

        let input_start lexer.position
        var input: ref[Vector[OperandSyntax]]?
        choose parse_operand_list#()
            when err: Error
            {
                choose err
                    when d: Different
                        throw ParserError.Invalid(InvalidSyntax(input_start, lexer.position, String$("expected Operand")))
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set input: success

        if ~lexer.parse_colon#()
            throw ParserError.Invalid(InvalidSyntax(start, lexer.position, String$("expected colon or newline")))

        let block_start lexer.position
        var block: ActionSyntax
        choose parse_action#()
            when err: Error
            {
                choose err
                    when d: Different
                        throw ParserError.Invalid(InvalidSyntax(block_start, lexer.position, String$("expected Action")))
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set block: success

        let end lexer.position

        LambdaSyntax(start, end, input, block)
    }

    function parse_for#(rp, this: Parser) returns ForSyntax throws ParserError
    {
        let start lexer.previous_position

        if ~lexer.parse_keyword#(String$("for"))
            throw ParserError.Different(DifferentSyntax())

        let variable lexer.parse_identifier#(keywords)
        if variable.length() = 0
            throw ParserError.Invalid(InvalidSyntax(start, lexer.position, String$("expected identifier")))

        let annotation_start lexer.position
        var annotation: ref[TypeAnnotationSyntax]? null
        choose parse_typeannotation#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set annotation: success

        if ~lexer.parse_keyword#(String$("in"))
            throw ParserError.Invalid(InvalidSyntax(start, lexer.position, String$("expected 'in'")))

        let operation_start lexer.position
        var operation: ref[Vector[OperandSyntax]]?
        choose parse_operand_list#()
            when err: Error
            {
                choose err
                    when d: Different
                        throw ParserError.Invalid(InvalidSyntax(operation_start, lexer.position, String$("expected Operand")))
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set operation: success

        if ~lexer.parse_colon#()
            throw ParserError.Invalid(InvalidSyntax(start, lexer.position, String$("expected colon or newline")))

        let name_start lexer.position
        var name: ref[LabelSyntax]? null
        choose parse_label#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set name: success

        let action_start lexer.position
        var action: ActionSyntax
        choose parse_action#()
            when err: Error
            {
                choose err
                    when d: Different
                        throw ParserError.Invalid(InvalidSyntax(action_start, lexer.position, String$("expected Action")))
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set action: success

        let end lexer.position

        ForSyntax(start, end, variable, annotation, operation, name, action)
    }

    function parse_label#(rp, this: Parser) returns LabelSyntax throws ParserError
    {
        let start lexer.previous_position

        if ~lexer.parse_keyword#(String$("label"))
            throw ParserError.Different(DifferentSyntax())

        let name lexer.parse_identifier#(keywords)
        if name.length() = 0
            throw ParserError.Invalid(InvalidSyntax(start, lexer.position, String$("expected identifier")))

        lexer.parse_colon#()

        let end lexer.position

        LabelSyntax(start, end, name)
    }

    function parse_repeat#(rp, this: Parser) returns RepeatSyntax throws ParserError
    {
        let start lexer.previous_position

        if ~lexer.parse_keyword#(String$("repeat"))
            throw ParserError.Different(DifferentSyntax())

        let name_start lexer.position
        var name: ref[LabelSyntax]? null
        choose parse_label#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set name: success

        let action_start lexer.position
        var action: ActionSyntax
        choose parse_action#()
            when err: Error
            {
                choose err
                    when d: Different
                        throw ParserError.Invalid(InvalidSyntax(action_start, lexer.position, String$("expected Action")))
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set action: success

        let end lexer.position

        RepeatSyntax(start, end, name, action)
    }

    function parse_action_list#(rp, this: Parser) returns ref[Vector[ActionSyntax]]? throws ParserError
    {
        var list List[ActionSyntax]$()
        while true
        {
            choose parse_action#()
                when err: Error
                {
                    choose err
                        when i: Invalid
                            throw ParserError.Invalid(i)
                        when d: Different
                        {
                            if list.head = null
                                throw ParserError.Different(d)
                            else
                                return Vector[ActionSyntax]#(list)
                        }
                }
                when node: Success
                    list.add$(node)
        }
    }

    function parse_action#(rp, this: Parser) returns ActionSyntax throws ParserError
    {
        choose parse_operation#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return ActionSyntax.Operation(node)
        choose parse_set#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return ActionSyntax.Set(node)
        choose parse_block#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return ActionSyntax.Block(node)
        throw ParserError.Different(DifferentSyntax())
    }

    function parse_operation#(rp, this: Parser) returns OperationSyntax throws ParserError
    {
        let start lexer.previous_position

        let operands_start lexer.position
        var operands: ref[Vector[OperandSyntax]]?
        choose parse_operand_list#()
            when err: Error
                throw err
            when success: Success
                set operands: success

        let end lexer.position

        OperationSyntax(start, end, operands)
    }

    function parse_set#(rp, this: Parser) returns SetSyntax throws ParserError
    {
        let start lexer.previous_position

        if ~lexer.parse_keyword#(String$("set"))
            throw ParserError.Different(DifferentSyntax())

        let target_start lexer.position
        var target: ref[Vector[OperandSyntax]]?
        choose parse_operand_list#()
            when err: Error
            {
                choose err
                    when d: Different
                        throw ParserError.Invalid(InvalidSyntax(target_start, lexer.position, String$("expected Operand")))
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set target: success

        if ~lexer.parse_colon#()
            throw ParserError.Invalid(InvalidSyntax(start, lexer.position, String$("expected colon or newline")))

        let source_start lexer.position
        var source: ref[Vector[OperandSyntax]]?
        choose parse_operand_list#()
            when err: Error
            {
                choose err
                    when d: Different
                        throw ParserError.Invalid(InvalidSyntax(source_start, lexer.position, String$("expected Operand")))
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set source: success

        let end lexer.position

        SetSyntax(start, end, target, source)
    }

    function parse_block#(rp, this: Parser) returns BlockSyntax throws ParserError
    {
        let start lexer.previous_position

        if ~lexer.parse_punctuation#(ParserConstants.CHAR_LBRACE())
            throw ParserError.Different(DifferentSyntax())

        let uses_start lexer.position
        var uses: ref[Vector[UseSyntax]]? null
        choose parse_use_list#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set uses: success

        let statements_start lexer.position
        var statements: ref[Vector[StatementSyntax]]? null
        choose parse_statement_list#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set statements: success

        if ~lexer.parse_punctuation#(ParserConstants.CHAR_RBRACE())
            throw ParserError.Invalid(InvalidSyntax(start, lexer.position, String$("expected '}'")))

        let end lexer.position

        BlockSyntax(start, end, uses, statements)
    }

    function parse_sizeof#(rp, this: Parser) returns SizeOfSyntax throws ParserError
    {
        let start lexer.previous_position

        if ~lexer.parse_keyword#(String$("sizeof"))
            throw ParserError.Different(DifferentSyntax())

        let type_start lexer.position
        var type: TypeSyntax
        choose parse_type#()
            when err: Error
            {
                choose err
                    when d: Different
                        throw ParserError.Invalid(InvalidSyntax(type_start, lexer.position, String$("expected Type")))
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set type: success

        let end lexer.position

        SizeOfSyntax(start, end, type)
    }

    function parse_alignof#(rp, this: Parser) returns AlignOfSyntax throws ParserError
    {
        let start lexer.previous_position

        if ~lexer.parse_keyword#(String$("alignof"))
            throw ParserError.Different(DifferentSyntax())

        let type_start lexer.position
        var type: TypeSyntax
        choose parse_type#()
            when err: Error
            {
                choose err
                    when d: Different
                        throw ParserError.Invalid(InvalidSyntax(type_start, lexer.position, String$("expected Type")))
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set type: success

        let end lexer.position

        AlignOfSyntax(start, end, type)
    }

    function parse_is#(rp, this: Parser) returns IsSyntax throws ParserError
    {
        let start lexer.previous_position

        if ~lexer.parse_keyword#(String$("is"))
            throw ParserError.Different(DifferentSyntax())

        let name_start lexer.position
        var name: NameSyntax
        choose parse_name#()
            when err: Error
            {
                choose err
                    when d: Different
                        throw ParserError.Invalid(InvalidSyntax(name_start, lexer.position, String$("expected Name")))
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set name: success

        let end lexer.position

        IsSyntax(start, end, name)
    }

    function parse_as#(rp, this: Parser) returns AsSyntax throws ParserError
    {
        let start lexer.previous_position

        if ~lexer.parse_keyword#(String$("as"))
            throw ParserError.Different(DifferentSyntax())

        let type_start lexer.position
        var type: TypeSyntax
        choose parse_type#()
            when err: Error
            {
                choose err
                    when d: Different
                        throw ParserError.Invalid(InvalidSyntax(type_start, lexer.position, String$("expected Type")))
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set type: success

        let end lexer.position

        AsSyntax(start, end, type)
    }

    function parse_type_list#(rp, this: Parser) returns ref[Vector[TypeSyntax]]? throws ParserError
    {
        var list List[TypeSyntax]$()
        while true
        {
            choose parse_type#()
                when err: Error
                {
                    choose err
                        when i: Invalid
                            throw ParserError.Invalid(i)
                        when d: Different
                        {
                            if list.head = null
                                throw ParserError.Different(d)
                            else
                                return Vector[TypeSyntax]#(list)
                        }
                }
                when node: Success
                    list.add$(node)
        }
    }

    function parse_type#(rp, this: Parser) returns TypeSyntax throws ParserError
    {
        let start lexer.previous_position

        let name_start lexer.position
        var name: NameSyntax
        choose parse_name#()
            when err: Error
                throw err
            when success: Success
                set name: success

        let generics_start lexer.position
        var generics: ref[GenericArgumentsSyntax]? null
        choose parse_genericarguments#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set generics: success

        let optional_start lexer.position
        var optional: ref[OptionalSyntax]? null
        choose parse_optional#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set optional: success

        let lifetime_start lexer.position
        var lifetime: ref[LifetimeSyntax]? null
        choose parse_lifetime#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set lifetime: success

        let end lexer.position

        TypeSyntax(start, end, name, generics, optional, lifetime)
    }

    function parse_name#(rp, this: Parser) returns NameSyntax throws ParserError
    {
        let start lexer.previous_position

        let name lexer.parse_identifier#(keywords)
        if name.length() = 0
            throw ParserError.Different(DifferentSyntax())

        let extensions_start lexer.position
        var extensions: ref[Vector[ExtensionSyntax]]? null
        choose parse_extension_list#()
            when err: Error
            {
                choose err
                    when d: Different {}
                    when i: Invalid
                        throw ParserError.Invalid(i)
            }
            when success: Success
                set extensions: success

        let end lexer.position

        NameSyntax(start, end, name, extensions)
    }

    function parse_extension_list#(rp, this: Parser) returns ref[Vector[ExtensionSyntax]]? throws ParserError
    {
        var list List[ExtensionSyntax]$()
        while true
        {
            choose parse_extension#()
                when err: Error
                {
                    choose err
                        when i: Invalid
                            throw ParserError.Invalid(i)
                        when d: Different
                        {
                            if list.head = null
                                throw ParserError.Different(d)
                            else
                                return Vector[ExtensionSyntax]#(list)
                        }
                }
                when node: Success
                    list.add$(node)
        }
    }

    function parse_extension#(rp, this: Parser) returns ExtensionSyntax throws ParserError
    {
        let start lexer.previous_position

        if ~lexer.parse_punctuation#(ParserConstants.CHAR_DOT())
            throw ParserError.Different(DifferentSyntax())

        let name lexer.parse_identifier#(keywords)
        if name.length() = 0
            throw ParserError.Invalid(InvalidSyntax(start, lexer.position, String$("expected identifier")))

        let end lexer.position

        ExtensionSyntax(start, end, name)
    }

    function parse_lifetime#(rp, this: Parser) returns LifetimeSyntax throws ParserError
    {
        choose parse_call#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return LifetimeSyntax.Call(node)
        choose parse_local#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return LifetimeSyntax.Local(node)
        choose parse_reference#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return LifetimeSyntax.Reference(node)
        choose parse_thrown#()
            when err: Error
            {
                choose err
                    when i: Invalid
                        throw ParserError.Invalid(i)
                    when d: Different {}
            }
            when node: Success
                return LifetimeSyntax.Thrown(node)
        throw ParserError.Different(DifferentSyntax())
    }

    function parse_call#(rp, this: Parser) returns CallSyntax throws ParserError
    {
        let start lexer.previous_position

        if ~lexer.parse_punctuation#(ParserConstants.CHAR_HASH())
            throw ParserError.Different(DifferentSyntax())

        let end lexer.position

        CallSyntax(start, end)
    }

    function parse_local#(rp, this: Parser) returns LocalSyntax throws ParserError
    {
        let start lexer.previous_position

        if ~lexer.parse_punctuation#(ParserConstants.CHAR_DOLLAR())
            throw ParserError.Different(DifferentSyntax())

        let end lexer.position

        LocalSyntax(start, end)
    }

    function parse_reference#(rp, this: Parser) returns ReferenceSyntax throws ParserError
    {
        let start lexer.previous_position

        if ~lexer.parse_punctuation#(ParserConstants.CHAR_CARET())
            throw ParserError.Different(DifferentSyntax())

        let location lexer.parse_identifier#(keywords)
        if location.length() = 0
            throw ParserError.Invalid(InvalidSyntax(start, lexer.position, String$("expected identifier")))

        let end lexer.position

        ReferenceSyntax(start, end, location)
    }

    function parse_thrown#(rp, this: Parser) returns ThrownSyntax throws ParserError
    {
        let start lexer.previous_position

        if ~lexer.parse_punctuation#(ParserConstants.CHAR_EXCL())
            throw ParserError.Different(DifferentSyntax())

        let end lexer.position

        ThrownSyntax(start, end)
    }

    function is_at_end(this: Parser) returns bool
        lexer.is_at_end()
}

function test() returns int
{
    ; Test 1: Parse a simple literal
    var parser Parser$(String$("42"))
    choose parser.parse_literal$()
        when err: Error
            return 1
        when literal: Success
        {
            if ~parser.is_at_end()
                return 2
        }

    ; Test 2: Parse an identifier expression
    set parser: Parser$(String$("foo"))
    choose parser.parse_name$()
        when err: Error
            return 3
        when name: Success
        {
            if ~parser.is_at_end()
                return 4
        }

    ; Test 3: Parse a function definition
    set parser: Parser$(String$("function hello() returns int 42"))
    choose parser.parse_function$()
        when err: Error
            return 5
        when func: Success
        {
            if ~parser.is_at_end()
                return 6
        }

    ; Test 4: Parse a structure definition (from old test_parser)
    set parser: Parser$(String$("define a ()"))
    choose parser.parse_definition$()
        when err: Error
            return 7
        when def: Success
        {
            if ~parser.is_at_end()
                return 8
        }

    ; Test 5: Parse a structure with properties
    set parser: Parser$(String$("define Point (x: int, y: int)"))
    choose parser.parse_definition$()
        when err: Error
            return 9
        when def: Success
        {
            if ~parser.is_at_end()
                return 10
        }

    ; Test 6: Parse a union definition
    set parser: Parser$(String$("define Option union (Some: int, None)"))
    choose parser.parse_definition$()
        when err: Error
            return 11
        when def: Success
        {
            if ~parser.is_at_end()
                return 12
        }

    0
}

