; Plan.scaly - Resolved/monomorphized model for code generation
; The Plan is the "execution plan" - concrete types with generics resolved,
; mangled names ready for LLVM emission, and provenance tracking for debug info.
;
; Ported from C++ Plan.h

use scaly.containers.Vector
use scaly.containers.String
use scalyc.compiler.Model.Span
use scalyc.compiler.Model.Lifetime
use scalyc.compiler.Model.Constant

; ============================================================================
; Type Inference Support
; ============================================================================

; Type variable - represents an unknown type during inference
define TypeVariable
(
    id: size_t
    debug_name: String      ; Optional: "T", "?1", etc. for error messages
)

; ============================================================================
; Provenance Tracking (for debug info)
; ============================================================================

; Tracks where a generic instantiation came from
define InstantiationInfo
(
    definition_loc: Span            ; Where the generic was defined
    instantiation_loc: Span         ; Where it was instantiated
    type_args: ref[Vector[String]]?  ; The concrete type arguments (readable)
)

; ============================================================================
; Planned Types (resolved, concrete)
; ============================================================================

; A fully resolved type
define PlannedType
(
    loc: Span
    name: String                     ; Readable: "List.int"
    mangled_name: String             ; Itanium: "_Z4ListIiE"
    generics: ref[Vector[PlannedType]]?   ; Resolved generic args (if any)
    life: Lifetime
    origin: ref[InstantiationInfo]?  ; null if not from generic

    ; For fixed-size array types: stores the size reference
    array_size: String

    ; For inference: may contain unresolved type variables
    variable: ref[TypeVariable]?  ; non-null if this is a type variable
)

; ============================================================================
; Type Inference Constraints
; ============================================================================

define EqualityConstraint
(
    left: PlannedType
    right: PlannedType
    loc: Span
    file: String
)

define InstanceConstraint
(
    type_var: TypeVariable
    trait_name: String
    loc: Span
)

define TypeConstraint union
(
    Equality: EqualityConstraint
    Instance: InstanceConstraint
)

; Type scheme for let-polymorphism
define TypeScheme
(
    quantified: ref[Vector[TypeVariable]]?
    scheme_type: ref[PlannedType]?
)

; ============================================================================
; Planned Attributes and Items
; ============================================================================

define PlannedConstant
(
    value: Constant
)

define PlannedAttribute
(
    loc: Span
    name: String
    value: scaly.compiler.Model.Model
)

define PlannedItem
(
    loc: Span
    is_private: bool
    name: ref[String]?
    item_type: ref[PlannedType]?
    attributes: ref[Vector[PlannedAttribute]]?
)

; ============================================================================
; Planned Properties and Variants
; ============================================================================

define PlannedProperty
(
    loc: Span
    is_private: bool
    name: String
    mangled_name: String
    prop_type: PlannedType
    initializer: ref[Vector[PlannedOperand]]?
    attributes: ref[Vector[PlannedAttribute]]?
    offset: size_t      ; Byte offset in struct layout
)

define PlannedVariant
(
    loc: Span
    name: String
    mangled_name: String
    var_type: ref[PlannedType]?
    attributes: ref[Vector[PlannedAttribute]]?
    tag: int            ; Discriminator value
)

; ============================================================================
; Planned Statements
; ============================================================================

define PlannedAction
(
    source: ref[Vector[PlannedOperand]]?
    target: ref[Vector[PlannedOperand]]?
    result_type: PlannedType
)

define PlannedBinding
(
    loc: Span
    binding_type: String    ; "const", "var", "mutable"
    binding_item: PlannedItem
    operation: ref[Vector[PlannedOperand]]?
)

define PlannedBreak
(
    loc: Span
    result: ref[Vector[PlannedOperand]]?
)

define PlannedContinue
(
    loc: Span
)

define PlannedReturn
(
    loc: Span
    result: ref[Vector[PlannedOperand]]?
)

define PlannedThrow
(
    loc: Span
    result: ref[Vector[PlannedOperand]]?
)

define PlannedStatement union
(
    Action: PlannedAction
    Binding: PlannedBinding
    Break: PlannedBreak
    Continue: PlannedContinue
    Return: PlannedReturn
    Throw: PlannedThrow
)

; ============================================================================
; Planned Control Flow
; ============================================================================

define PlannedBlock
(
    loc: Span
    statements: ref[Vector[PlannedStatement]]?
    needs_local_page_cleanup: bool  ; True if this block contains $ allocations
)

define PlannedIf
(
    loc: Span
    condition: ref[Vector[PlannedOperand]]?
    prop: ref[PlannedProperty]?
    consequent: ref[PlannedStatement]?
    alternative: ref[PlannedStatement]?
)

define PlannedCase
(
    loc: Span
    condition: ref[Vector[PlannedOperand]]?
)

define PlannedBranch
(
    loc: Span
    cases: ref[Vector[PlannedCase]]?
    consequent: ref[PlannedStatement]?
)

define PlannedMatch
(
    loc: Span
    condition: ref[Vector[PlannedOperand]]?
    branches: ref[Vector[PlannedBranch]]?
    alternative: ref[PlannedStatement]?
)

define PlannedWhen
(
    loc: Span
    name: String
    variant_type: PlannedType
    variant_index: size_t   ; Index in the union
    consequent: ref[PlannedStatement]?
)

define PlannedChoose
(
    loc: Span
    condition: ref[Vector[PlannedOperand]]?
    cases: ref[Vector[PlannedWhen]]?
    alternative: ref[PlannedStatement]?
)

define PlannedFor
(
    loc: Span
    identifier: String
    expr: ref[Vector[PlannedOperand]]?
    body: PlannedAction

    ; Iterator support fields
    is_iterator_loop: bool          ; true if iterator-based, false if integer range
    collection_type: PlannedType
    iterator_type: PlannedType
    element_type: PlannedType
    get_iterator_method: String     ; Mangled name of get_iterator
    next_method: String             ; Mangled name of next
)

define PlannedWhile
(
    loc: Span
    cond: PlannedBinding
    body: PlannedAction
)

define PlannedTry
(
    loc: Span
    cond: PlannedBinding
    catches: ref[Vector[PlannedWhen]]?
    alternative: ref[PlannedStatement]?
)

define PlannedSizeOf
(
    loc: Span
    sized_type: PlannedType
    size: size_t            ; Computed size in bytes
)

define PlannedAlignOf
(
    loc: Span
    aligned_type: PlannedType
    alignment: size_t       ; Computed alignment in bytes
)

define PlannedIs
(
    loc: Span
    test_type: PlannedType
    variant_tag: size_t             ; Tag value to compare against
    union_name: String              ; Name of the union type being tested
    value: ref[PlannedOperand]?  ; The union value being tested
    is_null_check: bool             ; true for "is null" checks
)

define PlannedAs
(
    loc: Span
    target_type: PlannedType
    value: ref[PlannedOperand]?
)

define PlannedVariantConstruction
(
    loc: Span
    union_type: PlannedType
    variant_name: String
    variant_tag: size_t
    value: ref[PlannedOperand]?
)

define PlannedCall
(
    loc: Span
    name: String                ; Operator symbol or function name
    mangled_name: String
    is_intrinsic: bool
    is_operator: bool
    can_throw: bool
    requires_page_param: bool   ; True if init# needs page parameter
    args: ref[Vector[PlannedOperand]]?
    result_type: PlannedType
    life: Lifetime              ; For constructors: allocation lifetime
)

; ============================================================================
; Planned Tuples and Matrices
; ============================================================================

define PlannedComponent
(
    loc: Span
    name: ref[String]?
    value: ref[Vector[PlannedOperand]]?
    attributes: ref[Vector[PlannedAttribute]]?
)

define PlannedTuple
(
    loc: Span
    components: ref[Vector[PlannedComponent]]?
    tuple_type: PlannedType
    is_region_alloc: bool
    life: Lifetime
    region_arg: ref[PlannedOperand]?     ; For ^name: the region pointer
)

define PlannedMatrix
(
    loc: Span
    operations: ref[Vector[Vector[PlannedOperand]]]?
    element_type: PlannedType
)

; ============================================================================
; Planned Expressions and Operands
; ============================================================================

define PlannedVariable
(
    loc: Span
    name: String
    variable_type: PlannedType
    is_mutable: bool
)

define PlannedGlobalRef
(
    loc: Span
    name: String
    mangled_name: String
    global_type: PlannedType
)

define PlannedExpression union
(
    Constant: PlannedConstant
    Type: PlannedType
    Variable: PlannedVariable
    GlobalRef: PlannedGlobalRef
    Call: PlannedCall
    Tuple: PlannedTuple
    Matrix: PlannedMatrix
    Block: PlannedBlock
    If: PlannedIf
    Match: PlannedMatch
    Choose: PlannedChoose
    For: PlannedFor
    While: PlannedWhile
    Try: PlannedTry
    SizeOf: PlannedSizeOf
    AlignOf: PlannedAlignOf
    Is: PlannedIs
    As: PlannedAs
    VariantConstruction: PlannedVariantConstruction
)

define PlannedMemberAccess
(
    name: String
    field_index: size_t
    is_method: bool
    is_union_value: bool
    parent_type: PlannedType
    result_type: PlannedType
)

define PlannedOperand
(
    loc: Span
    expr: PlannedExpression
    member_access: ref[Vector[PlannedMemberAccess]]?
    result_type: PlannedType
)

; ============================================================================
; Planned Functions and Operators
; ============================================================================

define PlannedExternImpl
(
    loc: Span
)

define PlannedInstructionImpl
(
    loc: Span
)

define PlannedIntrinsicImpl
(
    loc: Span
)

define PlannedImplementation union
(
    Action: PlannedAction
    Extern: PlannedExternImpl
    Instruction: PlannedInstructionImpl
    Intrinsic: PlannedIntrinsicImpl
)

define PlannedFunction
(
    loc: Span
    is_private: bool
    pure: bool
    name: String
    mangled_name: String
    page_parameter: ref[String]?
    input: ref[Vector[PlannedItem]]?
    return_type: ref[PlannedType]?
    throws_type: ref[PlannedType]?
    life: Lifetime
    impl: PlannedImplementation
    origin: ref[InstantiationInfo]?
    needs_local_page: bool
    can_throw: bool
    scheme: ref[TypeScheme]?
)

define PlannedInitializer
(
    loc: Span
    is_private: bool
    page_parameter: ref[String]?
    mangled_name: String
    input: ref[Vector[PlannedItem]]?
    impl: PlannedImplementation
)

define PlannedDeInitializer
(
    loc: Span
    mangled_name: String
    impl: PlannedImplementation
)

define PlannedOperator
(
    loc: Span
    is_private: bool
    name: String
    mangled_name: String
    input: ref[Vector[PlannedItem]]?
    return_type: ref[PlannedType]?
    throws_type: ref[PlannedType]?
    impl: PlannedImplementation
    origin: ref[InstantiationInfo]?
    scheme: ref[TypeScheme]?
)

; ============================================================================
; Planned Globals and Definitions
; ============================================================================

define PlannedGlobal
(
    loc: Span
    name: String
    mangled_name: String
    global_type: PlannedType
    value: ref[Vector[PlannedOperand]]?
)

define PlannedStructure
(
    loc: Span
    is_private: bool
    is_generic_placeholder: bool
    name: String
    mangled_name: String
    properties: ref[Vector[PlannedProperty]]?
    initializers: ref[Vector[PlannedInitializer]]?
    deinitializer: ref[PlannedDeInitializer]?
    methods: ref[Vector[PlannedFunction]]?
    operators: ref[Vector[PlannedOperator]]?
    size: size_t
    alignment: size_t
    origin: ref[InstantiationInfo]?
)

define PlannedUnion
(
    loc: Span
    is_private: bool
    name: String
    mangled_name: String
    variants: ref[Vector[PlannedVariant]]?
    methods: ref[Vector[PlannedFunction]]?
    operators: ref[Vector[PlannedOperator]]?
    size: size_t
    alignment: size_t
    origin: ref[InstantiationInfo]?
)

define PlannedNamespace
(
    loc: Span
    name: String
    mangled_name: String
    modules: ref[Vector[PlannedModule]]?
    functions: ref[Vector[PlannedFunction]]?
    operators: ref[Vector[PlannedOperator]]?
    concepts: ref[Vector[PlannedConcept]]?
)

define PlannedDefinition union
(
    Structure: PlannedStructure
    Union: PlannedUnion
    Namespace: PlannedNamespace
    Global: PlannedGlobal
    Type: PlannedType       ; Type alias
)

define PlannedConcept
(
    loc: Span
    name: String
    mangled_name: String
    attributes: ref[Vector[PlannedAttribute]]?
    definition: PlannedDefinition
    origin: ref[InstantiationInfo]?
)

; ============================================================================
; Planned Module and Program
; ============================================================================

define PlannedModule
(
    file: String
    name: String
    modules: ref[Vector[PlannedModule]]?
    concepts: ref[Vector[PlannedConcept]]?
    functions: ref[Vector[PlannedFunction]]?
    operators: ref[Vector[PlannedOperator]]?
)

; ============================================================================
; The Complete Plan
; ============================================================================

define Plan
(
    main_module: PlannedModule
    statements: ref[Vector[PlannedStatement]]?

    ; All instantiated types/functions (for quick lookup during emission)
    ; Note: In Scaly we'll use Vector pairs instead of maps for now
    structures: ref[Vector[PlannedStructure]]?
    unions: ref[Vector[PlannedUnion]]?
    functions: ref[Vector[PlannedFunction]]?
    globals: ref[Vector[PlannedGlobal]]?

    ; Type inference state
    next_type_var_id: size_t
    constraints: ref[Vector[TypeConstraint]]?
)

