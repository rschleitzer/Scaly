; cli.scaly - Command-line interface for the Scaly compiler
;
; This module handles argument parsing and drives the compilation pipeline.

; Standard library imports
use scaly.containers.String
use scaly.containers.Vector
use scaly.io.File
use scaly.io.Console

; Compiler module imports
use scalyc.compiler.Modeler
use scalyc.compiler.Model.Program
use scalyc.compiler.Planner
use scalyc.compiler.Plan.Plan
use scalyc.compiler.Emitter
use scalyc.compiler.Emitter.EmitterConfig

; ============================================================================
; Module declarations
; ============================================================================

; Parser module (which includes lexer)
module parser

; ============================================================================
; Command-line options
; ============================================================================

define Options
(
    input_file: String
    output_file: String
    verbose: bool
    emit_ir: bool           ; -S: emit LLVM IR
    compile_only: bool      ; -c: compile only, no link
    lex_only: bool          ; --lex: just tokenize
    parse_only: bool        ; --parse: just parse
    model_only: bool        ; --model: just build model
    plan_only: bool         ; --plan: just run planner
    show_help: bool
    error_message: String
)
{
    init()
    {
        set input_file: String()
        set output_file: String()
        set verbose: false
        set emit_ir: false
        set compile_only: false
        set lex_only: false
        set parse_only: false
        set model_only: false
        set plan_only: false
        set show_help: false
        set error_message: String()
    }

    function has_error(this) returns bool
        error_message.get_length() > 0

    function has_input(this) returns bool
        input_file.get_length() > 0
}

; ============================================================================
; Argument parsing
; ============================================================================

define cli
{
    ; Parse command-line arguments
    ; argc: argument count
    ; argv: argument vector (C-style array of char pointers)
    function parse_args#(argc: int, argv: pointer[pointer[char]]) returns Options
    {
        var opts Options#()

        var i 1  ; Skip program name (argv[0])
        while i < argc
        {
            let arg_ptr *(argv + i)
            var arg String$(arg_ptr)

            if arg.starts_with(String$("-"))
            {
                ; Option flag
                if arg.equals(String$("-h")) | arg.equals(String$("--help"))
                {
                    set opts.show_help: true
                }
                else if arg.equals(String$("-v")) | arg.equals(String$("--verbose"))
                {
                    set opts.verbose: true
                }
                else if arg.equals(String$("-S"))
                {
                    set opts.emit_ir: true
                }
                else if arg.equals(String$("-c"))
                {
                    set opts.compile_only: true
                }
                else if arg.equals(String$("--lex"))
                {
                    set opts.lex_only: true
                }
                else if arg.equals(String$("--parse"))
                {
                    set opts.parse_only: true
                }
                else if arg.equals(String$("--model"))
                {
                    set opts.model_only: true
                }
                else if arg.equals(String$("--plan"))
                {
                    set opts.plan_only: true
                }
                else if arg.equals(String$("-o"))
                {
                    ; Output file - next argument is the filename
                    set i: i + 1
                    if i < argc
                    {
                        let out_ptr *(argv + i)
                        set opts.output_file: String#(out_ptr)
                    }
                    else
                    {
                        set opts.error_message: String#("-o requires a filename")
                    }
                }
                else
                {
                    ; Unknown option
                    set opts.error_message: String#("Unknown option: ")
                    ; TODO: append arg to error message
                }
            }
            else
            {
                ; Input file
                if opts.has_input()
                {
                    set opts.error_message: String#("Multiple input files not yet supported")
                }
                else
                {
                    set opts.input_file: String#(arg_ptr)
                }
            }

            set i: i + 1
        }

        opts
    }

    ; Print usage information
    function print_usage()
    {
        Console.println("Usage: scalyc [options] <input file>")
        Console.println("")
        Console.println("Options:")
        Console.println("  -h, --help     Show this help message")
        Console.println("  -v, --verbose  Verbose output")
        Console.println("  -o <file>      Output file")
        Console.println("  -S             Emit LLVM IR")
        Console.println("  -c             Compile only (no link)")
        Console.println("  --lex          Lex input and print tokens")
        Console.println("  --parse        Parse input and validate syntax")
        Console.println("  --model        Build semantic model")
        Console.println("  --plan         Run planner (type resolution)")
    }

    ; Run the compiler with parsed options
    ; Returns 0 on success, non-zero on error
    function run#(opts: Options) returns int
    {
        if opts.show_help
        {
            print_usage()
            return 0
        }

        if opts.has_error()
        {
            Console.println("Error: ")
            ; TODO: print error message
            return 1
        }

        if opts.has_input() = false
        {
            Console.println("Error: No input file specified")
            print_usage()
            return 1
        }

        if opts.verbose
        {
            Console.println("Compiling: ")
            ; TODO: print input file
        }

        ; Read the source file
        var source File.read_to_string$(opts.input_file)
        if source.get_length() = 0
        {
            Console.println("Error: Could not read input file")
            return 1
        }

        if opts.verbose
        {
            Console.println("Read source file successfully")
        }

        ; ================================================================
        ; Stage 1: Parse
        ; ================================================================

        var p parser.Parser$(source)

        if opts.lex_only
        {
            ; Just tokenize and print tokens
            Console.println("Tokens:")
            p.lexer.advance$()
            while p.lexer.is_at_end() = false
            {
                ; TODO: Print token details
                Console.println("  <token>")
                p.lexer.advance$()
            }
            return 0
        }

        ; Parse the program
        var syntax: parser.ProgramSyntax
        choose p.parse_program$()
            when error: ParserError
            {
                Console.println("Parse error")
                return 2
            }
            when value: ProgramSyntax
            {
                set syntax: value
            }

        if opts.verbose
        {
            Console.println("Parsing completed successfully")
        }

        if opts.parse_only
        {
            Console.println("Parse successful")
            return 0
        }

        ; ================================================================
        ; Stage 2: Build semantic model
        ; ================================================================

        ; Extract program name from filename (strip path and extension)
        var program_name extract_program_name(opts.input_file)

        let model Modeler.build_program#(opts.input_file, program_name, syntax)

        if opts.verbose
        {
            Console.println("Model built successfully")
        }

        if opts.model_only
        {
            Console.println("Model built successfully")
            return 0
        }

        ; ================================================================
        ; Stage 3: Plan (type resolution, name mangling)
        ; ================================================================

        var planner Planner.Planner$(opts.input_file)
        let plan planner.plan_program(model)

        if plan = null
        {
            Console.println("Planner error")
            return 4
        }

        if opts.verbose
        {
            Console.println("Planning completed successfully")
        }

        if opts.plan_only
        {
            Console.println("Planning completed successfully")
            return 0
        }

        ; ================================================================
        ; Stage 4: Emit (LLVM IR generation)
        ; ================================================================

        var config EmitterConfig$()
        set config.emit_debug_info: false

        var emitter Emitter.Emitter$(config)
        let emit_result emitter.emit(plan, program_name)

        if emit_result = false
        {
            Console.println("Emitter error")
            return 5
        }

        if opts.verbose
        {
            Console.println("Code generation completed successfully")
        }

        if opts.emit_ir
        {
            ; TODO: Write IR to file or stdout
            Console.println("LLVM IR generation completed")
            return 0
        }

        ; TODO: Full compilation (link to executable)
        Console.println("Compilation completed successfully")
        0
    }

    ; Extract program name from file path
    ; e.g., "/path/to/hello.scaly" -> "hello"
    function extract_program_name#(file_path: String) returns String
    {
        ; Find last '/' or '\'
        var start 0
        var i 0
        while i < file_path.get_length() as int
        {
            let c file_path.get(i as size_t)
            if c = "/" as char
                set start: i + 1
            if c = "\\" as char
                set start: i + 1
            set i: i + 1
        }

        ; Find last '.'
        var end file_path.get_length() as int
        set i: end - 1
        while i >= start
        {
            let c file_path.get(i as size_t)
            if c = "." as char
            {
                set end: i
                ; break - just use assignment for now
                set i: -1
            }
            set i: i - 1
        }

        ; Extract substring
        if end <= start
            return file_path

        file_path.substring#(start as size_t, (end - start) as size_t)
    }

    ; Main entry point
    function main(argc: int, argv: pointer[pointer[char]]) returns int
    {
        var opts parse_args$(argc, argv)
        run$(opts)
    }

    ; Test function
    function test() returns int
    {
        ; Test 1: Check Options initialization
        var opts Options$()
        if opts.has_input()
            return -1
        if opts.has_error()
            return -2
        if opts.verbose
            return -3
        if opts.show_help
            return -4

        ; Test 2: Test extract_program_name
        var path1 String$("/path/to/hello.scaly")
        var name1 extract_program_name$(path1)
        if name1.equals(String$("hello")) = false
            return -10

        var path2 String$("simple.scaly")
        var name2 extract_program_name$(path2)
        if name2.equals(String$("simple")) = false
            return -11

        ; Test 3: Test pipeline on a minimal program
        var result test_pipeline$()
        if result <> 0
            return result - 100

        ; Test 4: Test pipeline on hello.scaly from disk
        set result: test_hello_scaly$()
        if result <> 0
            return result - 200

        ; All tests passed
        0
    }

    ; Test compiling hello.scaly from disk
    function test_hello_scaly#() returns int
    {
        ; Path to hello.scaly (relative to scalyc/build where tests run)
        var file_path String$("../../hello.scaly")

        ; Read the file
        var source File.read_to_string$(file_path)
        if source.get_length() = 0
            return -1  ; Could not read file

        ; Stage 1: Parse
        var p parser.Parser$(source)
        var syntax: parser.ProgramSyntax
        choose p.parse_program$()
            when error: ParserError
            {
                return -2  ; Parse failed
            }
            when value: ProgramSyntax
            {
                set syntax: value
            }

        ; Stage 2: Build model
        var program_name String$("hello")
        let model Modeler.build_program#(file_path, program_name, syntax)

        ; Stage 3: Plan
        var planner Planner.Planner$(file_path)
        let plan planner.plan_program(model)
        if plan = null
            return -3  ; Planning failed

        ; Stage 4: Emit
        var config EmitterConfig$()
        set config.emit_debug_info: false
        var emitter Emitter.Emitter$(config)
        let emit_result emitter.emit(plan, program_name)
        if emit_result = false
            return -4  ; Emission failed

        ; Successfully compiled hello.scaly!
        0
    }

    ; Test the compilation pipeline on a minimal program
    function test_pipeline#() returns int
    {
        ; Minimal valid Scaly program
        var source String$("function test_func() returns int { 42 }")

        ; Stage 1: Parse
        var p parser.Parser$(source)
        var syntax: parser.ProgramSyntax
        choose p.parse_program$()
            when error: ParserError
            {
                return -1  ; Parse failed
            }
            when value: ProgramSyntax
            {
                set syntax: value
            }

        ; Stage 2: Build model
        var file_name String$("test.scaly")
        var program_name String$("test")
        let model Modeler.build_program#(file_name, program_name, syntax)

        ; Stage 3: Plan
        var planner Planner.Planner$(file_name)
        let plan planner.plan_program(model)
        if plan = null
            return -3  ; Planning failed

        ; Stage 4: Emit (just verify it doesn't crash)
        var config EmitterConfig$()
        set config.emit_debug_info: false
        var emitter Emitter.Emitter$(config)
        let emit_result emitter.emit(plan, program_name)
        if emit_result = false
            return -4  ; Emission failed

        ; All pipeline stages passed
        0
    }
}
